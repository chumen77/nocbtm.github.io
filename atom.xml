<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>nocbtm&#39;s Blog</title>
  
  <subtitle>xixi</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-10T11:58:54.686Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Nocbtm</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Loop指令</title>
    <link href="http://yoursite.com/2018/09/10/Loop%E6%8C%87%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/09/10/Loop指令/</id>
    <published>2018-09-10T11:34:52.000Z</published>
    <updated>2018-09-10T11:58:54.686Z</updated>
    
    <content type="html"><![CDATA[<p>loop指令的格式是：loop 标号<br>CPU执行loop指令的时候，要进行两步操作，<br>1、(cx)=(cx)-1<br>2、判断cs中的值，不为零则转至标号处执行，如果为零则向下执行</p><p>例子1：计算2的十二次方<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code </span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">mov ax,2</span><br><span class="line">mov cx,11</span><br><span class="line">s: add ax,ax</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><p>例子2：用加法计算123*236</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">mov ax,0</span><br><span class="line">mov cx,123</span><br><span class="line">s: add ax,236</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;loop指令的格式是：loop 标号&lt;br&gt;CPU执行loop指令的时候，要进行两步操作，&lt;br&gt;1、(cx)=(cx)-1&lt;br&gt;2、判断cs中的值，不为零则转至标号处执行，如果为零则向下执行&lt;/p&gt;
&lt;p&gt;例子1：计算2的十二次方&lt;br&gt;&lt;figure class=&quot;h
      
    
    </summary>
    
    
      <category term="汇编语言" scheme="http://yoursite.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>寄存器（内存访问）</title>
    <link href="http://yoursite.com/2018/09/08/%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%EF%BC%89/"/>
    <id>http://yoursite.com/2018/09/08/寄存器（内存访问）/</id>
    <published>2018-09-08T09:23:21.000Z</published>
    <updated>2018-09-08T12:16:33.951Z</updated>
    
    <content type="html"><![CDATA[<h1 id="寄存器（内存访问）"><a href="#寄存器（内存访问）" class="headerlink" title="寄存器（内存访问）"></a>寄存器（内存访问）</h1><h2 id="内存中字的存储"><a href="#内存中字的存储" class="headerlink" title="内存中字的存储"></a>内存中字的存储</h2><p><img src="https://i.imgur.com/elPokAF.png" alt=""><br><img src="https://i.imgur.com/SvkdkRI.png" alt=""></p><h2 id="DS和-address"><a href="#DS和-address" class="headerlink" title="DS和[address]"></a>DS和[address]</h2><ul><li>8086CPU中有一个DS寄存器，通常用来存放要访问数据的地址段</li><li>[address]表示一个内存单元，address表示内存单元的偏移地址</li></ul><p>如果要读取10000H单元的内容，可以用如下的程序段进行</p><pre><code>mov bx,1000Hmov ds,bxmov al,[0]</code></pre><p>上面的3条指令将10000H（1000：0）中的数据读到al中<br><img src="https://i.imgur.com/m0dfFbY.png" alt=""></p><h2 id="字的传送"><a href="#字的传送" class="headerlink" title="字的传送"></a>字的传送</h2><pre><code>mov bx,1000Hmov ds,bxmov ax,[0]        ;1000:0处的数据送入axmov [0],cx        ;cx中的16位数据送到1000:0处</code></pre><h3 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h3><p><img src="https://i.imgur.com/Qxgebh8.png" alt=""></p><h3 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h3><p><img src="https://i.imgur.com/AWykHOU.png" alt=""><br><img src="https://i.imgur.com/5S8XbaN.png" alt=""></p><h3 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h3><p><img src="https://i.imgur.com/XObjMl6.png" alt=""></p><h2 id="检测点3-1"><a href="#检测点3-1" class="headerlink" title="检测点3.1"></a>检测点3.1</h2><p>(1)在Debug 中，用”d 0:0 1f” 查看内存，结果如下：</p><pre><code>0000:0000 70 80 F0 30 EF 60 30 E2-00 80 80 12 66 20 22 600000:0010 62 26 E6 D6 CC 2E 3C 3B-AB BA 00 00 26 06 66 88</code></pre><p>下面的程序执行前，AX=0,BX=0，写出每条汇编指令执行完毕后相关寄存器中的值：</p><pre><code>Mov ax,1Mov ds,axMov ax,[0000]       AX=2662Mov bx,[0001]       BX=E626Mov ax,bx           AX=E626Mov ax,[0000]       AX=2662Mov bx,[0002]       BX=D6E6Add ax,bx           AX=FD48Add ax,[0004]       AX=2C14Mov ax,0            AX=0Mov al,[0002]       AX=00E6Mov bx,0            BX=0Mov bl,[000C]       BX=0026Add al,bl           AX=000C</code></pre><p>(2)<br><img src="https://i.imgur.com/qN5f1kZ.png" alt=""><img src="https://i.imgur.com/CM1eYbo.png" alt=""></p><pre><code>mov ax,6622H        CS=2000H IP=0002Hjmp 0ff0:0100       CS=0ff0H IP=0100H  物理地址=CS*16+IP=10000Hmov ax,2000H        CS=0ff0H IP=0103Hmov ds,ax           CS=0ff0H IP=0105Hmov ax,[0008]       CS=0ff0H IP=0108Hmov ax,[0002]       CS=0ff0H Ip=010BH</code></pre><p>第一步：CS=2000H，IP=0H 地址：20000H</p><pre><code>读取第一条指令 mov ax,6622HCS=2000H, IP=03H执行指令 mov ax,6622H执行结果：AX=6622H</code></pre><p>第二步：地址：20003H</p><pre><code>读取第二条指令 jmp 0ff0:0100CS=2000H,IP=03H执行指令：jmp 0ff0:0100执行结果：CS=0ff0H, IP=0100H</code></pre><p>第三步：地址：CSx16+IP = 10000H</p><pre><code>读取指令：mov ax,2000HCS=0ff0H, IP=0103H执行指令：mov ax,2000H执行结果：AX=2000H</code></pre><p>第四步：地址：10003H</p><pre><code>读取指令：mov ds,axCS=0ff0H, IP=0105H执行指令：mov ds,ax  执行结果：ds=2000H</code></pre><p>第五步：地址：10005H</p><pre><code>读取指令：mov ax,[0008]</code></pre><p>CS=0ff0H，IP=10008H，DS=2000H</p><pre><code>执行指令：mov ax,[0008] ;</code></pre><p>也就是将地址【DS：IP】为 2000H：0008H的值移动到AX</p><pre><code>执行结果：AX=C189H</code></pre><p>第六步：读取指令：mov ax,[0002]</p><pre><code>CS=0ff0H ,IP=1000BH,DS=2000H执行指令：mov ax,[0002]执行结果：AX=EA66</code></pre><p>知识点：</p><p>任意时刻SS:SP 指向栈顶元素。</p><p>push指令和pop指令执行时，CPU从 SS和SP中得到栈顶的地址。</p><p>注：SS(Stack Segmet)堆栈段寄存器，指向当前的堆栈段。</p><p>SP(Stack Pointer)堆栈指针寄存器，主要用于堆栈操作，存放堆栈段首地</p><p>址到栈顶单元的偏移量。</p><p>入栈时：886CPU栈顶从高地址向低地址方向增长。</p><h2 id="CPU提供的栈机制"><a href="#CPU提供的栈机制" class="headerlink" title="CPU提供的栈机制"></a>CPU提供的栈机制</h2><p>CS、IP中存放着当前指令的段地址和偏移地址，而段寄存器SS和寄存器SP为CPU的入栈，出栈服务。任意时刻SS：SP指向栈顶元素。<br><img src="https://i.imgur.com/jCkIgBA.png" alt=""></p><h3 id="问题1-1"><a href="#问题1-1" class="headerlink" title="问题1"></a>问题1</h3><p>如果将10000H~1000Fh这段空间当作栈，初始空间是空的，此时，SS=1000H，SP=0010H<br><img src="https://i.imgur.com/JxoJjTE.png" alt=""></p><h3 id="问题2-1"><a href="#问题2-1" class="headerlink" title="问题2"></a>问题2</h3><p>利用栈，交换AX和BX中的数据</p><pre><code>mov ax,1000Hmov ss,axmov sp,0010H         ;初始化栈顶mov ax=001AHmov bx=001BHpush axpush bxpop ax               ；当前栈顶的数据是bx中的欲来的数据，所以先pop ax，即ax=001BHpop bx               ；执行pop ax后，栈顶的数据为ax原来的数据，所以再pop bx，即bx=001AH</code></pre><h3 id="问题3-1"><a href="#问题3-1" class="headerlink" title="问题3"></a>问题3</h3><p>利用栈在10000H处写入数据2266H</p><pre><code>mov ax,1000Hmov ss,axmov sp,0002Hmov ax,2266Hpush ax</code></pre><p>一般写法</p><pre><code>mov ax,1000Hmov ds,axmov ax,2266Hmov [0],ax</code></pre><p><img src="https://i.imgur.com/uQLhSXM.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;寄存器（内存访问）&quot;&gt;&lt;a href=&quot;#寄存器（内存访问）&quot; class=&quot;headerlink&quot; title=&quot;寄存器（内存访问）&quot;&gt;&lt;/a&gt;寄存器（内存访问）&lt;/h1&gt;&lt;h2 id=&quot;内存中字的存储&quot;&gt;&lt;a href=&quot;#内存中字的存储&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="汇编语言" scheme="http://yoursite.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>寄存器</title>
    <link href="http://yoursite.com/2018/09/07/%E5%AF%84%E5%AD%98%E5%99%A8/"/>
    <id>http://yoursite.com/2018/09/07/寄存器/</id>
    <published>2018-09-07T14:00:19.000Z</published>
    <updated>2018-09-08T09:24:47.381Z</updated>
    
    <content type="html"><![CDATA[<h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><ul><li>一个典型的CPU有运算器、控制器、寄存器等器件构成</li><li>寄存器是CPU中程序员可以用执行读写的部件。程序员通过改变各种寄存器中的内容来实现对CPU的控制</li><li>不同的CPU，寄存器的个数、结构是不同的。8086CPU有14个寄存器，每个寄存器有一个名称。这些寄存器是：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PWS、</li></ul><h2 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h2><ul><li>8086CPU的的所有寄存器都是16位的，可以存放两个字节，AX、BX、CX、DX、这四个寄存器位通用寄存器</li><li>一个16位的寄存器可以存储一个16位的数据，所能存储的数据最大值为2^16-1，或用16进制表示为FFFFH，也为10000H-1</li><li>AX的低8位构成了AL寄存器，高8位构成了AH寄存器，AH和AL寄存器是可以独立使用的<br><img src="https://i.imgur.com/QNIONUF.png" alt=""></li></ul><h2 id="字在寄存器中的存储"><a href="#字在寄存器中的存储" class="headerlink" title="字在寄存器中的存储"></a>字在寄存器中的存储</h2><ul><li>一个16位的寄存器可以存放两个字节（byte），即为一个字（word），一个字等于两个字节</li><li>而计算机的存储单元为字节（byte），一个内存（存储）单元可以存放8位数据（bit），也就是说，计算机中的数据大多是由1~N个8位数据构成。</li><li>很多时候，用16进制表示数据可以直观的看出数据是由哪些8位数据构成，如2000写成4E20，可以看出是由4E和20两个8位数据构成的，如果AX中存放4E20H，则AH里是4E，AL里是20<h2 id="mov和add汇编指令"><a href="#mov和add汇编指令" class="headerlink" title="mov和add汇编指令"></a>mov和add汇编指令</h2>原AX，BX中的值：0000H，0000H<br><img src="https://i.imgur.com/rMcnnbL.png" alt=""><br><img src="https://i.imgur.com/VwH9tTk.png" alt=""><br>问题2.1<br>在执行前ax和bx中的数据都为8226H，相加后所得值为：1044CH，但ax为16位寄存器，只能存放4位十六进制的数据，所以最高位的1不能在ax中保存，，ax中的数据为：044CH<br><img src="https://i.imgur.com/3DioByx.png" alt=""><br>问题2.2<br>在执行前，al中的数据为C5H，相加后所得的值为：158H，但是al为8位寄存器，只能诚邀您放两位16精致的数据，所以最高位的1丢失，ax中的数据为：0058H<br><img src="https://i.imgur.com/Kb8TLw6.png" alt=""><h2 id="检测点2-1："><a href="#检测点2-1：" class="headerlink" title="检测点2.1："></a>检测点2.1：</h2></li></ul><p>(1)写出每条汇编指令执行后相关寄存器中的值。</p><p>mov ax,62627 AX= F4A3H</p><p>mov ah,31H AX=31A3H</p><p>mov al,23H AX=3123H</p><p>add ax,ax AX=6246H</p><p>mov bx,826CH BX=826CH</p><p>mov cx,ax CX=6246H</p><p>mov ax,bx AX=826CH</p><p>add ax,bx AX=04D8H</p><p>mov al,bh AX=0482H</p><p>mov ah,bl AX=6C82H</p><p>add ah,ah AX=D882H</p><p>add al,6 AX=D888H</p><p>add al,al AX=D810H</p><p>mov ax,cx AX=6246H</p><p>(2)只能使用目前学过的汇编指令，最多使用4条指令，计算2的4次方.</p><p>mov ax,2h</p><p>add ax,ax</p><p>add ax,ax</p><p>add ax,ax</p><h2 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h2><p><img src="https://i.imgur.com/hriHdmb.png" alt=""><br><img src="https://i.imgur.com/VRoa36Z.png" alt=""></p><h2 id="段地址-16-偏移地址-物理地址的本质含义"><a href="#段地址-16-偏移地址-物理地址的本质含义" class="headerlink" title="段地址*16+偏移地址=物理地址的本质含义"></a>段地址*16+偏移地址=物理地址的本质含义</h2><p>CPU在访问内存时，用一个基础地址（段地址*16）和一个相对于基础地址的偏移地址相加，给出内存单元的物理地址</p><h2 id="检测点2-2"><a href="#检测点2-2" class="headerlink" title="检测点2.2"></a>检测点2.2</h2><p>（1）给定段地址为0001H，仅通过变化偏移地址寻址，CPU的寻址范围为多少到多少？</p><p> 答：物理地址=SA*16+EA</p><p>   EA的变化范围为0H~FFFFH</p><p> 物理地址范围为（SA<em>16+0H）~（SA</em>16+FFFFH）</p><p> 现在SA=0001H，那么寻址范围为</p><p> （0001H<em>16+0H）~（0001H</em>16+FFFFH）=00010H~1000FH</p><p> （2）有一数据存放在内存20000H单元中，现给定段地址为SA，若想用偏移地址寻到此单元。则SA应满足的条件是：最小为多少？最大为多少？</p><p>  答：</p><p>　物理地址 20000H ＝ SA * 10H ＋ 偏移地址</p><p>　显然，偏移地址应该取最大值，SA 才能达到最小。</p><p>　那么，偏移地址取最大值：FFFFH，行吗？</p><p>　代入上述方程，发现，两边的，最末位，不相等。</p><p> 偏移地址最大值，只能取到：FFF0H，方程才有可能成立。</p><p>　按照公式：</p><p>　物理地址 ＝ SA * 10H ＋ 偏移地址</p><p>　可知，物理地址、偏移地址，两者的最低位，必定是相同的。</p><p>　当物理地址＝20000H，偏移地址也只能是：XXX0H，取最大就是 FFF0H。</p><p> 于是：SA = (20000H － FFF0H) / 16＝10010H / 16 ＝ 1001H。</p><p> 标记：王爽汇编语言，段地址*16+偏移地址=物理地址，其中16是十进制。</p><p> 提示，反过来思考一下，当段地址给定为多少，CPU无论怎么变化偏移地址都无法寻到20000H单元？</p><p> 答：</p><p>　先求出，段地址为多少的时候，变化偏移地址可找到20000H地址单元。</p><p>　段地址 × 16  +  偏移地址  =  20000H</p><p>　偏移地址=0000H，段地址则为 2000H；</p><p>　偏移地址=FFF0H，段地址则为 1001H。</p><p>　那么，当段地址大于 2000H，或小于 1001H，就不能找到 20000H。</p><h2 id="CS和IP"><a href="#CS和IP" class="headerlink" title="CS和IP"></a>CS和IP</h2><p>CS和IP是8086CPU中最为关键的寄存器，CS为代码段寄存器（存放段地址），IP为指令指针寄存器（存放偏移地址）<br><img src="https://i.imgur.com/VtTkOAl.png" alt=""></p><p>1、 汇编指令由操作码和操作数组成   如：mov ax,0<br>   mov为操作数   表示指令的功能（是传送指令）<br>   ax,0是2个操作数   即0（0000H）为源操作数      ax为目的操作数<br>   该指令就是  将源操作数传送给目的操作数  从ax可以看出是一条16位的传送指令<br>2、 mov ax,0在内存中的机器指令是B8  00  00<br>   B8 是操作码  表示是一条以ax为目的操作数的传送指令（操作数ax为寄存器寻址  隐含在操作码 中，00  00    表示的是一个16位的立即数即0000H   低8位在前   高8位在后。<br>3、汇编指令在内存中  就是以B8 00 00机器指令表示的二进制代码。</p><h2 id="问题2-3"><a href="#问题2-3" class="headerlink" title="问题2.3"></a>问题2.3</h2><p><img src="https://i.imgur.com/8kaY3OY.png" alt=""><br><img src="https://i.imgur.com/auXp6R7.png" alt=""><br><img src="https://i.imgur.com/dqn3ecD.png" alt=""></p><h2 id="检测点"><a href="#检测点" class="headerlink" title="检测点"></a>检测点</h2><p>下面的3条指令执行后，cpu几次修改IP？都是在什么时候？最后IP中的值是多少？ </p><pre><code>mov ax,bx       sub ax,ax  jmp ax </code></pre><p>注：mov ax,bx  (高级编程语言就是ax=bx )<br>  sub ax,ax    (高级编程语言就是ax=ax-ax  发现ax=0H)<br>  jmp ax        (偏移增量为ax,进而IP=IP+ax，即加上索引的字节数）</p><p>  一共修改四次<br>  第一次：读取mov ax,bx之后<br>  第二次：读取sub ax,ax之后<br>  第三次：读取jmp ax之后<br>  第四次：执行jmp ax修改IP<br>  最后IP的值为0000H，因为最后ax中的值为0000H，所以IP中的值也为0000H</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;寄存器&quot;&gt;&lt;a href=&quot;#寄存器&quot; class=&quot;headerlink&quot; title=&quot;寄存器&quot;&gt;&lt;/a&gt;寄存器&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;一个典型的CPU有运算器、控制器、寄存器等器件构成&lt;/li&gt;
&lt;li&gt;寄存器是CPU中程序员可以用执行读写的部件。程序员
      
    
    </summary>
    
    
      <category term="汇编语言" scheme="http://yoursite.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>cpu与存储器</title>
    <link href="http://yoursite.com/2018/09/07/cpu/"/>
    <id>http://yoursite.com/2018/09/07/cpu/</id>
    <published>2018-09-07T12:37:33.000Z</published>
    <updated>2018-09-07T14:05:50.581Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cpu"><a href="#cpu" class="headerlink" title="cpu"></a>cpu</h1><p>中央处理器（CPU，Central Processing Unit）是一块超大规模的集成电路，是一台计算机的运算核心（Core）和控制核心（ Control Unit）。它的功能主要是解释计算机指令以及处理计算机软件中的数据。<br>中央处理器主要包括运算器（算术逻辑运算单元，ALU，Arithmetic Logic Unit）和高速缓冲存储器（Cache）及实现它们之间联系的数据（Data）、控制及状态的总线（Bus）。它与内部存储器（Memory）和输入/输出（I/O）设备合称为电子计算机三大核心部件。</p><h2 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h2><p>CPU包括运算逻辑部件、寄存器部件和控制部件等。</p><h2 id="逻辑部件"><a href="#逻辑部件" class="headerlink" title="逻辑部件"></a>逻辑部件</h2><p>运算逻辑部件。可以执行定点或浮点算术运算操作、移位操作以及逻辑操作，也可执行地址运算和转换。</p><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>寄存器部件，包括寄存器、专用寄存器和控制寄存器。 通用寄存器又可分定点数和浮点数两类，它们用来保存指令执行过程中临时存放的寄存器操作数和中间（或最终）的操作结果。 通用寄存器是中央处理器的重要部件之一。</p><h2 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h2><p>CPU从存储器或高速缓冲存储器中取出指令，放入指令寄存器，并对指令译码。它把指令分解成一系列的微操作，然后发出各种控制命令，执行微操作系列，从而完成一条指令的执行。指令是计算机规定执行操作的类型和操作数的基本命令。指令是由一个字节或者多个字节组成，其中包括操作码字段、一个或多个有关操作数地址的字段以及一些表征机器状态的状态字以及特征码。有的指令中也直接包含操作数本身。</p><h1 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h1><p>CPU是计算机的核心部件，要想让一个CPU工作，就必须向它提供指令和数据。而指令和数据在存储器中存放，也就是我们平时说的内存。</p><h2 id="存储单元"><a href="#存储单元" class="headerlink" title="存储单元"></a>存储单元</h2><ul><li>存储器被划分若干个存储单元，每个存储单元从0开始循序编号</li><li>这些编号可以看作存储单元在存储器中的地址</li><li>一个存储单元可以存储一个Byte，即8个二进制位（bit）</li></ul><h2 id="CPU对存储器的读写"><a href="#CPU对存储器的读写" class="headerlink" title="CPU对存储器的读写"></a>CPU对存储器的读写</h2><p><img src="https://i.imgur.com/148QNti.png" alt=""></p><ul><li>CPU通过地址线将地址信息3发出</li><li>CPU通过控制线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据</li><li>存储器将三号单元中的数据8通过数据线送入CPU。写操作与读操作的步骤相似。如向3号单元写入数据26</li></ul><h2 id="地址总线"><a href="#地址总线" class="headerlink" title="地址总线"></a>地址总线</h2><ul><li>若一个CPU有N根地址总线，也就是说这个CPU的地址总线的宽度为N，这样的CPU最多可以寻找2的N次方个内存单位</li></ul><h2 id="数据总线"><a href="#数据总线" class="headerlink" title="数据总线"></a>数据总线</h2><ul><li>数据总线的宽度决定了CPU和外界的数据传送速度。8根数据总线 一次可传送一个8位二进制数据（即一个字节）。16根数据总线一次可传送两个字节</li><li>8088CPU的数据总线宽度为8,8086CPU的为16<br><img src="https://i.imgur.com/Eat6XIM.png" alt=""><br><img src="https://i.imgur.com/Nk7DLsB.png" alt=""></li></ul><h2 id="控制总线"><a href="#控制总线" class="headerlink" title="控制总线"></a>控制总线</h2><ul><li>CPU对外部器件的控制是通过控制总线来进行的</li><li>控制总线的跨度决定了CPU对外部器件的控制能力</li></ul><h2 id="检测点1-1"><a href="#检测点1-1" class="headerlink" title="检测点1.1"></a>检测点1.1</h2><ol><li><p>一个CPU的寻址能力为8KB，那么他的地址总线宽度为13。<br>2^n=1024*8<br>n为总线宽度。<br>已知2^10 = 1024<br>因此n=13</p></li><li><p>1KB的存储器有1024个存储单元。存储单元的编号从0到1023 。<br>2^10=1KB=1024</p></li><li><p>1KB的存储器可以存储 8192个bit, 1024 个Byte。<br>1Byte=8bit</p></li><li><p>1GB、1MB、1KB分别是2^30 Byte,2^20 Byte,2^10 Byte。<br>1024<em>1024</em>1024=2^30<br>1024*1024=2^20<br>1024=2^10</p></li><li><p>8080、8088、80286、80386的地址总线宽度分别为16根、20根、24根、32根，则他们的寻址能力分别为： 64 （KB）、 1 （MB）、 16 （MB）、 4 （GB）。<br>2^10=1K 2^6=64<br>2^20=1M<br>2^4=16<br>2^30=1G 2^2=4</p></li><li><p>8080、8088、8086、80286、80386的数据总线宽度分别为8根、8根、16根、16根、32根。则它们一次可以传送的数据为： 1 （B）、 1 （B）、 2 （B）、 2 （B） 4 （B）。<br>1Byte=8bit<br>每8根总线一次最多可传递一字节数据。</p></li><li><p>从内存中读取1024字节的数据，8086至少要读 512 次，80386至少要读 256 次。<br>8086每次读2字节数据<br>80386每次读4字节数据</p></li><li><p>在存储器中，数据和程序以 二进制 形式存放。<br>数据与程序在存储器中以无差别的二进制数据形式存放</p></li></ol><h2 id="存储器芯片"><a href="#存储器芯片" class="headerlink" title="存储器芯片"></a>存储器芯片</h2><ul><li>一台PC机上，装有多个存储器芯片，从读写属性上看分为两类：随机存储器（RAM）和只读存储器（ROM）</li><li>随机存储器用于放供CPU使用的绝大部分程序和数据<br><img src="https://i.imgur.com/Qhqj8C7.png" alt=""></li></ul><h2 id="内存地址空间"><a href="#内存地址空间" class="headerlink" title="内存地址空间"></a>内存地址空间</h2><p><img src="https://i.imgur.com/NQ7MMMa.png" alt=""></p><ul><li>所有的物理存储器被看作一个由若干存储单元组成的的逻辑存储器</li><li>每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间</li><li>CPU在这段地址空间中读写数据，实际上就是在相对于的物理存储器中读写数据</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;cpu&quot;&gt;&lt;a href=&quot;#cpu&quot; class=&quot;headerlink&quot; title=&quot;cpu&quot;&gt;&lt;/a&gt;cpu&lt;/h1&gt;&lt;p&gt;中央处理器（CPU，Central Processing Unit）是一块超大规模的集成电路，是一台计算机的运算核心（Core）和控
      
    
    </summary>
    
    
      <category term="汇编语言" scheme="http://yoursite.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Cookie和Session</title>
    <link href="http://yoursite.com/2018/08/09/Cookie%E5%92%8CSession/"/>
    <id>http://yoursite.com/2018/08/09/Cookie和Session/</id>
    <published>2018-08-09T01:51:41.000Z</published>
    <updated>2018-08-10T12:55:17.783Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、Cookie"><a href="#1、Cookie" class="headerlink" title="1、Cookie"></a>1、Cookie</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>   Cookie是由服务器端生成，发送给User-Agent（一般是浏览器），浏览器会将Cookie的key/value保存到某个目录下的文本文件内，下次请求同一网站时就发送该Cookie给服务器（前提是浏览器设置为启用cookie）。Cookie名称和值可以由服务器端开发自己定义，这样服务器可以知道该用户是否是合法用户以及是否需要重新登录等，服务器可以设置或读取Cookies中包含信息，借此维护用户跟服务器会话中的状态。</p><p>   简单来说，Cookie 是保存在浏览器的一个键值对，每次的HTTP请求都会携带 Cookie 。</p><h2 id="cookie的作用"><a href="#cookie的作用" class="headerlink" title="cookie的作用"></a>cookie的作用</h2><p>　　服务器可以利用Cookies包含信息的任意性来筛选并经常性维护这些信息，以判断在HTTP传输中的状态。Cookies最典型的应用是判定注册用户是否已经登录网站，用户可能会得到提示，是否在下一次进入此网站时保留用户信息以便简化登录手续，这些都是Cookies的功用。另一个重要应用场合是“购物车”之类处理。用户可能会在一段时间内在同一家网站的不同页面中选择不同的商品，这些信息都会写入Cookies，以便在最后付款时提取信息。</p><h2 id="Django框架的下cookie"><a href="#Django框架的下cookie" class="headerlink" title="Django框架的下cookie"></a>Django框架的下cookie</h2><h3 id="1、-获取Cookie："><a href="#1、-获取Cookie：" class="headerlink" title="1、 获取Cookie："></a>1、 获取Cookie：</h3><p>  获取已经设置好的cookies极其简单。 每一个<code>HttpRequest</code> 对象都有一个<code>COOKIES</code> 对象，该对象的行为类似一个字典，你可以使用它读取任何浏览器发送给视图（view）的cookies。</p><pre><code>获取普通cookierequest.COOKIES[&apos;key&apos;]request.COOKIES.get(&apos;key&apos;)解密带签名的cookierequest.get_signed_cookie(key, default=RAISE_ERROR, salt=&apos;&apos;, max_age=None)       参数：           default: 默认值               salt: 加密盐            max_age: 后台控制过期时间</code></pre><h3 id="2、设置Cookie："><a href="#2、设置Cookie：" class="headerlink" title="2、设置Cookie："></a>2、设置Cookie：</h3><pre><code>rep = HttpResponse(...) 或 rep ＝ render(request, ...)#设置cookie需要使用 HttpResponse对象的 set_cookie()方法#设置普通cookierep.set_cookie(key,value,...)#设置带签名的cookierep.set_signed_cookie(key,value,salt=&apos;加密盐&apos;,...)   #参数：        key,              键        value=&apos;&apos;,         值        max_age=None,     超时时间        expires=None,     超时时间(IE requires expires, so set it if hasn&apos;t been already.)        path=&apos;/&apos;,         Cookie生效的路径，/ 表示根路径，特殊的：跟路径的cookie可以被任何url的页面访问        domain=None,      Cookie生效的域名        secure=False,     https传输        httponly=False    只能http协议传输，无法被JavaScript获取（不是绝对，底层抓包可以获取到也可以被覆盖）</code></pre><p>由于cookie保存在客户端的电脑上，所以，JavaScript和jquery也可以操作cookie。</p><pre><code>&lt;script src=&apos;/static/js/jquery.cookie.js&apos;&gt;&lt;/script&gt;$.cookie(&quot;list_pager_num&quot;, 30,{ path: &apos;/&apos; });</code></pre><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>　　Cookie(特别是那些没通过HTTPS传输的)是非常不安全的。 因为HTTP数据是以明文发送的，所以 特别容易受到嗅探攻击。 也就是说，嗅探攻击者可以在网络中拦截并读取cookies，因此你要 绝对避免在cookies中存储敏感信息。 这就意味着您不应该使用cookie来在存储任何敏感信息。</p><p>   因此不能在cookies中存储可能会被篡改的敏感数据。 在cookies中存储 IsLoggedIn=1 ，以标识用户已经登录。 犯这类错误的站点数量多的令人难以置信； 绕过这些网站的安全系统也是易如反掌。</p><h1 id="2、Session"><a href="#2、Session" class="headerlink" title="2、Session"></a>2、Session</h1><h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p>　　在WEB开发中，服务器可以为每个用户浏览器创建一个会话对象（session对象），注意：一个浏览器独占一个session对象(默认情况下)。因此，在需要保存用户数据时，服务器程序可以把用户数据写到用户浏览器独占的session中，当用户使用浏览器访问其它程序时，其它程序可以从用户的session中取出该用户的数据，为用户服务。</p><h3 id="Session与Cookie的区别："><a href="#Session与Cookie的区别：" class="headerlink" title="Session与Cookie的区别："></a>Session与Cookie的区别：</h3><p>　　Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中。</p><p>　　Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。</p><p>　　Session 必须要依赖 Cookie ，因为 Cookie的值就等于 Session 的Key</p><p>###Session的工作原理:</p><p>　　当用户第一次访问时，服务器会给其创建一个session，并且把session的Id(本质是随机字符串)以cookie的形式发送给客户端浏览器，下次再去访问服务器时，客户机浏览器会把存储到cookie中的session的Id一起传递到服务器端，服务器发现客户机浏览器带session id过来了，就会使用内存中与之对应的session为之服务</p><h2 id="2、Django下的-Session-框架"><a href="#2、Django下的-Session-框架" class="headerlink" title="2、Django下的 Session 框架"></a>2、Django下的 Session 框架</h2><p>　　由于存在的限制与安全漏洞，cookies和持续性会话已经成为Web开发中令人头疼的典范。 好消息是，Django的目标正是高效的“头疼杀手”，它自带的session框架会帮你搞定这些问题。</p><p>　　你可以用session 框架来存取每个访问者任意数据， 这些数据在服务器端存储，并对cookie的收发进行了抽象。 Cookies只存储数据的哈希会话ID，而不是数据本身，从而避免了大部分的常见cookie问题。</p><p>Django中默认支持Session，其内部提供了5种类型的Session供开发者使用：</p><ul><li>数据库（默认）</li><li>缓存</li><li>文件</li><li>缓存+数据库</li><li>加密cookie</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1、Cookie&quot;&gt;&lt;a href=&quot;#1、Cookie&quot; class=&quot;headerlink&quot; title=&quot;1、Cookie&quot;&gt;&lt;/a&gt;1、Cookie&lt;/h1&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="cookie" scheme="http://yoursite.com/tags/cookie/"/>
    
  </entry>
  
  <entry>
    <title>黑客游戏</title>
    <link href="http://yoursite.com/2018/08/07/%E9%BB%91%E5%AE%A2%E6%B8%B8%E6%88%8F/"/>
    <id>http://yoursite.com/2018/08/07/黑客游戏/</id>
    <published>2018-08-07T09:15:00.000Z</published>
    <updated>2018-08-07T09:55:21.892Z</updated>
    
    <content type="html"><![CDATA[<ul><li>第一关网址：<a href="http://www.cn-hack.cn/qs/5.htm" target="_blank" rel="noopener">http://www.cn-hack.cn/qs/5.htm</a></li></ul><p>进来可以看到要求输入密码进入下一关，<img src="https://i.imgur.com/E9u1Cwn.png" alt=""><br>可以先看下页面源代码发现下一关的网址，如图：<img src="https://i.imgur.com/nkDdttl.png" alt=""></p><ul><li>那就进入<a href="http://www.cn-hack.cn/qs/2sdfadf.htm来到第二关" target="_blank" rel="noopener">http://www.cn-hack.cn/qs/2sdfadf.htm来到第二关</a></li></ul><p>第二关是一张图片，提示密码在图片中，<br><img src="https://i.imgur.com/uQA0xto.png" alt="">那就把图片下载下来，改为txt文档，打开看看，发现第三关的网址，如图：<img src="https://i.imgur.com/GtIzWA6.png" alt=""></p><ul><li>进入第三关的网址<a href="http://www.cn-hack.cn/qs/or3.htm" target="_blank" rel="noopener">http://www.cn-hack.cn/qs/or3.htm</a><br><img src="https://i.imgur.com/wvtdJwK.png" alt=""></li></ul><p>第三关就直接给出密码：%68%74%74%70%3A%2F%2F%77%77%77%2E%63%6E%2D%68%61%63%6B%2E%63%6E%2F%71%73%2F%34%64%66%73%61%2E%68%74%6D ，不过是经过URL加密过的，进行URL解密得到网址：<a href="http://www.cn-hack.cn/qs/4dfsa.htm" target="_blank" rel="noopener">http://www.cn-hack.cn/qs/4dfsa.htm</a></p><ul><li>进入第四关<a href="http://www.cn-hack.cn/qs/4dfsa.htm" target="_blank" rel="noopener">http://www.cn-hack.cn/qs/4dfsa.htm</a><br><img src="https://i.imgur.com/AR5OmrN.png" alt=""></li></ul><p>需要输入用户名和密码，先看看页面源代码，没发现什么，那就随便输入用户名和密码，然后跳转到一个页面，那就在看看源代码，<img src="https://i.imgur.com/R5V5WR1.jpg" alt=""></p><ul><li>发现第五关的地址<br>进入第五关<a href="http://www.cn-hack.cn/qs/789.htm" target="_blank" rel="noopener">http://www.cn-hack.cn/qs/789.htm</a><br><img src="https://i.imgur.com/JfwzJTa.png" alt=""></li></ul><p>进来就让你输入通用密码中的两个字母，想看页面源代码也看不了，上网搜搜SQL通用密码，知道了密码为 or ,输入进去就通关了<img src="https://i.imgur.com/McRCcr2.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;第一关网址：&lt;a href=&quot;http://www.cn-hack.cn/qs/5.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.cn-hack.cn/qs/5.htm&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;进来可以
      
    
    </summary>
    
    
      <category term="html 前端" scheme="http://yoursite.com/tags/html-%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>python替换敏感词</title>
    <link href="http://yoursite.com/2018/07/31/python%E6%9B%BF%E6%8D%A2%E6%95%8F%E6%84%9F%E8%AF%8D/"/>
    <id>http://yoursite.com/2018/07/31/python替换敏感词/</id>
    <published>2018-07-31T10:25:26.000Z</published>
    <updated>2018-07-31T11:17:44.498Z</updated>
    
    <content type="html"><![CDATA[<h3 id="思路如下"><a href="#思路如下" class="headerlink" title="思路如下:"></a>思路如下:</h3><ul><li>首先，从敏感词文件中读取到敏感词汇，放入容器中</li><li>如果有标点符号，则把一些没用的标点符号去掉</li><li>然后，获取用户输入，判断输入是否包含敏感词汇， 并输出相对应的结果</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def filter_words(path):</span><br><span class="line">    if os.path.isfile(path):</span><br><span class="line">        with open(path, &apos;r&apos;) as f:</span><br><span class="line">            words = f.read()</span><br><span class="line">            words = words.replace(&apos;，&apos;, &apos;&apos;)</span><br><span class="line">            words = words.replace(&apos;\n&apos;, &apos;&apos;)</span><br><span class="line">            return words</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def sense_words():</span><br><span class="line">    words = filter_words(&apos;filter.txt&apos;)</span><br><span class="line">    print(&quot;敏感字内容如下:&quot;)</span><br><span class="line">    print(&quot;------------------------------------------------------------------&quot;)</span><br><span class="line">    print(words)</span><br><span class="line">    print(&quot;------------------------------------------------------------------&quot;)</span><br><span class="line">    while True:</span><br><span class="line">        sentence = input(&quot;请输入：&quot;)</span><br><span class="line">        if sentence == &apos;0&apos;:</span><br><span class="line">            print(&apos;exit&apos;)</span><br><span class="line">            break</span><br><span class="line">        for i in words:</span><br><span class="line">            if i in sentence:</span><br><span class="line">                replace = &apos;&apos;</span><br><span class="line">                for j in range(len(i)):</span><br><span class="line">                    replace = replace + &apos;*&apos;</span><br><span class="line"></span><br><span class="line">                sentence = sentence.replace(i, replace)</span><br><span class="line">        print(sentence)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    sense_words()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;思路如下&quot;&gt;&lt;a href=&quot;#思路如下&quot; class=&quot;headerlink&quot; title=&quot;思路如下:&quot;&gt;&lt;/a&gt;思路如下:&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;首先，从敏感词文件中读取到敏感词汇，放入容器中&lt;/li&gt;
&lt;li&gt;如果有标点符号，则把一些没用的标点符号去掉
      
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>南邮ctf-PY交易</title>
    <link href="http://yoursite.com/2018/07/27/%E5%8D%97%E9%82%AEctf-PY%E4%BA%A4%E6%98%93/"/>
    <id>http://yoursite.com/2018/07/27/南邮ctf-PY交易/</id>
    <published>2018-07-27T13:03:52.000Z</published>
    <updated>2018-07-27T13:21:49.135Z</updated>
    
    <content type="html"><![CDATA[<p>下载后是一个pyc文件 选择<a href="https://tool.lu/pyc/" target="_blank" rel="noopener">https://tool.lu/pyc/</a> 进行解密 如下：</p><p><img src="https://i.imgur.com/jlQnQRO.png" alt=""></p><p>只是一个简单的base64加密，得到的py脚本如下：</p><pre><code>import base64c = &apos;XlNkVmtUI1MgXWBZXCFeKY+AaXNt&apos;m = c.decode(&quot;base64&quot;)s = &apos;&apos;for i in m:        x = ord(i) - 16        x = x ^ 32        s=s+chr(x)print s</code></pre><p>只能在python2.X下运行 得到flag：nctf{d3c0mpil1n9_PyC}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;下载后是一个pyc文件 选择&lt;a href=&quot;https://tool.lu/pyc/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://tool.lu/pyc/&lt;/a&gt; 进行解密 如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.
      
    
    </summary>
    
    
      <category term="ctf" scheme="http://yoursite.com/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>BurpSuite系列----Intruder模块(暴力破解口令)</title>
    <link href="http://yoursite.com/2018/07/27/BurpSuit%20%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%E5%8F%A3%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/07/27/BurpSuit 暴力破解口令/</id>
    <published>2018-07-27T11:51:51.000Z</published>
    <updated>2018-09-08T12:33:40.635Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一、简介</strong></p><p>Burp Intruder是一个强大的工具，用于自动对Web应用程序自定义的攻击，Burp Intruder 是高度可配置的，并被用来在广范围内进行自动化攻击。你可以使用 Burp Intruder 方便地执行许多任务，包括枚举标识符，获取有用数据，漏洞模糊测试。合适的攻击类型取决于应用程序的情况，可能包括：缺陷测试：SQL 注入，跨站点脚本，缓冲区溢出，路径遍历；暴力攻击认证系统；枚举；操纵参数；拖出隐藏的内容和功能；会话令牌测序和会话劫持；数据挖掘；并发攻击；应用层的拒绝服务式攻击。</p><p><strong>二、模块说明</strong></p><p>Burp Intruder主要有四个模块组成:<br>1：Target 用于配置目标服务器进行攻击的详细信息。<br>2：Positions  设置Payloads的插入点以及攻击类型（攻击模式）。<br>3：Payloads  设置payload，配置字典<br>4：Opetions   此选项卡包含了request headers，request engine，attack results ，grep match，grep_extrack，grep payloads和redirections。你可以发动攻击之前，在主要Intruder的UI上编辑这些选项，大部分设置也可以在攻击时对已在运行的窗口进行修改。</p><p>1：Target 目标选项(Target tab)<br>这个选项是用来配置目标服务器的细节：<br><img src="https://i.imgur.com/p8GVQVW.png" alt=""></p><p>2：Positions 位置选项(Positions tab)<br>这个选项是用来配置在攻击里产生的所有 HTTP 请求的模板：<br><img src="https://i.imgur.com/beDxqN4.png" alt=""></p><p>使用一对§字符来标记出有效负荷的位置，在这两个符号直接包含了模板文本的内容。当把一个有效负荷放置到一个给出的请求的特殊位置上时，就把这§符号放到这个位置，然后在两个符号之间的出现的文本都会被有效负荷替换。当有个特殊位置没有为一个给出的请求安排有效负荷时(这只适用”sniper”攻击类型)，那个位置的§字符会被删除，出现在它们之间的文本不会变化。</p><p>当使用 Burp Suite 发送一个其他地方的请求时，Burp Intruder 会对你最想放置有效负荷的位置做一个最好的猜测，并且它把这些放置在每个 URL 和主体参数的值里，以及每个cookie 里。每个标记和它中间的文本都会被加亮以显得更清晰。你可以使用 Intruder 菜单上的选项标记的位置是要替换还是附加现有的参数值。在上面的请求编辑器里，指出了定义位置的数量和文本模板的大小。</p><p>你可以使用选项上的按钮来控制位置上的标记：</p><ol><li>add § — 在当前光标位置插入一个位置标记。</li><li>clear § — 删除整个模板或选中的部分模板里的位置标记。</li><li>auto § — 这会对放置标记的位置做一个猜测，放哪里会有用，然后就把标记放到相应位置。这是一个为攻击常规漏洞(SQL 注入)快速标记出合适位置的有用的功能，然后人工标记是为自定义攻击的。<br>4.refresh — 如果需要，可以刷新编辑器里有颜色的代码。<br>5.clear — 删除整个编辑器内容。</li></ol><p>3：Payloads 有效负荷选项(Payloads tab)<br>这个选项是用来配置一个或多个有效负荷的集合。如果定义了”cluster bomb”和”pitchfork”攻击类型，然后必须为每定义的有效负荷位置(最多8个)配置一个单独的有效负荷。使用”payload set”下拉菜单选择要配置的有效负荷。</p><p>选项1：Payload Sets Payload数量类型设置</p><p>选项2：Payload Opetions[Simple list]  该选项会根据选项1中Payload type的设置而改变<br><img src="https://i.imgur.com/q8CMHwD.png" alt=""></p><p>选项3：Payload Processing 对生成的Payload进行编码、加密、截取等操作</p><p><img src="https://i.imgur.com/KRTkbEF.png" alt=""></p><p>选项4：Payload Encoding 你可以配置哪些有效载荷中的字符应该是URL编码的HTTP请求中的安全传输。任何已配置的URL编码最后应用，任何有效载荷处理规则执行之后。 这是推荐使用此设置进行最终URL编码，而不是一个有效载荷处理规则，因为可以用来有效载荷的grep选项来检查响应为呼应有效载荷的最终URL编码应用之前。<br><img src="https://i.imgur.com/FdBhyoE.png" alt=""></p><p>4：Opetions  选项卡(Options tab) 此选项卡包含了request headers，request engine，attack results ，grep match，grep_extrack，grep payloads和redirections。你可以发动攻击之前，在主要Intruder的UI上编辑这些选项，大部分设置也可以在攻击时对已在运行的窗口进行修改。</p><p>选项1：Request Headers 这些设置控制在Intruder是否更新配置请求头。</p><p><img src="https://i.imgur.com/eIZokRo.png" alt=""></p><p>如果选中‘update Content-Length header’框，Burp Intruder 会使用每个请求的 HTTP 主体长度的正确值，添加或更新这个请求里 HTTP 消息头的内容长度。这个功能对一些需要把可变长度的有效载荷插入到 HTTP 请求模板主体的攻击是很有必要的。这个 HTTP 规范和大多数 web 服务器一样，需要使用消息头内容长度来指定 HTTP 主体长度的正确值。如果没有指定正确值，目标服务器会返回一个错误，也可能返回一个未完成的请求，也可能无限期地等待接收请求里的进一步数据。</p><p>如果选中‘set Connection: close’框，则 Burp Intruder 会添加或更新 HTTP 消息头的连接来请求在每个请求后已关闭的连接。在多数情况下，这个选项会让攻击执行得更快。</p><p>选项2：Request Engine 设置发送请求的线程、超时重试等。</p><p><img src="https://i.imgur.com/Trc0xgE.png" alt=""></p><p>选项3：Attack Results 设置攻击结果的显示。<br><img src="https://i.imgur.com/v7erb9v.png" alt=""></p><p>选项4：Grep - Match 在响应中找出存在指定的内容的一项。<br><img src="https://i.imgur.com/RssN1mz.png" alt=""></p><p>选项5：Grep - Extract 通过正则提取返回信息中的内容。</p><p><img src="https://i.imgur.com/s3WCB2B.png" alt=""></p><p>选项6：Grep - Payloads  这些设置可以用于包含已提交的有效负载的反射的标志结果项目。如果启用了此选项，BurpSuite会添加包含一个复选框指示当前负载的值在每个响应发现新的结果列。</p><p><img src="https://i.imgur.com/gemBP5N.png" alt=""></p><p>选项7：Redirections 重定向响应，控制Burp在进行攻击时如何处理重定向。</p><p><img src="https://i.imgur.com/l0FtAXK.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;一、简介&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Burp Intruder是一个强大的工具，用于自动对Web应用程序自定义的攻击，Burp Intruder 是高度可配置的，并被用来在广范围内进行自动化攻击。你可以使用 Burp Intruder 方便地执行许多任
      
    
    </summary>
    
    
      <category term="ctf" scheme="http://yoursite.com/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>南邮攻防训练平台逆向第四题WxyVM1</title>
    <link href="http://yoursite.com/2018/07/27/WxyVM1/"/>
    <id>http://yoursite.com/2018/07/27/WxyVM1/</id>
    <published>2018-07-27T11:51:51.000Z</published>
    <updated>2018-07-27T13:31:58.299Z</updated>
    
    <content type="html"><![CDATA[<p>下载文件elf文件，运行输入flag，用ida打开逆向算法：</p><p><img src="https://i.imgur.com/LPsRbJE.png" alt=""></p><p>不是很复杂，可以看出flag长度需要24，最终会和已给出dword_601060进行比较，<br>一致则成功，那么现在只需要看上面的sub_4005B6()函数了：<br><img src="https://i.imgur.com/S0pjIrz.png" alt=""></p><p>跟进两个地址进去看一下，发现有已经给出的处理所需数据，只是比较多，有15000个，想了想最后还是决定把数据提出来（其实是没其他办法了==）</p><p>最后是逆推py脚本：</p><p>那个15000的数组太长了，不好复制，要导出在一个文档里，才能复制完</p><pre><code>tmp=[1,  16,  37,   3,  13,  10,   2,  11,  40,   2 ]    //太长了只写前十个 final=[196, 52, 34, 177, 211, 17,   151, 7,   219,   55,       196, 6,  29,  252, 91, 237, 152,  223, 148,  216,       179,  132,   204, 8]i = 14997while i&gt;0:v0 = tmp[i]v3 = tmp[i+2]result =  tmp[i+1]if v0 == 1:    final[result] -= v3elif v0 == 2:    final[result] += v3elif v0 == 3:    final[result] ^= v3elif v0 == 4:    final[result] /= v3!elif v0 == 5:    final[result] ^= final[v3]final[result]&amp;=0xFF     //需要注意的地方，因为ascii字符码范围为0~127，可能发生越界i -= 3for x in final:    print(chr(x), end = &apos;&apos;)</code></pre><p>得到flag：nctf{Embr4ce_Vm_j0in_R3}</p><p>如果不加final[result]&amp;=0xFF 这句话就会越界，如图：<br><img src="https://i.imgur.com/qRMGM9J.png" alt=""></p><p>&amp;0xFF到底是什么意思</p><p>举个简单的例子:</p><p>byte[]  b = new byte[5];</p><p>b[0] = -12;</p><p>byte   8位二进制   =   1个字节    char   2个字节   short (2个字节)    int（4个字节） long（8个字节） float  （4个字节） double（8个字节）</p><p>计算机存储数据机制：正数存储的二进制原码,负数存储的是二进制的补码。  补码是负数的绝对值反码加1。</p><p>比如-12，-12 的绝对值原码是：0000 1100  取反： 1111 0011  加1：  1111 0100</p><p>byte –&gt; int   就是由8位变 32 位 高24位全部补1： 1111 1111 1111 1111 1111 1111 1111 0100 ;</p><p>0xFF 是计算机十六进制的表示： 0x就是代表十六进制，A B C D E F  分别代表10 11 12 13 14 15   F就是15  一个F 代表4位二进制：可以看做 是   8  4  2  1。</p><p>0xFF的二进制表示就是：1111 1111。   高24位补0：0000 0000 0000 0000 0000 0000 1111 1111;</p><p>-12的补码与0xFF 进行与（&amp;）操作  最后就是0000 0000 0000 0000 0000 0000 1111 0100 </p><p>转换为十进制就是 244。</p><p>byte类型的数字要&amp;0xff再赋值给int类型，其本质原因就是想保持二进制补码的一致性。</p><p>当byte要转化为int的时候，高的24位必然会补1，这样，其二进制补码其实已经不一致了，&amp;0xff可以将高的24位置为0，低8位保持原样。这样做的目的就是为了保证二进制数据的一致性。</p><p>有人问为什么上面的式子中b[0]不是8位而是32位，因为当系统检测到byte可能会转化成int或者说byte与int类型进行运算的时候，就会将byte的内存空间高位补1（也就是按符号位补位）扩充到32位，再参与运算。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;下载文件elf文件，运行输入flag，用ida打开逆向算法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/LPsRbJE.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;不是很复杂，可以看出flag长度需要24，最终会和已给出dword_601060进
      
    
    </summary>
    
    
      <category term="ctf" scheme="http://yoursite.com/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>大梦能看见吗？</title>
    <link href="http://yoursite.com/2018/07/22/%E5%A4%A7%E6%A2%A6%E8%83%BD%E7%9C%8B%E8%A7%81%E5%90%97%EF%BC%9F/"/>
    <id>http://yoursite.com/2018/07/22/大梦能看见吗？/</id>
    <published>2018-07-22T04:59:51.000Z</published>
    <updated>2018-07-22T10:26:42.813Z</updated>
    
    <content type="html"><![CDATA[<p>   略略略<br>   略略略<br>   略略略</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;   略略略&lt;br&gt;   略略略&lt;br&gt;   略略略&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>我的世界不会下雪</title>
    <link href="http://yoursite.com/2018/07/21/%E6%88%91%E7%9A%84%E4%B8%96%E7%95%8C%E4%B8%8D%E4%BC%9A%E4%B8%8B%E9%9B%AA/"/>
    <id>http://yoursite.com/2018/07/21/我的世界不会下雪/</id>
    <published>2018-07-21T12:53:55.000Z</published>
    <updated>2018-07-21T12:55:25.621Z</updated>
    
    <content type="html"><![CDATA[<pre><code>我的世界不会下雪 啦啦啦</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;我的世界不会下雪 啦啦啦
&lt;/code&gt;&lt;/pre&gt;
      
    
    </summary>
    
    
  </entry>
  
</feed>
