<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>nocbtm&#39;s Blog</title>
  
  <subtitle>xixi</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-16T08:54:02.352Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Nocbtm</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>cmp指令 </title>
    <link href="http://yoursite.com/2018/09/16/cmp%E6%8C%87%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/09/16/cmp指令/</id>
    <published>2018-09-16T08:16:31.000Z</published>
    <updated>2018-09-16T08:54:02.352Z</updated>
    
    <content type="html"><![CDATA[<p>cmp是比较指令，cmp的功能相当于减法指令，只是不保存结果。<br>cmp指令格式：cmp操作对象1，操作对象2<br>功能：计算操作对象1-操作对象2但不保存结果，仅仅根据计算结果对标志寄存器进行设置。</p><p>指令cmp ax，bx的逻辑含义是比较ax，bx中的值，如果执行后：<br>zf=1，说明(ax)=(bx)<br>zf=0，说明（ax）不等于（bx）<br>cf=1，说明（ax）&lt;(bx)<br>cf=0，说明（ax)&gt;=(bx)<br>cf=0且zf=0，说明（ax）&gt;(bx)<br>cf=1或zf=1,说明(ax)&lt;=(bx）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;cmp是比较指令，cmp的功能相当于减法指令，只是不保存结果。&lt;br&gt;cmp指令格式：cmp操作对象1，操作对象2&lt;br&gt;功能：计算操作对象1-操作对象2但不保存结果，仅仅根据计算结果对标志寄存器进行设置。&lt;/p&gt;
&lt;p&gt;指令cmp ax，bx的逻辑含义是比较ax，bx中的
      
    
    </summary>
    
    
      <category term="汇编语言" scheme="http://yoursite.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>sbb指令 </title>
    <link href="http://yoursite.com/2018/09/16/sbb%E6%8C%87%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/09/16/sbb指令/</id>
    <published>2018-09-16T08:16:16.000Z</published>
    <updated>2018-09-16T08:26:17.749Z</updated>
    
    <content type="html"><![CDATA[<p>sbb是带减法指令，它利于了CF位上记录的错位置。<br>指令格式：sbb 操作对象1，操作对象2<br>功能：操作对象1=操作对象1-操作对象2-CF<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov bx,1000H</span><br><span class="line">mov ax,003EH</span><br><span class="line">sub bx,2000H</span><br><span class="line">sbb ax,0020H</span><br></pre></td></tr></table></figure></p><p>sbb指令执行后，将对CF进行设置。利用sbb指令可以对任意大的数据进行减法运算。上面程序，就是计算003E1000H-00202000H</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;sbb是带减法指令，它利于了CF位上记录的错位置。&lt;br&gt;指令格式：sbb 操作对象1，操作对象2&lt;br&gt;功能：操作对象1=操作对象1-操作对象2-CF&lt;br&gt;例如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla
      
    
    </summary>
    
    
      <category term="汇编语言" scheme="http://yoursite.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>adc指令 </title>
    <link href="http://yoursite.com/2018/09/16/adc%E6%8C%87%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/09/16/adc指令/</id>
    <published>2018-09-16T06:52:54.000Z</published>
    <updated>2018-09-16T08:53:59.773Z</updated>
    
    <content type="html"><![CDATA[<p>adc是带进位加法指令<br>指令格式：adc 操作对象1，操作对象2<br>功能：操作对象1=操作对象1+操作对象2+CF</p><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,2</span><br><span class="line">mov bx,1</span><br><span class="line">sub bx,ax</span><br><span class="line">adc ax,1</span><br></pre></td></tr></table></figure></p><p>执行后，（ax）=4,abc执行时想，相当于计算：（ax）+1+CF=2+1+1=4<br>adc指令的目的，就是来进行假发的第二步运算的。adc指令和add指令相配合就可以对更大的数据进行加法运算。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;adc是带进位加法指令&lt;br&gt;指令格式：adc 操作对象1，操作对象2&lt;br&gt;功能：操作对象1=操作对象1+操作对象2+CF&lt;/p&gt;
&lt;p&gt;例如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter
      
    
    </summary>
    
    
      <category term="汇编语言" scheme="http://yoursite.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>检测点11.1 </title>
    <link href="http://yoursite.com/2018/09/16/%E6%A3%80%E6%B5%8B%E7%82%B911-1/"/>
    <id>http://yoursite.com/2018/09/16/检测点11-1/</id>
    <published>2018-09-16T06:29:30.000Z</published>
    <updated>2018-09-16T06:51:06.208Z</updated>
    
    <content type="html"><![CDATA[<p>写出下面每条指令执行后，ZF、PF、SF、等标志位的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sub al,al     al=0h        ZF=1        PF=1        SF=0 </span><br><span class="line"></span><br><span class="line">mov al,1      al=1h        ZF=1        PF=1        SF=0 </span><br><span class="line"></span><br><span class="line">push ax       ax=1h        ZF=1        PF=1        SF=0 </span><br><span class="line"></span><br><span class="line">pop bx        bx=1h        ZF=1        PF=1        SF=0 </span><br><span class="line"></span><br><span class="line">add al,bl     al=2h        ZF=0        PF=0        SF=0 </span><br><span class="line"></span><br><span class="line">add al,10     al=12h       ZF=0        PF=1        SF=0 </span><br><span class="line"></span><br><span class="line">mul al        ax=144h      ZF=0        PF=1        SF=0</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;写出下面每条指令执行后，ZF、PF、SF、等标志位的值。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span c
      
    
    </summary>
    
    
      <category term="汇编语言" scheme="http://yoursite.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>标志寄存器 </title>
    <link href="http://yoursite.com/2018/09/16/%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8/"/>
    <id>http://yoursite.com/2018/09/16/标志寄存器/</id>
    <published>2018-09-16T03:55:49.000Z</published>
    <updated>2018-09-16T08:53:51.172Z</updated>
    
    <content type="html"><![CDATA[<p>标志寄存器（简称flag）的作用：<br>（1）用来存储相关指令的某些执行结果。<br>（2）用来为CPU执行相关指令提供行为依据。<br>（3）用来控制CPU的相关工作方式。<br>flag和其他寄存器不一样，其他寄存器是用来存放数据的，都是整个寄存器具有一个含义。而flag寄存器死按位起作用的，它的每一位都有专门的含义，记录特定的信息。<img src="https://i.imgur.com/p2T0oAQ.png" alt=""></p><p>flag的1,3,5,12,13,14,15位在8086CPU中没有使用，不具有任何含义</p><h2 id="ZF标志"><a href="#ZF标志" class="headerlink" title="ZF标志"></a>ZF标志</h2><p>flag的第六位是ZF，零标志位。它记录相关指令执行后，其结果是否为0.如果结果为0，那么zf=1，如果结果不为0，那么zf=0</p><p>例如指令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1</span><br><span class="line">sub ax,1</span><br></pre></td></tr></table></figure></p><p>执行后，结果为0，则zf=1</p><h2 id="PF标志"><a href="#PF标志" class="headerlink" title="PF标志"></a>PF标志</h2><p>flag的第二位是PF，奇偶标志位，它记录相关指令执行后，其结果的所有bit位中1的个数是否位偶数。如果1的个数为偶数，pf=1，如果为奇数，那么pf=0<br>比如指令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1</span><br><span class="line">add al,10</span><br></pre></td></tr></table></figure></p><p>执行后，结果为00001011B，其中有3个1，则pf=0</p><h2 id="SF标志"><a href="#SF标志" class="headerlink" title="SF标志"></a>SF标志</h2><p>flag的第七位是SF，符号标志位，它记录相关指令后，其结果是否为负。如果结果为负，sf=1，如果不为负，sf=0<br>计算机通常用补码来表示有符号数据。计算机的UI个数据可以看做是由富豪书，也可以看做成无符号数。比如：<br>00000001B，可以看做无符号数1，或有符号数+1；<br>10000001B，可以看做无符号数129，也可以看作有符号数-127<br>不管我们如何看待，CPU在执行add等指令的时候，就已经包含了两种含义，也将得到同一种信息来记录的两种结果。关键在于我们的程序需要哪一种结果。<br>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,10000001B</span><br><span class="line">add al,1</span><br></pre></td></tr></table></figure></p><p>执行后，结果为10000010B，sf=1，表示：如果指令进行的是有符号数运算，那么结果为负；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,100000001B</span><br><span class="line">add al,011111111B</span><br></pre></td></tr></table></figure></p><p>执行后，结果为0，sf=0，表示：如果指令进行的是有符号数运算，那么结果为非负。<br>某些指令将影响寄存器中的多个标记为，这些被影响的标记位比较全面地记录了指令的执行结果，为相关的处理提供了所需的依据。比如指令sub，al，al执行后，ZF、PF、SF等标志位都要受到影响，它们分别为：1,1,0。</p><h2 id="CF标志位"><a href="#CF标志位" class="headerlink" title="CF标志位"></a>CF标志位</h2><p>flag的第0位是CF，进位标志位，一般情况下，在进行无符号运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。<br>比如，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,98H</span><br><span class="line">add al,al执行后：（al）=30H，CF=1，CF记录了从最高有效位向更高位的进位值</span><br><span class="line">add al,al执行后：（al）=60H，CF=0</span><br></pre></td></tr></table></figure></p><p>而当两个数据做减法的时候，有可能向更高位借位，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,97H</span><br><span class="line">sub al,98H；执行后（al）=FFH，CF=1，CF记录了向更高位的借位值</span><br><span class="line">sub al,al：执行后（al）=0，CF=0，CF记录了向更高位借位值</span><br></pre></td></tr></table></figure></p><h2 id="OF标志位"><a href="#OF标志位" class="headerlink" title="OF标志位"></a>OF标志位</h2><p>flag的第十一位是OF，溢出标志位。一般情况下，OF记录了有符号数运算的结果是否发生了溢出。如果发生溢出，OF=1；如果没有，OF=0.<br>对于无符号数运算，98+99没有进位，CF=0；<br>对于有符号数运算，98+99发生溢出，OF=1<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,F0H</span><br><span class="line">add al,88H</span><br></pre></td></tr></table></figure></p><p>add指令执行后：CF=1，OF=0.对于无符号运算，F0H+78H有进位，CF=1；<br>对于有符号数运算，F0H+78H不发生溢出，OF=0</p><h2 id="DF标志位"><a href="#DF标志位" class="headerlink" title="DF标志位"></a>DF标志位</h2><p>flag的第10位是DF，方向标志位。在串处理指令中，控制每次操作后si，di的增减。<br>df=0 每次操作后si、di递增<br>df=1 每次操作后si、di递减</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;标志寄存器（简称flag）的作用：&lt;br&gt;（1）用来存储相关指令的某些执行结果。&lt;br&gt;（2）用来为CPU执行相关指令提供行为依据。&lt;br&gt;（3）用来控制CPU的相关工作方式。&lt;br&gt;flag和其他寄存器不一样，其他寄存器是用来存放数据的，都是整个寄存器具有一个含义。而fl
      
    
    </summary>
    
    
      <category term="汇编语言" scheme="http://yoursite.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>mul指令</title>
    <link href="http://yoursite.com/2018/09/16/mul%E6%8C%87%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/09/16/mul指令/</id>
    <published>2018-09-16T02:58:12.000Z</published>
    <updated>2018-09-16T03:22:06.182Z</updated>
    
    <content type="html"><![CDATA[<p>mul指令是乘法指令<br>规定：<br>（1）两个项城的数，要么都是8位，要么都是16位，如果是8位，一个默认放在AL中，另一个放在8位reg或内存字单元中：如果是16位，一个默认放在AX中，另一个放在16位reg或内存子单元中。<br>（2）结果：如果是8位乘法，结果默认放在AX中；如果是16位乘法，结果高位默认放在DX中存放，低位在AX中放。</p><p>例如：<br>（1）计算100*10<br>100和10 都小于255，可以做8位陈发，程序如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,100</span><br><span class="line">mov bl,10</span><br><span class="line">mul bl</span><br></pre></td></tr></table></figure></p><p>结果（ax）=1000（03E8H）<br>（2）计算100*10000<br>100小于255，可10000大于255，所以必须做16位乘法，程序如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,100</span><br><span class="line">mov bx,10000</span><br><span class="line">mul bx</span><br></pre></td></tr></table></figure></p><p>结果：(ax)=4240H,(dx)=000FH (F4240H=100000)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;mul指令是乘法指令&lt;br&gt;规定：&lt;br&gt;（1）两个项城的数，要么都是8位，要么都是16位，如果是8位，一个默认放在AL中，另一个放在8位reg或内存字单元中：如果是16位，一个默认放在AX中，另一个放在16位reg或内存子单元中。&lt;br&gt;（2）结果：如果是8位乘法，结果默
      
    
    </summary>
    
    
      <category term="汇编语言" scheme="http://yoursite.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>call指令</title>
    <link href="http://yoursite.com/2018/09/12/call%E6%8C%87%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/09/12/call指令/</id>
    <published>2018-09-12T12:12:52.000Z</published>
    <updated>2018-09-16T08:09:45.700Z</updated>
    
    <content type="html"><![CDATA[<p>CPU执行call指令时，进行两步操作：<br>（1）将当前的IP或CS和IP压入栈中；<br>（2）转移<br>call指令不能实现短转移，除此之外，call指令实现转移的方法和jmp指令的原理相同。</p><h2 id="call-标号"><a href="#call-标号" class="headerlink" title="call 标号"></a>call 标号</h2><h3 id="依据位移进行转移的call指令"><a href="#依据位移进行转移的call指令" class="headerlink" title="依据位移进行转移的call指令"></a>依据位移进行转移的call指令</h3><p>CPU执行 “call 标号”指令时，进行如下操作：<br>（1）(sp)=(sp)-2<br>((ss)*16+(sp))=(IP)<br>(2) (IP)=(IP)+16位位移。</p><p>16位位移=标号处的地址-call指令后的第一个直接的地址；<br>16位位移的范围为-32768~32767，用补码表示；<br>16位位移由编译程序在编译时算出。</p><p>CPU执行”call 标号”时，用汇编语言解释，相当于进行：<br>push IP<br>jmp near ptr 标号</p><h2 id="call-far-ptr-标号"><a href="#call-far-ptr-标号" class="headerlink" title="call far ptr 标号"></a>call far ptr 标号</h2><h3 id="转移的目的之地在指令中的call指令"><a href="#转移的目的之地在指令中的call指令" class="headerlink" title="转移的目的之地在指令中的call指令"></a>转移的目的之地在指令中的call指令</h3><p>CPU执行”call far ptr 标号”指令时，进行如下的操作：<br>(1) (sp)=(sp)-2<br>((ss)*16+（sp))=(CS)</p><p>(sp)=(sp)-2<br>((ss)*16+(sp0=（IP）<br>(2)(CS)=标号所在段的段地址<br>（IP）=标号在段中的偏移地址</p><p>CPU执行”call far ptr 标号”时，用汇编语言解释，相当于进行：<br>push CS<br>push IP<br>jmp far ptr 标号</p><h2 id="call-16-位-reg"><a href="#call-16-位-reg" class="headerlink" title="call 16 位 reg"></a>call 16 位 reg</h2><h3 id="转移地址在寄存器中的call指令"><a href="#转移地址在寄存器中的call指令" class="headerlink" title="转移地址在寄存器中的call指令"></a>转移地址在寄存器中的call指令</h3><p>功能：<br>(sp)=(sp)-2<br>((ss)*16+(sp))=(IP)<br>(IP)=(16位reg)</p><p>用汇编语言解释，相当于进行：<br>push IP<br>jmp 16位 reg</p><h2 id="call-word-ptr-内存单元地址"><a href="#call-word-ptr-内存单元地址" class="headerlink" title="call word ptr 内存单元地址"></a>call word ptr 内存单元地址</h2><p>转移地址在内存中的call指令</p><p>用汇编语言解释，相当于进行：<br>push IP<br>jmp word ptr 内存单元地址</p><p>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov sp,10h</span><br><span class="line">mov as,0123h</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">call word ptr ds:[0]</span><br></pre></td></tr></table></figure></p><p>执行后，（IP）=0123H，（sp）=0EH</p><h2 id="call-dword-ptr-内存单元地址"><a href="#call-dword-ptr-内存单元地址" class="headerlink" title="call dword ptr 内存单元地址"></a>call dword ptr 内存单元地址</h2><p>转移地址在内存中的call指令</p><p>用汇编语言解释，相当于进行：<br>push CS<br>push IP<br>jmp word ptr 内存单元地址</p><p>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov sp,10h</span><br><span class="line">mov as,0123h</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">mov word ptr ds:[2],0</span><br><span class="line">call dword ptr ds:[0]</span><br></pre></td></tr></table></figure></p><p>执行后，（CS）=0，（IP）=0123H，（sp）=0CH</p><h2 id="call和ret的配合使用"><a href="#call和ret的配合使用" class="headerlink" title="call和ret的配合使用"></a>call和ret的配合使用</h2><p>call和ret配合使用来实现子程序<br>先分析一下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start: mov ax,1</span><br><span class="line">   mov cx,3</span><br><span class="line">   call s</span><br><span class="line">   mov bx,ax</span><br><span class="line">   mov ax,4c00h</span><br><span class="line">   int 21h</span><br><span class="line">    s: add ax,bx</span><br><span class="line">   loops</span><br><span class="line">   ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure></p><p>CPU执行这个程序的主要过程<br><img src="https://i.imgur.com/hzLJVqo.png" alt=""><br>可以写一个具有一定功能的程序段，我们称其为子程序，在需要的时候，用call指令去执行。可是执行完子程序后，如何让CPU接着call指令向下执行？call指令去执行子程序之前，call指令后面的指令的地址将存储在栈中，所以可在子程序后面使用ret指令，用栈中的数据设置IP的值，从而转到call指令后面的代码处继续执行。</p><p>具有子程序的源程序的框架如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">main: :</span><br><span class="line">  :</span><br><span class="line">  call sub1</span><br><span class="line">  :</span><br><span class="line">  :</span><br><span class="line">  mov ax,4c00h</span><br><span class="line">  int 21h</span><br><span class="line">sub1: :</span><br><span class="line">  :</span><br><span class="line">  call sub2</span><br><span class="line">  :</span><br><span class="line">  :</span><br><span class="line">  ret</span><br><span class="line">sub2: :</span><br><span class="line">  :</span><br><span class="line">  ret</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end main</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CPU执行call指令时，进行两步操作：&lt;br&gt;（1）将当前的IP或CS和IP压入栈中；&lt;br&gt;（2）转移&lt;br&gt;call指令不能实现短转移，除此之外，call指令实现转移的方法和jmp指令的原理相同。&lt;/p&gt;
&lt;h2 id=&quot;call-标号&quot;&gt;&lt;a href=&quot;#call
      
    
    </summary>
    
    
      <category term="汇编语言" scheme="http://yoursite.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>检测点10.1-10.5</title>
    <link href="http://yoursite.com/2018/09/12/%E6%A3%80%E6%B5%8B%E7%82%B910-1-10-5/"/>
    <id>http://yoursite.com/2018/09/12/检测点10-1-10-5/</id>
    <published>2018-09-12T12:08:33.000Z</published>
    <updated>2018-09-16T02:21:35.910Z</updated>
    
    <content type="html"><![CDATA[<h2 id="10-1"><a href="#10-1" class="headerlink" title="10.1"></a>10.1</h2><p>补全程序，实现从内存1000:0000处开始执行指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">db 16 dup (0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">start: mov ax,stack</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,16</span><br><span class="line">mov ax,0</span><br><span class="line">push ax</span><br><span class="line">mov ax,1000h</span><br><span class="line">retf</span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure></p><p>程序分析：</p><ol><li><p>retf指令作用（CPU角度）：从栈中弹出2个字单元，并修改CS（第二个字）和IP（第一个字）；首先它弹出的是IP，其次是CS，故在压栈时，CS的值首先入栈，IP再入栈。</p><p> 在汇编编程角度，retf实现了远转移。</p></li></ol><p>讲解：在汇编代码这个层次，retf指令作用是修改CS和IP的值，进而使指令从修改后的地址处开始执行。由于它所依赖的是栈中存储的内容，故在压栈过程中要搞清楚入栈的顺序、入栈的值。</p><p>2.熟悉ret指令和RETF指令执行的操作。</p><p>我们编译链接后，debug跟踪check10-1.exe</p><p>-d ss:0</p><p>0B66:0000  00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00   …………….</p><p>在stack数据区中初始化了16个0，此时它未成为栈结构。直到初始化栈的结构。</p><p>执行代码t t（二次）</p><p>AX=0B66  BX=0000  CX=0026  DX=0000  SP=0010  BP=0000  SI=0000  DI=0000</p><p>DS=0B56  ES=0B56  SS=0B66  CS=0B67  IP=0008   NV UP EI PL NZ NA PO NC</p><p>0B67:0008 B80010        MOV     AX,1000</p><p>-d ss:00</p><p>0B66:0000  00 00 00 00 00 00 66 0B-00 00 08 00 67 0B 68 05   ……f…..g.h.</p><p>初始化一个栈sp=0010H（16），栈地址：ss=0b66，这里我们发现一些不应该有的数据（不理会它，它是中断的信息）</p><p>继续执行代码：</p><p>-d ss:0</p><p>0B66:0000  00 00 00 00 00 00 10 00-67 0B 68 05 00 00 00 10   ……..g.h…..</p><p>发现从高位开始存储10 00 00 00四个字节的数据，（体会栈是从高地址向低地址发展的，sp指针从10H减少到了0cH）</p><p>此时的CS=0B67  IP=0010</p><p>执行retf代码：</p><p>我们发现：CS=1000  IP=0000，CS和IP的值改变了。</p><p>总结：ret和RETF依赖于栈的结构存储一个程序执行点（IP或CS和IP），当执行这个代码时，可以恢复到这个程序的执行点（将栈中的数据修改IP或CS和IP，使CPU指向新的CS：IP）</p><h2 id="10-2"><a href="#10-2" class="headerlink" title="10.2"></a>10.2</h2><p>下面的程序执行后，ax中的数值为多少？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">内存地址    机器码      汇编指令       执行后情况</span><br><span class="line"></span><br><span class="line">1000:0     b8 00 00     mov ax,0     ax=0 ip指向1000:3</span><br><span class="line"></span><br><span class="line">1000:3     e8 01 00     call s       读取指令后IP指向下一条指令IP为6;push 6</span><br><span class="line"></span><br><span class="line">1000:6     40           inc ax</span><br><span class="line"></span><br><span class="line">1000:7     58         s:pop ax       ax=6</span><br></pre></td></tr></table></figure></p><p> “call 标号”是将该指令后的第一个字节偏移地址入栈，再转到标号处执行指令。</p><h2 id="10-3"><a href="#10-3" class="headerlink" title="10.3"></a>10.3</h2><p>下面的程序执行后，AX中的数值为多少？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">内存地址        机器码               汇编指令  </span><br><span class="line"></span><br><span class="line">1000：0       b8 00 00             mov ax,0  </span><br><span class="line"></span><br><span class="line">1000：3       9A 09 00 00 10       call far ptr s    ;cs为1000h，ip为8，</span><br><span class="line">                                                      push 1000h，push 8</span><br><span class="line">1000：8       40                   inc ax   </span><br><span class="line">1000：9       58                   s:  pop ax        ;ax=8h  </span><br><span class="line">                                       add ax,ax     ;ax=10h  </span><br><span class="line">                                       pop bx        ;bx=1000h  </span><br><span class="line">                                       add ax,bx     ;ax=1010h</span><br></pre></td></tr></table></figure></p><p>执行call far ptr s时，取IP为8,add ax,ax    ax=16<br>BX=CS=1000H 相加转16进制ax=1010H</p><h2 id="10-4"><a href="#10-4" class="headerlink" title="10.4"></a>10.4</h2><p>下面的程序执行后，AX中的数值为多少？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">内存地址        机器码          汇编指令   </span><br><span class="line">1000：0       b8 06 00        mov ax,6   </span><br><span class="line">1000：3       ff d0           call ax</span><br><span class="line">1000：5       40              inc ax   </span><br><span class="line">1000：6                       mov bp,sp  </span><br><span class="line">                              add ax,[bp]</span><br></pre></td></tr></table></figure></p><p>在执行了<br>call ax<br>的时候<br>指令寄存器会指向下一条指令的起始地址，也就是<br>1000:5 inc ax<br>然后指令寄存器ip=5要压入堆栈<br>然后跳转到cs:ax指定的地址执行<br>又因为此时ax中的值为6 ,cs=1000<br>所以跳转到1000:6执行<br>于是修改 ip为6<br>到此时call ax指令才执行完毕</p><p>然后就执行<br>mov bp,sp<br>因为sp里面放的是堆顶的地址，所以bp也是栈顶的地址了<br>之后<br>add ax,[bp]<br>因为，bp里面放的是栈顶的地址，所以 [bp] 寄存器寻址后 [bp]实际是代表该地址单元的内容，也就是栈顶的内容，因为先前我把ip压入了堆栈，所以[bp]得到的内容就是5(先前在call ax时候压入的ip的值)</p><p>所以 ax=ax+[bp]<br>也就是 ax=6+5=0BH</p><h2 id="10-5"><a href="#10-5" class="headerlink" title="10.5"></a>10.5</h2><p>题目：下面的程序执行后，ax中的数据是多少？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code </span><br><span class="line">stack segment </span><br><span class="line">dw 8 dup (0) </span><br><span class="line">stack ends </span><br><span class="line"></span><br><span class="line">code segment </span><br><span class="line">start :mov ax,stack </span><br><span class="line">       mov ss,ax </span><br><span class="line">      mov sp,16        </span><br><span class="line"></span><br><span class="line">      mov ds,ax       </span><br><span class="line">      mov ax,0  </span><br><span class="line">      call word ptr ds:[0eH]     </span><br><span class="line">      inc ax </span><br><span class="line">      inc ax </span><br><span class="line">      inc ax </span><br><span class="line">code ends </span><br><span class="line">end start</span><br></pre></td></tr></table></figure></p><p>解答：刚开始时mov ax,stack到mov sp,10h是分别设置ss：sp指向程序中定义的栈段stack。mov ds,ax也把数据段的段地址也设置成了stack段的段地址。call word prt ds:[0Eh]相当于是sp=sp-2，push ip，jmp word ptr ds:[0Eh]这三条指令。而sp-2就是0Eh了，push ip就是把第一条inc ax对应的ip值给压入栈。存放在ss:[0Eh]和ss:[0Fh]里面。接下来是jmp word ptr ds:[0Eh]了，它的功能就是把stack段的[0eh]子单元的值付给ip，很巧的是stack中[0eh]字单元的值就是刚刚压入的ip值。所以ip值没有改变。程序继续执行inc ax后面的程序。所以ax的值是3.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;10-1&quot;&gt;&lt;a href=&quot;#10-1&quot; class=&quot;headerlink&quot; title=&quot;10.1&quot;&gt;&lt;/a&gt;10.1&lt;/h2&gt;&lt;p&gt;补全程序，实现从内存1000:0000处开始执行指令&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;
      
    
    </summary>
    
    
      <category term="汇编语言" scheme="http://yoursite.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>ret和retf</title>
    <link href="http://yoursite.com/2018/09/12/ret%E5%92%8Cretf/"/>
    <id>http://yoursite.com/2018/09/12/ret和retf/</id>
    <published>2018-09-12T11:44:58.000Z</published>
    <updated>2018-09-12T12:41:28.642Z</updated>
    
    <content type="html"><![CDATA[<p>ret指令用栈中的数据，修改IP的内容，从而实现进转移；<br>retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移；</p><p>CPU执行ret指令时，进行下面两步操作：<br>（1） （IP)=((ss)*16+(sp))<br>（2） (sp)=(sp)+2</p><p>CPU执行retf指令时，进行下面4部操作：<br>(1) (IP)=((ss)<em>16+(sp))<br>(2) (sp)=(sp)+2<br>(3) (CS)=((ss)</em>16+(sp))<br>(4) (sp)=(sp)+2</p><p>可以看出，CPU执行ret指令时，相当于进行：<br>pop IP</p><p>CPU执行retf指令时，相当于进行：<br>pop IP<br>pop CS</p><p>例如：<br>1、<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">db 16 dup (0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">start: mov ax,stack</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,16</span><br><span class="line">mov ax,0</span><br><span class="line">push ax</span><br><span class="line">mov bx,0</span><br><span class="line">ret</span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure></p><p>ret指令执行后CS：IP指向代码的第一条指令<br>2、<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">assume cs;code</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">db 16 dup (0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">start: mov ax,stack</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,16</span><br><span class="line">mov ax,0</span><br><span class="line">push cs</span><br><span class="line">push ax</span><br><span class="line">mov bx,0</span><br><span class="line">retf</span><br><span class="line">code ends</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure></p><p>retf指令执行后，CS：IP指向代码段的第一条指令。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ret指令用栈中的数据，修改IP的内容，从而实现进转移；&lt;br&gt;retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移；&lt;/p&gt;
&lt;p&gt;CPU执行ret指令时，进行下面两步操作：&lt;br&gt;（1） （IP)=((ss)*16+(sp))&lt;br&gt;（2） (sp)=(sp)
      
    
    </summary>
    
    
      <category term="汇编语言" scheme="http://yoursite.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>操作符offset</title>
    <link href="http://yoursite.com/2018/09/11/%E6%93%8D%E4%BD%9C%E7%AC%A6offset/"/>
    <id>http://yoursite.com/2018/09/11/操作符offset/</id>
    <published>2018-09-11T13:26:03.000Z</published>
    <updated>2018-09-11T13:44:54.175Z</updated>
    
    <content type="html"><![CDATA[<p>操作符offest在汇编语言中是由编译器处理的符号，它的功能是取得标号的偏移地址。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,offset strat      ;相当于mov ax,0</span><br><span class="line">s: mov ax,offset s             ;相当于mov ax,3</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure></p><p>offset操作符取得了标号start和s的偏移地址0和3<br>因为start是代码段中的标号，它所标记的指令是代码段中的第一条指令，偏移地址为0；<br>而s标记的指令是代码段中的第二条指令，第一条指令长度为3个字节，则s的偏移地址为3.</p><p>又比如：<img src="https://i.imgur.com/hPg1Fmt.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;操作符offest在汇编语言中是由编译器处理的符号，它的功能是取得标号的偏移地址。比如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/
      
    
    </summary>
    
    
      <category term="汇编语言" scheme="http://yoursite.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>dup指令</title>
    <link href="http://yoursite.com/2018/09/11/dup%E6%8C%87%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/09/11/dup指令/</id>
    <published>2018-09-11T13:04:52.000Z</published>
    <updated>2018-09-11T13:15:28.797Z</updated>
    
    <content type="html"><![CDATA[<p>dup是一个操作符，在汇编语言中同db、dw、dd、等一样。它是和db、dw、dd、等数据定义伪指令配合使用的，用来数据的重复。<br>dup的使用格式如下：<br>db 重复的次数 dup （重复的字节型数据）<br>dw 重复的次数 dup （重复的字型数据）<br>dd 重复的次数 dup （重复的双字符数据）</p><p>比如：<br>1、<br><figure class="highlight plain"><figcaption><span>3 dup (0)```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">定义了三个字节，它们的值都是0，相当于db 0,0,0。</span><br><span class="line"></span><br><span class="line">2、</span><br></pre></td></tr></table></figure></p><p>stack segment<br>db 200 dup (0)<br>stack ends<br><code>`</code><br>定义了一个容量为200个字节的栈段</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;dup是一个操作符，在汇编语言中同db、dw、dd、等一样。它是和db、dw、dd、等数据定义伪指令配合使用的，用来数据的重复。&lt;br&gt;dup的使用格式如下：&lt;br&gt;db 重复的次数 dup （重复的字节型数据）&lt;br&gt;dw 重复的次数 dup （重复的字型数据）&lt;br&gt;d
      
    
    </summary>
    
    
      <category term="汇编语言" scheme="http://yoursite.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>div指令</title>
    <link href="http://yoursite.com/2018/09/11/div%E6%8C%87%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/09/11/div指令/</id>
    <published>2018-09-11T11:48:19.000Z</published>
    <updated>2018-09-11T13:03:34.063Z</updated>
    
    <content type="html"><![CDATA[<p>div是除法指令，使用div做除法时应注意以下问题。</p><p>1、除数：有8位和16位两种，在一个reg或内存单元中。<br>2、被除数：默认放在AX或DX和AX中，如果除数位8位，被除数则为16位，默认在AX中存放；如果除数为16位，被除数则为32位，在DX和AX中存放，DX放高16位，AX存放低16位。<br>3、结果：如果除数为8位，则AL存储除法操作的商，AH存储除法操作的余数；<br>如果除数为16位，则AX存储除法操作的商，DX存储除法操作的余数。</p><p>例如：<br>1、除数为8位：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div byte ptr ds:[0]</span><br></pre></td></tr></table></figure><p>含义：（al）=（ax）/（（ds）*16+0）的商</p><p>（ah）=（ax）/（ds)*16+0)的余数</p><p>2、除数为16位：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div word ptr es:[0]</span><br></pre></td></tr></table></figure><p>含义：(ax)=[(dx)*10000H+(ax)] /</p><p>((es)*16+0)的商</p><p>（dx）=[(dx)*10000H+(ax)] / </p><p>(es)*16+0)的余数</p><p>3、用除法指令计算100001/100</p><p>分析：被除数100001大于65535（ffffh），所以用dx和ax两个寄存器联合存放100001，除数100虽然小于255可以在一个8位寄存器中存放，但是，因为除数是32位的，除数应为16位，所以要用16位寄存器存放除数100<br>100001表示为16进制为：186A1H。程序如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov dx,1</span><br><span class="line">mov ax,86A1H      ;(dx)*10000H+(ax)=100001</span><br><span class="line">mov bx,100</span><br><span class="line">div bx</span><br></pre></td></tr></table></figure></p><p>程序执行后（ax）=03E8H（即1000）（dx）=1（余数为1）</p><p>4、用除法指令计算1001/100<br>分析：被除数1001可用ax寄存器存放，除数100可用8位寄存器存放，也就是说，要进行8位的除法。程序如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1001</span><br><span class="line">mov bl,100</span><br><span class="line">div bl</span><br></pre></td></tr></table></figure></p><p>程序执行后，（al）=0AH（即10），（ah）=1（余数为1）</p><p>5、<img src="https://i.imgur.com/YtUX3E3.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;div是除法指令，使用div做除法时应注意以下问题。&lt;/p&gt;
&lt;p&gt;1、除数：有8位和16位两种，在一个reg或内存单元中。&lt;br&gt;2、被除数：默认放在AX或DX和AX中，如果除数位8位，被除数则为16位，默认在AX中存放；如果除数为16位，被除数则为32位，在DX和AX中
      
    
    </summary>
    
    
      <category term="汇编语言" scheme="http://yoursite.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>and和or指令</title>
    <link href="http://yoursite.com/2018/09/11/and%E5%92%8Cor%E6%8C%87%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/09/11/and和or指令/</id>
    <published>2018-09-11T11:05:02.000Z</published>
    <updated>2018-09-11T11:27:07.440Z</updated>
    
    <content type="html"><![CDATA[<p>1、and指令：逻辑与指令，按位进行与运算<br>通过该指令可将操作对象位设为0，其他为不变</p><p>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,01100011B</span><br><span class="line">and al,00111011B</span><br></pre></td></tr></table></figure></p><p>执行后al=00100011B</p><p>2、or指令：逻辑或指令，按位进行或运算。<br>通过该指令可将操作对象位设为1，其他位不变</p><p>例如指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al,0110001B</span><br><span class="line">or al,00111011B</span><br></pre></td></tr></table></figure><p>执行后：al=01111011B</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1、and指令：逻辑与指令，按位进行与运算&lt;br&gt;通过该指令可将操作对象位设为0，其他为不变&lt;/p&gt;
&lt;p&gt;例如：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cla
      
    
    </summary>
    
    
      <category term="汇编语言" scheme="http://yoursite.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>检测点6.1</title>
    <link href="http://yoursite.com/2018/09/10/%E6%A3%80%E6%B5%8B%E7%82%B96-1/"/>
    <id>http://yoursite.com/2018/09/10/检测点6-1/</id>
    <published>2018-09-10T13:01:50.000Z</published>
    <updated>2018-09-10T13:16:23.212Z</updated>
    
    <content type="html"><![CDATA[<p>知识点：1.用于显式地指明内存单元的段地址的”ds:” “cs:” “ss:” “es:” 在汇编语言中称为段前缀</p><p>2.Dos方式下，一般情况，0:200 - 0:2ff空间中没有系统或其他程序的数据或代码。</p><p>检测点：(1)下面的程序实现依次用内存0:0 - 0:15单元中的内容改写程序中的数据，完成程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line"></span><br><span class="line">dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h</span><br><span class="line">start: mov ax,0</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,0</span><br><span class="line"></span><br><span class="line">mov cx,8</span><br><span class="line">s: mov ax,[bx]</span><br><span class="line">mov cs:[bx],ax</span><br><span class="line">add bx,2</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure></p><p>(2)下面的程序实现依次用内存0:0 - 0:15单元中的内容改写程序中的数据，数据的传送用栈来进行。栈空间设置栈程序中。完成程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h</span><br><span class="line">dw 0,0,0,0,0,0,0,0,0,0</span><br><span class="line"></span><br><span class="line">start: mov ax,cs</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,24h</span><br><span class="line">mov ax,0</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,8</span><br><span class="line">s: push [bx]</span><br><span class="line">pop [bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;知识点：1.用于显式地指明内存单元的段地址的”ds:” “cs:” “ss:” “es:” 在汇编语言中称为段前缀&lt;/p&gt;
&lt;p&gt;2.Dos方式下，一般情况，0:200 - 0:2ff空间中没有系统或其他程序的数据或代码。&lt;/p&gt;
&lt;p&gt;检测点：(1)下面的程序实现依次用内
      
    
    </summary>
    
    
      <category term="汇编语言" scheme="http://yoursite.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>在代码段中使用栈</title>
    <link href="http://yoursite.com/2018/09/10/%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%AE%B5%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%A0%88/"/>
    <id>http://yoursite.com/2018/09/10/在代码段中使用栈/</id>
    <published>2018-09-10T12:14:07.000Z</published>
    <updated>2018-09-10T13:01:16.912Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">assum cs:codesg</span><br><span class="line">code segement</span><br><span class="line"></span><br><span class="line">dw 0123H，0456H，0789H，0abcH，0defH，0fedH，0cbaH，0987H</span><br><span class="line">dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0    ;用dw定义16个字型数据，在程序加载后，将取得</span><br><span class="line">                                          16个字的内存空间，存放着6个数据。在后面的程</span><br><span class="line">                                          序中将这段空间当作栈来使用</span><br><span class="line">start: mov ax,cs</span><br><span class="line">   mov ss,ax</span><br><span class="line">   mv sp,30h                         ;设置栈顶ss：sp指向CS：30</span><br><span class="line"></span><br><span class="line">       mov bx,0</span><br><span class="line">   mov cz,8</span><br><span class="line"></span><br><span class="line">   s: push cs:[bx]</span><br><span class="line">   add bx,2</span><br><span class="line">   loop s</span><br><span class="line"></span><br><span class="line">   s0: pop cs[bx]</span><br><span class="line">   add bx,2</span><br><span class="line">   loop s0                          ;将定义的数据逆序存放</span><br><span class="line"></span><br><span class="line">   mov ax,4c00h</span><br><span class="line">   int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
      <category term="汇编语言" scheme="http://yoursite.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>在代码段中使用数据</title>
    <link href="http://yoursite.com/2018/09/10/%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%AE%B5%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE/"/>
    <id>http://yoursite.com/2018/09/10/在代码段中使用数据/</id>
    <published>2018-09-10T12:13:37.000Z</published>
    <updated>2018-09-10T13:16:45.559Z</updated>
    
    <content type="html"><![CDATA[<p>编程计算以下8个数据的和，结果存在ax寄存器中：</p><p>0123H，0456H，0789H，0abcH，0defH，0fedH，0cbaH，0987H<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assum cs:code </span><br><span class="line">code segement</span><br><span class="line"></span><br><span class="line">dw 0123H，0456H，0789H，0abcH，0defH，0fedH，0cbaH，0987H</span><br><span class="line">mov bx,0</span><br><span class="line">mov ax,0</span><br><span class="line">mov cz,8</span><br><span class="line">s: add ax,cs:[bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><p>dw的含义是定义字型数据，dw即“define word”，在这里，使用dw定义了8个字型数据，它们所占的内存空间的大小为16个字节。<br>程序在运行的时候cs中存放代码段的段地址，所以可以从cs中得到它们的段地址</p><p>因为用dw定义的数据处于代码段的最开始，所以偏移地址为0，这8个数据就在代码段的偏移0、2、4、6、8、A、C、E处。程序运行时，它们的地址就是CS：0、CS：2、CS：4、CS：6、CS：8、CS：A、CS：C、CS：E。<br>用bx存放加2递增的偏移地址用循环来进行累加。在循环开始前,设置（bx）=0，CS：BX指向第一个数据存放的字单元。每次循环中（bx）=（bx）+2，CS：BX指向下一个数据所在的字单元。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;编程计算以下8个数据的和，结果存在ax寄存器中：&lt;/p&gt;
&lt;p&gt;0123H，0456H，0789H，0abcH，0defH，0fedH，0cbaH，0987H&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Loop指令</title>
    <link href="http://yoursite.com/2018/09/10/Loop%E6%8C%87%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/09/10/Loop指令/</id>
    <published>2018-09-10T11:34:52.000Z</published>
    <updated>2018-09-10T12:03:05.654Z</updated>
    
    <content type="html"><![CDATA[<p>loop指令的格式是：loop 标号<br>CPU执行loop指令的时候，要进行两步操作，<br>1、(cx)=(cx)-1<br>2、判断cx中的值，不为零则转至标号处执行，如果为零则向下执行</p><p>例子1：计算2的十二次方<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code </span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">mov ax,2</span><br><span class="line">mov cx,11</span><br><span class="line">s: add ax,ax</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><p>例子2：用加法计算123*236</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">mov ax,0</span><br><span class="line">mov cx,123</span><br><span class="line">s: add ax,236</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;loop指令的格式是：loop 标号&lt;br&gt;CPU执行loop指令的时候，要进行两步操作，&lt;br&gt;1、(cx)=(cx)-1&lt;br&gt;2、判断cx中的值，不为零则转至标号处执行，如果为零则向下执行&lt;/p&gt;
&lt;p&gt;例子1：计算2的十二次方&lt;br&gt;&lt;figure class=&quot;h
      
    
    </summary>
    
    
      <category term="汇编语言" scheme="http://yoursite.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>寄存器（内存访问）</title>
    <link href="http://yoursite.com/2018/09/08/%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%EF%BC%89/"/>
    <id>http://yoursite.com/2018/09/08/寄存器（内存访问）/</id>
    <published>2018-09-08T09:23:21.000Z</published>
    <updated>2018-09-08T12:16:33.951Z</updated>
    
    <content type="html"><![CDATA[<h1 id="寄存器（内存访问）"><a href="#寄存器（内存访问）" class="headerlink" title="寄存器（内存访问）"></a>寄存器（内存访问）</h1><h2 id="内存中字的存储"><a href="#内存中字的存储" class="headerlink" title="内存中字的存储"></a>内存中字的存储</h2><p><img src="https://i.imgur.com/elPokAF.png" alt=""><br><img src="https://i.imgur.com/SvkdkRI.png" alt=""></p><h2 id="DS和-address"><a href="#DS和-address" class="headerlink" title="DS和[address]"></a>DS和[address]</h2><ul><li>8086CPU中有一个DS寄存器，通常用来存放要访问数据的地址段</li><li>[address]表示一个内存单元，address表示内存单元的偏移地址</li></ul><p>如果要读取10000H单元的内容，可以用如下的程序段进行</p><pre><code>mov bx,1000Hmov ds,bxmov al,[0]</code></pre><p>上面的3条指令将10000H（1000：0）中的数据读到al中<br><img src="https://i.imgur.com/m0dfFbY.png" alt=""></p><h2 id="字的传送"><a href="#字的传送" class="headerlink" title="字的传送"></a>字的传送</h2><pre><code>mov bx,1000Hmov ds,bxmov ax,[0]        ;1000:0处的数据送入axmov [0],cx        ;cx中的16位数据送到1000:0处</code></pre><h3 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h3><p><img src="https://i.imgur.com/Qxgebh8.png" alt=""></p><h3 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h3><p><img src="https://i.imgur.com/AWykHOU.png" alt=""><br><img src="https://i.imgur.com/5S8XbaN.png" alt=""></p><h3 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h3><p><img src="https://i.imgur.com/XObjMl6.png" alt=""></p><h2 id="检测点3-1"><a href="#检测点3-1" class="headerlink" title="检测点3.1"></a>检测点3.1</h2><p>(1)在Debug 中，用”d 0:0 1f” 查看内存，结果如下：</p><pre><code>0000:0000 70 80 F0 30 EF 60 30 E2-00 80 80 12 66 20 22 600000:0010 62 26 E6 D6 CC 2E 3C 3B-AB BA 00 00 26 06 66 88</code></pre><p>下面的程序执行前，AX=0,BX=0，写出每条汇编指令执行完毕后相关寄存器中的值：</p><pre><code>Mov ax,1Mov ds,axMov ax,[0000]       AX=2662Mov bx,[0001]       BX=E626Mov ax,bx           AX=E626Mov ax,[0000]       AX=2662Mov bx,[0002]       BX=D6E6Add ax,bx           AX=FD48Add ax,[0004]       AX=2C14Mov ax,0            AX=0Mov al,[0002]       AX=00E6Mov bx,0            BX=0Mov bl,[000C]       BX=0026Add al,bl           AX=000C</code></pre><p>(2)<br><img src="https://i.imgur.com/qN5f1kZ.png" alt=""><img src="https://i.imgur.com/CM1eYbo.png" alt=""></p><pre><code>mov ax,6622H        CS=2000H IP=0002Hjmp 0ff0:0100       CS=0ff0H IP=0100H  物理地址=CS*16+IP=10000Hmov ax,2000H        CS=0ff0H IP=0103Hmov ds,ax           CS=0ff0H IP=0105Hmov ax,[0008]       CS=0ff0H IP=0108Hmov ax,[0002]       CS=0ff0H Ip=010BH</code></pre><p>第一步：CS=2000H，IP=0H 地址：20000H</p><pre><code>读取第一条指令 mov ax,6622HCS=2000H, IP=03H执行指令 mov ax,6622H执行结果：AX=6622H</code></pre><p>第二步：地址：20003H</p><pre><code>读取第二条指令 jmp 0ff0:0100CS=2000H,IP=03H执行指令：jmp 0ff0:0100执行结果：CS=0ff0H, IP=0100H</code></pre><p>第三步：地址：CSx16+IP = 10000H</p><pre><code>读取指令：mov ax,2000HCS=0ff0H, IP=0103H执行指令：mov ax,2000H执行结果：AX=2000H</code></pre><p>第四步：地址：10003H</p><pre><code>读取指令：mov ds,axCS=0ff0H, IP=0105H执行指令：mov ds,ax  执行结果：ds=2000H</code></pre><p>第五步：地址：10005H</p><pre><code>读取指令：mov ax,[0008]</code></pre><p>CS=0ff0H，IP=10008H，DS=2000H</p><pre><code>执行指令：mov ax,[0008] ;</code></pre><p>也就是将地址【DS：IP】为 2000H：0008H的值移动到AX</p><pre><code>执行结果：AX=C189H</code></pre><p>第六步：读取指令：mov ax,[0002]</p><pre><code>CS=0ff0H ,IP=1000BH,DS=2000H执行指令：mov ax,[0002]执行结果：AX=EA66</code></pre><p>知识点：</p><p>任意时刻SS:SP 指向栈顶元素。</p><p>push指令和pop指令执行时，CPU从 SS和SP中得到栈顶的地址。</p><p>注：SS(Stack Segmet)堆栈段寄存器，指向当前的堆栈段。</p><p>SP(Stack Pointer)堆栈指针寄存器，主要用于堆栈操作，存放堆栈段首地</p><p>址到栈顶单元的偏移量。</p><p>入栈时：886CPU栈顶从高地址向低地址方向增长。</p><h2 id="CPU提供的栈机制"><a href="#CPU提供的栈机制" class="headerlink" title="CPU提供的栈机制"></a>CPU提供的栈机制</h2><p>CS、IP中存放着当前指令的段地址和偏移地址，而段寄存器SS和寄存器SP为CPU的入栈，出栈服务。任意时刻SS：SP指向栈顶元素。<br><img src="https://i.imgur.com/jCkIgBA.png" alt=""></p><h3 id="问题1-1"><a href="#问题1-1" class="headerlink" title="问题1"></a>问题1</h3><p>如果将10000H~1000Fh这段空间当作栈，初始空间是空的，此时，SS=1000H，SP=0010H<br><img src="https://i.imgur.com/JxoJjTE.png" alt=""></p><h3 id="问题2-1"><a href="#问题2-1" class="headerlink" title="问题2"></a>问题2</h3><p>利用栈，交换AX和BX中的数据</p><pre><code>mov ax,1000Hmov ss,axmov sp,0010H         ;初始化栈顶mov ax=001AHmov bx=001BHpush axpush bxpop ax               ；当前栈顶的数据是bx中的欲来的数据，所以先pop ax，即ax=001BHpop bx               ；执行pop ax后，栈顶的数据为ax原来的数据，所以再pop bx，即bx=001AH</code></pre><h3 id="问题3-1"><a href="#问题3-1" class="headerlink" title="问题3"></a>问题3</h3><p>利用栈在10000H处写入数据2266H</p><pre><code>mov ax,1000Hmov ss,axmov sp,0002Hmov ax,2266Hpush ax</code></pre><p>一般写法</p><pre><code>mov ax,1000Hmov ds,axmov ax,2266Hmov [0],ax</code></pre><p><img src="https://i.imgur.com/uQLhSXM.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;寄存器（内存访问）&quot;&gt;&lt;a href=&quot;#寄存器（内存访问）&quot; class=&quot;headerlink&quot; title=&quot;寄存器（内存访问）&quot;&gt;&lt;/a&gt;寄存器（内存访问）&lt;/h1&gt;&lt;h2 id=&quot;内存中字的存储&quot;&gt;&lt;a href=&quot;#内存中字的存储&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="汇编语言" scheme="http://yoursite.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>寄存器</title>
    <link href="http://yoursite.com/2018/09/07/%E5%AF%84%E5%AD%98%E5%99%A8/"/>
    <id>http://yoursite.com/2018/09/07/寄存器/</id>
    <published>2018-09-07T14:00:19.000Z</published>
    <updated>2018-09-08T09:24:47.381Z</updated>
    
    <content type="html"><![CDATA[<h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><ul><li>一个典型的CPU有运算器、控制器、寄存器等器件构成</li><li>寄存器是CPU中程序员可以用执行读写的部件。程序员通过改变各种寄存器中的内容来实现对CPU的控制</li><li>不同的CPU，寄存器的个数、结构是不同的。8086CPU有14个寄存器，每个寄存器有一个名称。这些寄存器是：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PWS、</li></ul><h2 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h2><ul><li>8086CPU的的所有寄存器都是16位的，可以存放两个字节，AX、BX、CX、DX、这四个寄存器位通用寄存器</li><li>一个16位的寄存器可以存储一个16位的数据，所能存储的数据最大值为2^16-1，或用16进制表示为FFFFH，也为10000H-1</li><li>AX的低8位构成了AL寄存器，高8位构成了AH寄存器，AH和AL寄存器是可以独立使用的<br><img src="https://i.imgur.com/QNIONUF.png" alt=""></li></ul><h2 id="字在寄存器中的存储"><a href="#字在寄存器中的存储" class="headerlink" title="字在寄存器中的存储"></a>字在寄存器中的存储</h2><ul><li>一个16位的寄存器可以存放两个字节（byte），即为一个字（word），一个字等于两个字节</li><li>而计算机的存储单元为字节（byte），一个内存（存储）单元可以存放8位数据（bit），也就是说，计算机中的数据大多是由1~N个8位数据构成。</li><li>很多时候，用16进制表示数据可以直观的看出数据是由哪些8位数据构成，如2000写成4E20，可以看出是由4E和20两个8位数据构成的，如果AX中存放4E20H，则AH里是4E，AL里是20<h2 id="mov和add汇编指令"><a href="#mov和add汇编指令" class="headerlink" title="mov和add汇编指令"></a>mov和add汇编指令</h2>原AX，BX中的值：0000H，0000H<br><img src="https://i.imgur.com/rMcnnbL.png" alt=""><br><img src="https://i.imgur.com/VwH9tTk.png" alt=""><br>问题2.1<br>在执行前ax和bx中的数据都为8226H，相加后所得值为：1044CH，但ax为16位寄存器，只能存放4位十六进制的数据，所以最高位的1不能在ax中保存，，ax中的数据为：044CH<br><img src="https://i.imgur.com/3DioByx.png" alt=""><br>问题2.2<br>在执行前，al中的数据为C5H，相加后所得的值为：158H，但是al为8位寄存器，只能诚邀您放两位16精致的数据，所以最高位的1丢失，ax中的数据为：0058H<br><img src="https://i.imgur.com/Kb8TLw6.png" alt=""><h2 id="检测点2-1："><a href="#检测点2-1：" class="headerlink" title="检测点2.1："></a>检测点2.1：</h2></li></ul><p>(1)写出每条汇编指令执行后相关寄存器中的值。</p><p>mov ax,62627 AX= F4A3H</p><p>mov ah,31H AX=31A3H</p><p>mov al,23H AX=3123H</p><p>add ax,ax AX=6246H</p><p>mov bx,826CH BX=826CH</p><p>mov cx,ax CX=6246H</p><p>mov ax,bx AX=826CH</p><p>add ax,bx AX=04D8H</p><p>mov al,bh AX=0482H</p><p>mov ah,bl AX=6C82H</p><p>add ah,ah AX=D882H</p><p>add al,6 AX=D888H</p><p>add al,al AX=D810H</p><p>mov ax,cx AX=6246H</p><p>(2)只能使用目前学过的汇编指令，最多使用4条指令，计算2的4次方.</p><p>mov ax,2h</p><p>add ax,ax</p><p>add ax,ax</p><p>add ax,ax</p><h2 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h2><p><img src="https://i.imgur.com/hriHdmb.png" alt=""><br><img src="https://i.imgur.com/VRoa36Z.png" alt=""></p><h2 id="段地址-16-偏移地址-物理地址的本质含义"><a href="#段地址-16-偏移地址-物理地址的本质含义" class="headerlink" title="段地址*16+偏移地址=物理地址的本质含义"></a>段地址*16+偏移地址=物理地址的本质含义</h2><p>CPU在访问内存时，用一个基础地址（段地址*16）和一个相对于基础地址的偏移地址相加，给出内存单元的物理地址</p><h2 id="检测点2-2"><a href="#检测点2-2" class="headerlink" title="检测点2.2"></a>检测点2.2</h2><p>（1）给定段地址为0001H，仅通过变化偏移地址寻址，CPU的寻址范围为多少到多少？</p><p> 答：物理地址=SA*16+EA</p><p>   EA的变化范围为0H~FFFFH</p><p> 物理地址范围为（SA<em>16+0H）~（SA</em>16+FFFFH）</p><p> 现在SA=0001H，那么寻址范围为</p><p> （0001H<em>16+0H）~（0001H</em>16+FFFFH）=00010H~1000FH</p><p> （2）有一数据存放在内存20000H单元中，现给定段地址为SA，若想用偏移地址寻到此单元。则SA应满足的条件是：最小为多少？最大为多少？</p><p>  答：</p><p>　物理地址 20000H ＝ SA * 10H ＋ 偏移地址</p><p>　显然，偏移地址应该取最大值，SA 才能达到最小。</p><p>　那么，偏移地址取最大值：FFFFH，行吗？</p><p>　代入上述方程，发现，两边的，最末位，不相等。</p><p> 偏移地址最大值，只能取到：FFF0H，方程才有可能成立。</p><p>　按照公式：</p><p>　物理地址 ＝ SA * 10H ＋ 偏移地址</p><p>　可知，物理地址、偏移地址，两者的最低位，必定是相同的。</p><p>　当物理地址＝20000H，偏移地址也只能是：XXX0H，取最大就是 FFF0H。</p><p> 于是：SA = (20000H － FFF0H) / 16＝10010H / 16 ＝ 1001H。</p><p> 标记：王爽汇编语言，段地址*16+偏移地址=物理地址，其中16是十进制。</p><p> 提示，反过来思考一下，当段地址给定为多少，CPU无论怎么变化偏移地址都无法寻到20000H单元？</p><p> 答：</p><p>　先求出，段地址为多少的时候，变化偏移地址可找到20000H地址单元。</p><p>　段地址 × 16  +  偏移地址  =  20000H</p><p>　偏移地址=0000H，段地址则为 2000H；</p><p>　偏移地址=FFF0H，段地址则为 1001H。</p><p>　那么，当段地址大于 2000H，或小于 1001H，就不能找到 20000H。</p><h2 id="CS和IP"><a href="#CS和IP" class="headerlink" title="CS和IP"></a>CS和IP</h2><p>CS和IP是8086CPU中最为关键的寄存器，CS为代码段寄存器（存放段地址），IP为指令指针寄存器（存放偏移地址）<br><img src="https://i.imgur.com/VtTkOAl.png" alt=""></p><p>1、 汇编指令由操作码和操作数组成   如：mov ax,0<br>   mov为操作数   表示指令的功能（是传送指令）<br>   ax,0是2个操作数   即0（0000H）为源操作数      ax为目的操作数<br>   该指令就是  将源操作数传送给目的操作数  从ax可以看出是一条16位的传送指令<br>2、 mov ax,0在内存中的机器指令是B8  00  00<br>   B8 是操作码  表示是一条以ax为目的操作数的传送指令（操作数ax为寄存器寻址  隐含在操作码 中，00  00    表示的是一个16位的立即数即0000H   低8位在前   高8位在后。<br>3、汇编指令在内存中  就是以B8 00 00机器指令表示的二进制代码。</p><h2 id="问题2-3"><a href="#问题2-3" class="headerlink" title="问题2.3"></a>问题2.3</h2><p><img src="https://i.imgur.com/8kaY3OY.png" alt=""><br><img src="https://i.imgur.com/auXp6R7.png" alt=""><br><img src="https://i.imgur.com/dqn3ecD.png" alt=""></p><h2 id="检测点"><a href="#检测点" class="headerlink" title="检测点"></a>检测点</h2><p>下面的3条指令执行后，cpu几次修改IP？都是在什么时候？最后IP中的值是多少？ </p><pre><code>mov ax,bx       sub ax,ax  jmp ax </code></pre><p>注：mov ax,bx  (高级编程语言就是ax=bx )<br>  sub ax,ax    (高级编程语言就是ax=ax-ax  发现ax=0H)<br>  jmp ax        (偏移增量为ax,进而IP=IP+ax，即加上索引的字节数）</p><p>  一共修改四次<br>  第一次：读取mov ax,bx之后<br>  第二次：读取sub ax,ax之后<br>  第三次：读取jmp ax之后<br>  第四次：执行jmp ax修改IP<br>  最后IP的值为0000H，因为最后ax中的值为0000H，所以IP中的值也为0000H</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;寄存器&quot;&gt;&lt;a href=&quot;#寄存器&quot; class=&quot;headerlink&quot; title=&quot;寄存器&quot;&gt;&lt;/a&gt;寄存器&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;一个典型的CPU有运算器、控制器、寄存器等器件构成&lt;/li&gt;
&lt;li&gt;寄存器是CPU中程序员可以用执行读写的部件。程序员
      
    
    </summary>
    
    
      <category term="汇编语言" scheme="http://yoursite.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>cpu与存储器</title>
    <link href="http://yoursite.com/2018/09/07/cpu/"/>
    <id>http://yoursite.com/2018/09/07/cpu/</id>
    <published>2018-09-07T12:37:33.000Z</published>
    <updated>2018-09-07T14:05:50.581Z</updated>
    
    <content type="html"><![CDATA[<h1 id="cpu"><a href="#cpu" class="headerlink" title="cpu"></a>cpu</h1><p>中央处理器（CPU，Central Processing Unit）是一块超大规模的集成电路，是一台计算机的运算核心（Core）和控制核心（ Control Unit）。它的功能主要是解释计算机指令以及处理计算机软件中的数据。<br>中央处理器主要包括运算器（算术逻辑运算单元，ALU，Arithmetic Logic Unit）和高速缓冲存储器（Cache）及实现它们之间联系的数据（Data）、控制及状态的总线（Bus）。它与内部存储器（Memory）和输入/输出（I/O）设备合称为电子计算机三大核心部件。</p><h2 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h2><p>CPU包括运算逻辑部件、寄存器部件和控制部件等。</p><h2 id="逻辑部件"><a href="#逻辑部件" class="headerlink" title="逻辑部件"></a>逻辑部件</h2><p>运算逻辑部件。可以执行定点或浮点算术运算操作、移位操作以及逻辑操作，也可执行地址运算和转换。</p><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>寄存器部件，包括寄存器、专用寄存器和控制寄存器。 通用寄存器又可分定点数和浮点数两类，它们用来保存指令执行过程中临时存放的寄存器操作数和中间（或最终）的操作结果。 通用寄存器是中央处理器的重要部件之一。</p><h2 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h2><p>CPU从存储器或高速缓冲存储器中取出指令，放入指令寄存器，并对指令译码。它把指令分解成一系列的微操作，然后发出各种控制命令，执行微操作系列，从而完成一条指令的执行。指令是计算机规定执行操作的类型和操作数的基本命令。指令是由一个字节或者多个字节组成，其中包括操作码字段、一个或多个有关操作数地址的字段以及一些表征机器状态的状态字以及特征码。有的指令中也直接包含操作数本身。</p><h1 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h1><p>CPU是计算机的核心部件，要想让一个CPU工作，就必须向它提供指令和数据。而指令和数据在存储器中存放，也就是我们平时说的内存。</p><h2 id="存储单元"><a href="#存储单元" class="headerlink" title="存储单元"></a>存储单元</h2><ul><li>存储器被划分若干个存储单元，每个存储单元从0开始循序编号</li><li>这些编号可以看作存储单元在存储器中的地址</li><li>一个存储单元可以存储一个Byte，即8个二进制位（bit）</li></ul><h2 id="CPU对存储器的读写"><a href="#CPU对存储器的读写" class="headerlink" title="CPU对存储器的读写"></a>CPU对存储器的读写</h2><p><img src="https://i.imgur.com/148QNti.png" alt=""></p><ul><li>CPU通过地址线将地址信息3发出</li><li>CPU通过控制线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据</li><li>存储器将三号单元中的数据8通过数据线送入CPU。写操作与读操作的步骤相似。如向3号单元写入数据26</li></ul><h2 id="地址总线"><a href="#地址总线" class="headerlink" title="地址总线"></a>地址总线</h2><ul><li>若一个CPU有N根地址总线，也就是说这个CPU的地址总线的宽度为N，这样的CPU最多可以寻找2的N次方个内存单位</li></ul><h2 id="数据总线"><a href="#数据总线" class="headerlink" title="数据总线"></a>数据总线</h2><ul><li>数据总线的宽度决定了CPU和外界的数据传送速度。8根数据总线 一次可传送一个8位二进制数据（即一个字节）。16根数据总线一次可传送两个字节</li><li>8088CPU的数据总线宽度为8,8086CPU的为16<br><img src="https://i.imgur.com/Eat6XIM.png" alt=""><br><img src="https://i.imgur.com/Nk7DLsB.png" alt=""></li></ul><h2 id="控制总线"><a href="#控制总线" class="headerlink" title="控制总线"></a>控制总线</h2><ul><li>CPU对外部器件的控制是通过控制总线来进行的</li><li>控制总线的跨度决定了CPU对外部器件的控制能力</li></ul><h2 id="检测点1-1"><a href="#检测点1-1" class="headerlink" title="检测点1.1"></a>检测点1.1</h2><ol><li><p>一个CPU的寻址能力为8KB，那么他的地址总线宽度为13。<br>2^n=1024*8<br>n为总线宽度。<br>已知2^10 = 1024<br>因此n=13</p></li><li><p>1KB的存储器有1024个存储单元。存储单元的编号从0到1023 。<br>2^10=1KB=1024</p></li><li><p>1KB的存储器可以存储 8192个bit, 1024 个Byte。<br>1Byte=8bit</p></li><li><p>1GB、1MB、1KB分别是2^30 Byte,2^20 Byte,2^10 Byte。<br>1024<em>1024</em>1024=2^30<br>1024*1024=2^20<br>1024=2^10</p></li><li><p>8080、8088、80286、80386的地址总线宽度分别为16根、20根、24根、32根，则他们的寻址能力分别为： 64 （KB）、 1 （MB）、 16 （MB）、 4 （GB）。<br>2^10=1K 2^6=64<br>2^20=1M<br>2^4=16<br>2^30=1G 2^2=4</p></li><li><p>8080、8088、8086、80286、80386的数据总线宽度分别为8根、8根、16根、16根、32根。则它们一次可以传送的数据为： 1 （B）、 1 （B）、 2 （B）、 2 （B） 4 （B）。<br>1Byte=8bit<br>每8根总线一次最多可传递一字节数据。</p></li><li><p>从内存中读取1024字节的数据，8086至少要读 512 次，80386至少要读 256 次。<br>8086每次读2字节数据<br>80386每次读4字节数据</p></li><li><p>在存储器中，数据和程序以 二进制 形式存放。<br>数据与程序在存储器中以无差别的二进制数据形式存放</p></li></ol><h2 id="存储器芯片"><a href="#存储器芯片" class="headerlink" title="存储器芯片"></a>存储器芯片</h2><ul><li>一台PC机上，装有多个存储器芯片，从读写属性上看分为两类：随机存储器（RAM）和只读存储器（ROM）</li><li>随机存储器用于放供CPU使用的绝大部分程序和数据<br><img src="https://i.imgur.com/Qhqj8C7.png" alt=""></li></ul><h2 id="内存地址空间"><a href="#内存地址空间" class="headerlink" title="内存地址空间"></a>内存地址空间</h2><p><img src="https://i.imgur.com/NQ7MMMa.png" alt=""></p><ul><li>所有的物理存储器被看作一个由若干存储单元组成的的逻辑存储器</li><li>每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间</li><li>CPU在这段地址空间中读写数据，实际上就是在相对于的物理存储器中读写数据</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;cpu&quot;&gt;&lt;a href=&quot;#cpu&quot; class=&quot;headerlink&quot; title=&quot;cpu&quot;&gt;&lt;/a&gt;cpu&lt;/h1&gt;&lt;p&gt;中央处理器（CPU，Central Processing Unit）是一块超大规模的集成电路，是一台计算机的运算核心（Core）和控
      
    
    </summary>
    
    
      <category term="汇编语言" scheme="http://yoursite.com/tags/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
</feed>
