<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[操作符offset]]></title>
    <url>%2F2018%2F09%2F11%2F%E6%93%8D%E4%BD%9C%E7%AC%A6offset%2F</url>
    <content type="text"><![CDATA[操作符offest在汇编语言中是由编译器处理的符号，它的功能是取得标号的偏移地址。比如：123456assume cs:codesgcodesg segmentstart:mov ax,offset strat ;相当于mov ax,0s: mov ax,offset s ;相当于mov ax,3codesg endsend start offset操作符取得了标号start和s的偏移地址0和3因为start是代码段中的标号，它所标记的指令是代码段中的第一条指令，偏移地址为0；而s标记的指令是代码段中的第二条指令，第一条指令长度为3个字节，则s的偏移地址为3. 又比如：]]></content>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[dup指令]]></title>
    <url>%2F2018%2F09%2F11%2Fdup%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[dup是一个操作符，在汇编语言中同db、dw、dd、等一样。它是和db、dw、dd、等数据定义伪指令配合使用的，用来数据的重复。dup的使用格式如下：db 重复的次数 dup （重复的字节型数据）dw 重复的次数 dup （重复的字型数据）dd 重复的次数 dup （重复的双字符数据） 比如：1、3 dup (0)```123定义了三个字节，它们的值都是0，相当于db 0,0,0。2、 stack segmentdb 200 dup (0)stack ends`定义了一个容量为200个字节的栈段]]></content>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[div指令]]></title>
    <url>%2F2018%2F09%2F11%2Fdiv%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[div是除法指令，使用div做除法时应注意以下问题。 1、除数：有8位和16位两种，在一个reg或内存单元中。2、被除数：默认放在AX或DX和AX中，如果除数位8位，被除数则为16位，默认在AX中存放；如果除数为16位，被除数则为32位，在DX和AX中存放，DX放高16位，AX存放低16位。3、结果：如果除数为8位，则AL存储除法操作的商，AH存储除法操作的余数；如果除数为16位，则AX存储除法操作的商，DX存储除法操作的余数。 例如：1、除数为8位： 1div byte ptr ds:[0] 含义：（al）=（ax）/（（ds）*16+0）的商 （ah）=（ax）/（ds)*16+0)的余数 2、除数为16位： 1div word ptr es:[0] 含义：(ax)=[(dx)*10000H+(ax)] / ((es)*16+0)的商 （dx）=[(dx)*10000H+(ax)] / (es)*16+0)的余数 3、用除法指令计算100001/100 分析：被除数100001大于65535（ffffh），所以用dx和ax两个寄存器联合存放100001，除数100虽然小于255可以在一个8位寄存器中存放，但是，因为除数是32位的，除数应为16位，所以要用16位寄存器存放除数100100001表示为16进制为：186A1H。程序如下：1234mov dx,1mov ax,86A1H ;(dx)*10000H+(ax)=100001mov bx,100div bx 程序执行后（ax）=03E8H（即1000）（dx）=1（余数为1） 4、用除法指令计算1001/100分析：被除数1001可用ax寄存器存放，除数100可用8位寄存器存放，也就是说，要进行8位的除法。程序如下：123mov ax,1001mov bl,100div bl 程序执行后，（al）=0AH（即10），（ah）=1（余数为1） 5、]]></content>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[and和or指令]]></title>
    <url>%2F2018%2F09%2F11%2Fand%E5%92%8Cor%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1、and指令：逻辑与指令，按位进行与运算通过该指令可将操作对象位设为0，其他为不变 例如：12mov al,01100011Band al,00111011B 执行后al=00100011B 2、or指令：逻辑或指令，按位进行或运算。通过该指令可将操作对象位设为1，其他位不变 例如指令： 12mov al,0110001Bor al,00111011B 执行后：al=01111011B]]></content>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[检测点6.1]]></title>
    <url>%2F2018%2F09%2F10%2F%E6%A3%80%E6%B5%8B%E7%82%B96-1%2F</url>
    <content type="text"><![CDATA[知识点：1.用于显式地指明内存单元的段地址的”ds:” “cs:” “ss:” “es:” 在汇编语言中称为段前缀 2.Dos方式下，一般情况，0:200 - 0:2ff空间中没有系统或其他程序的数据或代码。 检测点：(1)下面的程序实现依次用内存0:0 - 0:15单元中的内容改写程序中的数据，完成程序：123456789101112131415161718assume cs:codesgcodesg segmentdw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987hstart: mov ax,0mov ds,axmov bx,0mov cx,8s: mov ax,[bx]mov cs:[bx],axadd bx,2loop smov ax,4c00hint 21hcodesg endsend start (2)下面的程序实现依次用内存0:0 - 0:15单元中的内容改写程序中的数据，数据的传送用栈来进行。栈空间设置栈程序中。完成程序：123456789101112131415161718192021assume cs:codesgcodesg segmentdw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987hdw 0,0,0,0,0,0,0,0,0,0start: mov ax,csmov ss,axmov sp,24hmov ax,0mov ds,axmov bx,0mov cx,8s: push [bx]pop [bx]add bx,2loop smov ax,4c00hint 21hcodesg endsend start]]></content>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在代码段中使用栈]]></title>
    <url>%2F2018%2F09%2F10%2F%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%AE%B5%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%A0%88%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526assum cs:codesgcode segement dw 0123H，0456H，0789H，0abcH，0defH，0fedH，0cbaH，0987H dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ;用dw定义16个字型数据，在程序加载后，将取得 16个字的内存空间，存放着6个数据。在后面的程 序中将这段空间当作栈来使用start: mov ax,cs mov ss,ax mv sp,30h ;设置栈顶ss：sp指向CS：30 mov bx,0 mov cz,8 s: push cs:[bx] add bx,2 loop s s0: pop cs[bx] add bx,2 loop s0 ;将定义的数据逆序存放 mov ax,4c00h int 21hcodesg endsend start]]></content>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在代码段中使用数据]]></title>
    <url>%2F2018%2F09%2F10%2F%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%AE%B5%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[编程计算以下8个数据的和，结果存在ax寄存器中： 0123H，0456H，0789H，0abcH，0defH，0fedH，0cbaH，0987H123456789101112131415assum cs:code code segementdw 0123H，0456H，0789H，0abcH，0defH，0fedH，0cbaH，0987Hmov bx,0mov ax,0mov cz,8s: add ax,cs:[bx]add bx,2loop smov ax,4c00hint 21hcode endsend dw的含义是定义字型数据，dw即“define word”，在这里，使用dw定义了8个字型数据，它们所占的内存空间的大小为16个字节。程序在运行的时候cs中存放代码段的段地址，所以可以从cs中得到它们的段地址 因为用dw定义的数据处于代码段的最开始，所以偏移地址为0，这8个数据就在代码段的偏移0、2、4、6、8、A、C、E处。程序运行时，它们的地址就是CS：0、CS：2、CS：4、CS：6、CS：8、CS：A、CS：C、CS：E。用bx存放加2递增的偏移地址用循环来进行累加。在循环开始前,设置（bx）=0，CS：BX指向第一个数据存放的字单元。每次循环中（bx）=（bx）+2，CS：BX指向下一个数据所在的字单元。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Loop指令]]></title>
    <url>%2F2018%2F09%2F10%2FLoop%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[loop指令的格式是：loop 标号CPU执行loop指令的时候，要进行两步操作，1、(cx)=(cx)-12、判断cx中的值，不为零则转至标号处执行，如果为零则向下执行 例子1：计算2的十二次方123456789101112assume cs:code code segmentmov ax,2mov cx,11s: add ax,axloop smov ax,4c00Hint 21Hcode endsend 例子2：用加法计算123*236 123456789101112assume cs:codecode segmentmov ax,0mov cx,123s: add ax,236loop smov ax,4c00Hint 21Hcode endsend]]></content>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[寄存器（内存访问）]]></title>
    <url>%2F2018%2F09%2F08%2F%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%EF%BC%89%2F</url>
    <content type="text"><![CDATA[寄存器（内存访问）内存中字的存储 DS和[address] 8086CPU中有一个DS寄存器，通常用来存放要访问数据的地址段 [address]表示一个内存单元，address表示内存单元的偏移地址 如果要读取10000H单元的内容，可以用如下的程序段进行 mov bx,1000H mov ds,bx mov al,[0] 上面的3条指令将10000H（1000：0）中的数据读到al中 字的传送mov bx,1000H mov ds,bx mov ax,[0] ;1000:0处的数据送入ax mov [0],cx ;cx中的16位数据送到1000:0处 问题1 问题2 问题3 检测点3.1(1)在Debug 中，用”d 0:0 1f” 查看内存，结果如下： 0000:0000 70 80 F0 30 EF 60 30 E2-00 80 80 12 66 20 22 60 0000:0010 62 26 E6 D6 CC 2E 3C 3B-AB BA 00 00 26 06 66 88 下面的程序执行前，AX=0,BX=0，写出每条汇编指令执行完毕后相关寄存器中的值： Mov ax,1 Mov ds,ax Mov ax,[0000] AX=2662 Mov bx,[0001] BX=E626 Mov ax,bx AX=E626 Mov ax,[0000] AX=2662 Mov bx,[0002] BX=D6E6 Add ax,bx AX=FD48 Add ax,[0004] AX=2C14 Mov ax,0 AX=0 Mov al,[0002] AX=00E6 Mov bx,0 BX=0 Mov bl,[000C] BX=0026 Add al,bl AX=000C (2) mov ax,6622H CS=2000H IP=0002H jmp 0ff0:0100 CS=0ff0H IP=0100H 物理地址=CS*16+IP=10000H mov ax,2000H CS=0ff0H IP=0103H mov ds,ax CS=0ff0H IP=0105H mov ax,[0008] CS=0ff0H IP=0108H mov ax,[0002] CS=0ff0H Ip=010BH 第一步：CS=2000H，IP=0H 地址：20000H 读取第一条指令 mov ax,6622H CS=2000H, IP=03H 执行指令 mov ax,6622H 执行结果：AX=6622H 第二步：地址：20003H 读取第二条指令 jmp 0ff0:0100 CS=2000H,IP=03H 执行指令：jmp 0ff0:0100 执行结果：CS=0ff0H, IP=0100H 第三步：地址：CSx16+IP = 10000H 读取指令：mov ax,2000H CS=0ff0H, IP=0103H 执行指令：mov ax,2000H 执行结果：AX=2000H 第四步：地址：10003H 读取指令：mov ds,ax CS=0ff0H, IP=0105H 执行指令：mov ds,ax 执行结果：ds=2000H 第五步：地址：10005H 读取指令：mov ax,[0008] CS=0ff0H，IP=10008H，DS=2000H 执行指令：mov ax,[0008] ; 也就是将地址【DS：IP】为 2000H：0008H的值移动到AX 执行结果：AX=C189H 第六步：读取指令：mov ax,[0002] CS=0ff0H ,IP=1000BH,DS=2000H 执行指令：mov ax,[0002] 执行结果：AX=EA66 知识点： 任意时刻SS:SP 指向栈顶元素。 push指令和pop指令执行时，CPU从 SS和SP中得到栈顶的地址。 注：SS(Stack Segmet)堆栈段寄存器，指向当前的堆栈段。 SP(Stack Pointer)堆栈指针寄存器，主要用于堆栈操作，存放堆栈段首地 址到栈顶单元的偏移量。 入栈时：886CPU栈顶从高地址向低地址方向增长。 CPU提供的栈机制CS、IP中存放着当前指令的段地址和偏移地址，而段寄存器SS和寄存器SP为CPU的入栈，出栈服务。任意时刻SS：SP指向栈顶元素。 问题1如果将10000H~1000Fh这段空间当作栈，初始空间是空的，此时，SS=1000H，SP=0010H 问题2利用栈，交换AX和BX中的数据 mov ax,1000H mov ss,ax mov sp,0010H ;初始化栈顶 mov ax=001AH mov bx=001BH push ax push bx pop ax ；当前栈顶的数据是bx中的欲来的数据，所以先pop ax，即ax=001BH pop bx ；执行pop ax后，栈顶的数据为ax原来的数据，所以再pop bx，即bx=001AH 问题3利用栈在10000H处写入数据2266H mov ax,1000H mov ss,ax mov sp,0002H mov ax,2266H push ax 一般写法 mov ax,1000H mov ds,ax mov ax,2266H mov [0],ax]]></content>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[寄存器]]></title>
    <url>%2F2018%2F09%2F07%2F%E5%AF%84%E5%AD%98%E5%99%A8%2F</url>
    <content type="text"><![CDATA[寄存器 一个典型的CPU有运算器、控制器、寄存器等器件构成 寄存器是CPU中程序员可以用执行读写的部件。程序员通过改变各种寄存器中的内容来实现对CPU的控制 不同的CPU，寄存器的个数、结构是不同的。8086CPU有14个寄存器，每个寄存器有一个名称。这些寄存器是：AX、BX、CX、DX、SI、DI、SP、BP、IP、CS、SS、DS、ES、PWS、 通用寄存器 8086CPU的的所有寄存器都是16位的，可以存放两个字节，AX、BX、CX、DX、这四个寄存器位通用寄存器 一个16位的寄存器可以存储一个16位的数据，所能存储的数据最大值为2^16-1，或用16进制表示为FFFFH，也为10000H-1 AX的低8位构成了AL寄存器，高8位构成了AH寄存器，AH和AL寄存器是可以独立使用的 字在寄存器中的存储 一个16位的寄存器可以存放两个字节（byte），即为一个字（word），一个字等于两个字节 而计算机的存储单元为字节（byte），一个内存（存储）单元可以存放8位数据（bit），也就是说，计算机中的数据大多是由1~N个8位数据构成。 很多时候，用16进制表示数据可以直观的看出数据是由哪些8位数据构成，如2000写成4E20，可以看出是由4E和20两个8位数据构成的，如果AX中存放4E20H，则AH里是4E，AL里是20mov和add汇编指令原AX，BX中的值：0000H，0000H问题2.1在执行前ax和bx中的数据都为8226H，相加后所得值为：1044CH，但ax为16位寄存器，只能存放4位十六进制的数据，所以最高位的1不能在ax中保存，，ax中的数据为：044CH问题2.2在执行前，al中的数据为C5H，相加后所得的值为：158H，但是al为8位寄存器，只能诚邀您放两位16精致的数据，所以最高位的1丢失，ax中的数据为：0058H检测点2.1： (1)写出每条汇编指令执行后相关寄存器中的值。 mov ax,62627 AX= F4A3H mov ah,31H AX=31A3H mov al,23H AX=3123H add ax,ax AX=6246H mov bx,826CH BX=826CH mov cx,ax CX=6246H mov ax,bx AX=826CH add ax,bx AX=04D8H mov al,bh AX=0482H mov ah,bl AX=6C82H add ah,ah AX=D882H add al,6 AX=D888H add al,al AX=D810H mov ax,cx AX=6246H (2)只能使用目前学过的汇编指令，最多使用4条指令，计算2的4次方. mov ax,2h add ax,ax add ax,ax add ax,ax 物理地址 段地址*16+偏移地址=物理地址的本质含义CPU在访问内存时，用一个基础地址（段地址*16）和一个相对于基础地址的偏移地址相加，给出内存单元的物理地址 检测点2.2（1）给定段地址为0001H，仅通过变化偏移地址寻址，CPU的寻址范围为多少到多少？ 答：物理地址=SA*16+EA EA的变化范围为0H~FFFFH 物理地址范围为（SA16+0H）~（SA16+FFFFH） 现在SA=0001H，那么寻址范围为 （0001H16+0H）~（0001H16+FFFFH）=00010H~1000FH （2）有一数据存放在内存20000H单元中，现给定段地址为SA，若想用偏移地址寻到此单元。则SA应满足的条件是：最小为多少？最大为多少？ 答： 物理地址 20000H ＝ SA * 10H ＋ 偏移地址 显然，偏移地址应该取最大值，SA 才能达到最小。 那么，偏移地址取最大值：FFFFH，行吗？ 代入上述方程，发现，两边的，最末位，不相等。 偏移地址最大值，只能取到：FFF0H，方程才有可能成立。 按照公式： 物理地址 ＝ SA * 10H ＋ 偏移地址 可知，物理地址、偏移地址，两者的最低位，必定是相同的。 当物理地址＝20000H，偏移地址也只能是：XXX0H，取最大就是 FFF0H。 于是：SA = (20000H － FFF0H) / 16＝10010H / 16 ＝ 1001H。 标记：王爽汇编语言，段地址*16+偏移地址=物理地址，其中16是十进制。 提示，反过来思考一下，当段地址给定为多少，CPU无论怎么变化偏移地址都无法寻到20000H单元？ 答： 先求出，段地址为多少的时候，变化偏移地址可找到20000H地址单元。 段地址 × 16 + 偏移地址 = 20000H 偏移地址=0000H，段地址则为 2000H； 偏移地址=FFF0H，段地址则为 1001H。 那么，当段地址大于 2000H，或小于 1001H，就不能找到 20000H。 CS和IPCS和IP是8086CPU中最为关键的寄存器，CS为代码段寄存器（存放段地址），IP为指令指针寄存器（存放偏移地址） 1、 汇编指令由操作码和操作数组成 如：mov ax,0 mov为操作数 表示指令的功能（是传送指令） ax,0是2个操作数 即0（0000H）为源操作数 ax为目的操作数 该指令就是 将源操作数传送给目的操作数 从ax可以看出是一条16位的传送指令2、 mov ax,0在内存中的机器指令是B8 00 00 B8 是操作码 表示是一条以ax为目的操作数的传送指令（操作数ax为寄存器寻址 隐含在操作码 中，00 00 表示的是一个16位的立即数即0000H 低8位在前 高8位在后。3、汇编指令在内存中 就是以B8 00 00机器指令表示的二进制代码。 问题2.3 检测点下面的3条指令执行后，cpu几次修改IP？都是在什么时候？最后IP中的值是多少？ mov ax,bx sub ax,ax jmp ax 注：mov ax,bx (高级编程语言就是ax=bx ) sub ax,ax (高级编程语言就是ax=ax-ax 发现ax=0H) jmp ax (偏移增量为ax,进而IP=IP+ax，即加上索引的字节数） 一共修改四次 第一次：读取mov ax,bx之后 第二次：读取sub ax,ax之后 第三次：读取jmp ax之后 第四次：执行jmp ax修改IP 最后IP的值为0000H，因为最后ax中的值为0000H，所以IP中的值也为0000H]]></content>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cpu与存储器]]></title>
    <url>%2F2018%2F09%2F07%2Fcpu%2F</url>
    <content type="text"><![CDATA[cpu中央处理器（CPU，Central Processing Unit）是一块超大规模的集成电路，是一台计算机的运算核心（Core）和控制核心（ Control Unit）。它的功能主要是解释计算机指令以及处理计算机软件中的数据。中央处理器主要包括运算器（算术逻辑运算单元，ALU，Arithmetic Logic Unit）和高速缓冲存储器（Cache）及实现它们之间联系的数据（Data）、控制及状态的总线（Bus）。它与内部存储器（Memory）和输入/输出（I/O）设备合称为电子计算机三大核心部件。 物理结构CPU包括运算逻辑部件、寄存器部件和控制部件等。 逻辑部件运算逻辑部件。可以执行定点或浮点算术运算操作、移位操作以及逻辑操作，也可执行地址运算和转换。 寄存器寄存器部件，包括寄存器、专用寄存器和控制寄存器。 通用寄存器又可分定点数和浮点数两类，它们用来保存指令执行过程中临时存放的寄存器操作数和中间（或最终）的操作结果。 通用寄存器是中央处理器的重要部件之一。 工作过程CPU从存储器或高速缓冲存储器中取出指令，放入指令寄存器，并对指令译码。它把指令分解成一系列的微操作，然后发出各种控制命令，执行微操作系列，从而完成一条指令的执行。指令是计算机规定执行操作的类型和操作数的基本命令。指令是由一个字节或者多个字节组成，其中包括操作码字段、一个或多个有关操作数地址的字段以及一些表征机器状态的状态字以及特征码。有的指令中也直接包含操作数本身。 存储器CPU是计算机的核心部件，要想让一个CPU工作，就必须向它提供指令和数据。而指令和数据在存储器中存放，也就是我们平时说的内存。 存储单元 存储器被划分若干个存储单元，每个存储单元从0开始循序编号 这些编号可以看作存储单元在存储器中的地址 一个存储单元可以存储一个Byte，即8个二进制位（bit） CPU对存储器的读写 CPU通过地址线将地址信息3发出 CPU通过控制线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据 存储器将三号单元中的数据8通过数据线送入CPU。写操作与读操作的步骤相似。如向3号单元写入数据26 地址总线 若一个CPU有N根地址总线，也就是说这个CPU的地址总线的宽度为N，这样的CPU最多可以寻找2的N次方个内存单位 数据总线 数据总线的宽度决定了CPU和外界的数据传送速度。8根数据总线 一次可传送一个8位二进制数据（即一个字节）。16根数据总线一次可传送两个字节 8088CPU的数据总线宽度为8,8086CPU的为16 控制总线 CPU对外部器件的控制是通过控制总线来进行的 控制总线的跨度决定了CPU对外部器件的控制能力 检测点1.1 一个CPU的寻址能力为8KB，那么他的地址总线宽度为13。2^n=1024*8n为总线宽度。已知2^10 = 1024因此n=13 1KB的存储器有1024个存储单元。存储单元的编号从0到1023 。2^10=1KB=1024 1KB的存储器可以存储 8192个bit, 1024 个Byte。1Byte=8bit 1GB、1MB、1KB分别是2^30 Byte,2^20 Byte,2^10 Byte。102410241024=2^301024*1024=2^201024=2^10 8080、8088、80286、80386的地址总线宽度分别为16根、20根、24根、32根，则他们的寻址能力分别为： 64 （KB）、 1 （MB）、 16 （MB）、 4 （GB）。2^10=1K 2^6=642^20=1M2^4=162^30=1G 2^2=4 8080、8088、8086、80286、80386的数据总线宽度分别为8根、8根、16根、16根、32根。则它们一次可以传送的数据为： 1 （B）、 1 （B）、 2 （B）、 2 （B） 4 （B）。1Byte=8bit每8根总线一次最多可传递一字节数据。 从内存中读取1024字节的数据，8086至少要读 512 次，80386至少要读 256 次。8086每次读2字节数据80386每次读4字节数据 在存储器中，数据和程序以 二进制 形式存放。数据与程序在存储器中以无差别的二进制数据形式存放 存储器芯片 一台PC机上，装有多个存储器芯片，从读写属性上看分为两类：随机存储器（RAM）和只读存储器（ROM） 随机存储器用于放供CPU使用的绝大部分程序和数据 内存地址空间 所有的物理存储器被看作一个由若干存储单元组成的的逻辑存储器 每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间 CPU在这段地址空间中读写数据，实际上就是在相对于的物理存储器中读写数据]]></content>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie和Session]]></title>
    <url>%2F2018%2F08%2F09%2FCookie%E5%92%8CSession%2F</url>
    <content type="text"><![CDATA[1、Cookie介绍 Cookie是由服务器端生成，发送给User-Agent（一般是浏览器），浏览器会将Cookie的key/value保存到某个目录下的文本文件内，下次请求同一网站时就发送该Cookie给服务器（前提是浏览器设置为启用cookie）。Cookie名称和值可以由服务器端开发自己定义，这样服务器可以知道该用户是否是合法用户以及是否需要重新登录等，服务器可以设置或读取Cookies中包含信息，借此维护用户跟服务器会话中的状态。 简单来说，Cookie 是保存在浏览器的一个键值对，每次的HTTP请求都会携带 Cookie 。 cookie的作用 服务器可以利用Cookies包含信息的任意性来筛选并经常性维护这些信息，以判断在HTTP传输中的状态。Cookies最典型的应用是判定注册用户是否已经登录网站，用户可能会得到提示，是否在下一次进入此网站时保留用户信息以便简化登录手续，这些都是Cookies的功用。另一个重要应用场合是“购物车”之类处理。用户可能会在一段时间内在同一家网站的不同页面中选择不同的商品，这些信息都会写入Cookies，以便在最后付款时提取信息。 Django框架的下cookie1、 获取Cookie： 获取已经设置好的cookies极其简单。 每一个HttpRequest 对象都有一个COOKIES 对象，该对象的行为类似一个字典，你可以使用它读取任何浏览器发送给视图（view）的cookies。 获取普通cookie request.COOKIES[&apos;key&apos;] request.COOKIES.get(&apos;key&apos;) 解密带签名的cookie request.get_signed_cookie(key, default=RAISE_ERROR, salt=&apos;&apos;, max_age=None) 参数： default: 默认值 salt: 加密盐 max_age: 后台控制过期时间 2、设置Cookie：rep = HttpResponse(...) 或 rep ＝ render(request, ...) #设置cookie需要使用 HttpResponse对象的 set_cookie()方法 #设置普通cookie rep.set_cookie(key,value,...) #设置带签名的cookie rep.set_signed_cookie(key,value,salt=&apos;加密盐&apos;,...) #参数： key, 键 value=&apos;&apos;, 值 max_age=None, 超时时间 expires=None, 超时时间(IE requires expires, so set it if hasn&apos;t been already.) path=&apos;/&apos;, Cookie生效的路径，/ 表示根路径，特殊的：跟路径的cookie可以被任何url的页面访问 domain=None, Cookie生效的域名 secure=False, https传输 httponly=False 只能http协议传输，无法被JavaScript获取（不是绝对，底层抓包可以获取到也可以被覆盖） 由于cookie保存在客户端的电脑上，所以，JavaScript和jquery也可以操作cookie。 &lt;script src=&apos;/static/js/jquery.cookie.js&apos;&gt;&lt;/script&gt; $.cookie(&quot;list_pager_num&quot;, 30,{ path: &apos;/&apos; }); 注意： Cookie(特别是那些没通过HTTPS传输的)是非常不安全的。 因为HTTP数据是以明文发送的，所以 特别容易受到嗅探攻击。 也就是说，嗅探攻击者可以在网络中拦截并读取cookies，因此你要 绝对避免在cookies中存储敏感信息。 这就意味着您不应该使用cookie来在存储任何敏感信息。 因此不能在cookies中存储可能会被篡改的敏感数据。 在cookies中存储 IsLoggedIn=1 ，以标识用户已经登录。 犯这类错误的站点数量多的令人难以置信； 绕过这些网站的安全系统也是易如反掌。 2、Session1、介绍 在WEB开发中，服务器可以为每个用户浏览器创建一个会话对象（session对象），注意：一个浏览器独占一个session对象(默认情况下)。因此，在需要保存用户数据时，服务器程序可以把用户数据写到用户浏览器独占的session中，当用户使用浏览器访问其它程序时，其它程序可以从用户的session中取出该用户的数据，为用户服务。 Session与Cookie的区别： Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中。 Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。 Session 必须要依赖 Cookie ，因为 Cookie的值就等于 Session 的Key ###Session的工作原理: 当用户第一次访问时，服务器会给其创建一个session，并且把session的Id(本质是随机字符串)以cookie的形式发送给客户端浏览器，下次再去访问服务器时，客户机浏览器会把存储到cookie中的session的Id一起传递到服务器端，服务器发现客户机浏览器带session id过来了，就会使用内存中与之对应的session为之服务 2、Django下的 Session 框架 由于存在的限制与安全漏洞，cookies和持续性会话已经成为Web开发中令人头疼的典范。 好消息是，Django的目标正是高效的“头疼杀手”，它自带的session框架会帮你搞定这些问题。 你可以用session 框架来存取每个访问者任意数据， 这些数据在服务器端存储，并对cookie的收发进行了抽象。 Cookies只存储数据的哈希会话ID，而不是数据本身，从而避免了大部分的常见cookie问题。 Django中默认支持Session，其内部提供了5种类型的Session供开发者使用： 数据库（默认） 缓存 文件 缓存+数据库 加密cookie]]></content>
      <tags>
        <tag>cookie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑客游戏]]></title>
    <url>%2F2018%2F08%2F07%2F%E9%BB%91%E5%AE%A2%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[第一关网址：http://www.cn-hack.cn/qs/5.htm 进来可以看到要求输入密码进入下一关，可以先看下页面源代码发现下一关的网址，如图： 那就进入http://www.cn-hack.cn/qs/2sdfadf.htm来到第二关 第二关是一张图片，提示密码在图片中，那就把图片下载下来，改为txt文档，打开看看，发现第三关的网址，如图： 进入第三关的网址http://www.cn-hack.cn/qs/or3.htm 第三关就直接给出密码：%68%74%74%70%3A%2F%2F%77%77%77%2E%63%6E%2D%68%61%63%6B%2E%63%6E%2F%71%73%2F%34%64%66%73%61%2E%68%74%6D ，不过是经过URL加密过的，进行URL解密得到网址：http://www.cn-hack.cn/qs/4dfsa.htm 进入第四关http://www.cn-hack.cn/qs/4dfsa.htm 需要输入用户名和密码，先看看页面源代码，没发现什么，那就随便输入用户名和密码，然后跳转到一个页面，那就在看看源代码， 发现第五关的地址进入第五关http://www.cn-hack.cn/qs/789.htm 进来就让你输入通用密码中的两个字母，想看页面源代码也看不了，上网搜搜SQL通用密码，知道了密码为 or ,输入进去就通关了]]></content>
      <tags>
        <tag>html 前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python替换敏感词]]></title>
    <url>%2F2018%2F07%2F31%2Fpython%E6%9B%BF%E6%8D%A2%E6%95%8F%E6%84%9F%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[思路如下: 首先，从敏感词文件中读取到敏感词汇，放入容器中 如果有标点符号，则把一些没用的标点符号去掉 然后，获取用户输入，判断输入是否包含敏感词汇， 并输出相对应的结果 1234567891011121314151617181920212223242526272829303132333435import osdef filter_words(path): if os.path.isfile(path): with open(path, &apos;r&apos;) as f: words = f.read() words = words.replace(&apos;，&apos;, &apos;&apos;) words = words.replace(&apos;\n&apos;, &apos;&apos;) return wordsdef sense_words(): words = filter_words(&apos;filter.txt&apos;) print(&quot;敏感字内容如下:&quot;) print(&quot;------------------------------------------------------------------&quot;) print(words) print(&quot;------------------------------------------------------------------&quot;) while True: sentence = input(&quot;请输入：&quot;) if sentence == &apos;0&apos;: print(&apos;exit&apos;) break for i in words: if i in sentence: replace = &apos;&apos; for j in range(len(i)): replace = replace + &apos;*&apos; sentence = sentence.replace(i, replace) print(sentence)if __name__ == &quot;__main__&quot;: sense_words()]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[南邮ctf-PY交易]]></title>
    <url>%2F2018%2F07%2F27%2F%E5%8D%97%E9%82%AEctf-PY%E4%BA%A4%E6%98%93%2F</url>
    <content type="text"><![CDATA[下载后是一个pyc文件 选择https://tool.lu/pyc/ 进行解密 如下： 只是一个简单的base64加密，得到的py脚本如下： import base64 c = &apos;XlNkVmtUI1MgXWBZXCFeKY+AaXNt&apos; m = c.decode(&quot;base64&quot;) s = &apos;&apos; for i in m: x = ord(i) - 16 x = x ^ 32 s=s+chr(x) print s 只能在python2.X下运行 得到flag：nctf{d3c0mpil1n9_PyC}]]></content>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[南邮攻防训练平台逆向第四题WxyVM1]]></title>
    <url>%2F2018%2F07%2F27%2FWxyVM1%2F</url>
    <content type="text"><![CDATA[下载文件elf文件，运行输入flag，用ida打开逆向算法： 不是很复杂，可以看出flag长度需要24，最终会和已给出dword_601060进行比较，一致则成功，那么现在只需要看上面的sub_4005B6()函数了： 跟进两个地址进去看一下，发现有已经给出的处理所需数据，只是比较多，有15000个，想了想最后还是决定把数据提出来（其实是没其他办法了==） 最后是逆推py脚本： 那个15000的数组太长了，不好复制，要导出在一个文档里，才能复制完 tmp=[1, 16, 37, 3, 13, 10, 2, 11, 40, 2 ] //太长了只写前十个 final=[196, 52, 34, 177, 211, 17, 151, 7, 219, 55, 196, 6, 29, 252, 91, 237, 152, 223, 148, 216, 179, 132, 204, 8] i = 14997 while i&gt;0: v0 = tmp[i] v3 = tmp[i+2] result = tmp[i+1] if v0 == 1: final[result] -= v3 elif v0 == 2: final[result] += v3 elif v0 == 3: final[result] ^= v3 elif v0 == 4: final[result] /= v3! elif v0 == 5: final[result] ^= final[v3] final[result]&amp;=0xFF //需要注意的地方，因为ascii字符码范围为0~127，可能发生越界 i -= 3 for x in final: print(chr(x), end = &apos;&apos;) 得到flag：nctf{Embr4ce_Vm_j0in_R3} 如果不加final[result]&amp;=0xFF 这句话就会越界，如图： &amp;0xFF到底是什么意思 举个简单的例子: byte[] b = new byte[5]; b[0] = -12; byte 8位二进制 = 1个字节 char 2个字节 short (2个字节) int（4个字节） long（8个字节） float （4个字节） double（8个字节） 计算机存储数据机制：正数存储的二进制原码,负数存储的是二进制的补码。 补码是负数的绝对值反码加1。 比如-12，-12 的绝对值原码是：0000 1100 取反： 1111 0011 加1： 1111 0100 byte –&gt; int 就是由8位变 32 位 高24位全部补1： 1111 1111 1111 1111 1111 1111 1111 0100 ; 0xFF 是计算机十六进制的表示： 0x就是代表十六进制，A B C D E F 分别代表10 11 12 13 14 15 F就是15 一个F 代表4位二进制：可以看做 是 8 4 2 1。 0xFF的二进制表示就是：1111 1111。 高24位补0：0000 0000 0000 0000 0000 0000 1111 1111; -12的补码与0xFF 进行与（&amp;）操作 最后就是0000 0000 0000 0000 0000 0000 1111 0100 转换为十进制就是 244。 byte类型的数字要&amp;0xff再赋值给int类型，其本质原因就是想保持二进制补码的一致性。 当byte要转化为int的时候，高的24位必然会补1，这样，其二进制补码其实已经不一致了，&amp;0xff可以将高的24位置为0，低8位保持原样。这样做的目的就是为了保证二进制数据的一致性。 有人问为什么上面的式子中b[0]不是8位而是32位，因为当系统检测到byte可能会转化成int或者说byte与int类型进行运算的时候，就会将byte的内存空间高位补1（也就是按符号位补位）扩充到32位，再参与运算。]]></content>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BurpSuite系列----Intruder模块(暴力破解口令)]]></title>
    <url>%2F2018%2F07%2F27%2FBurpSuit%20%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%E5%8F%A3%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[一、简介 Burp Intruder是一个强大的工具，用于自动对Web应用程序自定义的攻击，Burp Intruder 是高度可配置的，并被用来在广范围内进行自动化攻击。你可以使用 Burp Intruder 方便地执行许多任务，包括枚举标识符，获取有用数据，漏洞模糊测试。合适的攻击类型取决于应用程序的情况，可能包括：缺陷测试：SQL 注入，跨站点脚本，缓冲区溢出，路径遍历；暴力攻击认证系统；枚举；操纵参数；拖出隐藏的内容和功能；会话令牌测序和会话劫持；数据挖掘；并发攻击；应用层的拒绝服务式攻击。 二、模块说明 Burp Intruder主要有四个模块组成:1：Target 用于配置目标服务器进行攻击的详细信息。2：Positions 设置Payloads的插入点以及攻击类型（攻击模式）。3：Payloads 设置payload，配置字典4：Opetions 此选项卡包含了request headers，request engine，attack results ，grep match，grep_extrack，grep payloads和redirections。你可以发动攻击之前，在主要Intruder的UI上编辑这些选项，大部分设置也可以在攻击时对已在运行的窗口进行修改。 1：Target 目标选项(Target tab)这个选项是用来配置目标服务器的细节： 2：Positions 位置选项(Positions tab)这个选项是用来配置在攻击里产生的所有 HTTP 请求的模板： 使用一对§字符来标记出有效负荷的位置，在这两个符号直接包含了模板文本的内容。当把一个有效负荷放置到一个给出的请求的特殊位置上时，就把这§符号放到这个位置，然后在两个符号之间的出现的文本都会被有效负荷替换。当有个特殊位置没有为一个给出的请求安排有效负荷时(这只适用”sniper”攻击类型)，那个位置的§字符会被删除，出现在它们之间的文本不会变化。 当使用 Burp Suite 发送一个其他地方的请求时，Burp Intruder 会对你最想放置有效负荷的位置做一个最好的猜测，并且它把这些放置在每个 URL 和主体参数的值里，以及每个cookie 里。每个标记和它中间的文本都会被加亮以显得更清晰。你可以使用 Intruder 菜单上的选项标记的位置是要替换还是附加现有的参数值。在上面的请求编辑器里，指出了定义位置的数量和文本模板的大小。 你可以使用选项上的按钮来控制位置上的标记： add § — 在当前光标位置插入一个位置标记。 clear § — 删除整个模板或选中的部分模板里的位置标记。 auto § — 这会对放置标记的位置做一个猜测，放哪里会有用，然后就把标记放到相应位置。这是一个为攻击常规漏洞(SQL 注入)快速标记出合适位置的有用的功能，然后人工标记是为自定义攻击的。4.refresh — 如果需要，可以刷新编辑器里有颜色的代码。5.clear — 删除整个编辑器内容。 3：Payloads 有效负荷选项(Payloads tab)这个选项是用来配置一个或多个有效负荷的集合。如果定义了”cluster bomb”和”pitchfork”攻击类型，然后必须为每定义的有效负荷位置(最多8个)配置一个单独的有效负荷。使用”payload set”下拉菜单选择要配置的有效负荷。 选项1：Payload Sets Payload数量类型设置 选项2：Payload Opetions[Simple list] 该选项会根据选项1中Payload type的设置而改变 选项3：Payload Processing 对生成的Payload进行编码、加密、截取等操作 选项4：Payload Encoding 你可以配置哪些有效载荷中的字符应该是URL编码的HTTP请求中的安全传输。任何已配置的URL编码最后应用，任何有效载荷处理规则执行之后。 这是推荐使用此设置进行最终URL编码，而不是一个有效载荷处理规则，因为可以用来有效载荷的grep选项来检查响应为呼应有效载荷的最终URL编码应用之前。 4：Opetions 选项卡(Options tab) 此选项卡包含了request headers，request engine，attack results ，grep match，grep_extrack，grep payloads和redirections。你可以发动攻击之前，在主要Intruder的UI上编辑这些选项，大部分设置也可以在攻击时对已在运行的窗口进行修改。 选项1：Request Headers 这些设置控制在Intruder是否更新配置请求头。 如果选中‘update Content-Length header’框，Burp Intruder 会使用每个请求的 HTTP 主体长度的正确值，添加或更新这个请求里 HTTP 消息头的内容长度。这个功能对一些需要把可变长度的有效载荷插入到 HTTP 请求模板主体的攻击是很有必要的。这个 HTTP 规范和大多数 web 服务器一样，需要使用消息头内容长度来指定 HTTP 主体长度的正确值。如果没有指定正确值，目标服务器会返回一个错误，也可能返回一个未完成的请求，也可能无限期地等待接收请求里的进一步数据。 如果选中‘set Connection: close’框，则 Burp Intruder 会添加或更新 HTTP 消息头的连接来请求在每个请求后已关闭的连接。在多数情况下，这个选项会让攻击执行得更快。 选项2：Request Engine 设置发送请求的线程、超时重试等。 选项3：Attack Results 设置攻击结果的显示。 选项4：Grep - Match 在响应中找出存在指定的内容的一项。 选项5：Grep - Extract 通过正则提取返回信息中的内容。 选项6：Grep - Payloads 这些设置可以用于包含已提交的有效负载的反射的标志结果项目。如果启用了此选项，BurpSuite会添加包含一个复选框指示当前负载的值在每个响应发现新的结果列。 选项7：Redirections 重定向响应，控制Burp在进行攻击时如何处理重定向。]]></content>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大梦能看见吗？]]></title>
    <url>%2F2018%2F07%2F22%2F%E5%A4%A7%E6%A2%A6%E8%83%BD%E7%9C%8B%E8%A7%81%E5%90%97%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[略略略 略略略 略略略]]></content>
  </entry>
  <entry>
    <title><![CDATA[我的世界不会下雪]]></title>
    <url>%2F2018%2F07%2F21%2F%E6%88%91%E7%9A%84%E4%B8%96%E7%95%8C%E4%B8%8D%E4%BC%9A%E4%B8%8B%E9%9B%AA%2F</url>
    <content type="text"><![CDATA[我的世界不会下雪 啦啦啦]]></content>
  </entry>
</search>
